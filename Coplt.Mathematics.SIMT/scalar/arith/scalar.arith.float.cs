// generated by template, do not modify manually

namespace Coplt.Mathematics.SIMT;

#region float_mt4

public partial struct float_mt4
{
    #region Constants

    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static float_mt4 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277f); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static float_mt4 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094f); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static float_mt4 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009f);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static float_mt4 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923f);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static float_mt4 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846f);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static float_mt4 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861f);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static float_mt4 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144f);
    }

    #endregion
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static float_mt4 mod([This] float_mt4 a, float_mt4 b)
    {
        return new(simd.Mod(a.vector, b.vector));
    }
}

#endregion // float_mt4
#region float_mt8

public partial struct float_mt8
{
    #region Constants

    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static float_mt8 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277f); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static float_mt8 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094f); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static float_mt8 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009f);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static float_mt8 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923f);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static float_mt8 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846f);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static float_mt8 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861f);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static float_mt8 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144f);
    }

    #endregion
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static float_mt8 mod([This] float_mt8 a, float_mt8 b)
    {
        return new(simd.Mod(a.vector, b.vector));
    }
}

#endregion // float_mt8
#region float_mt16

public partial struct float_mt16
{
    #region Constants

    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static float_mt16 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277f); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static float_mt16 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094f); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static float_mt16 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009f);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static float_mt16 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923f);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static float_mt16 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846f);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static float_mt16 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861f);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static float_mt16 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144f);
    }

    #endregion
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static float_mt16 mod([This] float_mt16 a, float_mt16 b)
    {
        return new(simd.Mod(a.vector, b.vector));
    }
}

#endregion // float_mt16
#region float_mt32

public partial struct float_mt32
{
    #region Constants

    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static float_mt32 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277f); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static float_mt32 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094f); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static float_mt32 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009f);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static float_mt32 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923f);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static float_mt32 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846f);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static float_mt32 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861f);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static float_mt32 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144f);
    }

    #endregion
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static float_mt32 mod([This] float_mt32 a, float_mt32 b)
    {
        return new(simd.Mod(a.vector0, b.vector0), simd.Mod(a.vector1, b.vector1));
    }
}

#endregion // float_mt32
#region double_mt4

public partial struct double_mt4
{
    #region Constants

    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static double_mt4 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static double_mt4 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static double_mt4 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static double_mt4 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static double_mt4 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static double_mt4 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static double_mt4 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144);
    }

    #endregion
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static double_mt4 mod([This] double_mt4 a, double_mt4 b)
    {
        return new(simd.Mod(a.vector, b.vector));
    }
}

#endregion // double_mt4
#region double_mt8

public partial struct double_mt8
{
    #region Constants

    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static double_mt8 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static double_mt8 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static double_mt8 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static double_mt8 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static double_mt8 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static double_mt8 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static double_mt8 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144);
    }

    #endregion
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static double_mt8 mod([This] double_mt8 a, double_mt8 b)
    {
        return new(simd.Mod(a.vector, b.vector));
    }
}

#endregion // double_mt8
#region double_mt16

public partial struct double_mt16
{
    #region Constants

    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static double_mt16 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static double_mt16 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static double_mt16 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static double_mt16 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static double_mt16 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static double_mt16 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static double_mt16 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144);
    }

    #endregion
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static double_mt16 mod([This] double_mt16 a, double_mt16 b)
    {
        return new(simd.Mod(a.vector0, b.vector0), simd.Mod(a.vector1, b.vector1));
    }
}

#endregion // double_mt16
#region double_mt32

public partial struct double_mt32
{
    #region Constants

    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static double_mt32 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static double_mt32 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static double_mt32 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static double_mt32 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static double_mt32 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static double_mt32 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static double_mt32 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144);
    }

    #endregion
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static double_mt32 mod([This] double_mt32 a, double_mt32 b)
    {
        return new(simd.Mod(a.vector0, b.vector0), simd.Mod(a.vector1, b.vector1), simd.Mod(a.vector2, b.vector2), simd.Mod(a.vector3, b.vector3));
    }
}

#endregion // double_mt32
