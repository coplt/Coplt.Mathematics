<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="../../../Coplt.Mathematics/types.ttinclude" #><#@ import namespace="System.Linq" #>// generated by template, do not modify manually

namespace Coplt.Mathematics.SIMT;

<#
    var sizes = new[] { 4, 8, 16, 32 };
    foreach (var typ in Typ.Typs)
    {
        if (!typ.f) continue;
        if (!typ.arith) continue;
        if (!typ.simd) continue;
        if (typ.size < 4) continue;
        foreach (var size in sizes)
        {
            var byteSize = typ.size * size;
            var bitSize = 8 * byteSize;
            var num_vectors = Math.Max(1, bitSize / 512);
            bitSize = Math.Min(512, bitSize);

            var typeName = $"{typ.compType}_mt{size}";

            IEnumerable<string> ForVectors(string name)
            {
                if (num_vectors == 1) yield return name;
                else
                {
                    for (var i = 0; i < num_vectors; i++)
                    {
                        yield return $"{name}{i}";
                    }
                }
            }

            var vectors = ForVectors("vector").ToList();
#>
#region <#= typeName #>

public partial struct <#= typeName #>
{
    #region Constants

    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static <#= typeName #> E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277<#= typ.suffix #>); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static <#= typeName #> Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094<#= typ.suffix #>); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static <#= typeName #> Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009<#= typ.suffix #>);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static <#= typeName #> PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923<#= typ.suffix #>);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static <#= typeName #> Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846<#= typ.suffix #>);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static <#= typeName #> RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861<#= typ.suffix #>);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static <#= typeName #> DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144<#= typ.suffix #>);
    }

    #endregion
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static <#= typeName #> mod([This] <#= typeName #> a, <#= typeName #> b)
    {
        return new(<#= string.Join(", ", vectors.Select(v => $"simd.Mod(a.{v}, b.{v})")) #>);
    }
}

#endregion // <#= typeName #>
<#
        }
    }
#>
