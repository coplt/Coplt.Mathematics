// generated by template, do not modify manually

namespace Coplt.Mathematics.SIMT;

#region float_mt

[Serializable]
//[JsonConverter(typeof(float_mtJsonConverter))]
public partial struct float_mt
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => Vector<float>.Count;
    }

    #endregion

    #region Fields

    public Vector<float> vector;

    #endregion // Fields

    #region Properties

    public float this[int index]
    {
        [MethodImpl(256 | 512)]
        get => vector[index];
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(index, value);
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public float_mt(Vector<float> vector)
    {
        this.vector = vector;
    }

    [MethodImpl(256 | 512)]
    private float_mt(ref readonly float values)
    {
        vector = Vector.LoadUnsafe(in values);
    }

    [MethodImpl(256 | 512)]
    public static float_mt LoadUnsafe(ref readonly float values) => new(in values);

    [MethodImpl(256 | 512)]
    public static float_mt LoadUnsafe(params ReadOnlySpan<float> values) => new(in values.GetPinnableReference());

    [MethodImpl(256 | 512)]
    public float_mt(float value)
    {
        vector = new(value);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator float_mt(float value) => new(value);

    [MethodImpl(256 | 512)]
    public static float_mt operator-(float_mt a) => new(-a.vector);

    [MethodImpl(256 | 512)]
    public static float_mt operator+(float_mt a, float_mt b) => new(a.vector + b.vector);

    [MethodImpl(256 | 512)]
    public static float_mt operator-(float_mt a, float_mt b) => new(a.vector - b.vector);

    [MethodImpl(256 | 512)]
    public static float_mt operator*(float_mt a, float_mt b) => new(a.vector * b.vector);

    [MethodImpl(256 | 512)]
    public static float_mt operator/(float_mt a, float_mt b) => new(a.vector / b.vector);

    [MethodImpl(256 | 512)]
    public static float_mt operator/(float_mt a, float b) => new(a.vector / b);

    [MethodImpl(256 | 512)]
    public static float_mt operator%(float_mt a, float_mt b) => new(simd_mt.Rem(a.vector, b.vector));

    [MethodImpl(256 | 512)]
    public static float_mt operator%(float_mt a, float b) => new(simd_mt.Rem(a.vector, b));

    [MethodImpl(256 | 512)]
    public static float_mt operator~(float_mt a) => new(~a.vector);

    [MethodImpl(256 | 512)]
    public static float_mt operator|(float_mt a, float_mt b) => new(a.vector | b.vector);

    [MethodImpl(256 | 512)]
    public static float_mt operator&(float_mt a, float_mt b) => new(a.vector & b.vector);

    #endregion
}

#endregion // float_mt
#region int_mt

[Serializable]
//[JsonConverter(typeof(int_mtJsonConverter))]
public partial struct int_mt
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => Vector<int>.Count;
    }

    #endregion

    #region Fields

    public Vector<int> vector;

    #endregion // Fields

    #region Properties

    public int this[int index]
    {
        [MethodImpl(256 | 512)]
        get => vector[index];
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(index, value);
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public int_mt(Vector<int> vector)
    {
        this.vector = vector;
    }

    [MethodImpl(256 | 512)]
    private int_mt(ref readonly int values)
    {
        vector = Vector.LoadUnsafe(in values);
    }

    [MethodImpl(256 | 512)]
    public static int_mt LoadUnsafe(ref readonly int values) => new(in values);

    [MethodImpl(256 | 512)]
    public static int_mt LoadUnsafe(params ReadOnlySpan<int> values) => new(in values.GetPinnableReference());

    [MethodImpl(256 | 512)]
    public int_mt(int value)
    {
        vector = new(value);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator int_mt(int value) => new(value);

    [MethodImpl(256 | 512)]
    public static int_mt operator-(int_mt a) => new(-a.vector);

    [MethodImpl(256 | 512)]
    public static int_mt operator+(int_mt a, int_mt b) => new(a.vector + b.vector);

    [MethodImpl(256 | 512)]
    public static int_mt operator-(int_mt a, int_mt b) => new(a.vector - b.vector);

    [MethodImpl(256 | 512)]
    public static int_mt operator*(int_mt a, int_mt b) => new(a.vector * b.vector);

    [MethodImpl(256 | 512)]
    public static int_mt operator/(int_mt a, int_mt b) => new(a.vector / b.vector);

    [MethodImpl(256 | 512)]
    public static int_mt operator/(int_mt a, int b) => new(a.vector / b);

    [MethodImpl(256 | 512)]
    public static int_mt operator%(int_mt a, int_mt b) => new(simd_mt.Rem(a.vector, b.vector));

    [MethodImpl(256 | 512)]
    public static int_mt operator%(int_mt a, int b) => new(simd_mt.Rem(a.vector, b));

    [MethodImpl(256 | 512)]
    public static int_mt operator~(int_mt a) => new(~a.vector);

    [MethodImpl(256 | 512)]
    public static int_mt operator|(int_mt a, int_mt b) => new(a.vector | b.vector);

    [MethodImpl(256 | 512)]
    public static int_mt operator&(int_mt a, int_mt b) => new(a.vector & b.vector);

    #endregion
}

#endregion // int_mt
#region uint_mt

[Serializable]
//[JsonConverter(typeof(uint_mtJsonConverter))]
public partial struct uint_mt
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => Vector<uint>.Count;
    }

    #endregion

    #region Fields

    public Vector<uint> vector;

    #endregion // Fields

    #region Properties

    public uint this[int index]
    {
        [MethodImpl(256 | 512)]
        get => vector[index];
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(index, value);
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public uint_mt(Vector<uint> vector)
    {
        this.vector = vector;
    }

    [MethodImpl(256 | 512)]
    private uint_mt(ref readonly uint values)
    {
        vector = Vector.LoadUnsafe(in values);
    }

    [MethodImpl(256 | 512)]
    public static uint_mt LoadUnsafe(ref readonly uint values) => new(in values);

    [MethodImpl(256 | 512)]
    public static uint_mt LoadUnsafe(params ReadOnlySpan<uint> values) => new(in values.GetPinnableReference());

    [MethodImpl(256 | 512)]
    public uint_mt(uint value)
    {
        vector = new(value);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator uint_mt(uint value) => new(value);

    [MethodImpl(256 | 512)]
    public static uint_mt operator-(uint_mt a) => new(-a.vector);

    [MethodImpl(256 | 512)]
    public static uint_mt operator+(uint_mt a, uint_mt b) => new(a.vector + b.vector);

    [MethodImpl(256 | 512)]
    public static uint_mt operator-(uint_mt a, uint_mt b) => new(a.vector - b.vector);

    [MethodImpl(256 | 512)]
    public static uint_mt operator*(uint_mt a, uint_mt b) => new(a.vector * b.vector);

    [MethodImpl(256 | 512)]
    public static uint_mt operator/(uint_mt a, uint_mt b) => new(a.vector / b.vector);

    [MethodImpl(256 | 512)]
    public static uint_mt operator/(uint_mt a, uint b) => new(a.vector / b);

    [MethodImpl(256 | 512)]
    public static uint_mt operator%(uint_mt a, uint_mt b) => new(simd_mt.Rem(a.vector, b.vector));

    [MethodImpl(256 | 512)]
    public static uint_mt operator%(uint_mt a, uint b) => new(simd_mt.Rem(a.vector, b));

    [MethodImpl(256 | 512)]
    public static uint_mt operator~(uint_mt a) => new(~a.vector);

    [MethodImpl(256 | 512)]
    public static uint_mt operator|(uint_mt a, uint_mt b) => new(a.vector | b.vector);

    [MethodImpl(256 | 512)]
    public static uint_mt operator&(uint_mt a, uint_mt b) => new(a.vector & b.vector);

    #endregion
}

#endregion // uint_mt
#region b32_mt

[Serializable]
//[JsonConverter(typeof(b32_mtJsonConverter))]
public partial struct b32_mt
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => Vector<uint>.Count;
    }

    #endregion

    #region Fields

    public Vector<uint> vector;

    #endregion // Fields

    #region Properties

    public b32 this[int index]
    {
        [MethodImpl(256 | 512)]
        get => vector[index];
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(index, value);
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public b32_mt(Vector<uint> vector)
    {
        this.vector = vector;
    }

    [MethodImpl(256 | 512)]
    private b32_mt(ref readonly b32 values)
    {
        vector = Vector.LoadUnsafe(in Unsafe.As<b32, uint>(ref Unsafe.AsRef(in values)));
    }

    [MethodImpl(256 | 512)]
    public static b32_mt LoadUnsafe(ref readonly b32 values) => new(in values);

    [MethodImpl(256 | 512)]
    public static b32_mt LoadUnsafe(params ReadOnlySpan<b32> values) => new(in values.GetPinnableReference());

    [MethodImpl(256 | 512)]
    public b32_mt(b32 value)
    {
        vector = new((uint)value);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator b32_mt(b32 value) => new(value);

    [MethodImpl(256 | 512)]
    public static b32_mt operator~(b32_mt a) => new(~a.vector);

    [MethodImpl(256 | 512)]
    public static b32_mt operator|(b32_mt a, b32_mt b) => new(a.vector | b.vector);

    [MethodImpl(256 | 512)]
    public static b32_mt operator&(b32_mt a, b32_mt b) => new(a.vector & b.vector);

    #endregion
}

#endregion // b32_mt
