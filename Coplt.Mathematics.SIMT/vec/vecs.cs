// generated by template, do not modify manually

namespace Coplt.Mathematics.SIMT;

#region float2_mt

[Serializable]
//[JsonConverter(typeof(float2_mtJsonConverter))]
public partial struct float2_mt
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => Vector<float>.Count;
    }

    #endregion

    #region Fields

    public float_mt x;
    public float_mt y;

    #endregion // Fields

    #region Properties

    public float2 this[int index]
    {
        [MethodImpl(256 | 512)]
        get => new(x[index], y[index]);
        set 
        {
           x[index] = value.x;
           y[index] = value.y;
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public float2_mt(float_mt x, float_mt y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public float2_mt(float_mt value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public float2_mt(float2 value)
    {
        x = new(value.x);
        y = new(value.y);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator float2_mt(float value) => new float_mt(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float2_mt(float_mt value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float2_mt(float2 value) => new(value);

    [MethodImpl(256 | 512)]
    public static float2_mt operator-(float2_mt a) => new(-a.x, -a.y);

    [MethodImpl(256 | 512)]
    public static float2_mt operator+(float2_mt a, float2_mt b) => new(a.x + b.x, a.y + b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt operator-(float2_mt a, float2_mt b) => new(a.x - b.x, a.y - b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt operator*(float2_mt a, float2_mt b) => new(a.x * b.x, a.y * b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt operator/(float2_mt a, float2_mt b) => new(a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static float2_mt operator/(float2_mt a, float b) => new(a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static float2_mt operator%(float2_mt a, float2_mt b) => new(a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static float2_mt operator%(float2_mt a, float b) => new(a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static float2_mt operator~(float2_mt a) => new(~a.x, ~a.y);

    [MethodImpl(256 | 512)]
    public static float2_mt operator|(float2_mt a, float2_mt b) => new(a.x | b.x, a.y | b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt operator&(float2_mt a, float2_mt b) => new(a.x & b.x, a.y & b.y);

    #endregion // Operators
}

#endregion // float2_mt
#region float3_mt

[Serializable]
//[JsonConverter(typeof(float3_mtJsonConverter))]
public partial struct float3_mt
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => Vector<float>.Count;
    }

    #endregion

    #region Fields

    public float_mt x;
    public float_mt y;
    public float_mt z;

    #endregion // Fields

    #region Properties

    public float3 this[int index]
    {
        [MethodImpl(256 | 512)]
        get => new(x[index], y[index], z[index]);
        set 
        {
           x[index] = value.x;
           y[index] = value.y;
           z[index] = value.z;
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public float3_mt(float_mt x, float_mt y, float_mt z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public float3_mt(float_mt value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public float3_mt(float3 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator float3_mt(float value) => new float_mt(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float3_mt(float_mt value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float3_mt(float3 value) => new(value);

    [MethodImpl(256 | 512)]
    public static float3_mt operator-(float3_mt a) => new(-a.x, -a.y, -a.z);

    [MethodImpl(256 | 512)]
    public static float3_mt operator+(float3_mt a, float3_mt b) => new(a.x + b.x, a.y + b.y, a.z + b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt operator-(float3_mt a, float3_mt b) => new(a.x - b.x, a.y - b.y, a.z - b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt operator*(float3_mt a, float3_mt b) => new(a.x * b.x, a.y * b.y, a.z * b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt operator/(float3_mt a, float3_mt b) => new(a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static float3_mt operator/(float3_mt a, float b) => new(a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static float3_mt operator%(float3_mt a, float3_mt b) => new(a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static float3_mt operator%(float3_mt a, float b) => new(a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static float3_mt operator~(float3_mt a) => new(~a.x, ~a.y, ~a.z);

    [MethodImpl(256 | 512)]
    public static float3_mt operator|(float3_mt a, float3_mt b) => new(a.x | b.x, a.y | b.y, a.z | b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt operator&(float3_mt a, float3_mt b) => new(a.x & b.x, a.y & b.y, a.z & b.z);

    #endregion // Operators
}

#endregion // float3_mt
#region float4_mt

[Serializable]
//[JsonConverter(typeof(float4_mtJsonConverter))]
public partial struct float4_mt
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => Vector<float>.Count;
    }

    #endregion

    #region Fields

    public float_mt x;
    public float_mt y;
    public float_mt z;
    public float_mt w;

    #endregion // Fields

    #region Properties

    public float4 this[int index]
    {
        [MethodImpl(256 | 512)]
        get => new(x[index], y[index], z[index], w[index]);
        set 
        {
           x[index] = value.x;
           y[index] = value.y;
           z[index] = value.z;
           w[index] = value.w;
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public float4_mt(float_mt x, float_mt y, float_mt z, float_mt w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public float4_mt(float_mt value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public float4_mt(float4 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
        w = new(value.w);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator float4_mt(float value) => new float_mt(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float4_mt(float_mt value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float4_mt(float4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static float4_mt operator-(float4_mt a) => new(-a.x, -a.y, -a.z, -a.w);

    [MethodImpl(256 | 512)]
    public static float4_mt operator+(float4_mt a, float4_mt b) => new(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt operator-(float4_mt a, float4_mt b) => new(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt operator*(float4_mt a, float4_mt b) => new(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt operator/(float4_mt a, float4_mt b) => new(a.w / b.w, a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static float4_mt operator/(float4_mt a, float b) => new(a.w / b, a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static float4_mt operator%(float4_mt a, float4_mt b) => new(a.w % b.w, a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static float4_mt operator%(float4_mt a, float b) => new(a.w % b, a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static float4_mt operator~(float4_mt a) => new(~a.x, ~a.y, ~a.z, ~a.w);

    [MethodImpl(256 | 512)]
    public static float4_mt operator|(float4_mt a, float4_mt b) => new(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt operator&(float4_mt a, float4_mt b) => new(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);

    #endregion // Operators
}

#endregion // float4_mt
#region int2_mt

[Serializable]
//[JsonConverter(typeof(int2_mtJsonConverter))]
public partial struct int2_mt
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => Vector<int>.Count;
    }

    #endregion

    #region Fields

    public int_mt x;
    public int_mt y;

    #endregion // Fields

    #region Properties

    public int2 this[int index]
    {
        [MethodImpl(256 | 512)]
        get => new(x[index], y[index]);
        set 
        {
           x[index] = value.x;
           y[index] = value.y;
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public int2_mt(int_mt x, int_mt y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public int2_mt(int_mt value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public int2_mt(int2 value)
    {
        x = new(value.x);
        y = new(value.y);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator int2_mt(int value) => new int_mt(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int2_mt(int_mt value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int2_mt(int2 value) => new(value);

    [MethodImpl(256 | 512)]
    public static int2_mt operator-(int2_mt a) => new(-a.x, -a.y);

    [MethodImpl(256 | 512)]
    public static int2_mt operator+(int2_mt a, int2_mt b) => new(a.x + b.x, a.y + b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt operator-(int2_mt a, int2_mt b) => new(a.x - b.x, a.y - b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt operator*(int2_mt a, int2_mt b) => new(a.x * b.x, a.y * b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt operator/(int2_mt a, int2_mt b) => new(a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static int2_mt operator/(int2_mt a, int b) => new(a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static int2_mt operator%(int2_mt a, int2_mt b) => new(a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static int2_mt operator%(int2_mt a, int b) => new(a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static int2_mt operator~(int2_mt a) => new(~a.x, ~a.y);

    [MethodImpl(256 | 512)]
    public static int2_mt operator|(int2_mt a, int2_mt b) => new(a.x | b.x, a.y | b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt operator&(int2_mt a, int2_mt b) => new(a.x & b.x, a.y & b.y);

    #endregion // Operators
}

#endregion // int2_mt
#region int3_mt

[Serializable]
//[JsonConverter(typeof(int3_mtJsonConverter))]
public partial struct int3_mt
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => Vector<int>.Count;
    }

    #endregion

    #region Fields

    public int_mt x;
    public int_mt y;
    public int_mt z;

    #endregion // Fields

    #region Properties

    public int3 this[int index]
    {
        [MethodImpl(256 | 512)]
        get => new(x[index], y[index], z[index]);
        set 
        {
           x[index] = value.x;
           y[index] = value.y;
           z[index] = value.z;
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public int3_mt(int_mt x, int_mt y, int_mt z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public int3_mt(int_mt value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public int3_mt(int3 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator int3_mt(int value) => new int_mt(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int3_mt(int_mt value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int3_mt(int3 value) => new(value);

    [MethodImpl(256 | 512)]
    public static int3_mt operator-(int3_mt a) => new(-a.x, -a.y, -a.z);

    [MethodImpl(256 | 512)]
    public static int3_mt operator+(int3_mt a, int3_mt b) => new(a.x + b.x, a.y + b.y, a.z + b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt operator-(int3_mt a, int3_mt b) => new(a.x - b.x, a.y - b.y, a.z - b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt operator*(int3_mt a, int3_mt b) => new(a.x * b.x, a.y * b.y, a.z * b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt operator/(int3_mt a, int3_mt b) => new(a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static int3_mt operator/(int3_mt a, int b) => new(a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static int3_mt operator%(int3_mt a, int3_mt b) => new(a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static int3_mt operator%(int3_mt a, int b) => new(a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static int3_mt operator~(int3_mt a) => new(~a.x, ~a.y, ~a.z);

    [MethodImpl(256 | 512)]
    public static int3_mt operator|(int3_mt a, int3_mt b) => new(a.x | b.x, a.y | b.y, a.z | b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt operator&(int3_mt a, int3_mt b) => new(a.x & b.x, a.y & b.y, a.z & b.z);

    #endregion // Operators
}

#endregion // int3_mt
#region int4_mt

[Serializable]
//[JsonConverter(typeof(int4_mtJsonConverter))]
public partial struct int4_mt
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => Vector<int>.Count;
    }

    #endregion

    #region Fields

    public int_mt x;
    public int_mt y;
    public int_mt z;
    public int_mt w;

    #endregion // Fields

    #region Properties

    public int4 this[int index]
    {
        [MethodImpl(256 | 512)]
        get => new(x[index], y[index], z[index], w[index]);
        set 
        {
           x[index] = value.x;
           y[index] = value.y;
           z[index] = value.z;
           w[index] = value.w;
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public int4_mt(int_mt x, int_mt y, int_mt z, int_mt w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public int4_mt(int_mt value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public int4_mt(int4 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
        w = new(value.w);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator int4_mt(int value) => new int_mt(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int4_mt(int_mt value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int4_mt(int4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static int4_mt operator-(int4_mt a) => new(-a.x, -a.y, -a.z, -a.w);

    [MethodImpl(256 | 512)]
    public static int4_mt operator+(int4_mt a, int4_mt b) => new(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt operator-(int4_mt a, int4_mt b) => new(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt operator*(int4_mt a, int4_mt b) => new(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt operator/(int4_mt a, int4_mt b) => new(a.w / b.w, a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static int4_mt operator/(int4_mt a, int b) => new(a.w / b, a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static int4_mt operator%(int4_mt a, int4_mt b) => new(a.w % b.w, a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static int4_mt operator%(int4_mt a, int b) => new(a.w % b, a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static int4_mt operator~(int4_mt a) => new(~a.x, ~a.y, ~a.z, ~a.w);

    [MethodImpl(256 | 512)]
    public static int4_mt operator|(int4_mt a, int4_mt b) => new(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt operator&(int4_mt a, int4_mt b) => new(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);

    #endregion // Operators
}

#endregion // int4_mt
#region uint2_mt

[Serializable]
//[JsonConverter(typeof(uint2_mtJsonConverter))]
public partial struct uint2_mt
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => Vector<uint>.Count;
    }

    #endregion

    #region Fields

    public uint_mt x;
    public uint_mt y;

    #endregion // Fields

    #region Properties

    public uint2 this[int index]
    {
        [MethodImpl(256 | 512)]
        get => new(x[index], y[index]);
        set 
        {
           x[index] = value.x;
           y[index] = value.y;
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public uint2_mt(uint_mt x, uint_mt y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public uint2_mt(uint_mt value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public uint2_mt(uint2 value)
    {
        x = new(value.x);
        y = new(value.y);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator uint2_mt(uint value) => new uint_mt(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint2_mt(uint_mt value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint2_mt(uint2 value) => new(value);

    [MethodImpl(256 | 512)]
    public static uint2_mt operator-(uint2_mt a) => new(-a.x, -a.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt operator+(uint2_mt a, uint2_mt b) => new(a.x + b.x, a.y + b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt operator-(uint2_mt a, uint2_mt b) => new(a.x - b.x, a.y - b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt operator*(uint2_mt a, uint2_mt b) => new(a.x * b.x, a.y * b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt operator/(uint2_mt a, uint2_mt b) => new(a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static uint2_mt operator/(uint2_mt a, uint b) => new(a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static uint2_mt operator%(uint2_mt a, uint2_mt b) => new(a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static uint2_mt operator%(uint2_mt a, uint b) => new(a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static uint2_mt operator~(uint2_mt a) => new(~a.x, ~a.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt operator|(uint2_mt a, uint2_mt b) => new(a.x | b.x, a.y | b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt operator&(uint2_mt a, uint2_mt b) => new(a.x & b.x, a.y & b.y);

    #endregion // Operators
}

#endregion // uint2_mt
#region uint3_mt

[Serializable]
//[JsonConverter(typeof(uint3_mtJsonConverter))]
public partial struct uint3_mt
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => Vector<uint>.Count;
    }

    #endregion

    #region Fields

    public uint_mt x;
    public uint_mt y;
    public uint_mt z;

    #endregion // Fields

    #region Properties

    public uint3 this[int index]
    {
        [MethodImpl(256 | 512)]
        get => new(x[index], y[index], z[index]);
        set 
        {
           x[index] = value.x;
           y[index] = value.y;
           z[index] = value.z;
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public uint3_mt(uint_mt x, uint_mt y, uint_mt z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public uint3_mt(uint_mt value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public uint3_mt(uint3 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator uint3_mt(uint value) => new uint_mt(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint3_mt(uint_mt value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint3_mt(uint3 value) => new(value);

    [MethodImpl(256 | 512)]
    public static uint3_mt operator-(uint3_mt a) => new(-a.x, -a.y, -a.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt operator+(uint3_mt a, uint3_mt b) => new(a.x + b.x, a.y + b.y, a.z + b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt operator-(uint3_mt a, uint3_mt b) => new(a.x - b.x, a.y - b.y, a.z - b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt operator*(uint3_mt a, uint3_mt b) => new(a.x * b.x, a.y * b.y, a.z * b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt operator/(uint3_mt a, uint3_mt b) => new(a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static uint3_mt operator/(uint3_mt a, uint b) => new(a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static uint3_mt operator%(uint3_mt a, uint3_mt b) => new(a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static uint3_mt operator%(uint3_mt a, uint b) => new(a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static uint3_mt operator~(uint3_mt a) => new(~a.x, ~a.y, ~a.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt operator|(uint3_mt a, uint3_mt b) => new(a.x | b.x, a.y | b.y, a.z | b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt operator&(uint3_mt a, uint3_mt b) => new(a.x & b.x, a.y & b.y, a.z & b.z);

    #endregion // Operators
}

#endregion // uint3_mt
#region uint4_mt

[Serializable]
//[JsonConverter(typeof(uint4_mtJsonConverter))]
public partial struct uint4_mt
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => Vector<uint>.Count;
    }

    #endregion

    #region Fields

    public uint_mt x;
    public uint_mt y;
    public uint_mt z;
    public uint_mt w;

    #endregion // Fields

    #region Properties

    public uint4 this[int index]
    {
        [MethodImpl(256 | 512)]
        get => new(x[index], y[index], z[index], w[index]);
        set 
        {
           x[index] = value.x;
           y[index] = value.y;
           z[index] = value.z;
           w[index] = value.w;
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public uint4_mt(uint_mt x, uint_mt y, uint_mt z, uint_mt w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public uint4_mt(uint_mt value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public uint4_mt(uint4 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
        w = new(value.w);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator uint4_mt(uint value) => new uint_mt(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint4_mt(uint_mt value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint4_mt(uint4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static uint4_mt operator-(uint4_mt a) => new(-a.x, -a.y, -a.z, -a.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt operator+(uint4_mt a, uint4_mt b) => new(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt operator-(uint4_mt a, uint4_mt b) => new(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt operator*(uint4_mt a, uint4_mt b) => new(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt operator/(uint4_mt a, uint4_mt b) => new(a.w / b.w, a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static uint4_mt operator/(uint4_mt a, uint b) => new(a.w / b, a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static uint4_mt operator%(uint4_mt a, uint4_mt b) => new(a.w % b.w, a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static uint4_mt operator%(uint4_mt a, uint b) => new(a.w % b, a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static uint4_mt operator~(uint4_mt a) => new(~a.x, ~a.y, ~a.z, ~a.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt operator|(uint4_mt a, uint4_mt b) => new(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt operator&(uint4_mt a, uint4_mt b) => new(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);

    #endregion // Operators
}

#endregion // uint4_mt
#region b32v2_mt

[Serializable]
//[JsonConverter(typeof(b32v2_mtJsonConverter))]
public partial struct b32v2_mt
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => Vector<uint>.Count;
    }

    #endregion

    #region Fields

    public b32_mt x;
    public b32_mt y;

    #endregion // Fields

    #region Properties

    public b32v2 this[int index]
    {
        [MethodImpl(256 | 512)]
        get => new(x[index], y[index]);
        set 
        {
           x[index] = value.x;
           y[index] = value.y;
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public b32v2_mt(b32_mt x, b32_mt y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public b32v2_mt(b32_mt value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b32v2_mt(b32v2 value)
    {
        x = new(value.x);
        y = new(value.y);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator b32v2_mt(b32 value) => new b32_mt(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v2_mt(b32_mt value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v2_mt(b32v2 value) => new(value);

    [MethodImpl(256 | 512)]
    public static b32v2_mt operator~(b32v2_mt a) => new(~a.x, ~a.y);

    [MethodImpl(256 | 512)]
    public static b32v2_mt operator|(b32v2_mt a, b32v2_mt b) => new(a.x | b.x, a.y | b.y);

    [MethodImpl(256 | 512)]
    public static b32v2_mt operator&(b32v2_mt a, b32v2_mt b) => new(a.x & b.x, a.y & b.y);

    #endregion // Operators
}

#endregion // b32v2_mt
#region b32v3_mt

[Serializable]
//[JsonConverter(typeof(b32v3_mtJsonConverter))]
public partial struct b32v3_mt
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => Vector<uint>.Count;
    }

    #endregion

    #region Fields

    public b32_mt x;
    public b32_mt y;
    public b32_mt z;

    #endregion // Fields

    #region Properties

    public b32v3 this[int index]
    {
        [MethodImpl(256 | 512)]
        get => new(x[index], y[index], z[index]);
        set 
        {
           x[index] = value.x;
           y[index] = value.y;
           z[index] = value.z;
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public b32v3_mt(b32_mt x, b32_mt y, b32_mt z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public b32v3_mt(b32_mt value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b32v3_mt(b32v3 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator b32v3_mt(b32 value) => new b32_mt(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v3_mt(b32_mt value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v3_mt(b32v3 value) => new(value);

    [MethodImpl(256 | 512)]
    public static b32v3_mt operator~(b32v3_mt a) => new(~a.x, ~a.y, ~a.z);

    [MethodImpl(256 | 512)]
    public static b32v3_mt operator|(b32v3_mt a, b32v3_mt b) => new(a.x | b.x, a.y | b.y, a.z | b.z);

    [MethodImpl(256 | 512)]
    public static b32v3_mt operator&(b32v3_mt a, b32v3_mt b) => new(a.x & b.x, a.y & b.y, a.z & b.z);

    #endregion // Operators
}

#endregion // b32v3_mt
#region b32v4_mt

[Serializable]
//[JsonConverter(typeof(b32v4_mtJsonConverter))]
public partial struct b32v4_mt
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => Vector<uint>.Count;
    }

    #endregion

    #region Fields

    public b32_mt x;
    public b32_mt y;
    public b32_mt z;
    public b32_mt w;

    #endregion // Fields

    #region Properties

    public b32v4 this[int index]
    {
        [MethodImpl(256 | 512)]
        get => new(x[index], y[index], z[index], w[index]);
        set 
        {
           x[index] = value.x;
           y[index] = value.y;
           z[index] = value.z;
           w[index] = value.w;
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public b32v4_mt(b32_mt x, b32_mt y, b32_mt z, b32_mt w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public b32v4_mt(b32_mt value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b32v4_mt(b32v4 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
        w = new(value.w);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator b32v4_mt(b32 value) => new b32_mt(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v4_mt(b32_mt value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v4_mt(b32v4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static b32v4_mt operator~(b32v4_mt a) => new(~a.x, ~a.y, ~a.z, ~a.w);

    [MethodImpl(256 | 512)]
    public static b32v4_mt operator|(b32v4_mt a, b32v4_mt b) => new(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);

    [MethodImpl(256 | 512)]
    public static b32v4_mt operator&(b32v4_mt a, b32v4_mt b) => new(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);

    #endregion // Operators
}

#endregion // b32v4_mt
