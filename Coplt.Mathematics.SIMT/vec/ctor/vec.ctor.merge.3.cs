// generated by template, do not modify manually

namespace Coplt.Mathematics.Simt;

#region float3_mt4

public partial struct float3_mt4 
{
    [MethodImpl(256 | 512)]
    public float3_mt4(float2_mt4 xy, float z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public float3_mt4(float x, float2_mt4 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal float3_mt4(float2_mt4 xz, float y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static float3_mt4 float3_mt4(float2_mt4 xy, float z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static float3_mt4 float3_mt4(float x, float2_mt4 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float3_mt4 Ix(this float2_mt4 yz, float x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float3_mt4 Iy(this float2_mt4 xz, float y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float3_mt4 Iz(this float2_mt4 xy, float z) => new(xy, z);
}

#endregion // float3_mt4

#region float3_mt8

public partial struct float3_mt8 
{
    [MethodImpl(256 | 512)]
    public float3_mt8(float2_mt8 xy, float z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public float3_mt8(float x, float2_mt8 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal float3_mt8(float2_mt8 xz, float y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static float3_mt8 float3_mt8(float2_mt8 xy, float z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static float3_mt8 float3_mt8(float x, float2_mt8 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float3_mt8 Ix(this float2_mt8 yz, float x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float3_mt8 Iy(this float2_mt8 xz, float y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float3_mt8 Iz(this float2_mt8 xy, float z) => new(xy, z);
}

#endregion // float3_mt8

#region float3_mt16

public partial struct float3_mt16 
{
    [MethodImpl(256 | 512)]
    public float3_mt16(float2_mt16 xy, float z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public float3_mt16(float x, float2_mt16 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal float3_mt16(float2_mt16 xz, float y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static float3_mt16 float3_mt16(float2_mt16 xy, float z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static float3_mt16 float3_mt16(float x, float2_mt16 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float3_mt16 Ix(this float2_mt16 yz, float x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float3_mt16 Iy(this float2_mt16 xz, float y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float3_mt16 Iz(this float2_mt16 xy, float z) => new(xy, z);
}

#endregion // float3_mt16

#region float3_mt32

public partial struct float3_mt32 
{
    [MethodImpl(256 | 512)]
    public float3_mt32(float2_mt32 xy, float z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public float3_mt32(float x, float2_mt32 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal float3_mt32(float2_mt32 xz, float y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static float3_mt32 float3_mt32(float2_mt32 xy, float z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static float3_mt32 float3_mt32(float x, float2_mt32 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float3_mt32 Ix(this float2_mt32 yz, float x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float3_mt32 Iy(this float2_mt32 xz, float y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float3_mt32 Iz(this float2_mt32 xy, float z) => new(xy, z);
}

#endregion // float3_mt32

#region double3_mt4

public partial struct double3_mt4 
{
    [MethodImpl(256 | 512)]
    public double3_mt4(double2_mt4 xy, double z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public double3_mt4(double x, double2_mt4 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal double3_mt4(double2_mt4 xz, double y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static double3_mt4 double3_mt4(double2_mt4 xy, double z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static double3_mt4 double3_mt4(double x, double2_mt4 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double3_mt4 Ix(this double2_mt4 yz, double x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double3_mt4 Iy(this double2_mt4 xz, double y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double3_mt4 Iz(this double2_mt4 xy, double z) => new(xy, z);
}

#endregion // double3_mt4

#region double3_mt8

public partial struct double3_mt8 
{
    [MethodImpl(256 | 512)]
    public double3_mt8(double2_mt8 xy, double z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public double3_mt8(double x, double2_mt8 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal double3_mt8(double2_mt8 xz, double y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static double3_mt8 double3_mt8(double2_mt8 xy, double z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static double3_mt8 double3_mt8(double x, double2_mt8 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double3_mt8 Ix(this double2_mt8 yz, double x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double3_mt8 Iy(this double2_mt8 xz, double y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double3_mt8 Iz(this double2_mt8 xy, double z) => new(xy, z);
}

#endregion // double3_mt8

#region double3_mt16

public partial struct double3_mt16 
{
    [MethodImpl(256 | 512)]
    public double3_mt16(double2_mt16 xy, double z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public double3_mt16(double x, double2_mt16 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal double3_mt16(double2_mt16 xz, double y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static double3_mt16 double3_mt16(double2_mt16 xy, double z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static double3_mt16 double3_mt16(double x, double2_mt16 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double3_mt16 Ix(this double2_mt16 yz, double x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double3_mt16 Iy(this double2_mt16 xz, double y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double3_mt16 Iz(this double2_mt16 xy, double z) => new(xy, z);
}

#endregion // double3_mt16

#region double3_mt32

public partial struct double3_mt32 
{
    [MethodImpl(256 | 512)]
    public double3_mt32(double2_mt32 xy, double z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public double3_mt32(double x, double2_mt32 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal double3_mt32(double2_mt32 xz, double y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static double3_mt32 double3_mt32(double2_mt32 xy, double z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static double3_mt32 double3_mt32(double x, double2_mt32 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double3_mt32 Ix(this double2_mt32 yz, double x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double3_mt32 Iy(this double2_mt32 xz, double y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double3_mt32 Iz(this double2_mt32 xy, double z) => new(xy, z);
}

#endregion // double3_mt32

#region int3_mt4

public partial struct int3_mt4 
{
    [MethodImpl(256 | 512)]
    public int3_mt4(int2_mt4 xy, int z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public int3_mt4(int x, int2_mt4 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal int3_mt4(int2_mt4 xz, int y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static int3_mt4 int3_mt4(int2_mt4 xy, int z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static int3_mt4 int3_mt4(int x, int2_mt4 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int3_mt4 Ix(this int2_mt4 yz, int x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int3_mt4 Iy(this int2_mt4 xz, int y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int3_mt4 Iz(this int2_mt4 xy, int z) => new(xy, z);
}

#endregion // int3_mt4

#region int3_mt8

public partial struct int3_mt8 
{
    [MethodImpl(256 | 512)]
    public int3_mt8(int2_mt8 xy, int z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public int3_mt8(int x, int2_mt8 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal int3_mt8(int2_mt8 xz, int y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static int3_mt8 int3_mt8(int2_mt8 xy, int z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static int3_mt8 int3_mt8(int x, int2_mt8 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int3_mt8 Ix(this int2_mt8 yz, int x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int3_mt8 Iy(this int2_mt8 xz, int y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int3_mt8 Iz(this int2_mt8 xy, int z) => new(xy, z);
}

#endregion // int3_mt8

#region int3_mt16

public partial struct int3_mt16 
{
    [MethodImpl(256 | 512)]
    public int3_mt16(int2_mt16 xy, int z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public int3_mt16(int x, int2_mt16 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal int3_mt16(int2_mt16 xz, int y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static int3_mt16 int3_mt16(int2_mt16 xy, int z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static int3_mt16 int3_mt16(int x, int2_mt16 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int3_mt16 Ix(this int2_mt16 yz, int x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int3_mt16 Iy(this int2_mt16 xz, int y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int3_mt16 Iz(this int2_mt16 xy, int z) => new(xy, z);
}

#endregion // int3_mt16

#region int3_mt32

public partial struct int3_mt32 
{
    [MethodImpl(256 | 512)]
    public int3_mt32(int2_mt32 xy, int z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public int3_mt32(int x, int2_mt32 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal int3_mt32(int2_mt32 xz, int y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static int3_mt32 int3_mt32(int2_mt32 xy, int z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static int3_mt32 int3_mt32(int x, int2_mt32 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int3_mt32 Ix(this int2_mt32 yz, int x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int3_mt32 Iy(this int2_mt32 xz, int y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int3_mt32 Iz(this int2_mt32 xy, int z) => new(xy, z);
}

#endregion // int3_mt32

#region uint3_mt4

public partial struct uint3_mt4 
{
    [MethodImpl(256 | 512)]
    public uint3_mt4(uint2_mt4 xy, uint z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public uint3_mt4(uint x, uint2_mt4 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal uint3_mt4(uint2_mt4 xz, uint y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static uint3_mt4 uint3_mt4(uint2_mt4 xy, uint z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static uint3_mt4 uint3_mt4(uint x, uint2_mt4 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint3_mt4 Ix(this uint2_mt4 yz, uint x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint3_mt4 Iy(this uint2_mt4 xz, uint y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint3_mt4 Iz(this uint2_mt4 xy, uint z) => new(xy, z);
}

#endregion // uint3_mt4

#region uint3_mt8

public partial struct uint3_mt8 
{
    [MethodImpl(256 | 512)]
    public uint3_mt8(uint2_mt8 xy, uint z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public uint3_mt8(uint x, uint2_mt8 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal uint3_mt8(uint2_mt8 xz, uint y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static uint3_mt8 uint3_mt8(uint2_mt8 xy, uint z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static uint3_mt8 uint3_mt8(uint x, uint2_mt8 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint3_mt8 Ix(this uint2_mt8 yz, uint x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint3_mt8 Iy(this uint2_mt8 xz, uint y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint3_mt8 Iz(this uint2_mt8 xy, uint z) => new(xy, z);
}

#endregion // uint3_mt8

#region uint3_mt16

public partial struct uint3_mt16 
{
    [MethodImpl(256 | 512)]
    public uint3_mt16(uint2_mt16 xy, uint z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public uint3_mt16(uint x, uint2_mt16 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal uint3_mt16(uint2_mt16 xz, uint y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static uint3_mt16 uint3_mt16(uint2_mt16 xy, uint z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static uint3_mt16 uint3_mt16(uint x, uint2_mt16 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint3_mt16 Ix(this uint2_mt16 yz, uint x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint3_mt16 Iy(this uint2_mt16 xz, uint y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint3_mt16 Iz(this uint2_mt16 xy, uint z) => new(xy, z);
}

#endregion // uint3_mt16

#region uint3_mt32

public partial struct uint3_mt32 
{
    [MethodImpl(256 | 512)]
    public uint3_mt32(uint2_mt32 xy, uint z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public uint3_mt32(uint x, uint2_mt32 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal uint3_mt32(uint2_mt32 xz, uint y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static uint3_mt32 uint3_mt32(uint2_mt32 xy, uint z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static uint3_mt32 uint3_mt32(uint x, uint2_mt32 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint3_mt32 Ix(this uint2_mt32 yz, uint x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint3_mt32 Iy(this uint2_mt32 xz, uint y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint3_mt32 Iz(this uint2_mt32 xy, uint z) => new(xy, z);
}

#endregion // uint3_mt32

#region long3_mt4

public partial struct long3_mt4 
{
    [MethodImpl(256 | 512)]
    public long3_mt4(long2_mt4 xy, long z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public long3_mt4(long x, long2_mt4 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal long3_mt4(long2_mt4 xz, long y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static long3_mt4 long3_mt4(long2_mt4 xy, long z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static long3_mt4 long3_mt4(long x, long2_mt4 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long3_mt4 Ix(this long2_mt4 yz, long x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long3_mt4 Iy(this long2_mt4 xz, long y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long3_mt4 Iz(this long2_mt4 xy, long z) => new(xy, z);
}

#endregion // long3_mt4

#region long3_mt8

public partial struct long3_mt8 
{
    [MethodImpl(256 | 512)]
    public long3_mt8(long2_mt8 xy, long z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public long3_mt8(long x, long2_mt8 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal long3_mt8(long2_mt8 xz, long y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static long3_mt8 long3_mt8(long2_mt8 xy, long z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static long3_mt8 long3_mt8(long x, long2_mt8 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long3_mt8 Ix(this long2_mt8 yz, long x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long3_mt8 Iy(this long2_mt8 xz, long y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long3_mt8 Iz(this long2_mt8 xy, long z) => new(xy, z);
}

#endregion // long3_mt8

#region long3_mt16

public partial struct long3_mt16 
{
    [MethodImpl(256 | 512)]
    public long3_mt16(long2_mt16 xy, long z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public long3_mt16(long x, long2_mt16 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal long3_mt16(long2_mt16 xz, long y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static long3_mt16 long3_mt16(long2_mt16 xy, long z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static long3_mt16 long3_mt16(long x, long2_mt16 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long3_mt16 Ix(this long2_mt16 yz, long x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long3_mt16 Iy(this long2_mt16 xz, long y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long3_mt16 Iz(this long2_mt16 xy, long z) => new(xy, z);
}

#endregion // long3_mt16

#region long3_mt32

public partial struct long3_mt32 
{
    [MethodImpl(256 | 512)]
    public long3_mt32(long2_mt32 xy, long z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public long3_mt32(long x, long2_mt32 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal long3_mt32(long2_mt32 xz, long y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static long3_mt32 long3_mt32(long2_mt32 xy, long z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static long3_mt32 long3_mt32(long x, long2_mt32 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long3_mt32 Ix(this long2_mt32 yz, long x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long3_mt32 Iy(this long2_mt32 xz, long y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long3_mt32 Iz(this long2_mt32 xy, long z) => new(xy, z);
}

#endregion // long3_mt32

#region ulong3_mt4

public partial struct ulong3_mt4 
{
    [MethodImpl(256 | 512)]
    public ulong3_mt4(ulong2_mt4 xy, ulong z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public ulong3_mt4(ulong x, ulong2_mt4 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal ulong3_mt4(ulong2_mt4 xz, ulong y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static ulong3_mt4 ulong3_mt4(ulong2_mt4 xy, ulong z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt4 ulong3_mt4(ulong x, ulong2_mt4 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong3_mt4 Ix(this ulong2_mt4 yz, ulong x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong3_mt4 Iy(this ulong2_mt4 xz, ulong y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong3_mt4 Iz(this ulong2_mt4 xy, ulong z) => new(xy, z);
}

#endregion // ulong3_mt4

#region ulong3_mt8

public partial struct ulong3_mt8 
{
    [MethodImpl(256 | 512)]
    public ulong3_mt8(ulong2_mt8 xy, ulong z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public ulong3_mt8(ulong x, ulong2_mt8 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal ulong3_mt8(ulong2_mt8 xz, ulong y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static ulong3_mt8 ulong3_mt8(ulong2_mt8 xy, ulong z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt8 ulong3_mt8(ulong x, ulong2_mt8 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong3_mt8 Ix(this ulong2_mt8 yz, ulong x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong3_mt8 Iy(this ulong2_mt8 xz, ulong y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong3_mt8 Iz(this ulong2_mt8 xy, ulong z) => new(xy, z);
}

#endregion // ulong3_mt8

#region ulong3_mt16

public partial struct ulong3_mt16 
{
    [MethodImpl(256 | 512)]
    public ulong3_mt16(ulong2_mt16 xy, ulong z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public ulong3_mt16(ulong x, ulong2_mt16 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal ulong3_mt16(ulong2_mt16 xz, ulong y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static ulong3_mt16 ulong3_mt16(ulong2_mt16 xy, ulong z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt16 ulong3_mt16(ulong x, ulong2_mt16 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong3_mt16 Ix(this ulong2_mt16 yz, ulong x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong3_mt16 Iy(this ulong2_mt16 xz, ulong y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong3_mt16 Iz(this ulong2_mt16 xy, ulong z) => new(xy, z);
}

#endregion // ulong3_mt16

#region ulong3_mt32

public partial struct ulong3_mt32 
{
    [MethodImpl(256 | 512)]
    public ulong3_mt32(ulong2_mt32 xy, ulong z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public ulong3_mt32(ulong x, ulong2_mt32 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal ulong3_mt32(ulong2_mt32 xz, ulong y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static ulong3_mt32 ulong3_mt32(ulong2_mt32 xy, ulong z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt32 ulong3_mt32(ulong x, ulong2_mt32 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong3_mt32 Ix(this ulong2_mt32 yz, ulong x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong3_mt32 Iy(this ulong2_mt32 xz, ulong y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong3_mt32 Iz(this ulong2_mt32 xy, ulong z) => new(xy, z);
}

#endregion // ulong3_mt32

#region b32v3_mt4

public partial struct b32v3_mt4 
{
    [MethodImpl(256 | 512)]
    public b32v3_mt4(b32v2_mt4 xy, b32 z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public b32v3_mt4(b32 x, b32v2_mt4 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal b32v3_mt4(b32v2_mt4 xz, b32 y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static b32v3_mt4 b32v3_mt4(b32v2_mt4 xy, b32 z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static b32v3_mt4 b32v3_mt4(b32 x, b32v2_mt4 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v3_mt4 Ix(this b32v2_mt4 yz, b32 x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v3_mt4 Iy(this b32v2_mt4 xz, b32 y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v3_mt4 Iz(this b32v2_mt4 xy, b32 z) => new(xy, z);
}

#endregion // b32v3_mt4

#region b32v3_mt8

public partial struct b32v3_mt8 
{
    [MethodImpl(256 | 512)]
    public b32v3_mt8(b32v2_mt8 xy, b32 z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public b32v3_mt8(b32 x, b32v2_mt8 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal b32v3_mt8(b32v2_mt8 xz, b32 y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static b32v3_mt8 b32v3_mt8(b32v2_mt8 xy, b32 z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static b32v3_mt8 b32v3_mt8(b32 x, b32v2_mt8 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v3_mt8 Ix(this b32v2_mt8 yz, b32 x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v3_mt8 Iy(this b32v2_mt8 xz, b32 y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v3_mt8 Iz(this b32v2_mt8 xy, b32 z) => new(xy, z);
}

#endregion // b32v3_mt8

#region b32v3_mt16

public partial struct b32v3_mt16 
{
    [MethodImpl(256 | 512)]
    public b32v3_mt16(b32v2_mt16 xy, b32 z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public b32v3_mt16(b32 x, b32v2_mt16 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal b32v3_mt16(b32v2_mt16 xz, b32 y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static b32v3_mt16 b32v3_mt16(b32v2_mt16 xy, b32 z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static b32v3_mt16 b32v3_mt16(b32 x, b32v2_mt16 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v3_mt16 Ix(this b32v2_mt16 yz, b32 x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v3_mt16 Iy(this b32v2_mt16 xz, b32 y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v3_mt16 Iz(this b32v2_mt16 xy, b32 z) => new(xy, z);
}

#endregion // b32v3_mt16

#region b32v3_mt32

public partial struct b32v3_mt32 
{
    [MethodImpl(256 | 512)]
    public b32v3_mt32(b32v2_mt32 xy, b32 z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public b32v3_mt32(b32 x, b32v2_mt32 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal b32v3_mt32(b32v2_mt32 xz, b32 y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static b32v3_mt32 b32v3_mt32(b32v2_mt32 xy, b32 z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static b32v3_mt32 b32v3_mt32(b32 x, b32v2_mt32 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v3_mt32 Ix(this b32v2_mt32 yz, b32 x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v3_mt32 Iy(this b32v2_mt32 xz, b32 y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v3_mt32 Iz(this b32v2_mt32 xy, b32 z) => new(xy, z);
}

#endregion // b32v3_mt32

#region b64v3_mt4

public partial struct b64v3_mt4 
{
    [MethodImpl(256 | 512)]
    public b64v3_mt4(b64v2_mt4 xy, b64 z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public b64v3_mt4(b64 x, b64v2_mt4 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal b64v3_mt4(b64v2_mt4 xz, b64 y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static b64v3_mt4 b64v3_mt4(b64v2_mt4 xy, b64 z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static b64v3_mt4 b64v3_mt4(b64 x, b64v2_mt4 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v3_mt4 Ix(this b64v2_mt4 yz, b64 x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v3_mt4 Iy(this b64v2_mt4 xz, b64 y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v3_mt4 Iz(this b64v2_mt4 xy, b64 z) => new(xy, z);
}

#endregion // b64v3_mt4

#region b64v3_mt8

public partial struct b64v3_mt8 
{
    [MethodImpl(256 | 512)]
    public b64v3_mt8(b64v2_mt8 xy, b64 z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public b64v3_mt8(b64 x, b64v2_mt8 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal b64v3_mt8(b64v2_mt8 xz, b64 y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static b64v3_mt8 b64v3_mt8(b64v2_mt8 xy, b64 z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static b64v3_mt8 b64v3_mt8(b64 x, b64v2_mt8 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v3_mt8 Ix(this b64v2_mt8 yz, b64 x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v3_mt8 Iy(this b64v2_mt8 xz, b64 y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v3_mt8 Iz(this b64v2_mt8 xy, b64 z) => new(xy, z);
}

#endregion // b64v3_mt8

#region b64v3_mt16

public partial struct b64v3_mt16 
{
    [MethodImpl(256 | 512)]
    public b64v3_mt16(b64v2_mt16 xy, b64 z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public b64v3_mt16(b64 x, b64v2_mt16 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal b64v3_mt16(b64v2_mt16 xz, b64 y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static b64v3_mt16 b64v3_mt16(b64v2_mt16 xy, b64 z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static b64v3_mt16 b64v3_mt16(b64 x, b64v2_mt16 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v3_mt16 Ix(this b64v2_mt16 yz, b64 x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v3_mt16 Iy(this b64v2_mt16 xz, b64 y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v3_mt16 Iz(this b64v2_mt16 xy, b64 z) => new(xy, z);
}

#endregion // b64v3_mt16

#region b64v3_mt32

public partial struct b64v3_mt32 
{
    [MethodImpl(256 | 512)]
    public b64v3_mt32(b64v2_mt32 xy, b64 z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public b64v3_mt32(b64 x, b64v2_mt32 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal b64v3_mt32(b64v2_mt32 xz, b64 y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static b64v3_mt32 b64v3_mt32(b64v2_mt32 xy, b64 z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static b64v3_mt32 b64v3_mt32(b64 x, b64v2_mt32 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v3_mt32 Ix(this b64v2_mt32 yz, b64 x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v3_mt32 Iy(this b64v2_mt32 xz, b64 y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v3_mt32 Iz(this b64v2_mt32 xy, b64 z) => new(xy, z);
}

#endregion // b64v3_mt32
