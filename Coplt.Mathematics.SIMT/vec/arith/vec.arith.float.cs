// generated by template, do not modify manually

namespace Coplt.Mathematics.SIMT;

#region float2_mt4

public partial struct float2_mt4
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static float2_mt4 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277f); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static float2_mt4 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094f); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static float2_mt4 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009f);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static float2_mt4 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923f);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static float2_mt4 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846f);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static float2_mt4 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861f);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static float2_mt4 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144f);
    }
}

[Ex]
public static partial class math_mt
{
    #pragma warning disable CS1718
    // ReSharper disable once EqualExpressionComparison
    [MethodImpl(256 | 512)]
    public static b32v2_mt4 isNaN([This] float2_mt4 a) => a != a;
    #pragma warning restore CS1718

    [MethodImpl(256 | 512)]
    public static float2_mt4 ceil([This] float2_mt4 a) => new(a.x.floor(), a.y.floor());

    [MethodImpl(256 | 512)]
    public static float2_mt4 floor([This] float2_mt4 a) => new(a.x.floor(), a.y.floor());

    [MethodImpl(256 | 512)]
    public static float2_mt4 round([This] float2_mt4 a) => new(a.x.round(), a.y.round());

    [MethodImpl(256 | 512)]
    public static float2_mt4 trunc([This] float2_mt4 a) => new(a.x.trunc(), a.y.trunc());

    [MethodImpl(256 | 512)]
    public static float2_mt4 mod([This] float2_mt4 a, float2_mt4 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt4 mod([This] float_mt4 a, float2_mt4 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt4 mod([This] float2_mt4 a, float_mt4 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt4 mod([This] float a, float2_mt4 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt4 mod([This] float2_mt4 a, float b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt4 rem([This] float2_mt4 a, float2_mt4 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt4 rem([This] float_mt4 a, float2_mt4 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt4 rem([This] float2_mt4 a, float_mt4 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt4 rem([This] float a, float2_mt4 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt4 rem([This] float2_mt4 a, float b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt4 frac([This] float2_mt4 a) => a - floor(a);

    [MethodImpl(256 | 512)]
    public static float2_mt4 modf([This] float2_mt4 d, out float2_mt4 i)
    {
        i = trunc(d);
        return d - i;
    }

    [MethodImpl(256 | 512)]
    public static float2_mt4 rcp([This] float2_mt4 a) => new(rcp(a.x), rcp(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt4 saturate([This] float2_mt4 a) => a.clamp(default, float2_mt4.One);

    [MethodImpl(256 | 512)]
    public static float2_mt4 smoothstep(float2_mt4 min, float2_mt4 max, [This] float2_mt4 a)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * fnma(2.0f, t, 3.0f); // (3.0f - (2.0f * t))
    }

    [MethodImpl(256 | 512)]
    public static float2_mt4 reflect([This] float2_mt4 i, float2_mt4 n)
    {
        // i - 2f * n * dot(i, n);
        return fnma(2f * n, dot(i, n), i);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt4 project([This] float2_mt4 a, float2_mt4 onto) =>
        dot(a, onto) / dot(onto, onto) * onto;

    [MethodImpl(256 | 512)]
    public static float2_mt4 projectOnPlane([This] float2_mt4 a, float2_mt4 plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static float2_mt4 projectNormalized([This] float2_mt4 a, float2_mt4 onto) =>
        dot(a, onto) * onto;

    [MethodImpl(256 | 512)]
    public static float2_mt4 projectOnPlaneNormalized([This] float2_mt4 a, float2_mt4 plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static float2_mt4 radians([This] float2_mt4 a) => a * 0.0174532925199432957692369076848861271344287188854172545609719144f;

    [MethodImpl(256 | 512)]
    public static float2_mt4 degrees([This] float2_mt4 a) => a * 57.295779513082320876798154814105170332405472466564321549160243861f;

    [MethodImpl(256 | 512)]
    public static float2_mt4 wrap([This] float2_mt4 x, float2_mt4 min, float2_mt4 max)
    {
        return new(wrap(x.x, min.x, max.x), wrap(x.y, min.y, max.y));
    }

    [MethodImpl(256 | 512)]
    public static float2_mt4 wrap([This] float2_mt4 x, float_mt4 min, float_mt4 max)
    {
        return new(wrap(x.x, min, max), wrap(x.y, min, max));
    }

    [MethodImpl(256 | 512)]
    public static float2_mt4 wrap([This] float2_mt4 x, float min, float max)
    {
        return new(wrap(x.x, min, max), wrap(x.y, min, max));
    }

    [MethodImpl(256 | 512)]
    public static float2_mt4 log([This] float2_mt4 a) => new(log(a.x), log(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt4 log2([This] float2_mt4 a) => new(log2(a.x), log2(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt4 log([This] float2_mt4 a, float2_mt4 b) => new(log(a.x, b.x), log(a.y, b.y));

    [MethodImpl(256 | 512)]
    public static float2_mt4 log([This] float2_mt4 a, float_mt4 b) => new(log(a.x, b), log(a.y, b));

    [MethodImpl(256 | 512)]
    public static float2_mt4 log([This] float_mt4 a, float2_mt4 b) => new(log(a, b.x), log(a, b.y));

    [MethodImpl(256 | 512)]
    public static float2_mt4 log10([This] float2_mt4 a) => new(log10(a.x), log10(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt4 exp([This] float2_mt4 a) => new(exp(a.x), exp(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt4 exp2([This] float2_mt4 a) => new(exp2(a.x), exp2(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt4 exp10([This] float2_mt4 a) => new(exp10(a.x), exp10(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt4 pow([This] float2_mt4 a, float2_mt4 b) => new(pow(a.x, b.x), pow(a.y, b.y));

    [MethodImpl(256 | 512)]
    public static float2_mt4 pow([This] float2_mt4 a, float_mt4 b) => new(pow(a.x, b), pow(a.y, b));

    [MethodImpl(256 | 512)]
    public static float2_mt4 pow([This] float2_mt4 a, float b) => new(pow(a.x, b), pow(a.y, b));

    [MethodImpl(256 | 512)]
    public static float2_mt4 sqrt([This] float2_mt4 a) => new(sqrt(a.x), sqrt(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt4 rsqrt([This] float2_mt4 a) => new(rsqrt(a.x), rsqrt(a.y));

    [MethodImpl(256 | 512)]
    public static float_mt4 length([This] float2_mt4 a) => dot(a, a).sqrt();

    [MethodImpl(256 | 512)]
    public static float_mt4 distance([This] float2_mt4 a, float2_mt4 b) => length(b - a);

    [MethodImpl(256 | 512)]
    public static float2_mt4 normalize([This] float2_mt4 a) => a * dot(a, a).rsqrt();
    
    // todo normalizeSafe step refract projectSafe faceForward

    [MethodImpl(256 | 512)]
    public static float2_mt4 sin([This] float2_mt4 a) => new(sin(a.x), sin(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt4 cos([This] float2_mt4 a) => new(cos(a.x), cos(a.y));

    [MethodImpl(256 | 512)]
    public static (float2_mt4 sin, float2_mt4 cos) sincos([This] float2_mt4 a)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        return (
            new(sin_x, sin_y),
            new(cos_x, cos_y)
        );
    }

    [MethodImpl(256 | 512)]
    public static void sincos([This] float2_mt4 a, out float2_mt4 sin, out float2_mt4 cos)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        sin = new(sin_x, sin_y);
        cos = new(cos_x, cos_y);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt4 tan([This] float2_mt4 a) => new(tan(a.x), tan(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt4 asin([This] float2_mt4 a) => new(asin(a.x), asin(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt4 acos([This] float2_mt4 a) => new(acos(a.x), acos(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt4 atan([This] float2_mt4 a) => new(atan(a.x), atan(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt4 atan2([This] float2_mt4 a, float2_mt4 b) => new(atan2(a.x, b.x), atan2(a.y, b.y));

    [MethodImpl(256 | 512)]
    public static float2_mt4 sinh([This] float2_mt4 a) => new(sinh(a.x), sinh(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt4 cosh([This] float2_mt4 a) => new(cosh(a.x), cosh(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt4 tanh([This] float2_mt4 a) => new(tanh(a.x), tanh(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt4 asinh([This] float2_mt4 a) => new(asinh(a.x), asinh(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt4 acosh([This] float2_mt4 a) => new(acosh(a.x), acosh(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt4 atanh([This] float2_mt4 a) => new(atanh(a.x), atanh(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt4 chgsign([This] float2_mt4 a, float2_mt4 b) => new(chgsign(a.x, b.x), chgsign(a.y, b.y));
}

#endregion // float2_mt4
#region float2_mt8

public partial struct float2_mt8
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static float2_mt8 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277f); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static float2_mt8 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094f); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static float2_mt8 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009f);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static float2_mt8 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923f);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static float2_mt8 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846f);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static float2_mt8 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861f);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static float2_mt8 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144f);
    }
}

[Ex]
public static partial class math_mt
{
    #pragma warning disable CS1718
    // ReSharper disable once EqualExpressionComparison
    [MethodImpl(256 | 512)]
    public static b32v2_mt8 isNaN([This] float2_mt8 a) => a != a;
    #pragma warning restore CS1718

    [MethodImpl(256 | 512)]
    public static float2_mt8 ceil([This] float2_mt8 a) => new(a.x.floor(), a.y.floor());

    [MethodImpl(256 | 512)]
    public static float2_mt8 floor([This] float2_mt8 a) => new(a.x.floor(), a.y.floor());

    [MethodImpl(256 | 512)]
    public static float2_mt8 round([This] float2_mt8 a) => new(a.x.round(), a.y.round());

    [MethodImpl(256 | 512)]
    public static float2_mt8 trunc([This] float2_mt8 a) => new(a.x.trunc(), a.y.trunc());

    [MethodImpl(256 | 512)]
    public static float2_mt8 mod([This] float2_mt8 a, float2_mt8 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt8 mod([This] float_mt8 a, float2_mt8 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt8 mod([This] float2_mt8 a, float_mt8 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt8 mod([This] float a, float2_mt8 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt8 mod([This] float2_mt8 a, float b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt8 rem([This] float2_mt8 a, float2_mt8 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt8 rem([This] float_mt8 a, float2_mt8 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt8 rem([This] float2_mt8 a, float_mt8 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt8 rem([This] float a, float2_mt8 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt8 rem([This] float2_mt8 a, float b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt8 frac([This] float2_mt8 a) => a - floor(a);

    [MethodImpl(256 | 512)]
    public static float2_mt8 modf([This] float2_mt8 d, out float2_mt8 i)
    {
        i = trunc(d);
        return d - i;
    }

    [MethodImpl(256 | 512)]
    public static float2_mt8 rcp([This] float2_mt8 a) => new(rcp(a.x), rcp(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt8 saturate([This] float2_mt8 a) => a.clamp(default, float2_mt8.One);

    [MethodImpl(256 | 512)]
    public static float2_mt8 smoothstep(float2_mt8 min, float2_mt8 max, [This] float2_mt8 a)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * fnma(2.0f, t, 3.0f); // (3.0f - (2.0f * t))
    }

    [MethodImpl(256 | 512)]
    public static float2_mt8 reflect([This] float2_mt8 i, float2_mt8 n)
    {
        // i - 2f * n * dot(i, n);
        return fnma(2f * n, dot(i, n), i);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt8 project([This] float2_mt8 a, float2_mt8 onto) =>
        dot(a, onto) / dot(onto, onto) * onto;

    [MethodImpl(256 | 512)]
    public static float2_mt8 projectOnPlane([This] float2_mt8 a, float2_mt8 plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static float2_mt8 projectNormalized([This] float2_mt8 a, float2_mt8 onto) =>
        dot(a, onto) * onto;

    [MethodImpl(256 | 512)]
    public static float2_mt8 projectOnPlaneNormalized([This] float2_mt8 a, float2_mt8 plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static float2_mt8 radians([This] float2_mt8 a) => a * 0.0174532925199432957692369076848861271344287188854172545609719144f;

    [MethodImpl(256 | 512)]
    public static float2_mt8 degrees([This] float2_mt8 a) => a * 57.295779513082320876798154814105170332405472466564321549160243861f;

    [MethodImpl(256 | 512)]
    public static float2_mt8 wrap([This] float2_mt8 x, float2_mt8 min, float2_mt8 max)
    {
        return new(wrap(x.x, min.x, max.x), wrap(x.y, min.y, max.y));
    }

    [MethodImpl(256 | 512)]
    public static float2_mt8 wrap([This] float2_mt8 x, float_mt8 min, float_mt8 max)
    {
        return new(wrap(x.x, min, max), wrap(x.y, min, max));
    }

    [MethodImpl(256 | 512)]
    public static float2_mt8 wrap([This] float2_mt8 x, float min, float max)
    {
        return new(wrap(x.x, min, max), wrap(x.y, min, max));
    }

    [MethodImpl(256 | 512)]
    public static float2_mt8 log([This] float2_mt8 a) => new(log(a.x), log(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt8 log2([This] float2_mt8 a) => new(log2(a.x), log2(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt8 log([This] float2_mt8 a, float2_mt8 b) => new(log(a.x, b.x), log(a.y, b.y));

    [MethodImpl(256 | 512)]
    public static float2_mt8 log([This] float2_mt8 a, float_mt8 b) => new(log(a.x, b), log(a.y, b));

    [MethodImpl(256 | 512)]
    public static float2_mt8 log([This] float_mt8 a, float2_mt8 b) => new(log(a, b.x), log(a, b.y));

    [MethodImpl(256 | 512)]
    public static float2_mt8 log10([This] float2_mt8 a) => new(log10(a.x), log10(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt8 exp([This] float2_mt8 a) => new(exp(a.x), exp(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt8 exp2([This] float2_mt8 a) => new(exp2(a.x), exp2(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt8 exp10([This] float2_mt8 a) => new(exp10(a.x), exp10(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt8 pow([This] float2_mt8 a, float2_mt8 b) => new(pow(a.x, b.x), pow(a.y, b.y));

    [MethodImpl(256 | 512)]
    public static float2_mt8 pow([This] float2_mt8 a, float_mt8 b) => new(pow(a.x, b), pow(a.y, b));

    [MethodImpl(256 | 512)]
    public static float2_mt8 pow([This] float2_mt8 a, float b) => new(pow(a.x, b), pow(a.y, b));

    [MethodImpl(256 | 512)]
    public static float2_mt8 sqrt([This] float2_mt8 a) => new(sqrt(a.x), sqrt(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt8 rsqrt([This] float2_mt8 a) => new(rsqrt(a.x), rsqrt(a.y));

    [MethodImpl(256 | 512)]
    public static float_mt8 length([This] float2_mt8 a) => dot(a, a).sqrt();

    [MethodImpl(256 | 512)]
    public static float_mt8 distance([This] float2_mt8 a, float2_mt8 b) => length(b - a);

    [MethodImpl(256 | 512)]
    public static float2_mt8 normalize([This] float2_mt8 a) => a * dot(a, a).rsqrt();
    
    // todo normalizeSafe step refract projectSafe faceForward

    [MethodImpl(256 | 512)]
    public static float2_mt8 sin([This] float2_mt8 a) => new(sin(a.x), sin(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt8 cos([This] float2_mt8 a) => new(cos(a.x), cos(a.y));

    [MethodImpl(256 | 512)]
    public static (float2_mt8 sin, float2_mt8 cos) sincos([This] float2_mt8 a)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        return (
            new(sin_x, sin_y),
            new(cos_x, cos_y)
        );
    }

    [MethodImpl(256 | 512)]
    public static void sincos([This] float2_mt8 a, out float2_mt8 sin, out float2_mt8 cos)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        sin = new(sin_x, sin_y);
        cos = new(cos_x, cos_y);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt8 tan([This] float2_mt8 a) => new(tan(a.x), tan(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt8 asin([This] float2_mt8 a) => new(asin(a.x), asin(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt8 acos([This] float2_mt8 a) => new(acos(a.x), acos(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt8 atan([This] float2_mt8 a) => new(atan(a.x), atan(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt8 atan2([This] float2_mt8 a, float2_mt8 b) => new(atan2(a.x, b.x), atan2(a.y, b.y));

    [MethodImpl(256 | 512)]
    public static float2_mt8 sinh([This] float2_mt8 a) => new(sinh(a.x), sinh(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt8 cosh([This] float2_mt8 a) => new(cosh(a.x), cosh(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt8 tanh([This] float2_mt8 a) => new(tanh(a.x), tanh(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt8 asinh([This] float2_mt8 a) => new(asinh(a.x), asinh(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt8 acosh([This] float2_mt8 a) => new(acosh(a.x), acosh(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt8 atanh([This] float2_mt8 a) => new(atanh(a.x), atanh(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt8 chgsign([This] float2_mt8 a, float2_mt8 b) => new(chgsign(a.x, b.x), chgsign(a.y, b.y));
}

#endregion // float2_mt8
#region float2_mt16

public partial struct float2_mt16
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static float2_mt16 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277f); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static float2_mt16 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094f); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static float2_mt16 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009f);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static float2_mt16 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923f);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static float2_mt16 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846f);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static float2_mt16 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861f);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static float2_mt16 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144f);
    }
}

[Ex]
public static partial class math_mt
{
    #pragma warning disable CS1718
    // ReSharper disable once EqualExpressionComparison
    [MethodImpl(256 | 512)]
    public static b32v2_mt16 isNaN([This] float2_mt16 a) => a != a;
    #pragma warning restore CS1718

    [MethodImpl(256 | 512)]
    public static float2_mt16 ceil([This] float2_mt16 a) => new(a.x.floor(), a.y.floor());

    [MethodImpl(256 | 512)]
    public static float2_mt16 floor([This] float2_mt16 a) => new(a.x.floor(), a.y.floor());

    [MethodImpl(256 | 512)]
    public static float2_mt16 round([This] float2_mt16 a) => new(a.x.round(), a.y.round());

    [MethodImpl(256 | 512)]
    public static float2_mt16 trunc([This] float2_mt16 a) => new(a.x.trunc(), a.y.trunc());

    [MethodImpl(256 | 512)]
    public static float2_mt16 mod([This] float2_mt16 a, float2_mt16 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt16 mod([This] float_mt16 a, float2_mt16 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt16 mod([This] float2_mt16 a, float_mt16 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt16 mod([This] float a, float2_mt16 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt16 mod([This] float2_mt16 a, float b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt16 rem([This] float2_mt16 a, float2_mt16 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt16 rem([This] float_mt16 a, float2_mt16 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt16 rem([This] float2_mt16 a, float_mt16 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt16 rem([This] float a, float2_mt16 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt16 rem([This] float2_mt16 a, float b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt16 frac([This] float2_mt16 a) => a - floor(a);

    [MethodImpl(256 | 512)]
    public static float2_mt16 modf([This] float2_mt16 d, out float2_mt16 i)
    {
        i = trunc(d);
        return d - i;
    }

    [MethodImpl(256 | 512)]
    public static float2_mt16 rcp([This] float2_mt16 a) => new(rcp(a.x), rcp(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt16 saturate([This] float2_mt16 a) => a.clamp(default, float2_mt16.One);

    [MethodImpl(256 | 512)]
    public static float2_mt16 smoothstep(float2_mt16 min, float2_mt16 max, [This] float2_mt16 a)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * fnma(2.0f, t, 3.0f); // (3.0f - (2.0f * t))
    }

    [MethodImpl(256 | 512)]
    public static float2_mt16 reflect([This] float2_mt16 i, float2_mt16 n)
    {
        // i - 2f * n * dot(i, n);
        return fnma(2f * n, dot(i, n), i);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt16 project([This] float2_mt16 a, float2_mt16 onto) =>
        dot(a, onto) / dot(onto, onto) * onto;

    [MethodImpl(256 | 512)]
    public static float2_mt16 projectOnPlane([This] float2_mt16 a, float2_mt16 plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static float2_mt16 projectNormalized([This] float2_mt16 a, float2_mt16 onto) =>
        dot(a, onto) * onto;

    [MethodImpl(256 | 512)]
    public static float2_mt16 projectOnPlaneNormalized([This] float2_mt16 a, float2_mt16 plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static float2_mt16 radians([This] float2_mt16 a) => a * 0.0174532925199432957692369076848861271344287188854172545609719144f;

    [MethodImpl(256 | 512)]
    public static float2_mt16 degrees([This] float2_mt16 a) => a * 57.295779513082320876798154814105170332405472466564321549160243861f;

    [MethodImpl(256 | 512)]
    public static float2_mt16 wrap([This] float2_mt16 x, float2_mt16 min, float2_mt16 max)
    {
        return new(wrap(x.x, min.x, max.x), wrap(x.y, min.y, max.y));
    }

    [MethodImpl(256 | 512)]
    public static float2_mt16 wrap([This] float2_mt16 x, float_mt16 min, float_mt16 max)
    {
        return new(wrap(x.x, min, max), wrap(x.y, min, max));
    }

    [MethodImpl(256 | 512)]
    public static float2_mt16 wrap([This] float2_mt16 x, float min, float max)
    {
        return new(wrap(x.x, min, max), wrap(x.y, min, max));
    }

    [MethodImpl(256 | 512)]
    public static float2_mt16 log([This] float2_mt16 a) => new(log(a.x), log(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt16 log2([This] float2_mt16 a) => new(log2(a.x), log2(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt16 log([This] float2_mt16 a, float2_mt16 b) => new(log(a.x, b.x), log(a.y, b.y));

    [MethodImpl(256 | 512)]
    public static float2_mt16 log([This] float2_mt16 a, float_mt16 b) => new(log(a.x, b), log(a.y, b));

    [MethodImpl(256 | 512)]
    public static float2_mt16 log([This] float_mt16 a, float2_mt16 b) => new(log(a, b.x), log(a, b.y));

    [MethodImpl(256 | 512)]
    public static float2_mt16 log10([This] float2_mt16 a) => new(log10(a.x), log10(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt16 exp([This] float2_mt16 a) => new(exp(a.x), exp(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt16 exp2([This] float2_mt16 a) => new(exp2(a.x), exp2(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt16 exp10([This] float2_mt16 a) => new(exp10(a.x), exp10(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt16 pow([This] float2_mt16 a, float2_mt16 b) => new(pow(a.x, b.x), pow(a.y, b.y));

    [MethodImpl(256 | 512)]
    public static float2_mt16 pow([This] float2_mt16 a, float_mt16 b) => new(pow(a.x, b), pow(a.y, b));

    [MethodImpl(256 | 512)]
    public static float2_mt16 pow([This] float2_mt16 a, float b) => new(pow(a.x, b), pow(a.y, b));

    [MethodImpl(256 | 512)]
    public static float2_mt16 sqrt([This] float2_mt16 a) => new(sqrt(a.x), sqrt(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt16 rsqrt([This] float2_mt16 a) => new(rsqrt(a.x), rsqrt(a.y));

    [MethodImpl(256 | 512)]
    public static float_mt16 length([This] float2_mt16 a) => dot(a, a).sqrt();

    [MethodImpl(256 | 512)]
    public static float_mt16 distance([This] float2_mt16 a, float2_mt16 b) => length(b - a);

    [MethodImpl(256 | 512)]
    public static float2_mt16 normalize([This] float2_mt16 a) => a * dot(a, a).rsqrt();
    
    // todo normalizeSafe step refract projectSafe faceForward

    [MethodImpl(256 | 512)]
    public static float2_mt16 sin([This] float2_mt16 a) => new(sin(a.x), sin(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt16 cos([This] float2_mt16 a) => new(cos(a.x), cos(a.y));

    [MethodImpl(256 | 512)]
    public static (float2_mt16 sin, float2_mt16 cos) sincos([This] float2_mt16 a)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        return (
            new(sin_x, sin_y),
            new(cos_x, cos_y)
        );
    }

    [MethodImpl(256 | 512)]
    public static void sincos([This] float2_mt16 a, out float2_mt16 sin, out float2_mt16 cos)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        sin = new(sin_x, sin_y);
        cos = new(cos_x, cos_y);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt16 tan([This] float2_mt16 a) => new(tan(a.x), tan(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt16 asin([This] float2_mt16 a) => new(asin(a.x), asin(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt16 acos([This] float2_mt16 a) => new(acos(a.x), acos(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt16 atan([This] float2_mt16 a) => new(atan(a.x), atan(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt16 atan2([This] float2_mt16 a, float2_mt16 b) => new(atan2(a.x, b.x), atan2(a.y, b.y));

    [MethodImpl(256 | 512)]
    public static float2_mt16 sinh([This] float2_mt16 a) => new(sinh(a.x), sinh(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt16 cosh([This] float2_mt16 a) => new(cosh(a.x), cosh(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt16 tanh([This] float2_mt16 a) => new(tanh(a.x), tanh(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt16 asinh([This] float2_mt16 a) => new(asinh(a.x), asinh(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt16 acosh([This] float2_mt16 a) => new(acosh(a.x), acosh(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt16 atanh([This] float2_mt16 a) => new(atanh(a.x), atanh(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt16 chgsign([This] float2_mt16 a, float2_mt16 b) => new(chgsign(a.x, b.x), chgsign(a.y, b.y));
}

#endregion // float2_mt16
#region float2_mt32

public partial struct float2_mt32
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static float2_mt32 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277f); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static float2_mt32 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094f); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static float2_mt32 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009f);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static float2_mt32 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923f);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static float2_mt32 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846f);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static float2_mt32 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861f);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static float2_mt32 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144f);
    }
}

[Ex]
public static partial class math_mt
{
    #pragma warning disable CS1718
    // ReSharper disable once EqualExpressionComparison
    [MethodImpl(256 | 512)]
    public static b32v2_mt32 isNaN([This] float2_mt32 a) => a != a;
    #pragma warning restore CS1718

    [MethodImpl(256 | 512)]
    public static float2_mt32 ceil([This] float2_mt32 a) => new(a.x.floor(), a.y.floor());

    [MethodImpl(256 | 512)]
    public static float2_mt32 floor([This] float2_mt32 a) => new(a.x.floor(), a.y.floor());

    [MethodImpl(256 | 512)]
    public static float2_mt32 round([This] float2_mt32 a) => new(a.x.round(), a.y.round());

    [MethodImpl(256 | 512)]
    public static float2_mt32 trunc([This] float2_mt32 a) => new(a.x.trunc(), a.y.trunc());

    [MethodImpl(256 | 512)]
    public static float2_mt32 mod([This] float2_mt32 a, float2_mt32 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt32 mod([This] float_mt32 a, float2_mt32 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt32 mod([This] float2_mt32 a, float_mt32 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt32 mod([This] float a, float2_mt32 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt32 mod([This] float2_mt32 a, float b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt32 rem([This] float2_mt32 a, float2_mt32 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt32 rem([This] float_mt32 a, float2_mt32 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt32 rem([This] float2_mt32 a, float_mt32 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt32 rem([This] float a, float2_mt32 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt32 rem([This] float2_mt32 a, float b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt32 frac([This] float2_mt32 a) => a - floor(a);

    [MethodImpl(256 | 512)]
    public static float2_mt32 modf([This] float2_mt32 d, out float2_mt32 i)
    {
        i = trunc(d);
        return d - i;
    }

    [MethodImpl(256 | 512)]
    public static float2_mt32 rcp([This] float2_mt32 a) => new(rcp(a.x), rcp(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt32 saturate([This] float2_mt32 a) => a.clamp(default, float2_mt32.One);

    [MethodImpl(256 | 512)]
    public static float2_mt32 smoothstep(float2_mt32 min, float2_mt32 max, [This] float2_mt32 a)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * fnma(2.0f, t, 3.0f); // (3.0f - (2.0f * t))
    }

    [MethodImpl(256 | 512)]
    public static float2_mt32 reflect([This] float2_mt32 i, float2_mt32 n)
    {
        // i - 2f * n * dot(i, n);
        return fnma(2f * n, dot(i, n), i);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt32 project([This] float2_mt32 a, float2_mt32 onto) =>
        dot(a, onto) / dot(onto, onto) * onto;

    [MethodImpl(256 | 512)]
    public static float2_mt32 projectOnPlane([This] float2_mt32 a, float2_mt32 plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static float2_mt32 projectNormalized([This] float2_mt32 a, float2_mt32 onto) =>
        dot(a, onto) * onto;

    [MethodImpl(256 | 512)]
    public static float2_mt32 projectOnPlaneNormalized([This] float2_mt32 a, float2_mt32 plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static float2_mt32 radians([This] float2_mt32 a) => a * 0.0174532925199432957692369076848861271344287188854172545609719144f;

    [MethodImpl(256 | 512)]
    public static float2_mt32 degrees([This] float2_mt32 a) => a * 57.295779513082320876798154814105170332405472466564321549160243861f;

    [MethodImpl(256 | 512)]
    public static float2_mt32 wrap([This] float2_mt32 x, float2_mt32 min, float2_mt32 max)
    {
        return new(wrap(x.x, min.x, max.x), wrap(x.y, min.y, max.y));
    }

    [MethodImpl(256 | 512)]
    public static float2_mt32 wrap([This] float2_mt32 x, float_mt32 min, float_mt32 max)
    {
        return new(wrap(x.x, min, max), wrap(x.y, min, max));
    }

    [MethodImpl(256 | 512)]
    public static float2_mt32 wrap([This] float2_mt32 x, float min, float max)
    {
        return new(wrap(x.x, min, max), wrap(x.y, min, max));
    }

    [MethodImpl(256 | 512)]
    public static float2_mt32 log([This] float2_mt32 a) => new(log(a.x), log(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt32 log2([This] float2_mt32 a) => new(log2(a.x), log2(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt32 log([This] float2_mt32 a, float2_mt32 b) => new(log(a.x, b.x), log(a.y, b.y));

    [MethodImpl(256 | 512)]
    public static float2_mt32 log([This] float2_mt32 a, float_mt32 b) => new(log(a.x, b), log(a.y, b));

    [MethodImpl(256 | 512)]
    public static float2_mt32 log([This] float_mt32 a, float2_mt32 b) => new(log(a, b.x), log(a, b.y));

    [MethodImpl(256 | 512)]
    public static float2_mt32 log10([This] float2_mt32 a) => new(log10(a.x), log10(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt32 exp([This] float2_mt32 a) => new(exp(a.x), exp(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt32 exp2([This] float2_mt32 a) => new(exp2(a.x), exp2(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt32 exp10([This] float2_mt32 a) => new(exp10(a.x), exp10(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt32 pow([This] float2_mt32 a, float2_mt32 b) => new(pow(a.x, b.x), pow(a.y, b.y));

    [MethodImpl(256 | 512)]
    public static float2_mt32 pow([This] float2_mt32 a, float_mt32 b) => new(pow(a.x, b), pow(a.y, b));

    [MethodImpl(256 | 512)]
    public static float2_mt32 pow([This] float2_mt32 a, float b) => new(pow(a.x, b), pow(a.y, b));

    [MethodImpl(256 | 512)]
    public static float2_mt32 sqrt([This] float2_mt32 a) => new(sqrt(a.x), sqrt(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt32 rsqrt([This] float2_mt32 a) => new(rsqrt(a.x), rsqrt(a.y));

    [MethodImpl(256 | 512)]
    public static float_mt32 length([This] float2_mt32 a) => dot(a, a).sqrt();

    [MethodImpl(256 | 512)]
    public static float_mt32 distance([This] float2_mt32 a, float2_mt32 b) => length(b - a);

    [MethodImpl(256 | 512)]
    public static float2_mt32 normalize([This] float2_mt32 a) => a * dot(a, a).rsqrt();
    
    // todo normalizeSafe step refract projectSafe faceForward

    [MethodImpl(256 | 512)]
    public static float2_mt32 sin([This] float2_mt32 a) => new(sin(a.x), sin(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt32 cos([This] float2_mt32 a) => new(cos(a.x), cos(a.y));

    [MethodImpl(256 | 512)]
    public static (float2_mt32 sin, float2_mt32 cos) sincos([This] float2_mt32 a)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        return (
            new(sin_x, sin_y),
            new(cos_x, cos_y)
        );
    }

    [MethodImpl(256 | 512)]
    public static void sincos([This] float2_mt32 a, out float2_mt32 sin, out float2_mt32 cos)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        sin = new(sin_x, sin_y);
        cos = new(cos_x, cos_y);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt32 tan([This] float2_mt32 a) => new(tan(a.x), tan(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt32 asin([This] float2_mt32 a) => new(asin(a.x), asin(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt32 acos([This] float2_mt32 a) => new(acos(a.x), acos(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt32 atan([This] float2_mt32 a) => new(atan(a.x), atan(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt32 atan2([This] float2_mt32 a, float2_mt32 b) => new(atan2(a.x, b.x), atan2(a.y, b.y));

    [MethodImpl(256 | 512)]
    public static float2_mt32 sinh([This] float2_mt32 a) => new(sinh(a.x), sinh(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt32 cosh([This] float2_mt32 a) => new(cosh(a.x), cosh(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt32 tanh([This] float2_mt32 a) => new(tanh(a.x), tanh(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt32 asinh([This] float2_mt32 a) => new(asinh(a.x), asinh(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt32 acosh([This] float2_mt32 a) => new(acosh(a.x), acosh(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt32 atanh([This] float2_mt32 a) => new(atanh(a.x), atanh(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt32 chgsign([This] float2_mt32 a, float2_mt32 b) => new(chgsign(a.x, b.x), chgsign(a.y, b.y));
}

#endregion // float2_mt32
#region float3_mt4

public partial struct float3_mt4
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static float3_mt4 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277f); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static float3_mt4 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094f); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static float3_mt4 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009f);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static float3_mt4 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923f);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static float3_mt4 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846f);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static float3_mt4 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861f);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static float3_mt4 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144f);
    }
}

[Ex]
public static partial class math_mt
{
    #pragma warning disable CS1718
    // ReSharper disable once EqualExpressionComparison
    [MethodImpl(256 | 512)]
    public static b32v3_mt4 isNaN([This] float3_mt4 a) => a != a;
    #pragma warning restore CS1718

    [MethodImpl(256 | 512)]
    public static float3_mt4 ceil([This] float3_mt4 a) => new(a.x.floor(), a.y.floor(), a.z.floor());

    [MethodImpl(256 | 512)]
    public static float3_mt4 floor([This] float3_mt4 a) => new(a.x.floor(), a.y.floor(), a.z.floor());

    [MethodImpl(256 | 512)]
    public static float3_mt4 round([This] float3_mt4 a) => new(a.x.round(), a.y.round(), a.z.round());

    [MethodImpl(256 | 512)]
    public static float3_mt4 trunc([This] float3_mt4 a) => new(a.x.trunc(), a.y.trunc(), a.z.trunc());

    [MethodImpl(256 | 512)]
    public static float3_mt4 mod([This] float3_mt4 a, float3_mt4 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt4 mod([This] float_mt4 a, float3_mt4 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt4 mod([This] float3_mt4 a, float_mt4 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt4 mod([This] float a, float3_mt4 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt4 mod([This] float3_mt4 a, float b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt4 rem([This] float3_mt4 a, float3_mt4 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt4 rem([This] float_mt4 a, float3_mt4 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt4 rem([This] float3_mt4 a, float_mt4 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt4 rem([This] float a, float3_mt4 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt4 rem([This] float3_mt4 a, float b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt4 frac([This] float3_mt4 a) => a - floor(a);

    [MethodImpl(256 | 512)]
    public static float3_mt4 modf([This] float3_mt4 d, out float3_mt4 i)
    {
        i = trunc(d);
        return d - i;
    }

    [MethodImpl(256 | 512)]
    public static float3_mt4 rcp([This] float3_mt4 a) => new(rcp(a.x), rcp(a.y), rcp(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt4 saturate([This] float3_mt4 a) => a.clamp(default, float3_mt4.One);

    [MethodImpl(256 | 512)]
    public static float3_mt4 smoothstep(float3_mt4 min, float3_mt4 max, [This] float3_mt4 a)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * fnma(2.0f, t, 3.0f); // (3.0f - (2.0f * t))
    }

    [MethodImpl(256 | 512)]
    public static float3_mt4 reflect([This] float3_mt4 i, float3_mt4 n)
    {
        // i - 2f * n * dot(i, n);
        return fnma(2f * n, dot(i, n), i);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt4 project([This] float3_mt4 a, float3_mt4 onto) =>
        dot(a, onto) / dot(onto, onto) * onto;

    [MethodImpl(256 | 512)]
    public static float3_mt4 projectOnPlane([This] float3_mt4 a, float3_mt4 plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static float3_mt4 projectNormalized([This] float3_mt4 a, float3_mt4 onto) =>
        dot(a, onto) * onto;

    [MethodImpl(256 | 512)]
    public static float3_mt4 projectOnPlaneNormalized([This] float3_mt4 a, float3_mt4 plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static float3_mt4 radians([This] float3_mt4 a) => a * 0.0174532925199432957692369076848861271344287188854172545609719144f;

    [MethodImpl(256 | 512)]
    public static float3_mt4 degrees([This] float3_mt4 a) => a * 57.295779513082320876798154814105170332405472466564321549160243861f;

    [MethodImpl(256 | 512)]
    public static float3_mt4 wrap([This] float3_mt4 x, float3_mt4 min, float3_mt4 max)
    {
        return new(wrap(x.x, min.x, max.x), wrap(x.y, min.y, max.y), wrap(x.z, min.z, max.z));
    }

    [MethodImpl(256 | 512)]
    public static float3_mt4 wrap([This] float3_mt4 x, float_mt4 min, float_mt4 max)
    {
        return new(wrap(x.x, min, max), wrap(x.y, min, max), wrap(x.z, min, max));
    }

    [MethodImpl(256 | 512)]
    public static float3_mt4 wrap([This] float3_mt4 x, float min, float max)
    {
        return new(wrap(x.x, min, max), wrap(x.y, min, max), wrap(x.z, min, max));
    }

    [MethodImpl(256 | 512)]
    public static float3_mt4 log([This] float3_mt4 a) => new(log(a.x), log(a.y), log(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt4 log2([This] float3_mt4 a) => new(log2(a.x), log2(a.y), log2(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt4 log([This] float3_mt4 a, float3_mt4 b) => new(log(a.x, b.x), log(a.y, b.y), log(a.z, b.z));

    [MethodImpl(256 | 512)]
    public static float3_mt4 log([This] float3_mt4 a, float_mt4 b) => new(log(a.x, b), log(a.y, b), log(a.z, b));

    [MethodImpl(256 | 512)]
    public static float3_mt4 log([This] float_mt4 a, float3_mt4 b) => new(log(a, b.x), log(a, b.y), log(a, b.z));

    [MethodImpl(256 | 512)]
    public static float3_mt4 log10([This] float3_mt4 a) => new(log10(a.x), log10(a.y), log10(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt4 exp([This] float3_mt4 a) => new(exp(a.x), exp(a.y), exp(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt4 exp2([This] float3_mt4 a) => new(exp2(a.x), exp2(a.y), exp2(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt4 exp10([This] float3_mt4 a) => new(exp10(a.x), exp10(a.y), exp10(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt4 pow([This] float3_mt4 a, float3_mt4 b) => new(pow(a.x, b.x), pow(a.y, b.y), pow(a.z, b.z));

    [MethodImpl(256 | 512)]
    public static float3_mt4 pow([This] float3_mt4 a, float_mt4 b) => new(pow(a.x, b), pow(a.y, b), pow(a.z, b));

    [MethodImpl(256 | 512)]
    public static float3_mt4 pow([This] float3_mt4 a, float b) => new(pow(a.x, b), pow(a.y, b), pow(a.z, b));

    [MethodImpl(256 | 512)]
    public static float3_mt4 sqrt([This] float3_mt4 a) => new(sqrt(a.x), sqrt(a.y), sqrt(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt4 rsqrt([This] float3_mt4 a) => new(rsqrt(a.x), rsqrt(a.y), rsqrt(a.z));

    [MethodImpl(256 | 512)]
    public static float_mt4 length([This] float3_mt4 a) => dot(a, a).sqrt();

    [MethodImpl(256 | 512)]
    public static float_mt4 distance([This] float3_mt4 a, float3_mt4 b) => length(b - a);

    [MethodImpl(256 | 512)]
    public static float3_mt4 normalize([This] float3_mt4 a) => a * dot(a, a).rsqrt();
    
    // todo normalizeSafe step refract projectSafe faceForward

    [MethodImpl(256 | 512)]
    public static float3_mt4 sin([This] float3_mt4 a) => new(sin(a.x), sin(a.y), sin(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt4 cos([This] float3_mt4 a) => new(cos(a.x), cos(a.y), cos(a.z));

    [MethodImpl(256 | 512)]
    public static (float3_mt4 sin, float3_mt4 cos) sincos([This] float3_mt4 a)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        var (sin_z, cos_z) = sincos(a.z);
        return (
            new(sin_x, sin_y, sin_z),
            new(cos_x, cos_y, cos_z)
        );
    }

    [MethodImpl(256 | 512)]
    public static void sincos([This] float3_mt4 a, out float3_mt4 sin, out float3_mt4 cos)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        var (sin_z, cos_z) = sincos(a.z);
        sin = new(sin_x, sin_y, sin_z);
        cos = new(cos_x, cos_y, cos_z);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt4 tan([This] float3_mt4 a) => new(tan(a.x), tan(a.y), tan(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt4 asin([This] float3_mt4 a) => new(asin(a.x), asin(a.y), asin(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt4 acos([This] float3_mt4 a) => new(acos(a.x), acos(a.y), acos(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt4 atan([This] float3_mt4 a) => new(atan(a.x), atan(a.y), atan(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt4 atan2([This] float3_mt4 a, float3_mt4 b) => new(atan2(a.x, b.x), atan2(a.y, b.y), atan2(a.z, b.z));

    [MethodImpl(256 | 512)]
    public static float3_mt4 sinh([This] float3_mt4 a) => new(sinh(a.x), sinh(a.y), sinh(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt4 cosh([This] float3_mt4 a) => new(cosh(a.x), cosh(a.y), cosh(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt4 tanh([This] float3_mt4 a) => new(tanh(a.x), tanh(a.y), tanh(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt4 asinh([This] float3_mt4 a) => new(asinh(a.x), asinh(a.y), asinh(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt4 acosh([This] float3_mt4 a) => new(acosh(a.x), acosh(a.y), acosh(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt4 atanh([This] float3_mt4 a) => new(atanh(a.x), atanh(a.y), atanh(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt4 chgsign([This] float3_mt4 a, float3_mt4 b) => new(chgsign(a.x, b.x), chgsign(a.y, b.y), chgsign(a.z, b.z));
}

#endregion // float3_mt4
#region float3_mt8

public partial struct float3_mt8
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static float3_mt8 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277f); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static float3_mt8 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094f); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static float3_mt8 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009f);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static float3_mt8 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923f);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static float3_mt8 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846f);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static float3_mt8 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861f);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static float3_mt8 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144f);
    }
}

[Ex]
public static partial class math_mt
{
    #pragma warning disable CS1718
    // ReSharper disable once EqualExpressionComparison
    [MethodImpl(256 | 512)]
    public static b32v3_mt8 isNaN([This] float3_mt8 a) => a != a;
    #pragma warning restore CS1718

    [MethodImpl(256 | 512)]
    public static float3_mt8 ceil([This] float3_mt8 a) => new(a.x.floor(), a.y.floor(), a.z.floor());

    [MethodImpl(256 | 512)]
    public static float3_mt8 floor([This] float3_mt8 a) => new(a.x.floor(), a.y.floor(), a.z.floor());

    [MethodImpl(256 | 512)]
    public static float3_mt8 round([This] float3_mt8 a) => new(a.x.round(), a.y.round(), a.z.round());

    [MethodImpl(256 | 512)]
    public static float3_mt8 trunc([This] float3_mt8 a) => new(a.x.trunc(), a.y.trunc(), a.z.trunc());

    [MethodImpl(256 | 512)]
    public static float3_mt8 mod([This] float3_mt8 a, float3_mt8 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt8 mod([This] float_mt8 a, float3_mt8 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt8 mod([This] float3_mt8 a, float_mt8 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt8 mod([This] float a, float3_mt8 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt8 mod([This] float3_mt8 a, float b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt8 rem([This] float3_mt8 a, float3_mt8 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt8 rem([This] float_mt8 a, float3_mt8 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt8 rem([This] float3_mt8 a, float_mt8 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt8 rem([This] float a, float3_mt8 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt8 rem([This] float3_mt8 a, float b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt8 frac([This] float3_mt8 a) => a - floor(a);

    [MethodImpl(256 | 512)]
    public static float3_mt8 modf([This] float3_mt8 d, out float3_mt8 i)
    {
        i = trunc(d);
        return d - i;
    }

    [MethodImpl(256 | 512)]
    public static float3_mt8 rcp([This] float3_mt8 a) => new(rcp(a.x), rcp(a.y), rcp(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt8 saturate([This] float3_mt8 a) => a.clamp(default, float3_mt8.One);

    [MethodImpl(256 | 512)]
    public static float3_mt8 smoothstep(float3_mt8 min, float3_mt8 max, [This] float3_mt8 a)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * fnma(2.0f, t, 3.0f); // (3.0f - (2.0f * t))
    }

    [MethodImpl(256 | 512)]
    public static float3_mt8 reflect([This] float3_mt8 i, float3_mt8 n)
    {
        // i - 2f * n * dot(i, n);
        return fnma(2f * n, dot(i, n), i);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt8 project([This] float3_mt8 a, float3_mt8 onto) =>
        dot(a, onto) / dot(onto, onto) * onto;

    [MethodImpl(256 | 512)]
    public static float3_mt8 projectOnPlane([This] float3_mt8 a, float3_mt8 plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static float3_mt8 projectNormalized([This] float3_mt8 a, float3_mt8 onto) =>
        dot(a, onto) * onto;

    [MethodImpl(256 | 512)]
    public static float3_mt8 projectOnPlaneNormalized([This] float3_mt8 a, float3_mt8 plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static float3_mt8 radians([This] float3_mt8 a) => a * 0.0174532925199432957692369076848861271344287188854172545609719144f;

    [MethodImpl(256 | 512)]
    public static float3_mt8 degrees([This] float3_mt8 a) => a * 57.295779513082320876798154814105170332405472466564321549160243861f;

    [MethodImpl(256 | 512)]
    public static float3_mt8 wrap([This] float3_mt8 x, float3_mt8 min, float3_mt8 max)
    {
        return new(wrap(x.x, min.x, max.x), wrap(x.y, min.y, max.y), wrap(x.z, min.z, max.z));
    }

    [MethodImpl(256 | 512)]
    public static float3_mt8 wrap([This] float3_mt8 x, float_mt8 min, float_mt8 max)
    {
        return new(wrap(x.x, min, max), wrap(x.y, min, max), wrap(x.z, min, max));
    }

    [MethodImpl(256 | 512)]
    public static float3_mt8 wrap([This] float3_mt8 x, float min, float max)
    {
        return new(wrap(x.x, min, max), wrap(x.y, min, max), wrap(x.z, min, max));
    }

    [MethodImpl(256 | 512)]
    public static float3_mt8 log([This] float3_mt8 a) => new(log(a.x), log(a.y), log(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt8 log2([This] float3_mt8 a) => new(log2(a.x), log2(a.y), log2(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt8 log([This] float3_mt8 a, float3_mt8 b) => new(log(a.x, b.x), log(a.y, b.y), log(a.z, b.z));

    [MethodImpl(256 | 512)]
    public static float3_mt8 log([This] float3_mt8 a, float_mt8 b) => new(log(a.x, b), log(a.y, b), log(a.z, b));

    [MethodImpl(256 | 512)]
    public static float3_mt8 log([This] float_mt8 a, float3_mt8 b) => new(log(a, b.x), log(a, b.y), log(a, b.z));

    [MethodImpl(256 | 512)]
    public static float3_mt8 log10([This] float3_mt8 a) => new(log10(a.x), log10(a.y), log10(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt8 exp([This] float3_mt8 a) => new(exp(a.x), exp(a.y), exp(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt8 exp2([This] float3_mt8 a) => new(exp2(a.x), exp2(a.y), exp2(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt8 exp10([This] float3_mt8 a) => new(exp10(a.x), exp10(a.y), exp10(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt8 pow([This] float3_mt8 a, float3_mt8 b) => new(pow(a.x, b.x), pow(a.y, b.y), pow(a.z, b.z));

    [MethodImpl(256 | 512)]
    public static float3_mt8 pow([This] float3_mt8 a, float_mt8 b) => new(pow(a.x, b), pow(a.y, b), pow(a.z, b));

    [MethodImpl(256 | 512)]
    public static float3_mt8 pow([This] float3_mt8 a, float b) => new(pow(a.x, b), pow(a.y, b), pow(a.z, b));

    [MethodImpl(256 | 512)]
    public static float3_mt8 sqrt([This] float3_mt8 a) => new(sqrt(a.x), sqrt(a.y), sqrt(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt8 rsqrt([This] float3_mt8 a) => new(rsqrt(a.x), rsqrt(a.y), rsqrt(a.z));

    [MethodImpl(256 | 512)]
    public static float_mt8 length([This] float3_mt8 a) => dot(a, a).sqrt();

    [MethodImpl(256 | 512)]
    public static float_mt8 distance([This] float3_mt8 a, float3_mt8 b) => length(b - a);

    [MethodImpl(256 | 512)]
    public static float3_mt8 normalize([This] float3_mt8 a) => a * dot(a, a).rsqrt();
    
    // todo normalizeSafe step refract projectSafe faceForward

    [MethodImpl(256 | 512)]
    public static float3_mt8 sin([This] float3_mt8 a) => new(sin(a.x), sin(a.y), sin(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt8 cos([This] float3_mt8 a) => new(cos(a.x), cos(a.y), cos(a.z));

    [MethodImpl(256 | 512)]
    public static (float3_mt8 sin, float3_mt8 cos) sincos([This] float3_mt8 a)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        var (sin_z, cos_z) = sincos(a.z);
        return (
            new(sin_x, sin_y, sin_z),
            new(cos_x, cos_y, cos_z)
        );
    }

    [MethodImpl(256 | 512)]
    public static void sincos([This] float3_mt8 a, out float3_mt8 sin, out float3_mt8 cos)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        var (sin_z, cos_z) = sincos(a.z);
        sin = new(sin_x, sin_y, sin_z);
        cos = new(cos_x, cos_y, cos_z);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt8 tan([This] float3_mt8 a) => new(tan(a.x), tan(a.y), tan(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt8 asin([This] float3_mt8 a) => new(asin(a.x), asin(a.y), asin(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt8 acos([This] float3_mt8 a) => new(acos(a.x), acos(a.y), acos(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt8 atan([This] float3_mt8 a) => new(atan(a.x), atan(a.y), atan(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt8 atan2([This] float3_mt8 a, float3_mt8 b) => new(atan2(a.x, b.x), atan2(a.y, b.y), atan2(a.z, b.z));

    [MethodImpl(256 | 512)]
    public static float3_mt8 sinh([This] float3_mt8 a) => new(sinh(a.x), sinh(a.y), sinh(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt8 cosh([This] float3_mt8 a) => new(cosh(a.x), cosh(a.y), cosh(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt8 tanh([This] float3_mt8 a) => new(tanh(a.x), tanh(a.y), tanh(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt8 asinh([This] float3_mt8 a) => new(asinh(a.x), asinh(a.y), asinh(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt8 acosh([This] float3_mt8 a) => new(acosh(a.x), acosh(a.y), acosh(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt8 atanh([This] float3_mt8 a) => new(atanh(a.x), atanh(a.y), atanh(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt8 chgsign([This] float3_mt8 a, float3_mt8 b) => new(chgsign(a.x, b.x), chgsign(a.y, b.y), chgsign(a.z, b.z));
}

#endregion // float3_mt8
#region float3_mt16

public partial struct float3_mt16
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static float3_mt16 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277f); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static float3_mt16 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094f); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static float3_mt16 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009f);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static float3_mt16 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923f);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static float3_mt16 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846f);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static float3_mt16 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861f);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static float3_mt16 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144f);
    }
}

[Ex]
public static partial class math_mt
{
    #pragma warning disable CS1718
    // ReSharper disable once EqualExpressionComparison
    [MethodImpl(256 | 512)]
    public static b32v3_mt16 isNaN([This] float3_mt16 a) => a != a;
    #pragma warning restore CS1718

    [MethodImpl(256 | 512)]
    public static float3_mt16 ceil([This] float3_mt16 a) => new(a.x.floor(), a.y.floor(), a.z.floor());

    [MethodImpl(256 | 512)]
    public static float3_mt16 floor([This] float3_mt16 a) => new(a.x.floor(), a.y.floor(), a.z.floor());

    [MethodImpl(256 | 512)]
    public static float3_mt16 round([This] float3_mt16 a) => new(a.x.round(), a.y.round(), a.z.round());

    [MethodImpl(256 | 512)]
    public static float3_mt16 trunc([This] float3_mt16 a) => new(a.x.trunc(), a.y.trunc(), a.z.trunc());

    [MethodImpl(256 | 512)]
    public static float3_mt16 mod([This] float3_mt16 a, float3_mt16 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt16 mod([This] float_mt16 a, float3_mt16 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt16 mod([This] float3_mt16 a, float_mt16 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt16 mod([This] float a, float3_mt16 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt16 mod([This] float3_mt16 a, float b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt16 rem([This] float3_mt16 a, float3_mt16 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt16 rem([This] float_mt16 a, float3_mt16 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt16 rem([This] float3_mt16 a, float_mt16 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt16 rem([This] float a, float3_mt16 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt16 rem([This] float3_mt16 a, float b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt16 frac([This] float3_mt16 a) => a - floor(a);

    [MethodImpl(256 | 512)]
    public static float3_mt16 modf([This] float3_mt16 d, out float3_mt16 i)
    {
        i = trunc(d);
        return d - i;
    }

    [MethodImpl(256 | 512)]
    public static float3_mt16 rcp([This] float3_mt16 a) => new(rcp(a.x), rcp(a.y), rcp(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt16 saturate([This] float3_mt16 a) => a.clamp(default, float3_mt16.One);

    [MethodImpl(256 | 512)]
    public static float3_mt16 smoothstep(float3_mt16 min, float3_mt16 max, [This] float3_mt16 a)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * fnma(2.0f, t, 3.0f); // (3.0f - (2.0f * t))
    }

    [MethodImpl(256 | 512)]
    public static float3_mt16 reflect([This] float3_mt16 i, float3_mt16 n)
    {
        // i - 2f * n * dot(i, n);
        return fnma(2f * n, dot(i, n), i);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt16 project([This] float3_mt16 a, float3_mt16 onto) =>
        dot(a, onto) / dot(onto, onto) * onto;

    [MethodImpl(256 | 512)]
    public static float3_mt16 projectOnPlane([This] float3_mt16 a, float3_mt16 plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static float3_mt16 projectNormalized([This] float3_mt16 a, float3_mt16 onto) =>
        dot(a, onto) * onto;

    [MethodImpl(256 | 512)]
    public static float3_mt16 projectOnPlaneNormalized([This] float3_mt16 a, float3_mt16 plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static float3_mt16 radians([This] float3_mt16 a) => a * 0.0174532925199432957692369076848861271344287188854172545609719144f;

    [MethodImpl(256 | 512)]
    public static float3_mt16 degrees([This] float3_mt16 a) => a * 57.295779513082320876798154814105170332405472466564321549160243861f;

    [MethodImpl(256 | 512)]
    public static float3_mt16 wrap([This] float3_mt16 x, float3_mt16 min, float3_mt16 max)
    {
        return new(wrap(x.x, min.x, max.x), wrap(x.y, min.y, max.y), wrap(x.z, min.z, max.z));
    }

    [MethodImpl(256 | 512)]
    public static float3_mt16 wrap([This] float3_mt16 x, float_mt16 min, float_mt16 max)
    {
        return new(wrap(x.x, min, max), wrap(x.y, min, max), wrap(x.z, min, max));
    }

    [MethodImpl(256 | 512)]
    public static float3_mt16 wrap([This] float3_mt16 x, float min, float max)
    {
        return new(wrap(x.x, min, max), wrap(x.y, min, max), wrap(x.z, min, max));
    }

    [MethodImpl(256 | 512)]
    public static float3_mt16 log([This] float3_mt16 a) => new(log(a.x), log(a.y), log(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt16 log2([This] float3_mt16 a) => new(log2(a.x), log2(a.y), log2(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt16 log([This] float3_mt16 a, float3_mt16 b) => new(log(a.x, b.x), log(a.y, b.y), log(a.z, b.z));

    [MethodImpl(256 | 512)]
    public static float3_mt16 log([This] float3_mt16 a, float_mt16 b) => new(log(a.x, b), log(a.y, b), log(a.z, b));

    [MethodImpl(256 | 512)]
    public static float3_mt16 log([This] float_mt16 a, float3_mt16 b) => new(log(a, b.x), log(a, b.y), log(a, b.z));

    [MethodImpl(256 | 512)]
    public static float3_mt16 log10([This] float3_mt16 a) => new(log10(a.x), log10(a.y), log10(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt16 exp([This] float3_mt16 a) => new(exp(a.x), exp(a.y), exp(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt16 exp2([This] float3_mt16 a) => new(exp2(a.x), exp2(a.y), exp2(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt16 exp10([This] float3_mt16 a) => new(exp10(a.x), exp10(a.y), exp10(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt16 pow([This] float3_mt16 a, float3_mt16 b) => new(pow(a.x, b.x), pow(a.y, b.y), pow(a.z, b.z));

    [MethodImpl(256 | 512)]
    public static float3_mt16 pow([This] float3_mt16 a, float_mt16 b) => new(pow(a.x, b), pow(a.y, b), pow(a.z, b));

    [MethodImpl(256 | 512)]
    public static float3_mt16 pow([This] float3_mt16 a, float b) => new(pow(a.x, b), pow(a.y, b), pow(a.z, b));

    [MethodImpl(256 | 512)]
    public static float3_mt16 sqrt([This] float3_mt16 a) => new(sqrt(a.x), sqrt(a.y), sqrt(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt16 rsqrt([This] float3_mt16 a) => new(rsqrt(a.x), rsqrt(a.y), rsqrt(a.z));

    [MethodImpl(256 | 512)]
    public static float_mt16 length([This] float3_mt16 a) => dot(a, a).sqrt();

    [MethodImpl(256 | 512)]
    public static float_mt16 distance([This] float3_mt16 a, float3_mt16 b) => length(b - a);

    [MethodImpl(256 | 512)]
    public static float3_mt16 normalize([This] float3_mt16 a) => a * dot(a, a).rsqrt();
    
    // todo normalizeSafe step refract projectSafe faceForward

    [MethodImpl(256 | 512)]
    public static float3_mt16 sin([This] float3_mt16 a) => new(sin(a.x), sin(a.y), sin(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt16 cos([This] float3_mt16 a) => new(cos(a.x), cos(a.y), cos(a.z));

    [MethodImpl(256 | 512)]
    public static (float3_mt16 sin, float3_mt16 cos) sincos([This] float3_mt16 a)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        var (sin_z, cos_z) = sincos(a.z);
        return (
            new(sin_x, sin_y, sin_z),
            new(cos_x, cos_y, cos_z)
        );
    }

    [MethodImpl(256 | 512)]
    public static void sincos([This] float3_mt16 a, out float3_mt16 sin, out float3_mt16 cos)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        var (sin_z, cos_z) = sincos(a.z);
        sin = new(sin_x, sin_y, sin_z);
        cos = new(cos_x, cos_y, cos_z);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt16 tan([This] float3_mt16 a) => new(tan(a.x), tan(a.y), tan(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt16 asin([This] float3_mt16 a) => new(asin(a.x), asin(a.y), asin(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt16 acos([This] float3_mt16 a) => new(acos(a.x), acos(a.y), acos(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt16 atan([This] float3_mt16 a) => new(atan(a.x), atan(a.y), atan(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt16 atan2([This] float3_mt16 a, float3_mt16 b) => new(atan2(a.x, b.x), atan2(a.y, b.y), atan2(a.z, b.z));

    [MethodImpl(256 | 512)]
    public static float3_mt16 sinh([This] float3_mt16 a) => new(sinh(a.x), sinh(a.y), sinh(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt16 cosh([This] float3_mt16 a) => new(cosh(a.x), cosh(a.y), cosh(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt16 tanh([This] float3_mt16 a) => new(tanh(a.x), tanh(a.y), tanh(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt16 asinh([This] float3_mt16 a) => new(asinh(a.x), asinh(a.y), asinh(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt16 acosh([This] float3_mt16 a) => new(acosh(a.x), acosh(a.y), acosh(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt16 atanh([This] float3_mt16 a) => new(atanh(a.x), atanh(a.y), atanh(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt16 chgsign([This] float3_mt16 a, float3_mt16 b) => new(chgsign(a.x, b.x), chgsign(a.y, b.y), chgsign(a.z, b.z));
}

#endregion // float3_mt16
#region float3_mt32

public partial struct float3_mt32
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static float3_mt32 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277f); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static float3_mt32 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094f); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static float3_mt32 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009f);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static float3_mt32 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923f);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static float3_mt32 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846f);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static float3_mt32 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861f);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static float3_mt32 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144f);
    }
}

[Ex]
public static partial class math_mt
{
    #pragma warning disable CS1718
    // ReSharper disable once EqualExpressionComparison
    [MethodImpl(256 | 512)]
    public static b32v3_mt32 isNaN([This] float3_mt32 a) => a != a;
    #pragma warning restore CS1718

    [MethodImpl(256 | 512)]
    public static float3_mt32 ceil([This] float3_mt32 a) => new(a.x.floor(), a.y.floor(), a.z.floor());

    [MethodImpl(256 | 512)]
    public static float3_mt32 floor([This] float3_mt32 a) => new(a.x.floor(), a.y.floor(), a.z.floor());

    [MethodImpl(256 | 512)]
    public static float3_mt32 round([This] float3_mt32 a) => new(a.x.round(), a.y.round(), a.z.round());

    [MethodImpl(256 | 512)]
    public static float3_mt32 trunc([This] float3_mt32 a) => new(a.x.trunc(), a.y.trunc(), a.z.trunc());

    [MethodImpl(256 | 512)]
    public static float3_mt32 mod([This] float3_mt32 a, float3_mt32 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt32 mod([This] float_mt32 a, float3_mt32 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt32 mod([This] float3_mt32 a, float_mt32 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt32 mod([This] float a, float3_mt32 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt32 mod([This] float3_mt32 a, float b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt32 rem([This] float3_mt32 a, float3_mt32 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt32 rem([This] float_mt32 a, float3_mt32 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt32 rem([This] float3_mt32 a, float_mt32 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt32 rem([This] float a, float3_mt32 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt32 rem([This] float3_mt32 a, float b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt32 frac([This] float3_mt32 a) => a - floor(a);

    [MethodImpl(256 | 512)]
    public static float3_mt32 modf([This] float3_mt32 d, out float3_mt32 i)
    {
        i = trunc(d);
        return d - i;
    }

    [MethodImpl(256 | 512)]
    public static float3_mt32 rcp([This] float3_mt32 a) => new(rcp(a.x), rcp(a.y), rcp(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt32 saturate([This] float3_mt32 a) => a.clamp(default, float3_mt32.One);

    [MethodImpl(256 | 512)]
    public static float3_mt32 smoothstep(float3_mt32 min, float3_mt32 max, [This] float3_mt32 a)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * fnma(2.0f, t, 3.0f); // (3.0f - (2.0f * t))
    }

    [MethodImpl(256 | 512)]
    public static float3_mt32 reflect([This] float3_mt32 i, float3_mt32 n)
    {
        // i - 2f * n * dot(i, n);
        return fnma(2f * n, dot(i, n), i);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt32 project([This] float3_mt32 a, float3_mt32 onto) =>
        dot(a, onto) / dot(onto, onto) * onto;

    [MethodImpl(256 | 512)]
    public static float3_mt32 projectOnPlane([This] float3_mt32 a, float3_mt32 plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static float3_mt32 projectNormalized([This] float3_mt32 a, float3_mt32 onto) =>
        dot(a, onto) * onto;

    [MethodImpl(256 | 512)]
    public static float3_mt32 projectOnPlaneNormalized([This] float3_mt32 a, float3_mt32 plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static float3_mt32 radians([This] float3_mt32 a) => a * 0.0174532925199432957692369076848861271344287188854172545609719144f;

    [MethodImpl(256 | 512)]
    public static float3_mt32 degrees([This] float3_mt32 a) => a * 57.295779513082320876798154814105170332405472466564321549160243861f;

    [MethodImpl(256 | 512)]
    public static float3_mt32 wrap([This] float3_mt32 x, float3_mt32 min, float3_mt32 max)
    {
        return new(wrap(x.x, min.x, max.x), wrap(x.y, min.y, max.y), wrap(x.z, min.z, max.z));
    }

    [MethodImpl(256 | 512)]
    public static float3_mt32 wrap([This] float3_mt32 x, float_mt32 min, float_mt32 max)
    {
        return new(wrap(x.x, min, max), wrap(x.y, min, max), wrap(x.z, min, max));
    }

    [MethodImpl(256 | 512)]
    public static float3_mt32 wrap([This] float3_mt32 x, float min, float max)
    {
        return new(wrap(x.x, min, max), wrap(x.y, min, max), wrap(x.z, min, max));
    }

    [MethodImpl(256 | 512)]
    public static float3_mt32 log([This] float3_mt32 a) => new(log(a.x), log(a.y), log(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt32 log2([This] float3_mt32 a) => new(log2(a.x), log2(a.y), log2(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt32 log([This] float3_mt32 a, float3_mt32 b) => new(log(a.x, b.x), log(a.y, b.y), log(a.z, b.z));

    [MethodImpl(256 | 512)]
    public static float3_mt32 log([This] float3_mt32 a, float_mt32 b) => new(log(a.x, b), log(a.y, b), log(a.z, b));

    [MethodImpl(256 | 512)]
    public static float3_mt32 log([This] float_mt32 a, float3_mt32 b) => new(log(a, b.x), log(a, b.y), log(a, b.z));

    [MethodImpl(256 | 512)]
    public static float3_mt32 log10([This] float3_mt32 a) => new(log10(a.x), log10(a.y), log10(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt32 exp([This] float3_mt32 a) => new(exp(a.x), exp(a.y), exp(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt32 exp2([This] float3_mt32 a) => new(exp2(a.x), exp2(a.y), exp2(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt32 exp10([This] float3_mt32 a) => new(exp10(a.x), exp10(a.y), exp10(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt32 pow([This] float3_mt32 a, float3_mt32 b) => new(pow(a.x, b.x), pow(a.y, b.y), pow(a.z, b.z));

    [MethodImpl(256 | 512)]
    public static float3_mt32 pow([This] float3_mt32 a, float_mt32 b) => new(pow(a.x, b), pow(a.y, b), pow(a.z, b));

    [MethodImpl(256 | 512)]
    public static float3_mt32 pow([This] float3_mt32 a, float b) => new(pow(a.x, b), pow(a.y, b), pow(a.z, b));

    [MethodImpl(256 | 512)]
    public static float3_mt32 sqrt([This] float3_mt32 a) => new(sqrt(a.x), sqrt(a.y), sqrt(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt32 rsqrt([This] float3_mt32 a) => new(rsqrt(a.x), rsqrt(a.y), rsqrt(a.z));

    [MethodImpl(256 | 512)]
    public static float_mt32 length([This] float3_mt32 a) => dot(a, a).sqrt();

    [MethodImpl(256 | 512)]
    public static float_mt32 distance([This] float3_mt32 a, float3_mt32 b) => length(b - a);

    [MethodImpl(256 | 512)]
    public static float3_mt32 normalize([This] float3_mt32 a) => a * dot(a, a).rsqrt();
    
    // todo normalizeSafe step refract projectSafe faceForward

    [MethodImpl(256 | 512)]
    public static float3_mt32 sin([This] float3_mt32 a) => new(sin(a.x), sin(a.y), sin(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt32 cos([This] float3_mt32 a) => new(cos(a.x), cos(a.y), cos(a.z));

    [MethodImpl(256 | 512)]
    public static (float3_mt32 sin, float3_mt32 cos) sincos([This] float3_mt32 a)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        var (sin_z, cos_z) = sincos(a.z);
        return (
            new(sin_x, sin_y, sin_z),
            new(cos_x, cos_y, cos_z)
        );
    }

    [MethodImpl(256 | 512)]
    public static void sincos([This] float3_mt32 a, out float3_mt32 sin, out float3_mt32 cos)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        var (sin_z, cos_z) = sincos(a.z);
        sin = new(sin_x, sin_y, sin_z);
        cos = new(cos_x, cos_y, cos_z);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt32 tan([This] float3_mt32 a) => new(tan(a.x), tan(a.y), tan(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt32 asin([This] float3_mt32 a) => new(asin(a.x), asin(a.y), asin(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt32 acos([This] float3_mt32 a) => new(acos(a.x), acos(a.y), acos(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt32 atan([This] float3_mt32 a) => new(atan(a.x), atan(a.y), atan(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt32 atan2([This] float3_mt32 a, float3_mt32 b) => new(atan2(a.x, b.x), atan2(a.y, b.y), atan2(a.z, b.z));

    [MethodImpl(256 | 512)]
    public static float3_mt32 sinh([This] float3_mt32 a) => new(sinh(a.x), sinh(a.y), sinh(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt32 cosh([This] float3_mt32 a) => new(cosh(a.x), cosh(a.y), cosh(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt32 tanh([This] float3_mt32 a) => new(tanh(a.x), tanh(a.y), tanh(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt32 asinh([This] float3_mt32 a) => new(asinh(a.x), asinh(a.y), asinh(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt32 acosh([This] float3_mt32 a) => new(acosh(a.x), acosh(a.y), acosh(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt32 atanh([This] float3_mt32 a) => new(atanh(a.x), atanh(a.y), atanh(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt32 chgsign([This] float3_mt32 a, float3_mt32 b) => new(chgsign(a.x, b.x), chgsign(a.y, b.y), chgsign(a.z, b.z));
}

#endregion // float3_mt32
#region float4_mt4

public partial struct float4_mt4
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static float4_mt4 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277f); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static float4_mt4 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094f); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static float4_mt4 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009f);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static float4_mt4 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923f);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static float4_mt4 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846f);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static float4_mt4 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861f);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static float4_mt4 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144f);
    }
}

[Ex]
public static partial class math_mt
{
    #pragma warning disable CS1718
    // ReSharper disable once EqualExpressionComparison
    [MethodImpl(256 | 512)]
    public static b32v4_mt4 isNaN([This] float4_mt4 a) => a != a;
    #pragma warning restore CS1718

    [MethodImpl(256 | 512)]
    public static float4_mt4 ceil([This] float4_mt4 a) => new(a.x.floor(), a.y.floor(), a.z.floor(), a.w.floor());

    [MethodImpl(256 | 512)]
    public static float4_mt4 floor([This] float4_mt4 a) => new(a.x.floor(), a.y.floor(), a.z.floor(), a.w.floor());

    [MethodImpl(256 | 512)]
    public static float4_mt4 round([This] float4_mt4 a) => new(a.x.round(), a.y.round(), a.z.round(), a.w.round());

    [MethodImpl(256 | 512)]
    public static float4_mt4 trunc([This] float4_mt4 a) => new(a.x.trunc(), a.y.trunc(), a.z.trunc(), a.w.trunc());

    [MethodImpl(256 | 512)]
    public static float4_mt4 mod([This] float4_mt4 a, float4_mt4 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt4 mod([This] float_mt4 a, float4_mt4 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt4 mod([This] float4_mt4 a, float_mt4 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt4 mod([This] float a, float4_mt4 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt4 mod([This] float4_mt4 a, float b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt4 rem([This] float4_mt4 a, float4_mt4 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt4 rem([This] float_mt4 a, float4_mt4 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt4 rem([This] float4_mt4 a, float_mt4 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt4 rem([This] float a, float4_mt4 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt4 rem([This] float4_mt4 a, float b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt4 frac([This] float4_mt4 a) => a - floor(a);

    [MethodImpl(256 | 512)]
    public static float4_mt4 modf([This] float4_mt4 d, out float4_mt4 i)
    {
        i = trunc(d);
        return d - i;
    }

    [MethodImpl(256 | 512)]
    public static float4_mt4 rcp([This] float4_mt4 a) => new(rcp(a.x), rcp(a.y), rcp(a.z), rcp(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt4 saturate([This] float4_mt4 a) => a.clamp(default, float4_mt4.One);

    [MethodImpl(256 | 512)]
    public static float4_mt4 smoothstep(float4_mt4 min, float4_mt4 max, [This] float4_mt4 a)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * fnma(2.0f, t, 3.0f); // (3.0f - (2.0f * t))
    }

    [MethodImpl(256 | 512)]
    public static float4_mt4 reflect([This] float4_mt4 i, float4_mt4 n)
    {
        // i - 2f * n * dot(i, n);
        return fnma(2f * n, dot(i, n), i);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt4 project([This] float4_mt4 a, float4_mt4 onto) =>
        dot(a, onto) / dot(onto, onto) * onto;

    [MethodImpl(256 | 512)]
    public static float4_mt4 projectOnPlane([This] float4_mt4 a, float4_mt4 plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static float4_mt4 projectNormalized([This] float4_mt4 a, float4_mt4 onto) =>
        dot(a, onto) * onto;

    [MethodImpl(256 | 512)]
    public static float4_mt4 projectOnPlaneNormalized([This] float4_mt4 a, float4_mt4 plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static float4_mt4 radians([This] float4_mt4 a) => a * 0.0174532925199432957692369076848861271344287188854172545609719144f;

    [MethodImpl(256 | 512)]
    public static float4_mt4 degrees([This] float4_mt4 a) => a * 57.295779513082320876798154814105170332405472466564321549160243861f;

    [MethodImpl(256 | 512)]
    public static float4_mt4 wrap([This] float4_mt4 x, float4_mt4 min, float4_mt4 max)
    {
        return new(wrap(x.x, min.x, max.x), wrap(x.y, min.y, max.y), wrap(x.z, min.z, max.z), wrap(x.w, min.w, max.w));
    }

    [MethodImpl(256 | 512)]
    public static float4_mt4 wrap([This] float4_mt4 x, float_mt4 min, float_mt4 max)
    {
        return new(wrap(x.x, min, max), wrap(x.y, min, max), wrap(x.z, min, max), wrap(x.w, min, max));
    }

    [MethodImpl(256 | 512)]
    public static float4_mt4 wrap([This] float4_mt4 x, float min, float max)
    {
        return new(wrap(x.x, min, max), wrap(x.y, min, max), wrap(x.z, min, max), wrap(x.w, min, max));
    }

    [MethodImpl(256 | 512)]
    public static float4_mt4 log([This] float4_mt4 a) => new(log(a.x), log(a.y), log(a.z), log(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt4 log2([This] float4_mt4 a) => new(log2(a.x), log2(a.y), log2(a.z), log2(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt4 log([This] float4_mt4 a, float4_mt4 b) => new(log(a.x, b.x), log(a.y, b.y), log(a.z, b.z), log(a.w, b.w));

    [MethodImpl(256 | 512)]
    public static float4_mt4 log([This] float4_mt4 a, float_mt4 b) => new(log(a.x, b), log(a.y, b), log(a.z, b), log(a.w, b));

    [MethodImpl(256 | 512)]
    public static float4_mt4 log([This] float_mt4 a, float4_mt4 b) => new(log(a, b.x), log(a, b.y), log(a, b.z), log(a, b.w));

    [MethodImpl(256 | 512)]
    public static float4_mt4 log10([This] float4_mt4 a) => new(log10(a.x), log10(a.y), log10(a.z), log10(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt4 exp([This] float4_mt4 a) => new(exp(a.x), exp(a.y), exp(a.z), exp(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt4 exp2([This] float4_mt4 a) => new(exp2(a.x), exp2(a.y), exp2(a.z), exp2(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt4 exp10([This] float4_mt4 a) => new(exp10(a.x), exp10(a.y), exp10(a.z), exp10(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt4 pow([This] float4_mt4 a, float4_mt4 b) => new(pow(a.x, b.x), pow(a.y, b.y), pow(a.z, b.z), pow(a.w, b.w));

    [MethodImpl(256 | 512)]
    public static float4_mt4 pow([This] float4_mt4 a, float_mt4 b) => new(pow(a.x, b), pow(a.y, b), pow(a.z, b), pow(a.w, b));

    [MethodImpl(256 | 512)]
    public static float4_mt4 pow([This] float4_mt4 a, float b) => new(pow(a.x, b), pow(a.y, b), pow(a.z, b), pow(a.w, b));

    [MethodImpl(256 | 512)]
    public static float4_mt4 sqrt([This] float4_mt4 a) => new(sqrt(a.x), sqrt(a.y), sqrt(a.z), sqrt(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt4 rsqrt([This] float4_mt4 a) => new(rsqrt(a.x), rsqrt(a.y), rsqrt(a.z), rsqrt(a.w));

    [MethodImpl(256 | 512)]
    public static float_mt4 length([This] float4_mt4 a) => dot(a, a).sqrt();

    [MethodImpl(256 | 512)]
    public static float_mt4 distance([This] float4_mt4 a, float4_mt4 b) => length(b - a);

    [MethodImpl(256 | 512)]
    public static float4_mt4 normalize([This] float4_mt4 a) => a * dot(a, a).rsqrt();
    
    // todo normalizeSafe step refract projectSafe faceForward

    [MethodImpl(256 | 512)]
    public static float4_mt4 sin([This] float4_mt4 a) => new(sin(a.x), sin(a.y), sin(a.z), sin(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt4 cos([This] float4_mt4 a) => new(cos(a.x), cos(a.y), cos(a.z), cos(a.w));

    [MethodImpl(256 | 512)]
    public static (float4_mt4 sin, float4_mt4 cos) sincos([This] float4_mt4 a)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        var (sin_z, cos_z) = sincos(a.z);
        var (sin_w, cos_w) = sincos(a.w);
        return (
            new(sin_x, sin_y, sin_z, sin_w),
            new(cos_x, cos_y, cos_z, cos_w)
        );
    }

    [MethodImpl(256 | 512)]
    public static void sincos([This] float4_mt4 a, out float4_mt4 sin, out float4_mt4 cos)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        var (sin_z, cos_z) = sincos(a.z);
        var (sin_w, cos_w) = sincos(a.w);
        sin = new(sin_x, sin_y, sin_z, sin_w);
        cos = new(cos_x, cos_y, cos_z, cos_w);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt4 tan([This] float4_mt4 a) => new(tan(a.x), tan(a.y), tan(a.z), tan(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt4 asin([This] float4_mt4 a) => new(asin(a.x), asin(a.y), asin(a.z), asin(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt4 acos([This] float4_mt4 a) => new(acos(a.x), acos(a.y), acos(a.z), acos(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt4 atan([This] float4_mt4 a) => new(atan(a.x), atan(a.y), atan(a.z), atan(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt4 atan2([This] float4_mt4 a, float4_mt4 b) => new(atan2(a.x, b.x), atan2(a.y, b.y), atan2(a.z, b.z), atan2(a.w, b.w));

    [MethodImpl(256 | 512)]
    public static float4_mt4 sinh([This] float4_mt4 a) => new(sinh(a.x), sinh(a.y), sinh(a.z), sinh(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt4 cosh([This] float4_mt4 a) => new(cosh(a.x), cosh(a.y), cosh(a.z), cosh(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt4 tanh([This] float4_mt4 a) => new(tanh(a.x), tanh(a.y), tanh(a.z), tanh(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt4 asinh([This] float4_mt4 a) => new(asinh(a.x), asinh(a.y), asinh(a.z), asinh(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt4 acosh([This] float4_mt4 a) => new(acosh(a.x), acosh(a.y), acosh(a.z), acosh(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt4 atanh([This] float4_mt4 a) => new(atanh(a.x), atanh(a.y), atanh(a.z), atanh(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt4 chgsign([This] float4_mt4 a, float4_mt4 b) => new(chgsign(a.x, b.x), chgsign(a.y, b.y), chgsign(a.z, b.z), chgsign(a.w, b.w));
}

#endregion // float4_mt4
#region float4_mt8

public partial struct float4_mt8
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static float4_mt8 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277f); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static float4_mt8 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094f); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static float4_mt8 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009f);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static float4_mt8 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923f);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static float4_mt8 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846f);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static float4_mt8 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861f);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static float4_mt8 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144f);
    }
}

[Ex]
public static partial class math_mt
{
    #pragma warning disable CS1718
    // ReSharper disable once EqualExpressionComparison
    [MethodImpl(256 | 512)]
    public static b32v4_mt8 isNaN([This] float4_mt8 a) => a != a;
    #pragma warning restore CS1718

    [MethodImpl(256 | 512)]
    public static float4_mt8 ceil([This] float4_mt8 a) => new(a.x.floor(), a.y.floor(), a.z.floor(), a.w.floor());

    [MethodImpl(256 | 512)]
    public static float4_mt8 floor([This] float4_mt8 a) => new(a.x.floor(), a.y.floor(), a.z.floor(), a.w.floor());

    [MethodImpl(256 | 512)]
    public static float4_mt8 round([This] float4_mt8 a) => new(a.x.round(), a.y.round(), a.z.round(), a.w.round());

    [MethodImpl(256 | 512)]
    public static float4_mt8 trunc([This] float4_mt8 a) => new(a.x.trunc(), a.y.trunc(), a.z.trunc(), a.w.trunc());

    [MethodImpl(256 | 512)]
    public static float4_mt8 mod([This] float4_mt8 a, float4_mt8 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt8 mod([This] float_mt8 a, float4_mt8 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt8 mod([This] float4_mt8 a, float_mt8 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt8 mod([This] float a, float4_mt8 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt8 mod([This] float4_mt8 a, float b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt8 rem([This] float4_mt8 a, float4_mt8 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt8 rem([This] float_mt8 a, float4_mt8 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt8 rem([This] float4_mt8 a, float_mt8 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt8 rem([This] float a, float4_mt8 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt8 rem([This] float4_mt8 a, float b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt8 frac([This] float4_mt8 a) => a - floor(a);

    [MethodImpl(256 | 512)]
    public static float4_mt8 modf([This] float4_mt8 d, out float4_mt8 i)
    {
        i = trunc(d);
        return d - i;
    }

    [MethodImpl(256 | 512)]
    public static float4_mt8 rcp([This] float4_mt8 a) => new(rcp(a.x), rcp(a.y), rcp(a.z), rcp(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt8 saturate([This] float4_mt8 a) => a.clamp(default, float4_mt8.One);

    [MethodImpl(256 | 512)]
    public static float4_mt8 smoothstep(float4_mt8 min, float4_mt8 max, [This] float4_mt8 a)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * fnma(2.0f, t, 3.0f); // (3.0f - (2.0f * t))
    }

    [MethodImpl(256 | 512)]
    public static float4_mt8 reflect([This] float4_mt8 i, float4_mt8 n)
    {
        // i - 2f * n * dot(i, n);
        return fnma(2f * n, dot(i, n), i);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt8 project([This] float4_mt8 a, float4_mt8 onto) =>
        dot(a, onto) / dot(onto, onto) * onto;

    [MethodImpl(256 | 512)]
    public static float4_mt8 projectOnPlane([This] float4_mt8 a, float4_mt8 plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static float4_mt8 projectNormalized([This] float4_mt8 a, float4_mt8 onto) =>
        dot(a, onto) * onto;

    [MethodImpl(256 | 512)]
    public static float4_mt8 projectOnPlaneNormalized([This] float4_mt8 a, float4_mt8 plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static float4_mt8 radians([This] float4_mt8 a) => a * 0.0174532925199432957692369076848861271344287188854172545609719144f;

    [MethodImpl(256 | 512)]
    public static float4_mt8 degrees([This] float4_mt8 a) => a * 57.295779513082320876798154814105170332405472466564321549160243861f;

    [MethodImpl(256 | 512)]
    public static float4_mt8 wrap([This] float4_mt8 x, float4_mt8 min, float4_mt8 max)
    {
        return new(wrap(x.x, min.x, max.x), wrap(x.y, min.y, max.y), wrap(x.z, min.z, max.z), wrap(x.w, min.w, max.w));
    }

    [MethodImpl(256 | 512)]
    public static float4_mt8 wrap([This] float4_mt8 x, float_mt8 min, float_mt8 max)
    {
        return new(wrap(x.x, min, max), wrap(x.y, min, max), wrap(x.z, min, max), wrap(x.w, min, max));
    }

    [MethodImpl(256 | 512)]
    public static float4_mt8 wrap([This] float4_mt8 x, float min, float max)
    {
        return new(wrap(x.x, min, max), wrap(x.y, min, max), wrap(x.z, min, max), wrap(x.w, min, max));
    }

    [MethodImpl(256 | 512)]
    public static float4_mt8 log([This] float4_mt8 a) => new(log(a.x), log(a.y), log(a.z), log(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt8 log2([This] float4_mt8 a) => new(log2(a.x), log2(a.y), log2(a.z), log2(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt8 log([This] float4_mt8 a, float4_mt8 b) => new(log(a.x, b.x), log(a.y, b.y), log(a.z, b.z), log(a.w, b.w));

    [MethodImpl(256 | 512)]
    public static float4_mt8 log([This] float4_mt8 a, float_mt8 b) => new(log(a.x, b), log(a.y, b), log(a.z, b), log(a.w, b));

    [MethodImpl(256 | 512)]
    public static float4_mt8 log([This] float_mt8 a, float4_mt8 b) => new(log(a, b.x), log(a, b.y), log(a, b.z), log(a, b.w));

    [MethodImpl(256 | 512)]
    public static float4_mt8 log10([This] float4_mt8 a) => new(log10(a.x), log10(a.y), log10(a.z), log10(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt8 exp([This] float4_mt8 a) => new(exp(a.x), exp(a.y), exp(a.z), exp(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt8 exp2([This] float4_mt8 a) => new(exp2(a.x), exp2(a.y), exp2(a.z), exp2(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt8 exp10([This] float4_mt8 a) => new(exp10(a.x), exp10(a.y), exp10(a.z), exp10(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt8 pow([This] float4_mt8 a, float4_mt8 b) => new(pow(a.x, b.x), pow(a.y, b.y), pow(a.z, b.z), pow(a.w, b.w));

    [MethodImpl(256 | 512)]
    public static float4_mt8 pow([This] float4_mt8 a, float_mt8 b) => new(pow(a.x, b), pow(a.y, b), pow(a.z, b), pow(a.w, b));

    [MethodImpl(256 | 512)]
    public static float4_mt8 pow([This] float4_mt8 a, float b) => new(pow(a.x, b), pow(a.y, b), pow(a.z, b), pow(a.w, b));

    [MethodImpl(256 | 512)]
    public static float4_mt8 sqrt([This] float4_mt8 a) => new(sqrt(a.x), sqrt(a.y), sqrt(a.z), sqrt(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt8 rsqrt([This] float4_mt8 a) => new(rsqrt(a.x), rsqrt(a.y), rsqrt(a.z), rsqrt(a.w));

    [MethodImpl(256 | 512)]
    public static float_mt8 length([This] float4_mt8 a) => dot(a, a).sqrt();

    [MethodImpl(256 | 512)]
    public static float_mt8 distance([This] float4_mt8 a, float4_mt8 b) => length(b - a);

    [MethodImpl(256 | 512)]
    public static float4_mt8 normalize([This] float4_mt8 a) => a * dot(a, a).rsqrt();
    
    // todo normalizeSafe step refract projectSafe faceForward

    [MethodImpl(256 | 512)]
    public static float4_mt8 sin([This] float4_mt8 a) => new(sin(a.x), sin(a.y), sin(a.z), sin(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt8 cos([This] float4_mt8 a) => new(cos(a.x), cos(a.y), cos(a.z), cos(a.w));

    [MethodImpl(256 | 512)]
    public static (float4_mt8 sin, float4_mt8 cos) sincos([This] float4_mt8 a)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        var (sin_z, cos_z) = sincos(a.z);
        var (sin_w, cos_w) = sincos(a.w);
        return (
            new(sin_x, sin_y, sin_z, sin_w),
            new(cos_x, cos_y, cos_z, cos_w)
        );
    }

    [MethodImpl(256 | 512)]
    public static void sincos([This] float4_mt8 a, out float4_mt8 sin, out float4_mt8 cos)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        var (sin_z, cos_z) = sincos(a.z);
        var (sin_w, cos_w) = sincos(a.w);
        sin = new(sin_x, sin_y, sin_z, sin_w);
        cos = new(cos_x, cos_y, cos_z, cos_w);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt8 tan([This] float4_mt8 a) => new(tan(a.x), tan(a.y), tan(a.z), tan(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt8 asin([This] float4_mt8 a) => new(asin(a.x), asin(a.y), asin(a.z), asin(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt8 acos([This] float4_mt8 a) => new(acos(a.x), acos(a.y), acos(a.z), acos(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt8 atan([This] float4_mt8 a) => new(atan(a.x), atan(a.y), atan(a.z), atan(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt8 atan2([This] float4_mt8 a, float4_mt8 b) => new(atan2(a.x, b.x), atan2(a.y, b.y), atan2(a.z, b.z), atan2(a.w, b.w));

    [MethodImpl(256 | 512)]
    public static float4_mt8 sinh([This] float4_mt8 a) => new(sinh(a.x), sinh(a.y), sinh(a.z), sinh(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt8 cosh([This] float4_mt8 a) => new(cosh(a.x), cosh(a.y), cosh(a.z), cosh(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt8 tanh([This] float4_mt8 a) => new(tanh(a.x), tanh(a.y), tanh(a.z), tanh(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt8 asinh([This] float4_mt8 a) => new(asinh(a.x), asinh(a.y), asinh(a.z), asinh(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt8 acosh([This] float4_mt8 a) => new(acosh(a.x), acosh(a.y), acosh(a.z), acosh(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt8 atanh([This] float4_mt8 a) => new(atanh(a.x), atanh(a.y), atanh(a.z), atanh(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt8 chgsign([This] float4_mt8 a, float4_mt8 b) => new(chgsign(a.x, b.x), chgsign(a.y, b.y), chgsign(a.z, b.z), chgsign(a.w, b.w));
}

#endregion // float4_mt8
#region float4_mt16

public partial struct float4_mt16
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static float4_mt16 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277f); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static float4_mt16 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094f); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static float4_mt16 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009f);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static float4_mt16 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923f);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static float4_mt16 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846f);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static float4_mt16 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861f);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static float4_mt16 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144f);
    }
}

[Ex]
public static partial class math_mt
{
    #pragma warning disable CS1718
    // ReSharper disable once EqualExpressionComparison
    [MethodImpl(256 | 512)]
    public static b32v4_mt16 isNaN([This] float4_mt16 a) => a != a;
    #pragma warning restore CS1718

    [MethodImpl(256 | 512)]
    public static float4_mt16 ceil([This] float4_mt16 a) => new(a.x.floor(), a.y.floor(), a.z.floor(), a.w.floor());

    [MethodImpl(256 | 512)]
    public static float4_mt16 floor([This] float4_mt16 a) => new(a.x.floor(), a.y.floor(), a.z.floor(), a.w.floor());

    [MethodImpl(256 | 512)]
    public static float4_mt16 round([This] float4_mt16 a) => new(a.x.round(), a.y.round(), a.z.round(), a.w.round());

    [MethodImpl(256 | 512)]
    public static float4_mt16 trunc([This] float4_mt16 a) => new(a.x.trunc(), a.y.trunc(), a.z.trunc(), a.w.trunc());

    [MethodImpl(256 | 512)]
    public static float4_mt16 mod([This] float4_mt16 a, float4_mt16 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt16 mod([This] float_mt16 a, float4_mt16 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt16 mod([This] float4_mt16 a, float_mt16 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt16 mod([This] float a, float4_mt16 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt16 mod([This] float4_mt16 a, float b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt16 rem([This] float4_mt16 a, float4_mt16 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt16 rem([This] float_mt16 a, float4_mt16 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt16 rem([This] float4_mt16 a, float_mt16 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt16 rem([This] float a, float4_mt16 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt16 rem([This] float4_mt16 a, float b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt16 frac([This] float4_mt16 a) => a - floor(a);

    [MethodImpl(256 | 512)]
    public static float4_mt16 modf([This] float4_mt16 d, out float4_mt16 i)
    {
        i = trunc(d);
        return d - i;
    }

    [MethodImpl(256 | 512)]
    public static float4_mt16 rcp([This] float4_mt16 a) => new(rcp(a.x), rcp(a.y), rcp(a.z), rcp(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt16 saturate([This] float4_mt16 a) => a.clamp(default, float4_mt16.One);

    [MethodImpl(256 | 512)]
    public static float4_mt16 smoothstep(float4_mt16 min, float4_mt16 max, [This] float4_mt16 a)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * fnma(2.0f, t, 3.0f); // (3.0f - (2.0f * t))
    }

    [MethodImpl(256 | 512)]
    public static float4_mt16 reflect([This] float4_mt16 i, float4_mt16 n)
    {
        // i - 2f * n * dot(i, n);
        return fnma(2f * n, dot(i, n), i);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt16 project([This] float4_mt16 a, float4_mt16 onto) =>
        dot(a, onto) / dot(onto, onto) * onto;

    [MethodImpl(256 | 512)]
    public static float4_mt16 projectOnPlane([This] float4_mt16 a, float4_mt16 plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static float4_mt16 projectNormalized([This] float4_mt16 a, float4_mt16 onto) =>
        dot(a, onto) * onto;

    [MethodImpl(256 | 512)]
    public static float4_mt16 projectOnPlaneNormalized([This] float4_mt16 a, float4_mt16 plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static float4_mt16 radians([This] float4_mt16 a) => a * 0.0174532925199432957692369076848861271344287188854172545609719144f;

    [MethodImpl(256 | 512)]
    public static float4_mt16 degrees([This] float4_mt16 a) => a * 57.295779513082320876798154814105170332405472466564321549160243861f;

    [MethodImpl(256 | 512)]
    public static float4_mt16 wrap([This] float4_mt16 x, float4_mt16 min, float4_mt16 max)
    {
        return new(wrap(x.x, min.x, max.x), wrap(x.y, min.y, max.y), wrap(x.z, min.z, max.z), wrap(x.w, min.w, max.w));
    }

    [MethodImpl(256 | 512)]
    public static float4_mt16 wrap([This] float4_mt16 x, float_mt16 min, float_mt16 max)
    {
        return new(wrap(x.x, min, max), wrap(x.y, min, max), wrap(x.z, min, max), wrap(x.w, min, max));
    }

    [MethodImpl(256 | 512)]
    public static float4_mt16 wrap([This] float4_mt16 x, float min, float max)
    {
        return new(wrap(x.x, min, max), wrap(x.y, min, max), wrap(x.z, min, max), wrap(x.w, min, max));
    }

    [MethodImpl(256 | 512)]
    public static float4_mt16 log([This] float4_mt16 a) => new(log(a.x), log(a.y), log(a.z), log(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt16 log2([This] float4_mt16 a) => new(log2(a.x), log2(a.y), log2(a.z), log2(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt16 log([This] float4_mt16 a, float4_mt16 b) => new(log(a.x, b.x), log(a.y, b.y), log(a.z, b.z), log(a.w, b.w));

    [MethodImpl(256 | 512)]
    public static float4_mt16 log([This] float4_mt16 a, float_mt16 b) => new(log(a.x, b), log(a.y, b), log(a.z, b), log(a.w, b));

    [MethodImpl(256 | 512)]
    public static float4_mt16 log([This] float_mt16 a, float4_mt16 b) => new(log(a, b.x), log(a, b.y), log(a, b.z), log(a, b.w));

    [MethodImpl(256 | 512)]
    public static float4_mt16 log10([This] float4_mt16 a) => new(log10(a.x), log10(a.y), log10(a.z), log10(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt16 exp([This] float4_mt16 a) => new(exp(a.x), exp(a.y), exp(a.z), exp(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt16 exp2([This] float4_mt16 a) => new(exp2(a.x), exp2(a.y), exp2(a.z), exp2(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt16 exp10([This] float4_mt16 a) => new(exp10(a.x), exp10(a.y), exp10(a.z), exp10(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt16 pow([This] float4_mt16 a, float4_mt16 b) => new(pow(a.x, b.x), pow(a.y, b.y), pow(a.z, b.z), pow(a.w, b.w));

    [MethodImpl(256 | 512)]
    public static float4_mt16 pow([This] float4_mt16 a, float_mt16 b) => new(pow(a.x, b), pow(a.y, b), pow(a.z, b), pow(a.w, b));

    [MethodImpl(256 | 512)]
    public static float4_mt16 pow([This] float4_mt16 a, float b) => new(pow(a.x, b), pow(a.y, b), pow(a.z, b), pow(a.w, b));

    [MethodImpl(256 | 512)]
    public static float4_mt16 sqrt([This] float4_mt16 a) => new(sqrt(a.x), sqrt(a.y), sqrt(a.z), sqrt(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt16 rsqrt([This] float4_mt16 a) => new(rsqrt(a.x), rsqrt(a.y), rsqrt(a.z), rsqrt(a.w));

    [MethodImpl(256 | 512)]
    public static float_mt16 length([This] float4_mt16 a) => dot(a, a).sqrt();

    [MethodImpl(256 | 512)]
    public static float_mt16 distance([This] float4_mt16 a, float4_mt16 b) => length(b - a);

    [MethodImpl(256 | 512)]
    public static float4_mt16 normalize([This] float4_mt16 a) => a * dot(a, a).rsqrt();
    
    // todo normalizeSafe step refract projectSafe faceForward

    [MethodImpl(256 | 512)]
    public static float4_mt16 sin([This] float4_mt16 a) => new(sin(a.x), sin(a.y), sin(a.z), sin(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt16 cos([This] float4_mt16 a) => new(cos(a.x), cos(a.y), cos(a.z), cos(a.w));

    [MethodImpl(256 | 512)]
    public static (float4_mt16 sin, float4_mt16 cos) sincos([This] float4_mt16 a)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        var (sin_z, cos_z) = sincos(a.z);
        var (sin_w, cos_w) = sincos(a.w);
        return (
            new(sin_x, sin_y, sin_z, sin_w),
            new(cos_x, cos_y, cos_z, cos_w)
        );
    }

    [MethodImpl(256 | 512)]
    public static void sincos([This] float4_mt16 a, out float4_mt16 sin, out float4_mt16 cos)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        var (sin_z, cos_z) = sincos(a.z);
        var (sin_w, cos_w) = sincos(a.w);
        sin = new(sin_x, sin_y, sin_z, sin_w);
        cos = new(cos_x, cos_y, cos_z, cos_w);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt16 tan([This] float4_mt16 a) => new(tan(a.x), tan(a.y), tan(a.z), tan(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt16 asin([This] float4_mt16 a) => new(asin(a.x), asin(a.y), asin(a.z), asin(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt16 acos([This] float4_mt16 a) => new(acos(a.x), acos(a.y), acos(a.z), acos(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt16 atan([This] float4_mt16 a) => new(atan(a.x), atan(a.y), atan(a.z), atan(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt16 atan2([This] float4_mt16 a, float4_mt16 b) => new(atan2(a.x, b.x), atan2(a.y, b.y), atan2(a.z, b.z), atan2(a.w, b.w));

    [MethodImpl(256 | 512)]
    public static float4_mt16 sinh([This] float4_mt16 a) => new(sinh(a.x), sinh(a.y), sinh(a.z), sinh(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt16 cosh([This] float4_mt16 a) => new(cosh(a.x), cosh(a.y), cosh(a.z), cosh(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt16 tanh([This] float4_mt16 a) => new(tanh(a.x), tanh(a.y), tanh(a.z), tanh(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt16 asinh([This] float4_mt16 a) => new(asinh(a.x), asinh(a.y), asinh(a.z), asinh(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt16 acosh([This] float4_mt16 a) => new(acosh(a.x), acosh(a.y), acosh(a.z), acosh(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt16 atanh([This] float4_mt16 a) => new(atanh(a.x), atanh(a.y), atanh(a.z), atanh(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt16 chgsign([This] float4_mt16 a, float4_mt16 b) => new(chgsign(a.x, b.x), chgsign(a.y, b.y), chgsign(a.z, b.z), chgsign(a.w, b.w));
}

#endregion // float4_mt16
#region float4_mt32

public partial struct float4_mt32
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static float4_mt32 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277f); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static float4_mt32 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094f); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static float4_mt32 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009f);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static float4_mt32 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923f);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static float4_mt32 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846f);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static float4_mt32 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861f);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static float4_mt32 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144f);
    }
}

[Ex]
public static partial class math_mt
{
    #pragma warning disable CS1718
    // ReSharper disable once EqualExpressionComparison
    [MethodImpl(256 | 512)]
    public static b32v4_mt32 isNaN([This] float4_mt32 a) => a != a;
    #pragma warning restore CS1718

    [MethodImpl(256 | 512)]
    public static float4_mt32 ceil([This] float4_mt32 a) => new(a.x.floor(), a.y.floor(), a.z.floor(), a.w.floor());

    [MethodImpl(256 | 512)]
    public static float4_mt32 floor([This] float4_mt32 a) => new(a.x.floor(), a.y.floor(), a.z.floor(), a.w.floor());

    [MethodImpl(256 | 512)]
    public static float4_mt32 round([This] float4_mt32 a) => new(a.x.round(), a.y.round(), a.z.round(), a.w.round());

    [MethodImpl(256 | 512)]
    public static float4_mt32 trunc([This] float4_mt32 a) => new(a.x.trunc(), a.y.trunc(), a.z.trunc(), a.w.trunc());

    [MethodImpl(256 | 512)]
    public static float4_mt32 mod([This] float4_mt32 a, float4_mt32 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt32 mod([This] float_mt32 a, float4_mt32 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt32 mod([This] float4_mt32 a, float_mt32 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt32 mod([This] float a, float4_mt32 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt32 mod([This] float4_mt32 a, float b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt32 rem([This] float4_mt32 a, float4_mt32 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt32 rem([This] float_mt32 a, float4_mt32 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt32 rem([This] float4_mt32 a, float_mt32 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt32 rem([This] float a, float4_mt32 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt32 rem([This] float4_mt32 a, float b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt32 frac([This] float4_mt32 a) => a - floor(a);

    [MethodImpl(256 | 512)]
    public static float4_mt32 modf([This] float4_mt32 d, out float4_mt32 i)
    {
        i = trunc(d);
        return d - i;
    }

    [MethodImpl(256 | 512)]
    public static float4_mt32 rcp([This] float4_mt32 a) => new(rcp(a.x), rcp(a.y), rcp(a.z), rcp(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt32 saturate([This] float4_mt32 a) => a.clamp(default, float4_mt32.One);

    [MethodImpl(256 | 512)]
    public static float4_mt32 smoothstep(float4_mt32 min, float4_mt32 max, [This] float4_mt32 a)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * fnma(2.0f, t, 3.0f); // (3.0f - (2.0f * t))
    }

    [MethodImpl(256 | 512)]
    public static float4_mt32 reflect([This] float4_mt32 i, float4_mt32 n)
    {
        // i - 2f * n * dot(i, n);
        return fnma(2f * n, dot(i, n), i);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt32 project([This] float4_mt32 a, float4_mt32 onto) =>
        dot(a, onto) / dot(onto, onto) * onto;

    [MethodImpl(256 | 512)]
    public static float4_mt32 projectOnPlane([This] float4_mt32 a, float4_mt32 plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static float4_mt32 projectNormalized([This] float4_mt32 a, float4_mt32 onto) =>
        dot(a, onto) * onto;

    [MethodImpl(256 | 512)]
    public static float4_mt32 projectOnPlaneNormalized([This] float4_mt32 a, float4_mt32 plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static float4_mt32 radians([This] float4_mt32 a) => a * 0.0174532925199432957692369076848861271344287188854172545609719144f;

    [MethodImpl(256 | 512)]
    public static float4_mt32 degrees([This] float4_mt32 a) => a * 57.295779513082320876798154814105170332405472466564321549160243861f;

    [MethodImpl(256 | 512)]
    public static float4_mt32 wrap([This] float4_mt32 x, float4_mt32 min, float4_mt32 max)
    {
        return new(wrap(x.x, min.x, max.x), wrap(x.y, min.y, max.y), wrap(x.z, min.z, max.z), wrap(x.w, min.w, max.w));
    }

    [MethodImpl(256 | 512)]
    public static float4_mt32 wrap([This] float4_mt32 x, float_mt32 min, float_mt32 max)
    {
        return new(wrap(x.x, min, max), wrap(x.y, min, max), wrap(x.z, min, max), wrap(x.w, min, max));
    }

    [MethodImpl(256 | 512)]
    public static float4_mt32 wrap([This] float4_mt32 x, float min, float max)
    {
        return new(wrap(x.x, min, max), wrap(x.y, min, max), wrap(x.z, min, max), wrap(x.w, min, max));
    }

    [MethodImpl(256 | 512)]
    public static float4_mt32 log([This] float4_mt32 a) => new(log(a.x), log(a.y), log(a.z), log(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt32 log2([This] float4_mt32 a) => new(log2(a.x), log2(a.y), log2(a.z), log2(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt32 log([This] float4_mt32 a, float4_mt32 b) => new(log(a.x, b.x), log(a.y, b.y), log(a.z, b.z), log(a.w, b.w));

    [MethodImpl(256 | 512)]
    public static float4_mt32 log([This] float4_mt32 a, float_mt32 b) => new(log(a.x, b), log(a.y, b), log(a.z, b), log(a.w, b));

    [MethodImpl(256 | 512)]
    public static float4_mt32 log([This] float_mt32 a, float4_mt32 b) => new(log(a, b.x), log(a, b.y), log(a, b.z), log(a, b.w));

    [MethodImpl(256 | 512)]
    public static float4_mt32 log10([This] float4_mt32 a) => new(log10(a.x), log10(a.y), log10(a.z), log10(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt32 exp([This] float4_mt32 a) => new(exp(a.x), exp(a.y), exp(a.z), exp(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt32 exp2([This] float4_mt32 a) => new(exp2(a.x), exp2(a.y), exp2(a.z), exp2(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt32 exp10([This] float4_mt32 a) => new(exp10(a.x), exp10(a.y), exp10(a.z), exp10(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt32 pow([This] float4_mt32 a, float4_mt32 b) => new(pow(a.x, b.x), pow(a.y, b.y), pow(a.z, b.z), pow(a.w, b.w));

    [MethodImpl(256 | 512)]
    public static float4_mt32 pow([This] float4_mt32 a, float_mt32 b) => new(pow(a.x, b), pow(a.y, b), pow(a.z, b), pow(a.w, b));

    [MethodImpl(256 | 512)]
    public static float4_mt32 pow([This] float4_mt32 a, float b) => new(pow(a.x, b), pow(a.y, b), pow(a.z, b), pow(a.w, b));

    [MethodImpl(256 | 512)]
    public static float4_mt32 sqrt([This] float4_mt32 a) => new(sqrt(a.x), sqrt(a.y), sqrt(a.z), sqrt(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt32 rsqrt([This] float4_mt32 a) => new(rsqrt(a.x), rsqrt(a.y), rsqrt(a.z), rsqrt(a.w));

    [MethodImpl(256 | 512)]
    public static float_mt32 length([This] float4_mt32 a) => dot(a, a).sqrt();

    [MethodImpl(256 | 512)]
    public static float_mt32 distance([This] float4_mt32 a, float4_mt32 b) => length(b - a);

    [MethodImpl(256 | 512)]
    public static float4_mt32 normalize([This] float4_mt32 a) => a * dot(a, a).rsqrt();
    
    // todo normalizeSafe step refract projectSafe faceForward

    [MethodImpl(256 | 512)]
    public static float4_mt32 sin([This] float4_mt32 a) => new(sin(a.x), sin(a.y), sin(a.z), sin(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt32 cos([This] float4_mt32 a) => new(cos(a.x), cos(a.y), cos(a.z), cos(a.w));

    [MethodImpl(256 | 512)]
    public static (float4_mt32 sin, float4_mt32 cos) sincos([This] float4_mt32 a)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        var (sin_z, cos_z) = sincos(a.z);
        var (sin_w, cos_w) = sincos(a.w);
        return (
            new(sin_x, sin_y, sin_z, sin_w),
            new(cos_x, cos_y, cos_z, cos_w)
        );
    }

    [MethodImpl(256 | 512)]
    public static void sincos([This] float4_mt32 a, out float4_mt32 sin, out float4_mt32 cos)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        var (sin_z, cos_z) = sincos(a.z);
        var (sin_w, cos_w) = sincos(a.w);
        sin = new(sin_x, sin_y, sin_z, sin_w);
        cos = new(cos_x, cos_y, cos_z, cos_w);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt32 tan([This] float4_mt32 a) => new(tan(a.x), tan(a.y), tan(a.z), tan(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt32 asin([This] float4_mt32 a) => new(asin(a.x), asin(a.y), asin(a.z), asin(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt32 acos([This] float4_mt32 a) => new(acos(a.x), acos(a.y), acos(a.z), acos(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt32 atan([This] float4_mt32 a) => new(atan(a.x), atan(a.y), atan(a.z), atan(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt32 atan2([This] float4_mt32 a, float4_mt32 b) => new(atan2(a.x, b.x), atan2(a.y, b.y), atan2(a.z, b.z), atan2(a.w, b.w));

    [MethodImpl(256 | 512)]
    public static float4_mt32 sinh([This] float4_mt32 a) => new(sinh(a.x), sinh(a.y), sinh(a.z), sinh(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt32 cosh([This] float4_mt32 a) => new(cosh(a.x), cosh(a.y), cosh(a.z), cosh(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt32 tanh([This] float4_mt32 a) => new(tanh(a.x), tanh(a.y), tanh(a.z), tanh(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt32 asinh([This] float4_mt32 a) => new(asinh(a.x), asinh(a.y), asinh(a.z), asinh(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt32 acosh([This] float4_mt32 a) => new(acosh(a.x), acosh(a.y), acosh(a.z), acosh(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt32 atanh([This] float4_mt32 a) => new(atanh(a.x), atanh(a.y), atanh(a.z), atanh(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt32 chgsign([This] float4_mt32 a, float4_mt32 b) => new(chgsign(a.x, b.x), chgsign(a.y, b.y), chgsign(a.z, b.z), chgsign(a.w, b.w));
}

#endregion // float4_mt32
#region double2_mt4

public partial struct double2_mt4
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static double2_mt4 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static double2_mt4 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static double2_mt4 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static double2_mt4 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static double2_mt4 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static double2_mt4 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static double2_mt4 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144);
    }
}

[Ex]
public static partial class math_mt
{
    #pragma warning disable CS1718
    // ReSharper disable once EqualExpressionComparison
    [MethodImpl(256 | 512)]
    public static b64v2_mt4 isNaN([This] double2_mt4 a) => a != a;
    #pragma warning restore CS1718

    [MethodImpl(256 | 512)]
    public static double2_mt4 ceil([This] double2_mt4 a) => new(a.x.floor(), a.y.floor());

    [MethodImpl(256 | 512)]
    public static double2_mt4 floor([This] double2_mt4 a) => new(a.x.floor(), a.y.floor());

    [MethodImpl(256 | 512)]
    public static double2_mt4 round([This] double2_mt4 a) => new(a.x.round(), a.y.round());

    [MethodImpl(256 | 512)]
    public static double2_mt4 trunc([This] double2_mt4 a) => new(a.x.trunc(), a.y.trunc());

    [MethodImpl(256 | 512)]
    public static double2_mt4 mod([This] double2_mt4 a, double2_mt4 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt4 mod([This] double_mt4 a, double2_mt4 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt4 mod([This] double2_mt4 a, double_mt4 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt4 mod([This] double a, double2_mt4 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt4 mod([This] double2_mt4 a, double b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt4 rem([This] double2_mt4 a, double2_mt4 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt4 rem([This] double_mt4 a, double2_mt4 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt4 rem([This] double2_mt4 a, double_mt4 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt4 rem([This] double a, double2_mt4 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt4 rem([This] double2_mt4 a, double b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt4 frac([This] double2_mt4 a) => a - floor(a);

    [MethodImpl(256 | 512)]
    public static double2_mt4 modf([This] double2_mt4 d, out double2_mt4 i)
    {
        i = trunc(d);
        return d - i;
    }

    [MethodImpl(256 | 512)]
    public static double2_mt4 rcp([This] double2_mt4 a) => new(rcp(a.x), rcp(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt4 saturate([This] double2_mt4 a) => a.clamp(default, double2_mt4.One);

    [MethodImpl(256 | 512)]
    public static double2_mt4 smoothstep(double2_mt4 min, double2_mt4 max, [This] double2_mt4 a)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * fnma(2.0, t, 3.0); // (3.0 - (2.0 * t))
    }

    [MethodImpl(256 | 512)]
    public static double2_mt4 reflect([This] double2_mt4 i, double2_mt4 n)
    {
        // i - 2 * n * dot(i, n);
        return fnma(2 * n, dot(i, n), i);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt4 project([This] double2_mt4 a, double2_mt4 onto) =>
        dot(a, onto) / dot(onto, onto) * onto;

    [MethodImpl(256 | 512)]
    public static double2_mt4 projectOnPlane([This] double2_mt4 a, double2_mt4 plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static double2_mt4 projectNormalized([This] double2_mt4 a, double2_mt4 onto) =>
        dot(a, onto) * onto;

    [MethodImpl(256 | 512)]
    public static double2_mt4 projectOnPlaneNormalized([This] double2_mt4 a, double2_mt4 plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static double2_mt4 radians([This] double2_mt4 a) => a * 0.0174532925199432957692369076848861271344287188854172545609719144;

    [MethodImpl(256 | 512)]
    public static double2_mt4 degrees([This] double2_mt4 a) => a * 57.295779513082320876798154814105170332405472466564321549160243861;

    [MethodImpl(256 | 512)]
    public static double2_mt4 wrap([This] double2_mt4 x, double2_mt4 min, double2_mt4 max)
    {
        return new(wrap(x.x, min.x, max.x), wrap(x.y, min.y, max.y));
    }

    [MethodImpl(256 | 512)]
    public static double2_mt4 wrap([This] double2_mt4 x, double_mt4 min, double_mt4 max)
    {
        return new(wrap(x.x, min, max), wrap(x.y, min, max));
    }

    [MethodImpl(256 | 512)]
    public static double2_mt4 wrap([This] double2_mt4 x, double min, double max)
    {
        return new(wrap(x.x, min, max), wrap(x.y, min, max));
    }

    [MethodImpl(256 | 512)]
    public static double2_mt4 log([This] double2_mt4 a) => new(log(a.x), log(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt4 log2([This] double2_mt4 a) => new(log2(a.x), log2(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt4 log([This] double2_mt4 a, double2_mt4 b) => new(log(a.x, b.x), log(a.y, b.y));

    [MethodImpl(256 | 512)]
    public static double2_mt4 log([This] double2_mt4 a, double_mt4 b) => new(log(a.x, b), log(a.y, b));

    [MethodImpl(256 | 512)]
    public static double2_mt4 log([This] double_mt4 a, double2_mt4 b) => new(log(a, b.x), log(a, b.y));

    [MethodImpl(256 | 512)]
    public static double2_mt4 log10([This] double2_mt4 a) => new(log10(a.x), log10(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt4 exp([This] double2_mt4 a) => new(exp(a.x), exp(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt4 exp2([This] double2_mt4 a) => new(exp2(a.x), exp2(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt4 exp10([This] double2_mt4 a) => new(exp10(a.x), exp10(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt4 pow([This] double2_mt4 a, double2_mt4 b) => new(pow(a.x, b.x), pow(a.y, b.y));

    [MethodImpl(256 | 512)]
    public static double2_mt4 pow([This] double2_mt4 a, double_mt4 b) => new(pow(a.x, b), pow(a.y, b));

    [MethodImpl(256 | 512)]
    public static double2_mt4 pow([This] double2_mt4 a, double b) => new(pow(a.x, b), pow(a.y, b));

    [MethodImpl(256 | 512)]
    public static double2_mt4 sqrt([This] double2_mt4 a) => new(sqrt(a.x), sqrt(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt4 rsqrt([This] double2_mt4 a) => new(rsqrt(a.x), rsqrt(a.y));

    [MethodImpl(256 | 512)]
    public static double_mt4 length([This] double2_mt4 a) => dot(a, a).sqrt();

    [MethodImpl(256 | 512)]
    public static double_mt4 distance([This] double2_mt4 a, double2_mt4 b) => length(b - a);

    [MethodImpl(256 | 512)]
    public static double2_mt4 normalize([This] double2_mt4 a) => a * dot(a, a).rsqrt();
    
    // todo normalizeSafe step refract projectSafe faceForward

    [MethodImpl(256 | 512)]
    public static double2_mt4 sin([This] double2_mt4 a) => new(sin(a.x), sin(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt4 cos([This] double2_mt4 a) => new(cos(a.x), cos(a.y));

    [MethodImpl(256 | 512)]
    public static (double2_mt4 sin, double2_mt4 cos) sincos([This] double2_mt4 a)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        return (
            new(sin_x, sin_y),
            new(cos_x, cos_y)
        );
    }

    [MethodImpl(256 | 512)]
    public static void sincos([This] double2_mt4 a, out double2_mt4 sin, out double2_mt4 cos)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        sin = new(sin_x, sin_y);
        cos = new(cos_x, cos_y);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt4 tan([This] double2_mt4 a) => new(tan(a.x), tan(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt4 asin([This] double2_mt4 a) => new(asin(a.x), asin(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt4 acos([This] double2_mt4 a) => new(acos(a.x), acos(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt4 atan([This] double2_mt4 a) => new(atan(a.x), atan(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt4 atan2([This] double2_mt4 a, double2_mt4 b) => new(atan2(a.x, b.x), atan2(a.y, b.y));

    [MethodImpl(256 | 512)]
    public static double2_mt4 sinh([This] double2_mt4 a) => new(sinh(a.x), sinh(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt4 cosh([This] double2_mt4 a) => new(cosh(a.x), cosh(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt4 tanh([This] double2_mt4 a) => new(tanh(a.x), tanh(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt4 asinh([This] double2_mt4 a) => new(asinh(a.x), asinh(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt4 acosh([This] double2_mt4 a) => new(acosh(a.x), acosh(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt4 atanh([This] double2_mt4 a) => new(atanh(a.x), atanh(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt4 chgsign([This] double2_mt4 a, double2_mt4 b) => new(chgsign(a.x, b.x), chgsign(a.y, b.y));
}

#endregion // double2_mt4
#region double2_mt8

public partial struct double2_mt8
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static double2_mt8 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static double2_mt8 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static double2_mt8 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static double2_mt8 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static double2_mt8 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static double2_mt8 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static double2_mt8 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144);
    }
}

[Ex]
public static partial class math_mt
{
    #pragma warning disable CS1718
    // ReSharper disable once EqualExpressionComparison
    [MethodImpl(256 | 512)]
    public static b64v2_mt8 isNaN([This] double2_mt8 a) => a != a;
    #pragma warning restore CS1718

    [MethodImpl(256 | 512)]
    public static double2_mt8 ceil([This] double2_mt8 a) => new(a.x.floor(), a.y.floor());

    [MethodImpl(256 | 512)]
    public static double2_mt8 floor([This] double2_mt8 a) => new(a.x.floor(), a.y.floor());

    [MethodImpl(256 | 512)]
    public static double2_mt8 round([This] double2_mt8 a) => new(a.x.round(), a.y.round());

    [MethodImpl(256 | 512)]
    public static double2_mt8 trunc([This] double2_mt8 a) => new(a.x.trunc(), a.y.trunc());

    [MethodImpl(256 | 512)]
    public static double2_mt8 mod([This] double2_mt8 a, double2_mt8 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt8 mod([This] double_mt8 a, double2_mt8 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt8 mod([This] double2_mt8 a, double_mt8 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt8 mod([This] double a, double2_mt8 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt8 mod([This] double2_mt8 a, double b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt8 rem([This] double2_mt8 a, double2_mt8 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt8 rem([This] double_mt8 a, double2_mt8 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt8 rem([This] double2_mt8 a, double_mt8 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt8 rem([This] double a, double2_mt8 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt8 rem([This] double2_mt8 a, double b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt8 frac([This] double2_mt8 a) => a - floor(a);

    [MethodImpl(256 | 512)]
    public static double2_mt8 modf([This] double2_mt8 d, out double2_mt8 i)
    {
        i = trunc(d);
        return d - i;
    }

    [MethodImpl(256 | 512)]
    public static double2_mt8 rcp([This] double2_mt8 a) => new(rcp(a.x), rcp(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt8 saturate([This] double2_mt8 a) => a.clamp(default, double2_mt8.One);

    [MethodImpl(256 | 512)]
    public static double2_mt8 smoothstep(double2_mt8 min, double2_mt8 max, [This] double2_mt8 a)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * fnma(2.0, t, 3.0); // (3.0 - (2.0 * t))
    }

    [MethodImpl(256 | 512)]
    public static double2_mt8 reflect([This] double2_mt8 i, double2_mt8 n)
    {
        // i - 2 * n * dot(i, n);
        return fnma(2 * n, dot(i, n), i);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt8 project([This] double2_mt8 a, double2_mt8 onto) =>
        dot(a, onto) / dot(onto, onto) * onto;

    [MethodImpl(256 | 512)]
    public static double2_mt8 projectOnPlane([This] double2_mt8 a, double2_mt8 plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static double2_mt8 projectNormalized([This] double2_mt8 a, double2_mt8 onto) =>
        dot(a, onto) * onto;

    [MethodImpl(256 | 512)]
    public static double2_mt8 projectOnPlaneNormalized([This] double2_mt8 a, double2_mt8 plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static double2_mt8 radians([This] double2_mt8 a) => a * 0.0174532925199432957692369076848861271344287188854172545609719144;

    [MethodImpl(256 | 512)]
    public static double2_mt8 degrees([This] double2_mt8 a) => a * 57.295779513082320876798154814105170332405472466564321549160243861;

    [MethodImpl(256 | 512)]
    public static double2_mt8 wrap([This] double2_mt8 x, double2_mt8 min, double2_mt8 max)
    {
        return new(wrap(x.x, min.x, max.x), wrap(x.y, min.y, max.y));
    }

    [MethodImpl(256 | 512)]
    public static double2_mt8 wrap([This] double2_mt8 x, double_mt8 min, double_mt8 max)
    {
        return new(wrap(x.x, min, max), wrap(x.y, min, max));
    }

    [MethodImpl(256 | 512)]
    public static double2_mt8 wrap([This] double2_mt8 x, double min, double max)
    {
        return new(wrap(x.x, min, max), wrap(x.y, min, max));
    }

    [MethodImpl(256 | 512)]
    public static double2_mt8 log([This] double2_mt8 a) => new(log(a.x), log(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt8 log2([This] double2_mt8 a) => new(log2(a.x), log2(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt8 log([This] double2_mt8 a, double2_mt8 b) => new(log(a.x, b.x), log(a.y, b.y));

    [MethodImpl(256 | 512)]
    public static double2_mt8 log([This] double2_mt8 a, double_mt8 b) => new(log(a.x, b), log(a.y, b));

    [MethodImpl(256 | 512)]
    public static double2_mt8 log([This] double_mt8 a, double2_mt8 b) => new(log(a, b.x), log(a, b.y));

    [MethodImpl(256 | 512)]
    public static double2_mt8 log10([This] double2_mt8 a) => new(log10(a.x), log10(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt8 exp([This] double2_mt8 a) => new(exp(a.x), exp(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt8 exp2([This] double2_mt8 a) => new(exp2(a.x), exp2(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt8 exp10([This] double2_mt8 a) => new(exp10(a.x), exp10(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt8 pow([This] double2_mt8 a, double2_mt8 b) => new(pow(a.x, b.x), pow(a.y, b.y));

    [MethodImpl(256 | 512)]
    public static double2_mt8 pow([This] double2_mt8 a, double_mt8 b) => new(pow(a.x, b), pow(a.y, b));

    [MethodImpl(256 | 512)]
    public static double2_mt8 pow([This] double2_mt8 a, double b) => new(pow(a.x, b), pow(a.y, b));

    [MethodImpl(256 | 512)]
    public static double2_mt8 sqrt([This] double2_mt8 a) => new(sqrt(a.x), sqrt(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt8 rsqrt([This] double2_mt8 a) => new(rsqrt(a.x), rsqrt(a.y));

    [MethodImpl(256 | 512)]
    public static double_mt8 length([This] double2_mt8 a) => dot(a, a).sqrt();

    [MethodImpl(256 | 512)]
    public static double_mt8 distance([This] double2_mt8 a, double2_mt8 b) => length(b - a);

    [MethodImpl(256 | 512)]
    public static double2_mt8 normalize([This] double2_mt8 a) => a * dot(a, a).rsqrt();
    
    // todo normalizeSafe step refract projectSafe faceForward

    [MethodImpl(256 | 512)]
    public static double2_mt8 sin([This] double2_mt8 a) => new(sin(a.x), sin(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt8 cos([This] double2_mt8 a) => new(cos(a.x), cos(a.y));

    [MethodImpl(256 | 512)]
    public static (double2_mt8 sin, double2_mt8 cos) sincos([This] double2_mt8 a)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        return (
            new(sin_x, sin_y),
            new(cos_x, cos_y)
        );
    }

    [MethodImpl(256 | 512)]
    public static void sincos([This] double2_mt8 a, out double2_mt8 sin, out double2_mt8 cos)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        sin = new(sin_x, sin_y);
        cos = new(cos_x, cos_y);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt8 tan([This] double2_mt8 a) => new(tan(a.x), tan(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt8 asin([This] double2_mt8 a) => new(asin(a.x), asin(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt8 acos([This] double2_mt8 a) => new(acos(a.x), acos(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt8 atan([This] double2_mt8 a) => new(atan(a.x), atan(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt8 atan2([This] double2_mt8 a, double2_mt8 b) => new(atan2(a.x, b.x), atan2(a.y, b.y));

    [MethodImpl(256 | 512)]
    public static double2_mt8 sinh([This] double2_mt8 a) => new(sinh(a.x), sinh(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt8 cosh([This] double2_mt8 a) => new(cosh(a.x), cosh(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt8 tanh([This] double2_mt8 a) => new(tanh(a.x), tanh(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt8 asinh([This] double2_mt8 a) => new(asinh(a.x), asinh(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt8 acosh([This] double2_mt8 a) => new(acosh(a.x), acosh(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt8 atanh([This] double2_mt8 a) => new(atanh(a.x), atanh(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt8 chgsign([This] double2_mt8 a, double2_mt8 b) => new(chgsign(a.x, b.x), chgsign(a.y, b.y));
}

#endregion // double2_mt8
#region double2_mt16

public partial struct double2_mt16
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static double2_mt16 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static double2_mt16 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static double2_mt16 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static double2_mt16 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static double2_mt16 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static double2_mt16 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static double2_mt16 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144);
    }
}

[Ex]
public static partial class math_mt
{
    #pragma warning disable CS1718
    // ReSharper disable once EqualExpressionComparison
    [MethodImpl(256 | 512)]
    public static b64v2_mt16 isNaN([This] double2_mt16 a) => a != a;
    #pragma warning restore CS1718

    [MethodImpl(256 | 512)]
    public static double2_mt16 ceil([This] double2_mt16 a) => new(a.x.floor(), a.y.floor());

    [MethodImpl(256 | 512)]
    public static double2_mt16 floor([This] double2_mt16 a) => new(a.x.floor(), a.y.floor());

    [MethodImpl(256 | 512)]
    public static double2_mt16 round([This] double2_mt16 a) => new(a.x.round(), a.y.round());

    [MethodImpl(256 | 512)]
    public static double2_mt16 trunc([This] double2_mt16 a) => new(a.x.trunc(), a.y.trunc());

    [MethodImpl(256 | 512)]
    public static double2_mt16 mod([This] double2_mt16 a, double2_mt16 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt16 mod([This] double_mt16 a, double2_mt16 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt16 mod([This] double2_mt16 a, double_mt16 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt16 mod([This] double a, double2_mt16 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt16 mod([This] double2_mt16 a, double b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt16 rem([This] double2_mt16 a, double2_mt16 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt16 rem([This] double_mt16 a, double2_mt16 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt16 rem([This] double2_mt16 a, double_mt16 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt16 rem([This] double a, double2_mt16 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt16 rem([This] double2_mt16 a, double b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt16 frac([This] double2_mt16 a) => a - floor(a);

    [MethodImpl(256 | 512)]
    public static double2_mt16 modf([This] double2_mt16 d, out double2_mt16 i)
    {
        i = trunc(d);
        return d - i;
    }

    [MethodImpl(256 | 512)]
    public static double2_mt16 rcp([This] double2_mt16 a) => new(rcp(a.x), rcp(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt16 saturate([This] double2_mt16 a) => a.clamp(default, double2_mt16.One);

    [MethodImpl(256 | 512)]
    public static double2_mt16 smoothstep(double2_mt16 min, double2_mt16 max, [This] double2_mt16 a)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * fnma(2.0, t, 3.0); // (3.0 - (2.0 * t))
    }

    [MethodImpl(256 | 512)]
    public static double2_mt16 reflect([This] double2_mt16 i, double2_mt16 n)
    {
        // i - 2 * n * dot(i, n);
        return fnma(2 * n, dot(i, n), i);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt16 project([This] double2_mt16 a, double2_mt16 onto) =>
        dot(a, onto) / dot(onto, onto) * onto;

    [MethodImpl(256 | 512)]
    public static double2_mt16 projectOnPlane([This] double2_mt16 a, double2_mt16 plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static double2_mt16 projectNormalized([This] double2_mt16 a, double2_mt16 onto) =>
        dot(a, onto) * onto;

    [MethodImpl(256 | 512)]
    public static double2_mt16 projectOnPlaneNormalized([This] double2_mt16 a, double2_mt16 plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static double2_mt16 radians([This] double2_mt16 a) => a * 0.0174532925199432957692369076848861271344287188854172545609719144;

    [MethodImpl(256 | 512)]
    public static double2_mt16 degrees([This] double2_mt16 a) => a * 57.295779513082320876798154814105170332405472466564321549160243861;

    [MethodImpl(256 | 512)]
    public static double2_mt16 wrap([This] double2_mt16 x, double2_mt16 min, double2_mt16 max)
    {
        return new(wrap(x.x, min.x, max.x), wrap(x.y, min.y, max.y));
    }

    [MethodImpl(256 | 512)]
    public static double2_mt16 wrap([This] double2_mt16 x, double_mt16 min, double_mt16 max)
    {
        return new(wrap(x.x, min, max), wrap(x.y, min, max));
    }

    [MethodImpl(256 | 512)]
    public static double2_mt16 wrap([This] double2_mt16 x, double min, double max)
    {
        return new(wrap(x.x, min, max), wrap(x.y, min, max));
    }

    [MethodImpl(256 | 512)]
    public static double2_mt16 log([This] double2_mt16 a) => new(log(a.x), log(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt16 log2([This] double2_mt16 a) => new(log2(a.x), log2(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt16 log([This] double2_mt16 a, double2_mt16 b) => new(log(a.x, b.x), log(a.y, b.y));

    [MethodImpl(256 | 512)]
    public static double2_mt16 log([This] double2_mt16 a, double_mt16 b) => new(log(a.x, b), log(a.y, b));

    [MethodImpl(256 | 512)]
    public static double2_mt16 log([This] double_mt16 a, double2_mt16 b) => new(log(a, b.x), log(a, b.y));

    [MethodImpl(256 | 512)]
    public static double2_mt16 log10([This] double2_mt16 a) => new(log10(a.x), log10(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt16 exp([This] double2_mt16 a) => new(exp(a.x), exp(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt16 exp2([This] double2_mt16 a) => new(exp2(a.x), exp2(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt16 exp10([This] double2_mt16 a) => new(exp10(a.x), exp10(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt16 pow([This] double2_mt16 a, double2_mt16 b) => new(pow(a.x, b.x), pow(a.y, b.y));

    [MethodImpl(256 | 512)]
    public static double2_mt16 pow([This] double2_mt16 a, double_mt16 b) => new(pow(a.x, b), pow(a.y, b));

    [MethodImpl(256 | 512)]
    public static double2_mt16 pow([This] double2_mt16 a, double b) => new(pow(a.x, b), pow(a.y, b));

    [MethodImpl(256 | 512)]
    public static double2_mt16 sqrt([This] double2_mt16 a) => new(sqrt(a.x), sqrt(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt16 rsqrt([This] double2_mt16 a) => new(rsqrt(a.x), rsqrt(a.y));

    [MethodImpl(256 | 512)]
    public static double_mt16 length([This] double2_mt16 a) => dot(a, a).sqrt();

    [MethodImpl(256 | 512)]
    public static double_mt16 distance([This] double2_mt16 a, double2_mt16 b) => length(b - a);

    [MethodImpl(256 | 512)]
    public static double2_mt16 normalize([This] double2_mt16 a) => a * dot(a, a).rsqrt();
    
    // todo normalizeSafe step refract projectSafe faceForward

    [MethodImpl(256 | 512)]
    public static double2_mt16 sin([This] double2_mt16 a) => new(sin(a.x), sin(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt16 cos([This] double2_mt16 a) => new(cos(a.x), cos(a.y));

    [MethodImpl(256 | 512)]
    public static (double2_mt16 sin, double2_mt16 cos) sincos([This] double2_mt16 a)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        return (
            new(sin_x, sin_y),
            new(cos_x, cos_y)
        );
    }

    [MethodImpl(256 | 512)]
    public static void sincos([This] double2_mt16 a, out double2_mt16 sin, out double2_mt16 cos)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        sin = new(sin_x, sin_y);
        cos = new(cos_x, cos_y);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt16 tan([This] double2_mt16 a) => new(tan(a.x), tan(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt16 asin([This] double2_mt16 a) => new(asin(a.x), asin(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt16 acos([This] double2_mt16 a) => new(acos(a.x), acos(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt16 atan([This] double2_mt16 a) => new(atan(a.x), atan(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt16 atan2([This] double2_mt16 a, double2_mt16 b) => new(atan2(a.x, b.x), atan2(a.y, b.y));

    [MethodImpl(256 | 512)]
    public static double2_mt16 sinh([This] double2_mt16 a) => new(sinh(a.x), sinh(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt16 cosh([This] double2_mt16 a) => new(cosh(a.x), cosh(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt16 tanh([This] double2_mt16 a) => new(tanh(a.x), tanh(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt16 asinh([This] double2_mt16 a) => new(asinh(a.x), asinh(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt16 acosh([This] double2_mt16 a) => new(acosh(a.x), acosh(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt16 atanh([This] double2_mt16 a) => new(atanh(a.x), atanh(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt16 chgsign([This] double2_mt16 a, double2_mt16 b) => new(chgsign(a.x, b.x), chgsign(a.y, b.y));
}

#endregion // double2_mt16
#region double2_mt32

public partial struct double2_mt32
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static double2_mt32 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static double2_mt32 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static double2_mt32 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static double2_mt32 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static double2_mt32 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static double2_mt32 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static double2_mt32 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144);
    }
}

[Ex]
public static partial class math_mt
{
    #pragma warning disable CS1718
    // ReSharper disable once EqualExpressionComparison
    [MethodImpl(256 | 512)]
    public static b64v2_mt32 isNaN([This] double2_mt32 a) => a != a;
    #pragma warning restore CS1718

    [MethodImpl(256 | 512)]
    public static double2_mt32 ceil([This] double2_mt32 a) => new(a.x.floor(), a.y.floor());

    [MethodImpl(256 | 512)]
    public static double2_mt32 floor([This] double2_mt32 a) => new(a.x.floor(), a.y.floor());

    [MethodImpl(256 | 512)]
    public static double2_mt32 round([This] double2_mt32 a) => new(a.x.round(), a.y.round());

    [MethodImpl(256 | 512)]
    public static double2_mt32 trunc([This] double2_mt32 a) => new(a.x.trunc(), a.y.trunc());

    [MethodImpl(256 | 512)]
    public static double2_mt32 mod([This] double2_mt32 a, double2_mt32 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt32 mod([This] double_mt32 a, double2_mt32 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt32 mod([This] double2_mt32 a, double_mt32 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt32 mod([This] double a, double2_mt32 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt32 mod([This] double2_mt32 a, double b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt32 rem([This] double2_mt32 a, double2_mt32 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt32 rem([This] double_mt32 a, double2_mt32 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt32 rem([This] double2_mt32 a, double_mt32 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt32 rem([This] double a, double2_mt32 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt32 rem([This] double2_mt32 a, double b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt32 frac([This] double2_mt32 a) => a - floor(a);

    [MethodImpl(256 | 512)]
    public static double2_mt32 modf([This] double2_mt32 d, out double2_mt32 i)
    {
        i = trunc(d);
        return d - i;
    }

    [MethodImpl(256 | 512)]
    public static double2_mt32 rcp([This] double2_mt32 a) => new(rcp(a.x), rcp(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt32 saturate([This] double2_mt32 a) => a.clamp(default, double2_mt32.One);

    [MethodImpl(256 | 512)]
    public static double2_mt32 smoothstep(double2_mt32 min, double2_mt32 max, [This] double2_mt32 a)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * fnma(2.0, t, 3.0); // (3.0 - (2.0 * t))
    }

    [MethodImpl(256 | 512)]
    public static double2_mt32 reflect([This] double2_mt32 i, double2_mt32 n)
    {
        // i - 2 * n * dot(i, n);
        return fnma(2 * n, dot(i, n), i);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt32 project([This] double2_mt32 a, double2_mt32 onto) =>
        dot(a, onto) / dot(onto, onto) * onto;

    [MethodImpl(256 | 512)]
    public static double2_mt32 projectOnPlane([This] double2_mt32 a, double2_mt32 plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static double2_mt32 projectNormalized([This] double2_mt32 a, double2_mt32 onto) =>
        dot(a, onto) * onto;

    [MethodImpl(256 | 512)]
    public static double2_mt32 projectOnPlaneNormalized([This] double2_mt32 a, double2_mt32 plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static double2_mt32 radians([This] double2_mt32 a) => a * 0.0174532925199432957692369076848861271344287188854172545609719144;

    [MethodImpl(256 | 512)]
    public static double2_mt32 degrees([This] double2_mt32 a) => a * 57.295779513082320876798154814105170332405472466564321549160243861;

    [MethodImpl(256 | 512)]
    public static double2_mt32 wrap([This] double2_mt32 x, double2_mt32 min, double2_mt32 max)
    {
        return new(wrap(x.x, min.x, max.x), wrap(x.y, min.y, max.y));
    }

    [MethodImpl(256 | 512)]
    public static double2_mt32 wrap([This] double2_mt32 x, double_mt32 min, double_mt32 max)
    {
        return new(wrap(x.x, min, max), wrap(x.y, min, max));
    }

    [MethodImpl(256 | 512)]
    public static double2_mt32 wrap([This] double2_mt32 x, double min, double max)
    {
        return new(wrap(x.x, min, max), wrap(x.y, min, max));
    }

    [MethodImpl(256 | 512)]
    public static double2_mt32 log([This] double2_mt32 a) => new(log(a.x), log(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt32 log2([This] double2_mt32 a) => new(log2(a.x), log2(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt32 log([This] double2_mt32 a, double2_mt32 b) => new(log(a.x, b.x), log(a.y, b.y));

    [MethodImpl(256 | 512)]
    public static double2_mt32 log([This] double2_mt32 a, double_mt32 b) => new(log(a.x, b), log(a.y, b));

    [MethodImpl(256 | 512)]
    public static double2_mt32 log([This] double_mt32 a, double2_mt32 b) => new(log(a, b.x), log(a, b.y));

    [MethodImpl(256 | 512)]
    public static double2_mt32 log10([This] double2_mt32 a) => new(log10(a.x), log10(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt32 exp([This] double2_mt32 a) => new(exp(a.x), exp(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt32 exp2([This] double2_mt32 a) => new(exp2(a.x), exp2(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt32 exp10([This] double2_mt32 a) => new(exp10(a.x), exp10(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt32 pow([This] double2_mt32 a, double2_mt32 b) => new(pow(a.x, b.x), pow(a.y, b.y));

    [MethodImpl(256 | 512)]
    public static double2_mt32 pow([This] double2_mt32 a, double_mt32 b) => new(pow(a.x, b), pow(a.y, b));

    [MethodImpl(256 | 512)]
    public static double2_mt32 pow([This] double2_mt32 a, double b) => new(pow(a.x, b), pow(a.y, b));

    [MethodImpl(256 | 512)]
    public static double2_mt32 sqrt([This] double2_mt32 a) => new(sqrt(a.x), sqrt(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt32 rsqrt([This] double2_mt32 a) => new(rsqrt(a.x), rsqrt(a.y));

    [MethodImpl(256 | 512)]
    public static double_mt32 length([This] double2_mt32 a) => dot(a, a).sqrt();

    [MethodImpl(256 | 512)]
    public static double_mt32 distance([This] double2_mt32 a, double2_mt32 b) => length(b - a);

    [MethodImpl(256 | 512)]
    public static double2_mt32 normalize([This] double2_mt32 a) => a * dot(a, a).rsqrt();
    
    // todo normalizeSafe step refract projectSafe faceForward

    [MethodImpl(256 | 512)]
    public static double2_mt32 sin([This] double2_mt32 a) => new(sin(a.x), sin(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt32 cos([This] double2_mt32 a) => new(cos(a.x), cos(a.y));

    [MethodImpl(256 | 512)]
    public static (double2_mt32 sin, double2_mt32 cos) sincos([This] double2_mt32 a)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        return (
            new(sin_x, sin_y),
            new(cos_x, cos_y)
        );
    }

    [MethodImpl(256 | 512)]
    public static void sincos([This] double2_mt32 a, out double2_mt32 sin, out double2_mt32 cos)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        sin = new(sin_x, sin_y);
        cos = new(cos_x, cos_y);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt32 tan([This] double2_mt32 a) => new(tan(a.x), tan(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt32 asin([This] double2_mt32 a) => new(asin(a.x), asin(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt32 acos([This] double2_mt32 a) => new(acos(a.x), acos(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt32 atan([This] double2_mt32 a) => new(atan(a.x), atan(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt32 atan2([This] double2_mt32 a, double2_mt32 b) => new(atan2(a.x, b.x), atan2(a.y, b.y));

    [MethodImpl(256 | 512)]
    public static double2_mt32 sinh([This] double2_mt32 a) => new(sinh(a.x), sinh(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt32 cosh([This] double2_mt32 a) => new(cosh(a.x), cosh(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt32 tanh([This] double2_mt32 a) => new(tanh(a.x), tanh(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt32 asinh([This] double2_mt32 a) => new(asinh(a.x), asinh(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt32 acosh([This] double2_mt32 a) => new(acosh(a.x), acosh(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt32 atanh([This] double2_mt32 a) => new(atanh(a.x), atanh(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt32 chgsign([This] double2_mt32 a, double2_mt32 b) => new(chgsign(a.x, b.x), chgsign(a.y, b.y));
}

#endregion // double2_mt32
#region double3_mt4

public partial struct double3_mt4
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static double3_mt4 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static double3_mt4 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static double3_mt4 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static double3_mt4 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static double3_mt4 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static double3_mt4 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static double3_mt4 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144);
    }
}

[Ex]
public static partial class math_mt
{
    #pragma warning disable CS1718
    // ReSharper disable once EqualExpressionComparison
    [MethodImpl(256 | 512)]
    public static b64v3_mt4 isNaN([This] double3_mt4 a) => a != a;
    #pragma warning restore CS1718

    [MethodImpl(256 | 512)]
    public static double3_mt4 ceil([This] double3_mt4 a) => new(a.x.floor(), a.y.floor(), a.z.floor());

    [MethodImpl(256 | 512)]
    public static double3_mt4 floor([This] double3_mt4 a) => new(a.x.floor(), a.y.floor(), a.z.floor());

    [MethodImpl(256 | 512)]
    public static double3_mt4 round([This] double3_mt4 a) => new(a.x.round(), a.y.round(), a.z.round());

    [MethodImpl(256 | 512)]
    public static double3_mt4 trunc([This] double3_mt4 a) => new(a.x.trunc(), a.y.trunc(), a.z.trunc());

    [MethodImpl(256 | 512)]
    public static double3_mt4 mod([This] double3_mt4 a, double3_mt4 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt4 mod([This] double_mt4 a, double3_mt4 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt4 mod([This] double3_mt4 a, double_mt4 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt4 mod([This] double a, double3_mt4 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt4 mod([This] double3_mt4 a, double b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt4 rem([This] double3_mt4 a, double3_mt4 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt4 rem([This] double_mt4 a, double3_mt4 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt4 rem([This] double3_mt4 a, double_mt4 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt4 rem([This] double a, double3_mt4 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt4 rem([This] double3_mt4 a, double b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt4 frac([This] double3_mt4 a) => a - floor(a);

    [MethodImpl(256 | 512)]
    public static double3_mt4 modf([This] double3_mt4 d, out double3_mt4 i)
    {
        i = trunc(d);
        return d - i;
    }

    [MethodImpl(256 | 512)]
    public static double3_mt4 rcp([This] double3_mt4 a) => new(rcp(a.x), rcp(a.y), rcp(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt4 saturate([This] double3_mt4 a) => a.clamp(default, double3_mt4.One);

    [MethodImpl(256 | 512)]
    public static double3_mt4 smoothstep(double3_mt4 min, double3_mt4 max, [This] double3_mt4 a)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * fnma(2.0, t, 3.0); // (3.0 - (2.0 * t))
    }

    [MethodImpl(256 | 512)]
    public static double3_mt4 reflect([This] double3_mt4 i, double3_mt4 n)
    {
        // i - 2 * n * dot(i, n);
        return fnma(2 * n, dot(i, n), i);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt4 project([This] double3_mt4 a, double3_mt4 onto) =>
        dot(a, onto) / dot(onto, onto) * onto;

    [MethodImpl(256 | 512)]
    public static double3_mt4 projectOnPlane([This] double3_mt4 a, double3_mt4 plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static double3_mt4 projectNormalized([This] double3_mt4 a, double3_mt4 onto) =>
        dot(a, onto) * onto;

    [MethodImpl(256 | 512)]
    public static double3_mt4 projectOnPlaneNormalized([This] double3_mt4 a, double3_mt4 plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static double3_mt4 radians([This] double3_mt4 a) => a * 0.0174532925199432957692369076848861271344287188854172545609719144;

    [MethodImpl(256 | 512)]
    public static double3_mt4 degrees([This] double3_mt4 a) => a * 57.295779513082320876798154814105170332405472466564321549160243861;

    [MethodImpl(256 | 512)]
    public static double3_mt4 wrap([This] double3_mt4 x, double3_mt4 min, double3_mt4 max)
    {
        return new(wrap(x.x, min.x, max.x), wrap(x.y, min.y, max.y), wrap(x.z, min.z, max.z));
    }

    [MethodImpl(256 | 512)]
    public static double3_mt4 wrap([This] double3_mt4 x, double_mt4 min, double_mt4 max)
    {
        return new(wrap(x.x, min, max), wrap(x.y, min, max), wrap(x.z, min, max));
    }

    [MethodImpl(256 | 512)]
    public static double3_mt4 wrap([This] double3_mt4 x, double min, double max)
    {
        return new(wrap(x.x, min, max), wrap(x.y, min, max), wrap(x.z, min, max));
    }

    [MethodImpl(256 | 512)]
    public static double3_mt4 log([This] double3_mt4 a) => new(log(a.x), log(a.y), log(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt4 log2([This] double3_mt4 a) => new(log2(a.x), log2(a.y), log2(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt4 log([This] double3_mt4 a, double3_mt4 b) => new(log(a.x, b.x), log(a.y, b.y), log(a.z, b.z));

    [MethodImpl(256 | 512)]
    public static double3_mt4 log([This] double3_mt4 a, double_mt4 b) => new(log(a.x, b), log(a.y, b), log(a.z, b));

    [MethodImpl(256 | 512)]
    public static double3_mt4 log([This] double_mt4 a, double3_mt4 b) => new(log(a, b.x), log(a, b.y), log(a, b.z));

    [MethodImpl(256 | 512)]
    public static double3_mt4 log10([This] double3_mt4 a) => new(log10(a.x), log10(a.y), log10(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt4 exp([This] double3_mt4 a) => new(exp(a.x), exp(a.y), exp(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt4 exp2([This] double3_mt4 a) => new(exp2(a.x), exp2(a.y), exp2(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt4 exp10([This] double3_mt4 a) => new(exp10(a.x), exp10(a.y), exp10(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt4 pow([This] double3_mt4 a, double3_mt4 b) => new(pow(a.x, b.x), pow(a.y, b.y), pow(a.z, b.z));

    [MethodImpl(256 | 512)]
    public static double3_mt4 pow([This] double3_mt4 a, double_mt4 b) => new(pow(a.x, b), pow(a.y, b), pow(a.z, b));

    [MethodImpl(256 | 512)]
    public static double3_mt4 pow([This] double3_mt4 a, double b) => new(pow(a.x, b), pow(a.y, b), pow(a.z, b));

    [MethodImpl(256 | 512)]
    public static double3_mt4 sqrt([This] double3_mt4 a) => new(sqrt(a.x), sqrt(a.y), sqrt(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt4 rsqrt([This] double3_mt4 a) => new(rsqrt(a.x), rsqrt(a.y), rsqrt(a.z));

    [MethodImpl(256 | 512)]
    public static double_mt4 length([This] double3_mt4 a) => dot(a, a).sqrt();

    [MethodImpl(256 | 512)]
    public static double_mt4 distance([This] double3_mt4 a, double3_mt4 b) => length(b - a);

    [MethodImpl(256 | 512)]
    public static double3_mt4 normalize([This] double3_mt4 a) => a * dot(a, a).rsqrt();
    
    // todo normalizeSafe step refract projectSafe faceForward

    [MethodImpl(256 | 512)]
    public static double3_mt4 sin([This] double3_mt4 a) => new(sin(a.x), sin(a.y), sin(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt4 cos([This] double3_mt4 a) => new(cos(a.x), cos(a.y), cos(a.z));

    [MethodImpl(256 | 512)]
    public static (double3_mt4 sin, double3_mt4 cos) sincos([This] double3_mt4 a)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        var (sin_z, cos_z) = sincos(a.z);
        return (
            new(sin_x, sin_y, sin_z),
            new(cos_x, cos_y, cos_z)
        );
    }

    [MethodImpl(256 | 512)]
    public static void sincos([This] double3_mt4 a, out double3_mt4 sin, out double3_mt4 cos)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        var (sin_z, cos_z) = sincos(a.z);
        sin = new(sin_x, sin_y, sin_z);
        cos = new(cos_x, cos_y, cos_z);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt4 tan([This] double3_mt4 a) => new(tan(a.x), tan(a.y), tan(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt4 asin([This] double3_mt4 a) => new(asin(a.x), asin(a.y), asin(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt4 acos([This] double3_mt4 a) => new(acos(a.x), acos(a.y), acos(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt4 atan([This] double3_mt4 a) => new(atan(a.x), atan(a.y), atan(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt4 atan2([This] double3_mt4 a, double3_mt4 b) => new(atan2(a.x, b.x), atan2(a.y, b.y), atan2(a.z, b.z));

    [MethodImpl(256 | 512)]
    public static double3_mt4 sinh([This] double3_mt4 a) => new(sinh(a.x), sinh(a.y), sinh(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt4 cosh([This] double3_mt4 a) => new(cosh(a.x), cosh(a.y), cosh(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt4 tanh([This] double3_mt4 a) => new(tanh(a.x), tanh(a.y), tanh(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt4 asinh([This] double3_mt4 a) => new(asinh(a.x), asinh(a.y), asinh(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt4 acosh([This] double3_mt4 a) => new(acosh(a.x), acosh(a.y), acosh(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt4 atanh([This] double3_mt4 a) => new(atanh(a.x), atanh(a.y), atanh(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt4 chgsign([This] double3_mt4 a, double3_mt4 b) => new(chgsign(a.x, b.x), chgsign(a.y, b.y), chgsign(a.z, b.z));
}

#endregion // double3_mt4
#region double3_mt8

public partial struct double3_mt8
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static double3_mt8 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static double3_mt8 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static double3_mt8 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static double3_mt8 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static double3_mt8 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static double3_mt8 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static double3_mt8 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144);
    }
}

[Ex]
public static partial class math_mt
{
    #pragma warning disable CS1718
    // ReSharper disable once EqualExpressionComparison
    [MethodImpl(256 | 512)]
    public static b64v3_mt8 isNaN([This] double3_mt8 a) => a != a;
    #pragma warning restore CS1718

    [MethodImpl(256 | 512)]
    public static double3_mt8 ceil([This] double3_mt8 a) => new(a.x.floor(), a.y.floor(), a.z.floor());

    [MethodImpl(256 | 512)]
    public static double3_mt8 floor([This] double3_mt8 a) => new(a.x.floor(), a.y.floor(), a.z.floor());

    [MethodImpl(256 | 512)]
    public static double3_mt8 round([This] double3_mt8 a) => new(a.x.round(), a.y.round(), a.z.round());

    [MethodImpl(256 | 512)]
    public static double3_mt8 trunc([This] double3_mt8 a) => new(a.x.trunc(), a.y.trunc(), a.z.trunc());

    [MethodImpl(256 | 512)]
    public static double3_mt8 mod([This] double3_mt8 a, double3_mt8 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt8 mod([This] double_mt8 a, double3_mt8 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt8 mod([This] double3_mt8 a, double_mt8 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt8 mod([This] double a, double3_mt8 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt8 mod([This] double3_mt8 a, double b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt8 rem([This] double3_mt8 a, double3_mt8 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt8 rem([This] double_mt8 a, double3_mt8 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt8 rem([This] double3_mt8 a, double_mt8 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt8 rem([This] double a, double3_mt8 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt8 rem([This] double3_mt8 a, double b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt8 frac([This] double3_mt8 a) => a - floor(a);

    [MethodImpl(256 | 512)]
    public static double3_mt8 modf([This] double3_mt8 d, out double3_mt8 i)
    {
        i = trunc(d);
        return d - i;
    }

    [MethodImpl(256 | 512)]
    public static double3_mt8 rcp([This] double3_mt8 a) => new(rcp(a.x), rcp(a.y), rcp(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt8 saturate([This] double3_mt8 a) => a.clamp(default, double3_mt8.One);

    [MethodImpl(256 | 512)]
    public static double3_mt8 smoothstep(double3_mt8 min, double3_mt8 max, [This] double3_mt8 a)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * fnma(2.0, t, 3.0); // (3.0 - (2.0 * t))
    }

    [MethodImpl(256 | 512)]
    public static double3_mt8 reflect([This] double3_mt8 i, double3_mt8 n)
    {
        // i - 2 * n * dot(i, n);
        return fnma(2 * n, dot(i, n), i);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt8 project([This] double3_mt8 a, double3_mt8 onto) =>
        dot(a, onto) / dot(onto, onto) * onto;

    [MethodImpl(256 | 512)]
    public static double3_mt8 projectOnPlane([This] double3_mt8 a, double3_mt8 plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static double3_mt8 projectNormalized([This] double3_mt8 a, double3_mt8 onto) =>
        dot(a, onto) * onto;

    [MethodImpl(256 | 512)]
    public static double3_mt8 projectOnPlaneNormalized([This] double3_mt8 a, double3_mt8 plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static double3_mt8 radians([This] double3_mt8 a) => a * 0.0174532925199432957692369076848861271344287188854172545609719144;

    [MethodImpl(256 | 512)]
    public static double3_mt8 degrees([This] double3_mt8 a) => a * 57.295779513082320876798154814105170332405472466564321549160243861;

    [MethodImpl(256 | 512)]
    public static double3_mt8 wrap([This] double3_mt8 x, double3_mt8 min, double3_mt8 max)
    {
        return new(wrap(x.x, min.x, max.x), wrap(x.y, min.y, max.y), wrap(x.z, min.z, max.z));
    }

    [MethodImpl(256 | 512)]
    public static double3_mt8 wrap([This] double3_mt8 x, double_mt8 min, double_mt8 max)
    {
        return new(wrap(x.x, min, max), wrap(x.y, min, max), wrap(x.z, min, max));
    }

    [MethodImpl(256 | 512)]
    public static double3_mt8 wrap([This] double3_mt8 x, double min, double max)
    {
        return new(wrap(x.x, min, max), wrap(x.y, min, max), wrap(x.z, min, max));
    }

    [MethodImpl(256 | 512)]
    public static double3_mt8 log([This] double3_mt8 a) => new(log(a.x), log(a.y), log(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt8 log2([This] double3_mt8 a) => new(log2(a.x), log2(a.y), log2(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt8 log([This] double3_mt8 a, double3_mt8 b) => new(log(a.x, b.x), log(a.y, b.y), log(a.z, b.z));

    [MethodImpl(256 | 512)]
    public static double3_mt8 log([This] double3_mt8 a, double_mt8 b) => new(log(a.x, b), log(a.y, b), log(a.z, b));

    [MethodImpl(256 | 512)]
    public static double3_mt8 log([This] double_mt8 a, double3_mt8 b) => new(log(a, b.x), log(a, b.y), log(a, b.z));

    [MethodImpl(256 | 512)]
    public static double3_mt8 log10([This] double3_mt8 a) => new(log10(a.x), log10(a.y), log10(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt8 exp([This] double3_mt8 a) => new(exp(a.x), exp(a.y), exp(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt8 exp2([This] double3_mt8 a) => new(exp2(a.x), exp2(a.y), exp2(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt8 exp10([This] double3_mt8 a) => new(exp10(a.x), exp10(a.y), exp10(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt8 pow([This] double3_mt8 a, double3_mt8 b) => new(pow(a.x, b.x), pow(a.y, b.y), pow(a.z, b.z));

    [MethodImpl(256 | 512)]
    public static double3_mt8 pow([This] double3_mt8 a, double_mt8 b) => new(pow(a.x, b), pow(a.y, b), pow(a.z, b));

    [MethodImpl(256 | 512)]
    public static double3_mt8 pow([This] double3_mt8 a, double b) => new(pow(a.x, b), pow(a.y, b), pow(a.z, b));

    [MethodImpl(256 | 512)]
    public static double3_mt8 sqrt([This] double3_mt8 a) => new(sqrt(a.x), sqrt(a.y), sqrt(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt8 rsqrt([This] double3_mt8 a) => new(rsqrt(a.x), rsqrt(a.y), rsqrt(a.z));

    [MethodImpl(256 | 512)]
    public static double_mt8 length([This] double3_mt8 a) => dot(a, a).sqrt();

    [MethodImpl(256 | 512)]
    public static double_mt8 distance([This] double3_mt8 a, double3_mt8 b) => length(b - a);

    [MethodImpl(256 | 512)]
    public static double3_mt8 normalize([This] double3_mt8 a) => a * dot(a, a).rsqrt();
    
    // todo normalizeSafe step refract projectSafe faceForward

    [MethodImpl(256 | 512)]
    public static double3_mt8 sin([This] double3_mt8 a) => new(sin(a.x), sin(a.y), sin(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt8 cos([This] double3_mt8 a) => new(cos(a.x), cos(a.y), cos(a.z));

    [MethodImpl(256 | 512)]
    public static (double3_mt8 sin, double3_mt8 cos) sincos([This] double3_mt8 a)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        var (sin_z, cos_z) = sincos(a.z);
        return (
            new(sin_x, sin_y, sin_z),
            new(cos_x, cos_y, cos_z)
        );
    }

    [MethodImpl(256 | 512)]
    public static void sincos([This] double3_mt8 a, out double3_mt8 sin, out double3_mt8 cos)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        var (sin_z, cos_z) = sincos(a.z);
        sin = new(sin_x, sin_y, sin_z);
        cos = new(cos_x, cos_y, cos_z);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt8 tan([This] double3_mt8 a) => new(tan(a.x), tan(a.y), tan(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt8 asin([This] double3_mt8 a) => new(asin(a.x), asin(a.y), asin(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt8 acos([This] double3_mt8 a) => new(acos(a.x), acos(a.y), acos(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt8 atan([This] double3_mt8 a) => new(atan(a.x), atan(a.y), atan(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt8 atan2([This] double3_mt8 a, double3_mt8 b) => new(atan2(a.x, b.x), atan2(a.y, b.y), atan2(a.z, b.z));

    [MethodImpl(256 | 512)]
    public static double3_mt8 sinh([This] double3_mt8 a) => new(sinh(a.x), sinh(a.y), sinh(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt8 cosh([This] double3_mt8 a) => new(cosh(a.x), cosh(a.y), cosh(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt8 tanh([This] double3_mt8 a) => new(tanh(a.x), tanh(a.y), tanh(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt8 asinh([This] double3_mt8 a) => new(asinh(a.x), asinh(a.y), asinh(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt8 acosh([This] double3_mt8 a) => new(acosh(a.x), acosh(a.y), acosh(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt8 atanh([This] double3_mt8 a) => new(atanh(a.x), atanh(a.y), atanh(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt8 chgsign([This] double3_mt8 a, double3_mt8 b) => new(chgsign(a.x, b.x), chgsign(a.y, b.y), chgsign(a.z, b.z));
}

#endregion // double3_mt8
#region double3_mt16

public partial struct double3_mt16
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static double3_mt16 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static double3_mt16 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static double3_mt16 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static double3_mt16 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static double3_mt16 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static double3_mt16 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static double3_mt16 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144);
    }
}

[Ex]
public static partial class math_mt
{
    #pragma warning disable CS1718
    // ReSharper disable once EqualExpressionComparison
    [MethodImpl(256 | 512)]
    public static b64v3_mt16 isNaN([This] double3_mt16 a) => a != a;
    #pragma warning restore CS1718

    [MethodImpl(256 | 512)]
    public static double3_mt16 ceil([This] double3_mt16 a) => new(a.x.floor(), a.y.floor(), a.z.floor());

    [MethodImpl(256 | 512)]
    public static double3_mt16 floor([This] double3_mt16 a) => new(a.x.floor(), a.y.floor(), a.z.floor());

    [MethodImpl(256 | 512)]
    public static double3_mt16 round([This] double3_mt16 a) => new(a.x.round(), a.y.round(), a.z.round());

    [MethodImpl(256 | 512)]
    public static double3_mt16 trunc([This] double3_mt16 a) => new(a.x.trunc(), a.y.trunc(), a.z.trunc());

    [MethodImpl(256 | 512)]
    public static double3_mt16 mod([This] double3_mt16 a, double3_mt16 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt16 mod([This] double_mt16 a, double3_mt16 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt16 mod([This] double3_mt16 a, double_mt16 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt16 mod([This] double a, double3_mt16 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt16 mod([This] double3_mt16 a, double b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt16 rem([This] double3_mt16 a, double3_mt16 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt16 rem([This] double_mt16 a, double3_mt16 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt16 rem([This] double3_mt16 a, double_mt16 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt16 rem([This] double a, double3_mt16 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt16 rem([This] double3_mt16 a, double b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt16 frac([This] double3_mt16 a) => a - floor(a);

    [MethodImpl(256 | 512)]
    public static double3_mt16 modf([This] double3_mt16 d, out double3_mt16 i)
    {
        i = trunc(d);
        return d - i;
    }

    [MethodImpl(256 | 512)]
    public static double3_mt16 rcp([This] double3_mt16 a) => new(rcp(a.x), rcp(a.y), rcp(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt16 saturate([This] double3_mt16 a) => a.clamp(default, double3_mt16.One);

    [MethodImpl(256 | 512)]
    public static double3_mt16 smoothstep(double3_mt16 min, double3_mt16 max, [This] double3_mt16 a)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * fnma(2.0, t, 3.0); // (3.0 - (2.0 * t))
    }

    [MethodImpl(256 | 512)]
    public static double3_mt16 reflect([This] double3_mt16 i, double3_mt16 n)
    {
        // i - 2 * n * dot(i, n);
        return fnma(2 * n, dot(i, n), i);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt16 project([This] double3_mt16 a, double3_mt16 onto) =>
        dot(a, onto) / dot(onto, onto) * onto;

    [MethodImpl(256 | 512)]
    public static double3_mt16 projectOnPlane([This] double3_mt16 a, double3_mt16 plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static double3_mt16 projectNormalized([This] double3_mt16 a, double3_mt16 onto) =>
        dot(a, onto) * onto;

    [MethodImpl(256 | 512)]
    public static double3_mt16 projectOnPlaneNormalized([This] double3_mt16 a, double3_mt16 plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static double3_mt16 radians([This] double3_mt16 a) => a * 0.0174532925199432957692369076848861271344287188854172545609719144;

    [MethodImpl(256 | 512)]
    public static double3_mt16 degrees([This] double3_mt16 a) => a * 57.295779513082320876798154814105170332405472466564321549160243861;

    [MethodImpl(256 | 512)]
    public static double3_mt16 wrap([This] double3_mt16 x, double3_mt16 min, double3_mt16 max)
    {
        return new(wrap(x.x, min.x, max.x), wrap(x.y, min.y, max.y), wrap(x.z, min.z, max.z));
    }

    [MethodImpl(256 | 512)]
    public static double3_mt16 wrap([This] double3_mt16 x, double_mt16 min, double_mt16 max)
    {
        return new(wrap(x.x, min, max), wrap(x.y, min, max), wrap(x.z, min, max));
    }

    [MethodImpl(256 | 512)]
    public static double3_mt16 wrap([This] double3_mt16 x, double min, double max)
    {
        return new(wrap(x.x, min, max), wrap(x.y, min, max), wrap(x.z, min, max));
    }

    [MethodImpl(256 | 512)]
    public static double3_mt16 log([This] double3_mt16 a) => new(log(a.x), log(a.y), log(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt16 log2([This] double3_mt16 a) => new(log2(a.x), log2(a.y), log2(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt16 log([This] double3_mt16 a, double3_mt16 b) => new(log(a.x, b.x), log(a.y, b.y), log(a.z, b.z));

    [MethodImpl(256 | 512)]
    public static double3_mt16 log([This] double3_mt16 a, double_mt16 b) => new(log(a.x, b), log(a.y, b), log(a.z, b));

    [MethodImpl(256 | 512)]
    public static double3_mt16 log([This] double_mt16 a, double3_mt16 b) => new(log(a, b.x), log(a, b.y), log(a, b.z));

    [MethodImpl(256 | 512)]
    public static double3_mt16 log10([This] double3_mt16 a) => new(log10(a.x), log10(a.y), log10(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt16 exp([This] double3_mt16 a) => new(exp(a.x), exp(a.y), exp(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt16 exp2([This] double3_mt16 a) => new(exp2(a.x), exp2(a.y), exp2(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt16 exp10([This] double3_mt16 a) => new(exp10(a.x), exp10(a.y), exp10(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt16 pow([This] double3_mt16 a, double3_mt16 b) => new(pow(a.x, b.x), pow(a.y, b.y), pow(a.z, b.z));

    [MethodImpl(256 | 512)]
    public static double3_mt16 pow([This] double3_mt16 a, double_mt16 b) => new(pow(a.x, b), pow(a.y, b), pow(a.z, b));

    [MethodImpl(256 | 512)]
    public static double3_mt16 pow([This] double3_mt16 a, double b) => new(pow(a.x, b), pow(a.y, b), pow(a.z, b));

    [MethodImpl(256 | 512)]
    public static double3_mt16 sqrt([This] double3_mt16 a) => new(sqrt(a.x), sqrt(a.y), sqrt(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt16 rsqrt([This] double3_mt16 a) => new(rsqrt(a.x), rsqrt(a.y), rsqrt(a.z));

    [MethodImpl(256 | 512)]
    public static double_mt16 length([This] double3_mt16 a) => dot(a, a).sqrt();

    [MethodImpl(256 | 512)]
    public static double_mt16 distance([This] double3_mt16 a, double3_mt16 b) => length(b - a);

    [MethodImpl(256 | 512)]
    public static double3_mt16 normalize([This] double3_mt16 a) => a * dot(a, a).rsqrt();
    
    // todo normalizeSafe step refract projectSafe faceForward

    [MethodImpl(256 | 512)]
    public static double3_mt16 sin([This] double3_mt16 a) => new(sin(a.x), sin(a.y), sin(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt16 cos([This] double3_mt16 a) => new(cos(a.x), cos(a.y), cos(a.z));

    [MethodImpl(256 | 512)]
    public static (double3_mt16 sin, double3_mt16 cos) sincos([This] double3_mt16 a)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        var (sin_z, cos_z) = sincos(a.z);
        return (
            new(sin_x, sin_y, sin_z),
            new(cos_x, cos_y, cos_z)
        );
    }

    [MethodImpl(256 | 512)]
    public static void sincos([This] double3_mt16 a, out double3_mt16 sin, out double3_mt16 cos)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        var (sin_z, cos_z) = sincos(a.z);
        sin = new(sin_x, sin_y, sin_z);
        cos = new(cos_x, cos_y, cos_z);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt16 tan([This] double3_mt16 a) => new(tan(a.x), tan(a.y), tan(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt16 asin([This] double3_mt16 a) => new(asin(a.x), asin(a.y), asin(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt16 acos([This] double3_mt16 a) => new(acos(a.x), acos(a.y), acos(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt16 atan([This] double3_mt16 a) => new(atan(a.x), atan(a.y), atan(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt16 atan2([This] double3_mt16 a, double3_mt16 b) => new(atan2(a.x, b.x), atan2(a.y, b.y), atan2(a.z, b.z));

    [MethodImpl(256 | 512)]
    public static double3_mt16 sinh([This] double3_mt16 a) => new(sinh(a.x), sinh(a.y), sinh(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt16 cosh([This] double3_mt16 a) => new(cosh(a.x), cosh(a.y), cosh(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt16 tanh([This] double3_mt16 a) => new(tanh(a.x), tanh(a.y), tanh(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt16 asinh([This] double3_mt16 a) => new(asinh(a.x), asinh(a.y), asinh(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt16 acosh([This] double3_mt16 a) => new(acosh(a.x), acosh(a.y), acosh(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt16 atanh([This] double3_mt16 a) => new(atanh(a.x), atanh(a.y), atanh(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt16 chgsign([This] double3_mt16 a, double3_mt16 b) => new(chgsign(a.x, b.x), chgsign(a.y, b.y), chgsign(a.z, b.z));
}

#endregion // double3_mt16
#region double3_mt32

public partial struct double3_mt32
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static double3_mt32 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static double3_mt32 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static double3_mt32 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static double3_mt32 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static double3_mt32 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static double3_mt32 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static double3_mt32 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144);
    }
}

[Ex]
public static partial class math_mt
{
    #pragma warning disable CS1718
    // ReSharper disable once EqualExpressionComparison
    [MethodImpl(256 | 512)]
    public static b64v3_mt32 isNaN([This] double3_mt32 a) => a != a;
    #pragma warning restore CS1718

    [MethodImpl(256 | 512)]
    public static double3_mt32 ceil([This] double3_mt32 a) => new(a.x.floor(), a.y.floor(), a.z.floor());

    [MethodImpl(256 | 512)]
    public static double3_mt32 floor([This] double3_mt32 a) => new(a.x.floor(), a.y.floor(), a.z.floor());

    [MethodImpl(256 | 512)]
    public static double3_mt32 round([This] double3_mt32 a) => new(a.x.round(), a.y.round(), a.z.round());

    [MethodImpl(256 | 512)]
    public static double3_mt32 trunc([This] double3_mt32 a) => new(a.x.trunc(), a.y.trunc(), a.z.trunc());

    [MethodImpl(256 | 512)]
    public static double3_mt32 mod([This] double3_mt32 a, double3_mt32 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt32 mod([This] double_mt32 a, double3_mt32 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt32 mod([This] double3_mt32 a, double_mt32 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt32 mod([This] double a, double3_mt32 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt32 mod([This] double3_mt32 a, double b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt32 rem([This] double3_mt32 a, double3_mt32 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt32 rem([This] double_mt32 a, double3_mt32 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt32 rem([This] double3_mt32 a, double_mt32 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt32 rem([This] double a, double3_mt32 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt32 rem([This] double3_mt32 a, double b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt32 frac([This] double3_mt32 a) => a - floor(a);

    [MethodImpl(256 | 512)]
    public static double3_mt32 modf([This] double3_mt32 d, out double3_mt32 i)
    {
        i = trunc(d);
        return d - i;
    }

    [MethodImpl(256 | 512)]
    public static double3_mt32 rcp([This] double3_mt32 a) => new(rcp(a.x), rcp(a.y), rcp(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt32 saturate([This] double3_mt32 a) => a.clamp(default, double3_mt32.One);

    [MethodImpl(256 | 512)]
    public static double3_mt32 smoothstep(double3_mt32 min, double3_mt32 max, [This] double3_mt32 a)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * fnma(2.0, t, 3.0); // (3.0 - (2.0 * t))
    }

    [MethodImpl(256 | 512)]
    public static double3_mt32 reflect([This] double3_mt32 i, double3_mt32 n)
    {
        // i - 2 * n * dot(i, n);
        return fnma(2 * n, dot(i, n), i);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt32 project([This] double3_mt32 a, double3_mt32 onto) =>
        dot(a, onto) / dot(onto, onto) * onto;

    [MethodImpl(256 | 512)]
    public static double3_mt32 projectOnPlane([This] double3_mt32 a, double3_mt32 plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static double3_mt32 projectNormalized([This] double3_mt32 a, double3_mt32 onto) =>
        dot(a, onto) * onto;

    [MethodImpl(256 | 512)]
    public static double3_mt32 projectOnPlaneNormalized([This] double3_mt32 a, double3_mt32 plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static double3_mt32 radians([This] double3_mt32 a) => a * 0.0174532925199432957692369076848861271344287188854172545609719144;

    [MethodImpl(256 | 512)]
    public static double3_mt32 degrees([This] double3_mt32 a) => a * 57.295779513082320876798154814105170332405472466564321549160243861;

    [MethodImpl(256 | 512)]
    public static double3_mt32 wrap([This] double3_mt32 x, double3_mt32 min, double3_mt32 max)
    {
        return new(wrap(x.x, min.x, max.x), wrap(x.y, min.y, max.y), wrap(x.z, min.z, max.z));
    }

    [MethodImpl(256 | 512)]
    public static double3_mt32 wrap([This] double3_mt32 x, double_mt32 min, double_mt32 max)
    {
        return new(wrap(x.x, min, max), wrap(x.y, min, max), wrap(x.z, min, max));
    }

    [MethodImpl(256 | 512)]
    public static double3_mt32 wrap([This] double3_mt32 x, double min, double max)
    {
        return new(wrap(x.x, min, max), wrap(x.y, min, max), wrap(x.z, min, max));
    }

    [MethodImpl(256 | 512)]
    public static double3_mt32 log([This] double3_mt32 a) => new(log(a.x), log(a.y), log(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt32 log2([This] double3_mt32 a) => new(log2(a.x), log2(a.y), log2(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt32 log([This] double3_mt32 a, double3_mt32 b) => new(log(a.x, b.x), log(a.y, b.y), log(a.z, b.z));

    [MethodImpl(256 | 512)]
    public static double3_mt32 log([This] double3_mt32 a, double_mt32 b) => new(log(a.x, b), log(a.y, b), log(a.z, b));

    [MethodImpl(256 | 512)]
    public static double3_mt32 log([This] double_mt32 a, double3_mt32 b) => new(log(a, b.x), log(a, b.y), log(a, b.z));

    [MethodImpl(256 | 512)]
    public static double3_mt32 log10([This] double3_mt32 a) => new(log10(a.x), log10(a.y), log10(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt32 exp([This] double3_mt32 a) => new(exp(a.x), exp(a.y), exp(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt32 exp2([This] double3_mt32 a) => new(exp2(a.x), exp2(a.y), exp2(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt32 exp10([This] double3_mt32 a) => new(exp10(a.x), exp10(a.y), exp10(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt32 pow([This] double3_mt32 a, double3_mt32 b) => new(pow(a.x, b.x), pow(a.y, b.y), pow(a.z, b.z));

    [MethodImpl(256 | 512)]
    public static double3_mt32 pow([This] double3_mt32 a, double_mt32 b) => new(pow(a.x, b), pow(a.y, b), pow(a.z, b));

    [MethodImpl(256 | 512)]
    public static double3_mt32 pow([This] double3_mt32 a, double b) => new(pow(a.x, b), pow(a.y, b), pow(a.z, b));

    [MethodImpl(256 | 512)]
    public static double3_mt32 sqrt([This] double3_mt32 a) => new(sqrt(a.x), sqrt(a.y), sqrt(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt32 rsqrt([This] double3_mt32 a) => new(rsqrt(a.x), rsqrt(a.y), rsqrt(a.z));

    [MethodImpl(256 | 512)]
    public static double_mt32 length([This] double3_mt32 a) => dot(a, a).sqrt();

    [MethodImpl(256 | 512)]
    public static double_mt32 distance([This] double3_mt32 a, double3_mt32 b) => length(b - a);

    [MethodImpl(256 | 512)]
    public static double3_mt32 normalize([This] double3_mt32 a) => a * dot(a, a).rsqrt();
    
    // todo normalizeSafe step refract projectSafe faceForward

    [MethodImpl(256 | 512)]
    public static double3_mt32 sin([This] double3_mt32 a) => new(sin(a.x), sin(a.y), sin(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt32 cos([This] double3_mt32 a) => new(cos(a.x), cos(a.y), cos(a.z));

    [MethodImpl(256 | 512)]
    public static (double3_mt32 sin, double3_mt32 cos) sincos([This] double3_mt32 a)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        var (sin_z, cos_z) = sincos(a.z);
        return (
            new(sin_x, sin_y, sin_z),
            new(cos_x, cos_y, cos_z)
        );
    }

    [MethodImpl(256 | 512)]
    public static void sincos([This] double3_mt32 a, out double3_mt32 sin, out double3_mt32 cos)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        var (sin_z, cos_z) = sincos(a.z);
        sin = new(sin_x, sin_y, sin_z);
        cos = new(cos_x, cos_y, cos_z);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt32 tan([This] double3_mt32 a) => new(tan(a.x), tan(a.y), tan(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt32 asin([This] double3_mt32 a) => new(asin(a.x), asin(a.y), asin(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt32 acos([This] double3_mt32 a) => new(acos(a.x), acos(a.y), acos(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt32 atan([This] double3_mt32 a) => new(atan(a.x), atan(a.y), atan(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt32 atan2([This] double3_mt32 a, double3_mt32 b) => new(atan2(a.x, b.x), atan2(a.y, b.y), atan2(a.z, b.z));

    [MethodImpl(256 | 512)]
    public static double3_mt32 sinh([This] double3_mt32 a) => new(sinh(a.x), sinh(a.y), sinh(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt32 cosh([This] double3_mt32 a) => new(cosh(a.x), cosh(a.y), cosh(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt32 tanh([This] double3_mt32 a) => new(tanh(a.x), tanh(a.y), tanh(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt32 asinh([This] double3_mt32 a) => new(asinh(a.x), asinh(a.y), asinh(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt32 acosh([This] double3_mt32 a) => new(acosh(a.x), acosh(a.y), acosh(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt32 atanh([This] double3_mt32 a) => new(atanh(a.x), atanh(a.y), atanh(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt32 chgsign([This] double3_mt32 a, double3_mt32 b) => new(chgsign(a.x, b.x), chgsign(a.y, b.y), chgsign(a.z, b.z));
}

#endregion // double3_mt32
#region double4_mt4

public partial struct double4_mt4
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static double4_mt4 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static double4_mt4 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static double4_mt4 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static double4_mt4 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static double4_mt4 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static double4_mt4 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static double4_mt4 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144);
    }
}

[Ex]
public static partial class math_mt
{
    #pragma warning disable CS1718
    // ReSharper disable once EqualExpressionComparison
    [MethodImpl(256 | 512)]
    public static b64v4_mt4 isNaN([This] double4_mt4 a) => a != a;
    #pragma warning restore CS1718

    [MethodImpl(256 | 512)]
    public static double4_mt4 ceil([This] double4_mt4 a) => new(a.x.floor(), a.y.floor(), a.z.floor(), a.w.floor());

    [MethodImpl(256 | 512)]
    public static double4_mt4 floor([This] double4_mt4 a) => new(a.x.floor(), a.y.floor(), a.z.floor(), a.w.floor());

    [MethodImpl(256 | 512)]
    public static double4_mt4 round([This] double4_mt4 a) => new(a.x.round(), a.y.round(), a.z.round(), a.w.round());

    [MethodImpl(256 | 512)]
    public static double4_mt4 trunc([This] double4_mt4 a) => new(a.x.trunc(), a.y.trunc(), a.z.trunc(), a.w.trunc());

    [MethodImpl(256 | 512)]
    public static double4_mt4 mod([This] double4_mt4 a, double4_mt4 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt4 mod([This] double_mt4 a, double4_mt4 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt4 mod([This] double4_mt4 a, double_mt4 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt4 mod([This] double a, double4_mt4 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt4 mod([This] double4_mt4 a, double b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt4 rem([This] double4_mt4 a, double4_mt4 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt4 rem([This] double_mt4 a, double4_mt4 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt4 rem([This] double4_mt4 a, double_mt4 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt4 rem([This] double a, double4_mt4 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt4 rem([This] double4_mt4 a, double b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt4 frac([This] double4_mt4 a) => a - floor(a);

    [MethodImpl(256 | 512)]
    public static double4_mt4 modf([This] double4_mt4 d, out double4_mt4 i)
    {
        i = trunc(d);
        return d - i;
    }

    [MethodImpl(256 | 512)]
    public static double4_mt4 rcp([This] double4_mt4 a) => new(rcp(a.x), rcp(a.y), rcp(a.z), rcp(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt4 saturate([This] double4_mt4 a) => a.clamp(default, double4_mt4.One);

    [MethodImpl(256 | 512)]
    public static double4_mt4 smoothstep(double4_mt4 min, double4_mt4 max, [This] double4_mt4 a)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * fnma(2.0, t, 3.0); // (3.0 - (2.0 * t))
    }

    [MethodImpl(256 | 512)]
    public static double4_mt4 reflect([This] double4_mt4 i, double4_mt4 n)
    {
        // i - 2 * n * dot(i, n);
        return fnma(2 * n, dot(i, n), i);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt4 project([This] double4_mt4 a, double4_mt4 onto) =>
        dot(a, onto) / dot(onto, onto) * onto;

    [MethodImpl(256 | 512)]
    public static double4_mt4 projectOnPlane([This] double4_mt4 a, double4_mt4 plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static double4_mt4 projectNormalized([This] double4_mt4 a, double4_mt4 onto) =>
        dot(a, onto) * onto;

    [MethodImpl(256 | 512)]
    public static double4_mt4 projectOnPlaneNormalized([This] double4_mt4 a, double4_mt4 plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static double4_mt4 radians([This] double4_mt4 a) => a * 0.0174532925199432957692369076848861271344287188854172545609719144;

    [MethodImpl(256 | 512)]
    public static double4_mt4 degrees([This] double4_mt4 a) => a * 57.295779513082320876798154814105170332405472466564321549160243861;

    [MethodImpl(256 | 512)]
    public static double4_mt4 wrap([This] double4_mt4 x, double4_mt4 min, double4_mt4 max)
    {
        return new(wrap(x.x, min.x, max.x), wrap(x.y, min.y, max.y), wrap(x.z, min.z, max.z), wrap(x.w, min.w, max.w));
    }

    [MethodImpl(256 | 512)]
    public static double4_mt4 wrap([This] double4_mt4 x, double_mt4 min, double_mt4 max)
    {
        return new(wrap(x.x, min, max), wrap(x.y, min, max), wrap(x.z, min, max), wrap(x.w, min, max));
    }

    [MethodImpl(256 | 512)]
    public static double4_mt4 wrap([This] double4_mt4 x, double min, double max)
    {
        return new(wrap(x.x, min, max), wrap(x.y, min, max), wrap(x.z, min, max), wrap(x.w, min, max));
    }

    [MethodImpl(256 | 512)]
    public static double4_mt4 log([This] double4_mt4 a) => new(log(a.x), log(a.y), log(a.z), log(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt4 log2([This] double4_mt4 a) => new(log2(a.x), log2(a.y), log2(a.z), log2(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt4 log([This] double4_mt4 a, double4_mt4 b) => new(log(a.x, b.x), log(a.y, b.y), log(a.z, b.z), log(a.w, b.w));

    [MethodImpl(256 | 512)]
    public static double4_mt4 log([This] double4_mt4 a, double_mt4 b) => new(log(a.x, b), log(a.y, b), log(a.z, b), log(a.w, b));

    [MethodImpl(256 | 512)]
    public static double4_mt4 log([This] double_mt4 a, double4_mt4 b) => new(log(a, b.x), log(a, b.y), log(a, b.z), log(a, b.w));

    [MethodImpl(256 | 512)]
    public static double4_mt4 log10([This] double4_mt4 a) => new(log10(a.x), log10(a.y), log10(a.z), log10(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt4 exp([This] double4_mt4 a) => new(exp(a.x), exp(a.y), exp(a.z), exp(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt4 exp2([This] double4_mt4 a) => new(exp2(a.x), exp2(a.y), exp2(a.z), exp2(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt4 exp10([This] double4_mt4 a) => new(exp10(a.x), exp10(a.y), exp10(a.z), exp10(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt4 pow([This] double4_mt4 a, double4_mt4 b) => new(pow(a.x, b.x), pow(a.y, b.y), pow(a.z, b.z), pow(a.w, b.w));

    [MethodImpl(256 | 512)]
    public static double4_mt4 pow([This] double4_mt4 a, double_mt4 b) => new(pow(a.x, b), pow(a.y, b), pow(a.z, b), pow(a.w, b));

    [MethodImpl(256 | 512)]
    public static double4_mt4 pow([This] double4_mt4 a, double b) => new(pow(a.x, b), pow(a.y, b), pow(a.z, b), pow(a.w, b));

    [MethodImpl(256 | 512)]
    public static double4_mt4 sqrt([This] double4_mt4 a) => new(sqrt(a.x), sqrt(a.y), sqrt(a.z), sqrt(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt4 rsqrt([This] double4_mt4 a) => new(rsqrt(a.x), rsqrt(a.y), rsqrt(a.z), rsqrt(a.w));

    [MethodImpl(256 | 512)]
    public static double_mt4 length([This] double4_mt4 a) => dot(a, a).sqrt();

    [MethodImpl(256 | 512)]
    public static double_mt4 distance([This] double4_mt4 a, double4_mt4 b) => length(b - a);

    [MethodImpl(256 | 512)]
    public static double4_mt4 normalize([This] double4_mt4 a) => a * dot(a, a).rsqrt();
    
    // todo normalizeSafe step refract projectSafe faceForward

    [MethodImpl(256 | 512)]
    public static double4_mt4 sin([This] double4_mt4 a) => new(sin(a.x), sin(a.y), sin(a.z), sin(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt4 cos([This] double4_mt4 a) => new(cos(a.x), cos(a.y), cos(a.z), cos(a.w));

    [MethodImpl(256 | 512)]
    public static (double4_mt4 sin, double4_mt4 cos) sincos([This] double4_mt4 a)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        var (sin_z, cos_z) = sincos(a.z);
        var (sin_w, cos_w) = sincos(a.w);
        return (
            new(sin_x, sin_y, sin_z, sin_w),
            new(cos_x, cos_y, cos_z, cos_w)
        );
    }

    [MethodImpl(256 | 512)]
    public static void sincos([This] double4_mt4 a, out double4_mt4 sin, out double4_mt4 cos)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        var (sin_z, cos_z) = sincos(a.z);
        var (sin_w, cos_w) = sincos(a.w);
        sin = new(sin_x, sin_y, sin_z, sin_w);
        cos = new(cos_x, cos_y, cos_z, cos_w);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt4 tan([This] double4_mt4 a) => new(tan(a.x), tan(a.y), tan(a.z), tan(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt4 asin([This] double4_mt4 a) => new(asin(a.x), asin(a.y), asin(a.z), asin(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt4 acos([This] double4_mt4 a) => new(acos(a.x), acos(a.y), acos(a.z), acos(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt4 atan([This] double4_mt4 a) => new(atan(a.x), atan(a.y), atan(a.z), atan(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt4 atan2([This] double4_mt4 a, double4_mt4 b) => new(atan2(a.x, b.x), atan2(a.y, b.y), atan2(a.z, b.z), atan2(a.w, b.w));

    [MethodImpl(256 | 512)]
    public static double4_mt4 sinh([This] double4_mt4 a) => new(sinh(a.x), sinh(a.y), sinh(a.z), sinh(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt4 cosh([This] double4_mt4 a) => new(cosh(a.x), cosh(a.y), cosh(a.z), cosh(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt4 tanh([This] double4_mt4 a) => new(tanh(a.x), tanh(a.y), tanh(a.z), tanh(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt4 asinh([This] double4_mt4 a) => new(asinh(a.x), asinh(a.y), asinh(a.z), asinh(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt4 acosh([This] double4_mt4 a) => new(acosh(a.x), acosh(a.y), acosh(a.z), acosh(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt4 atanh([This] double4_mt4 a) => new(atanh(a.x), atanh(a.y), atanh(a.z), atanh(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt4 chgsign([This] double4_mt4 a, double4_mt4 b) => new(chgsign(a.x, b.x), chgsign(a.y, b.y), chgsign(a.z, b.z), chgsign(a.w, b.w));
}

#endregion // double4_mt4
#region double4_mt8

public partial struct double4_mt8
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static double4_mt8 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static double4_mt8 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static double4_mt8 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static double4_mt8 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static double4_mt8 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static double4_mt8 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static double4_mt8 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144);
    }
}

[Ex]
public static partial class math_mt
{
    #pragma warning disable CS1718
    // ReSharper disable once EqualExpressionComparison
    [MethodImpl(256 | 512)]
    public static b64v4_mt8 isNaN([This] double4_mt8 a) => a != a;
    #pragma warning restore CS1718

    [MethodImpl(256 | 512)]
    public static double4_mt8 ceil([This] double4_mt8 a) => new(a.x.floor(), a.y.floor(), a.z.floor(), a.w.floor());

    [MethodImpl(256 | 512)]
    public static double4_mt8 floor([This] double4_mt8 a) => new(a.x.floor(), a.y.floor(), a.z.floor(), a.w.floor());

    [MethodImpl(256 | 512)]
    public static double4_mt8 round([This] double4_mt8 a) => new(a.x.round(), a.y.round(), a.z.round(), a.w.round());

    [MethodImpl(256 | 512)]
    public static double4_mt8 trunc([This] double4_mt8 a) => new(a.x.trunc(), a.y.trunc(), a.z.trunc(), a.w.trunc());

    [MethodImpl(256 | 512)]
    public static double4_mt8 mod([This] double4_mt8 a, double4_mt8 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt8 mod([This] double_mt8 a, double4_mt8 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt8 mod([This] double4_mt8 a, double_mt8 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt8 mod([This] double a, double4_mt8 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt8 mod([This] double4_mt8 a, double b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt8 rem([This] double4_mt8 a, double4_mt8 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt8 rem([This] double_mt8 a, double4_mt8 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt8 rem([This] double4_mt8 a, double_mt8 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt8 rem([This] double a, double4_mt8 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt8 rem([This] double4_mt8 a, double b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt8 frac([This] double4_mt8 a) => a - floor(a);

    [MethodImpl(256 | 512)]
    public static double4_mt8 modf([This] double4_mt8 d, out double4_mt8 i)
    {
        i = trunc(d);
        return d - i;
    }

    [MethodImpl(256 | 512)]
    public static double4_mt8 rcp([This] double4_mt8 a) => new(rcp(a.x), rcp(a.y), rcp(a.z), rcp(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt8 saturate([This] double4_mt8 a) => a.clamp(default, double4_mt8.One);

    [MethodImpl(256 | 512)]
    public static double4_mt8 smoothstep(double4_mt8 min, double4_mt8 max, [This] double4_mt8 a)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * fnma(2.0, t, 3.0); // (3.0 - (2.0 * t))
    }

    [MethodImpl(256 | 512)]
    public static double4_mt8 reflect([This] double4_mt8 i, double4_mt8 n)
    {
        // i - 2 * n * dot(i, n);
        return fnma(2 * n, dot(i, n), i);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt8 project([This] double4_mt8 a, double4_mt8 onto) =>
        dot(a, onto) / dot(onto, onto) * onto;

    [MethodImpl(256 | 512)]
    public static double4_mt8 projectOnPlane([This] double4_mt8 a, double4_mt8 plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static double4_mt8 projectNormalized([This] double4_mt8 a, double4_mt8 onto) =>
        dot(a, onto) * onto;

    [MethodImpl(256 | 512)]
    public static double4_mt8 projectOnPlaneNormalized([This] double4_mt8 a, double4_mt8 plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static double4_mt8 radians([This] double4_mt8 a) => a * 0.0174532925199432957692369076848861271344287188854172545609719144;

    [MethodImpl(256 | 512)]
    public static double4_mt8 degrees([This] double4_mt8 a) => a * 57.295779513082320876798154814105170332405472466564321549160243861;

    [MethodImpl(256 | 512)]
    public static double4_mt8 wrap([This] double4_mt8 x, double4_mt8 min, double4_mt8 max)
    {
        return new(wrap(x.x, min.x, max.x), wrap(x.y, min.y, max.y), wrap(x.z, min.z, max.z), wrap(x.w, min.w, max.w));
    }

    [MethodImpl(256 | 512)]
    public static double4_mt8 wrap([This] double4_mt8 x, double_mt8 min, double_mt8 max)
    {
        return new(wrap(x.x, min, max), wrap(x.y, min, max), wrap(x.z, min, max), wrap(x.w, min, max));
    }

    [MethodImpl(256 | 512)]
    public static double4_mt8 wrap([This] double4_mt8 x, double min, double max)
    {
        return new(wrap(x.x, min, max), wrap(x.y, min, max), wrap(x.z, min, max), wrap(x.w, min, max));
    }

    [MethodImpl(256 | 512)]
    public static double4_mt8 log([This] double4_mt8 a) => new(log(a.x), log(a.y), log(a.z), log(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt8 log2([This] double4_mt8 a) => new(log2(a.x), log2(a.y), log2(a.z), log2(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt8 log([This] double4_mt8 a, double4_mt8 b) => new(log(a.x, b.x), log(a.y, b.y), log(a.z, b.z), log(a.w, b.w));

    [MethodImpl(256 | 512)]
    public static double4_mt8 log([This] double4_mt8 a, double_mt8 b) => new(log(a.x, b), log(a.y, b), log(a.z, b), log(a.w, b));

    [MethodImpl(256 | 512)]
    public static double4_mt8 log([This] double_mt8 a, double4_mt8 b) => new(log(a, b.x), log(a, b.y), log(a, b.z), log(a, b.w));

    [MethodImpl(256 | 512)]
    public static double4_mt8 log10([This] double4_mt8 a) => new(log10(a.x), log10(a.y), log10(a.z), log10(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt8 exp([This] double4_mt8 a) => new(exp(a.x), exp(a.y), exp(a.z), exp(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt8 exp2([This] double4_mt8 a) => new(exp2(a.x), exp2(a.y), exp2(a.z), exp2(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt8 exp10([This] double4_mt8 a) => new(exp10(a.x), exp10(a.y), exp10(a.z), exp10(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt8 pow([This] double4_mt8 a, double4_mt8 b) => new(pow(a.x, b.x), pow(a.y, b.y), pow(a.z, b.z), pow(a.w, b.w));

    [MethodImpl(256 | 512)]
    public static double4_mt8 pow([This] double4_mt8 a, double_mt8 b) => new(pow(a.x, b), pow(a.y, b), pow(a.z, b), pow(a.w, b));

    [MethodImpl(256 | 512)]
    public static double4_mt8 pow([This] double4_mt8 a, double b) => new(pow(a.x, b), pow(a.y, b), pow(a.z, b), pow(a.w, b));

    [MethodImpl(256 | 512)]
    public static double4_mt8 sqrt([This] double4_mt8 a) => new(sqrt(a.x), sqrt(a.y), sqrt(a.z), sqrt(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt8 rsqrt([This] double4_mt8 a) => new(rsqrt(a.x), rsqrt(a.y), rsqrt(a.z), rsqrt(a.w));

    [MethodImpl(256 | 512)]
    public static double_mt8 length([This] double4_mt8 a) => dot(a, a).sqrt();

    [MethodImpl(256 | 512)]
    public static double_mt8 distance([This] double4_mt8 a, double4_mt8 b) => length(b - a);

    [MethodImpl(256 | 512)]
    public static double4_mt8 normalize([This] double4_mt8 a) => a * dot(a, a).rsqrt();
    
    // todo normalizeSafe step refract projectSafe faceForward

    [MethodImpl(256 | 512)]
    public static double4_mt8 sin([This] double4_mt8 a) => new(sin(a.x), sin(a.y), sin(a.z), sin(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt8 cos([This] double4_mt8 a) => new(cos(a.x), cos(a.y), cos(a.z), cos(a.w));

    [MethodImpl(256 | 512)]
    public static (double4_mt8 sin, double4_mt8 cos) sincos([This] double4_mt8 a)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        var (sin_z, cos_z) = sincos(a.z);
        var (sin_w, cos_w) = sincos(a.w);
        return (
            new(sin_x, sin_y, sin_z, sin_w),
            new(cos_x, cos_y, cos_z, cos_w)
        );
    }

    [MethodImpl(256 | 512)]
    public static void sincos([This] double4_mt8 a, out double4_mt8 sin, out double4_mt8 cos)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        var (sin_z, cos_z) = sincos(a.z);
        var (sin_w, cos_w) = sincos(a.w);
        sin = new(sin_x, sin_y, sin_z, sin_w);
        cos = new(cos_x, cos_y, cos_z, cos_w);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt8 tan([This] double4_mt8 a) => new(tan(a.x), tan(a.y), tan(a.z), tan(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt8 asin([This] double4_mt8 a) => new(asin(a.x), asin(a.y), asin(a.z), asin(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt8 acos([This] double4_mt8 a) => new(acos(a.x), acos(a.y), acos(a.z), acos(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt8 atan([This] double4_mt8 a) => new(atan(a.x), atan(a.y), atan(a.z), atan(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt8 atan2([This] double4_mt8 a, double4_mt8 b) => new(atan2(a.x, b.x), atan2(a.y, b.y), atan2(a.z, b.z), atan2(a.w, b.w));

    [MethodImpl(256 | 512)]
    public static double4_mt8 sinh([This] double4_mt8 a) => new(sinh(a.x), sinh(a.y), sinh(a.z), sinh(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt8 cosh([This] double4_mt8 a) => new(cosh(a.x), cosh(a.y), cosh(a.z), cosh(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt8 tanh([This] double4_mt8 a) => new(tanh(a.x), tanh(a.y), tanh(a.z), tanh(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt8 asinh([This] double4_mt8 a) => new(asinh(a.x), asinh(a.y), asinh(a.z), asinh(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt8 acosh([This] double4_mt8 a) => new(acosh(a.x), acosh(a.y), acosh(a.z), acosh(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt8 atanh([This] double4_mt8 a) => new(atanh(a.x), atanh(a.y), atanh(a.z), atanh(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt8 chgsign([This] double4_mt8 a, double4_mt8 b) => new(chgsign(a.x, b.x), chgsign(a.y, b.y), chgsign(a.z, b.z), chgsign(a.w, b.w));
}

#endregion // double4_mt8
#region double4_mt16

public partial struct double4_mt16
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static double4_mt16 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static double4_mt16 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static double4_mt16 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static double4_mt16 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static double4_mt16 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static double4_mt16 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static double4_mt16 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144);
    }
}

[Ex]
public static partial class math_mt
{
    #pragma warning disable CS1718
    // ReSharper disable once EqualExpressionComparison
    [MethodImpl(256 | 512)]
    public static b64v4_mt16 isNaN([This] double4_mt16 a) => a != a;
    #pragma warning restore CS1718

    [MethodImpl(256 | 512)]
    public static double4_mt16 ceil([This] double4_mt16 a) => new(a.x.floor(), a.y.floor(), a.z.floor(), a.w.floor());

    [MethodImpl(256 | 512)]
    public static double4_mt16 floor([This] double4_mt16 a) => new(a.x.floor(), a.y.floor(), a.z.floor(), a.w.floor());

    [MethodImpl(256 | 512)]
    public static double4_mt16 round([This] double4_mt16 a) => new(a.x.round(), a.y.round(), a.z.round(), a.w.round());

    [MethodImpl(256 | 512)]
    public static double4_mt16 trunc([This] double4_mt16 a) => new(a.x.trunc(), a.y.trunc(), a.z.trunc(), a.w.trunc());

    [MethodImpl(256 | 512)]
    public static double4_mt16 mod([This] double4_mt16 a, double4_mt16 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt16 mod([This] double_mt16 a, double4_mt16 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt16 mod([This] double4_mt16 a, double_mt16 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt16 mod([This] double a, double4_mt16 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt16 mod([This] double4_mt16 a, double b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt16 rem([This] double4_mt16 a, double4_mt16 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt16 rem([This] double_mt16 a, double4_mt16 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt16 rem([This] double4_mt16 a, double_mt16 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt16 rem([This] double a, double4_mt16 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt16 rem([This] double4_mt16 a, double b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt16 frac([This] double4_mt16 a) => a - floor(a);

    [MethodImpl(256 | 512)]
    public static double4_mt16 modf([This] double4_mt16 d, out double4_mt16 i)
    {
        i = trunc(d);
        return d - i;
    }

    [MethodImpl(256 | 512)]
    public static double4_mt16 rcp([This] double4_mt16 a) => new(rcp(a.x), rcp(a.y), rcp(a.z), rcp(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt16 saturate([This] double4_mt16 a) => a.clamp(default, double4_mt16.One);

    [MethodImpl(256 | 512)]
    public static double4_mt16 smoothstep(double4_mt16 min, double4_mt16 max, [This] double4_mt16 a)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * fnma(2.0, t, 3.0); // (3.0 - (2.0 * t))
    }

    [MethodImpl(256 | 512)]
    public static double4_mt16 reflect([This] double4_mt16 i, double4_mt16 n)
    {
        // i - 2 * n * dot(i, n);
        return fnma(2 * n, dot(i, n), i);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt16 project([This] double4_mt16 a, double4_mt16 onto) =>
        dot(a, onto) / dot(onto, onto) * onto;

    [MethodImpl(256 | 512)]
    public static double4_mt16 projectOnPlane([This] double4_mt16 a, double4_mt16 plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static double4_mt16 projectNormalized([This] double4_mt16 a, double4_mt16 onto) =>
        dot(a, onto) * onto;

    [MethodImpl(256 | 512)]
    public static double4_mt16 projectOnPlaneNormalized([This] double4_mt16 a, double4_mt16 plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static double4_mt16 radians([This] double4_mt16 a) => a * 0.0174532925199432957692369076848861271344287188854172545609719144;

    [MethodImpl(256 | 512)]
    public static double4_mt16 degrees([This] double4_mt16 a) => a * 57.295779513082320876798154814105170332405472466564321549160243861;

    [MethodImpl(256 | 512)]
    public static double4_mt16 wrap([This] double4_mt16 x, double4_mt16 min, double4_mt16 max)
    {
        return new(wrap(x.x, min.x, max.x), wrap(x.y, min.y, max.y), wrap(x.z, min.z, max.z), wrap(x.w, min.w, max.w));
    }

    [MethodImpl(256 | 512)]
    public static double4_mt16 wrap([This] double4_mt16 x, double_mt16 min, double_mt16 max)
    {
        return new(wrap(x.x, min, max), wrap(x.y, min, max), wrap(x.z, min, max), wrap(x.w, min, max));
    }

    [MethodImpl(256 | 512)]
    public static double4_mt16 wrap([This] double4_mt16 x, double min, double max)
    {
        return new(wrap(x.x, min, max), wrap(x.y, min, max), wrap(x.z, min, max), wrap(x.w, min, max));
    }

    [MethodImpl(256 | 512)]
    public static double4_mt16 log([This] double4_mt16 a) => new(log(a.x), log(a.y), log(a.z), log(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt16 log2([This] double4_mt16 a) => new(log2(a.x), log2(a.y), log2(a.z), log2(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt16 log([This] double4_mt16 a, double4_mt16 b) => new(log(a.x, b.x), log(a.y, b.y), log(a.z, b.z), log(a.w, b.w));

    [MethodImpl(256 | 512)]
    public static double4_mt16 log([This] double4_mt16 a, double_mt16 b) => new(log(a.x, b), log(a.y, b), log(a.z, b), log(a.w, b));

    [MethodImpl(256 | 512)]
    public static double4_mt16 log([This] double_mt16 a, double4_mt16 b) => new(log(a, b.x), log(a, b.y), log(a, b.z), log(a, b.w));

    [MethodImpl(256 | 512)]
    public static double4_mt16 log10([This] double4_mt16 a) => new(log10(a.x), log10(a.y), log10(a.z), log10(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt16 exp([This] double4_mt16 a) => new(exp(a.x), exp(a.y), exp(a.z), exp(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt16 exp2([This] double4_mt16 a) => new(exp2(a.x), exp2(a.y), exp2(a.z), exp2(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt16 exp10([This] double4_mt16 a) => new(exp10(a.x), exp10(a.y), exp10(a.z), exp10(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt16 pow([This] double4_mt16 a, double4_mt16 b) => new(pow(a.x, b.x), pow(a.y, b.y), pow(a.z, b.z), pow(a.w, b.w));

    [MethodImpl(256 | 512)]
    public static double4_mt16 pow([This] double4_mt16 a, double_mt16 b) => new(pow(a.x, b), pow(a.y, b), pow(a.z, b), pow(a.w, b));

    [MethodImpl(256 | 512)]
    public static double4_mt16 pow([This] double4_mt16 a, double b) => new(pow(a.x, b), pow(a.y, b), pow(a.z, b), pow(a.w, b));

    [MethodImpl(256 | 512)]
    public static double4_mt16 sqrt([This] double4_mt16 a) => new(sqrt(a.x), sqrt(a.y), sqrt(a.z), sqrt(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt16 rsqrt([This] double4_mt16 a) => new(rsqrt(a.x), rsqrt(a.y), rsqrt(a.z), rsqrt(a.w));

    [MethodImpl(256 | 512)]
    public static double_mt16 length([This] double4_mt16 a) => dot(a, a).sqrt();

    [MethodImpl(256 | 512)]
    public static double_mt16 distance([This] double4_mt16 a, double4_mt16 b) => length(b - a);

    [MethodImpl(256 | 512)]
    public static double4_mt16 normalize([This] double4_mt16 a) => a * dot(a, a).rsqrt();
    
    // todo normalizeSafe step refract projectSafe faceForward

    [MethodImpl(256 | 512)]
    public static double4_mt16 sin([This] double4_mt16 a) => new(sin(a.x), sin(a.y), sin(a.z), sin(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt16 cos([This] double4_mt16 a) => new(cos(a.x), cos(a.y), cos(a.z), cos(a.w));

    [MethodImpl(256 | 512)]
    public static (double4_mt16 sin, double4_mt16 cos) sincos([This] double4_mt16 a)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        var (sin_z, cos_z) = sincos(a.z);
        var (sin_w, cos_w) = sincos(a.w);
        return (
            new(sin_x, sin_y, sin_z, sin_w),
            new(cos_x, cos_y, cos_z, cos_w)
        );
    }

    [MethodImpl(256 | 512)]
    public static void sincos([This] double4_mt16 a, out double4_mt16 sin, out double4_mt16 cos)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        var (sin_z, cos_z) = sincos(a.z);
        var (sin_w, cos_w) = sincos(a.w);
        sin = new(sin_x, sin_y, sin_z, sin_w);
        cos = new(cos_x, cos_y, cos_z, cos_w);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt16 tan([This] double4_mt16 a) => new(tan(a.x), tan(a.y), tan(a.z), tan(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt16 asin([This] double4_mt16 a) => new(asin(a.x), asin(a.y), asin(a.z), asin(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt16 acos([This] double4_mt16 a) => new(acos(a.x), acos(a.y), acos(a.z), acos(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt16 atan([This] double4_mt16 a) => new(atan(a.x), atan(a.y), atan(a.z), atan(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt16 atan2([This] double4_mt16 a, double4_mt16 b) => new(atan2(a.x, b.x), atan2(a.y, b.y), atan2(a.z, b.z), atan2(a.w, b.w));

    [MethodImpl(256 | 512)]
    public static double4_mt16 sinh([This] double4_mt16 a) => new(sinh(a.x), sinh(a.y), sinh(a.z), sinh(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt16 cosh([This] double4_mt16 a) => new(cosh(a.x), cosh(a.y), cosh(a.z), cosh(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt16 tanh([This] double4_mt16 a) => new(tanh(a.x), tanh(a.y), tanh(a.z), tanh(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt16 asinh([This] double4_mt16 a) => new(asinh(a.x), asinh(a.y), asinh(a.z), asinh(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt16 acosh([This] double4_mt16 a) => new(acosh(a.x), acosh(a.y), acosh(a.z), acosh(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt16 atanh([This] double4_mt16 a) => new(atanh(a.x), atanh(a.y), atanh(a.z), atanh(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt16 chgsign([This] double4_mt16 a, double4_mt16 b) => new(chgsign(a.x, b.x), chgsign(a.y, b.y), chgsign(a.z, b.z), chgsign(a.w, b.w));
}

#endregion // double4_mt16
#region double4_mt32

public partial struct double4_mt32
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static double4_mt32 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static double4_mt32 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static double4_mt32 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static double4_mt32 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static double4_mt32 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static double4_mt32 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static double4_mt32 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144);
    }
}

[Ex]
public static partial class math_mt
{
    #pragma warning disable CS1718
    // ReSharper disable once EqualExpressionComparison
    [MethodImpl(256 | 512)]
    public static b64v4_mt32 isNaN([This] double4_mt32 a) => a != a;
    #pragma warning restore CS1718

    [MethodImpl(256 | 512)]
    public static double4_mt32 ceil([This] double4_mt32 a) => new(a.x.floor(), a.y.floor(), a.z.floor(), a.w.floor());

    [MethodImpl(256 | 512)]
    public static double4_mt32 floor([This] double4_mt32 a) => new(a.x.floor(), a.y.floor(), a.z.floor(), a.w.floor());

    [MethodImpl(256 | 512)]
    public static double4_mt32 round([This] double4_mt32 a) => new(a.x.round(), a.y.round(), a.z.round(), a.w.round());

    [MethodImpl(256 | 512)]
    public static double4_mt32 trunc([This] double4_mt32 a) => new(a.x.trunc(), a.y.trunc(), a.z.trunc(), a.w.trunc());

    [MethodImpl(256 | 512)]
    public static double4_mt32 mod([This] double4_mt32 a, double4_mt32 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt32 mod([This] double_mt32 a, double4_mt32 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt32 mod([This] double4_mt32 a, double_mt32 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt32 mod([This] double a, double4_mt32 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt32 mod([This] double4_mt32 a, double b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt32 rem([This] double4_mt32 a, double4_mt32 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt32 rem([This] double_mt32 a, double4_mt32 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt32 rem([This] double4_mt32 a, double_mt32 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt32 rem([This] double a, double4_mt32 b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt32 rem([This] double4_mt32 a, double b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt32 frac([This] double4_mt32 a) => a - floor(a);

    [MethodImpl(256 | 512)]
    public static double4_mt32 modf([This] double4_mt32 d, out double4_mt32 i)
    {
        i = trunc(d);
        return d - i;
    }

    [MethodImpl(256 | 512)]
    public static double4_mt32 rcp([This] double4_mt32 a) => new(rcp(a.x), rcp(a.y), rcp(a.z), rcp(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt32 saturate([This] double4_mt32 a) => a.clamp(default, double4_mt32.One);

    [MethodImpl(256 | 512)]
    public static double4_mt32 smoothstep(double4_mt32 min, double4_mt32 max, [This] double4_mt32 a)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * fnma(2.0, t, 3.0); // (3.0 - (2.0 * t))
    }

    [MethodImpl(256 | 512)]
    public static double4_mt32 reflect([This] double4_mt32 i, double4_mt32 n)
    {
        // i - 2 * n * dot(i, n);
        return fnma(2 * n, dot(i, n), i);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt32 project([This] double4_mt32 a, double4_mt32 onto) =>
        dot(a, onto) / dot(onto, onto) * onto;

    [MethodImpl(256 | 512)]
    public static double4_mt32 projectOnPlane([This] double4_mt32 a, double4_mt32 plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static double4_mt32 projectNormalized([This] double4_mt32 a, double4_mt32 onto) =>
        dot(a, onto) * onto;

    [MethodImpl(256 | 512)]
    public static double4_mt32 projectOnPlaneNormalized([This] double4_mt32 a, double4_mt32 plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static double4_mt32 radians([This] double4_mt32 a) => a * 0.0174532925199432957692369076848861271344287188854172545609719144;

    [MethodImpl(256 | 512)]
    public static double4_mt32 degrees([This] double4_mt32 a) => a * 57.295779513082320876798154814105170332405472466564321549160243861;

    [MethodImpl(256 | 512)]
    public static double4_mt32 wrap([This] double4_mt32 x, double4_mt32 min, double4_mt32 max)
    {
        return new(wrap(x.x, min.x, max.x), wrap(x.y, min.y, max.y), wrap(x.z, min.z, max.z), wrap(x.w, min.w, max.w));
    }

    [MethodImpl(256 | 512)]
    public static double4_mt32 wrap([This] double4_mt32 x, double_mt32 min, double_mt32 max)
    {
        return new(wrap(x.x, min, max), wrap(x.y, min, max), wrap(x.z, min, max), wrap(x.w, min, max));
    }

    [MethodImpl(256 | 512)]
    public static double4_mt32 wrap([This] double4_mt32 x, double min, double max)
    {
        return new(wrap(x.x, min, max), wrap(x.y, min, max), wrap(x.z, min, max), wrap(x.w, min, max));
    }

    [MethodImpl(256 | 512)]
    public static double4_mt32 log([This] double4_mt32 a) => new(log(a.x), log(a.y), log(a.z), log(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt32 log2([This] double4_mt32 a) => new(log2(a.x), log2(a.y), log2(a.z), log2(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt32 log([This] double4_mt32 a, double4_mt32 b) => new(log(a.x, b.x), log(a.y, b.y), log(a.z, b.z), log(a.w, b.w));

    [MethodImpl(256 | 512)]
    public static double4_mt32 log([This] double4_mt32 a, double_mt32 b) => new(log(a.x, b), log(a.y, b), log(a.z, b), log(a.w, b));

    [MethodImpl(256 | 512)]
    public static double4_mt32 log([This] double_mt32 a, double4_mt32 b) => new(log(a, b.x), log(a, b.y), log(a, b.z), log(a, b.w));

    [MethodImpl(256 | 512)]
    public static double4_mt32 log10([This] double4_mt32 a) => new(log10(a.x), log10(a.y), log10(a.z), log10(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt32 exp([This] double4_mt32 a) => new(exp(a.x), exp(a.y), exp(a.z), exp(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt32 exp2([This] double4_mt32 a) => new(exp2(a.x), exp2(a.y), exp2(a.z), exp2(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt32 exp10([This] double4_mt32 a) => new(exp10(a.x), exp10(a.y), exp10(a.z), exp10(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt32 pow([This] double4_mt32 a, double4_mt32 b) => new(pow(a.x, b.x), pow(a.y, b.y), pow(a.z, b.z), pow(a.w, b.w));

    [MethodImpl(256 | 512)]
    public static double4_mt32 pow([This] double4_mt32 a, double_mt32 b) => new(pow(a.x, b), pow(a.y, b), pow(a.z, b), pow(a.w, b));

    [MethodImpl(256 | 512)]
    public static double4_mt32 pow([This] double4_mt32 a, double b) => new(pow(a.x, b), pow(a.y, b), pow(a.z, b), pow(a.w, b));

    [MethodImpl(256 | 512)]
    public static double4_mt32 sqrt([This] double4_mt32 a) => new(sqrt(a.x), sqrt(a.y), sqrt(a.z), sqrt(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt32 rsqrt([This] double4_mt32 a) => new(rsqrt(a.x), rsqrt(a.y), rsqrt(a.z), rsqrt(a.w));

    [MethodImpl(256 | 512)]
    public static double_mt32 length([This] double4_mt32 a) => dot(a, a).sqrt();

    [MethodImpl(256 | 512)]
    public static double_mt32 distance([This] double4_mt32 a, double4_mt32 b) => length(b - a);

    [MethodImpl(256 | 512)]
    public static double4_mt32 normalize([This] double4_mt32 a) => a * dot(a, a).rsqrt();
    
    // todo normalizeSafe step refract projectSafe faceForward

    [MethodImpl(256 | 512)]
    public static double4_mt32 sin([This] double4_mt32 a) => new(sin(a.x), sin(a.y), sin(a.z), sin(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt32 cos([This] double4_mt32 a) => new(cos(a.x), cos(a.y), cos(a.z), cos(a.w));

    [MethodImpl(256 | 512)]
    public static (double4_mt32 sin, double4_mt32 cos) sincos([This] double4_mt32 a)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        var (sin_z, cos_z) = sincos(a.z);
        var (sin_w, cos_w) = sincos(a.w);
        return (
            new(sin_x, sin_y, sin_z, sin_w),
            new(cos_x, cos_y, cos_z, cos_w)
        );
    }

    [MethodImpl(256 | 512)]
    public static void sincos([This] double4_mt32 a, out double4_mt32 sin, out double4_mt32 cos)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        var (sin_z, cos_z) = sincos(a.z);
        var (sin_w, cos_w) = sincos(a.w);
        sin = new(sin_x, sin_y, sin_z, sin_w);
        cos = new(cos_x, cos_y, cos_z, cos_w);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt32 tan([This] double4_mt32 a) => new(tan(a.x), tan(a.y), tan(a.z), tan(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt32 asin([This] double4_mt32 a) => new(asin(a.x), asin(a.y), asin(a.z), asin(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt32 acos([This] double4_mt32 a) => new(acos(a.x), acos(a.y), acos(a.z), acos(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt32 atan([This] double4_mt32 a) => new(atan(a.x), atan(a.y), atan(a.z), atan(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt32 atan2([This] double4_mt32 a, double4_mt32 b) => new(atan2(a.x, b.x), atan2(a.y, b.y), atan2(a.z, b.z), atan2(a.w, b.w));

    [MethodImpl(256 | 512)]
    public static double4_mt32 sinh([This] double4_mt32 a) => new(sinh(a.x), sinh(a.y), sinh(a.z), sinh(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt32 cosh([This] double4_mt32 a) => new(cosh(a.x), cosh(a.y), cosh(a.z), cosh(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt32 tanh([This] double4_mt32 a) => new(tanh(a.x), tanh(a.y), tanh(a.z), tanh(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt32 asinh([This] double4_mt32 a) => new(asinh(a.x), asinh(a.y), asinh(a.z), asinh(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt32 acosh([This] double4_mt32 a) => new(acosh(a.x), acosh(a.y), acosh(a.z), acosh(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt32 atanh([This] double4_mt32 a) => new(atanh(a.x), atanh(a.y), atanh(a.z), atanh(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt32 chgsign([This] double4_mt32 a, double4_mt32 b) => new(chgsign(a.x, b.x), chgsign(a.y, b.y), chgsign(a.z, b.z), chgsign(a.w, b.w));
}

#endregion // double4_mt32
