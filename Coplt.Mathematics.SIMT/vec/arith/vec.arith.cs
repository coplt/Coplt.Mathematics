// generated by template, do not modify manually

namespace Coplt.Mathematics.SIMT;

#region float2_mt4

public partial struct float2_mt4
{
    #region Constants

    public static float2_mt4 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static float2_mt4 One
    {
        [MethodImpl(256 | 512)]
        get => new(1.0f);
    }

    public static float2_mt4 Two
    {
        [MethodImpl(256 | 512)]
        get => new(2.0f);
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static float2_mt4 operator-(float2_mt4 a) => new(-a.x, -a.y);

    [MethodImpl(256 | 512)]
    public static float2_mt4 operator+(float2_mt4 a, float2_mt4 b) => new(a.x + b.x, a.y + b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt4 operator+(float2_mt4 a, float_mt4 b) => new(a.x + b, a.y + b);

    [MethodImpl(256 | 512)]
    public static float2_mt4 operator+(float_mt4 a, float2_mt4 b) => new(a + b.x, a + b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt4 operator-(float2_mt4 a, float2_mt4 b) => new(a.x - b.x, a.y - b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt4 operator-(float2_mt4 a, float_mt4 b) => new(a.x - b, a.y - b);

    [MethodImpl(256 | 512)]
    public static float2_mt4 operator-(float_mt4 a, float2_mt4 b) => new(a - b.x, a - b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt4 operator*(float2_mt4 a, float2_mt4 b) => new(a.x * b.x, a.y * b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt4 operator*(float2_mt4 a, float_mt4 b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static float2_mt4 operator*(float_mt4 a, float2_mt4 b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt4 operator*(float2_mt4 a, float b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static float2_mt4 operator*(float a, float2_mt4 b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt4 operator/(float2_mt4 a, float2_mt4 b) => new(a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static float2_mt4 operator/(float_mt4 a, float2_mt4 b) => new(a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static float2_mt4 operator/(float2_mt4 a, float_mt4 b) => new(a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static float2_mt4 operator/(float2_mt4 a, float b) => new(a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static float2_mt4 operator%(float2_mt4 a, float2_mt4 b) => new(a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static float2_mt4 operator%(float_mt4 a, float2_mt4 b) => new(a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static float2_mt4 operator%(float2_mt4 a, float_mt4 b) => new(a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static float2_mt4 operator%(float2_mt4 a, float b) => new(a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static float2_mt4 operator++(float2_mt4 a) => a + float_mt4.One;

    [MethodImpl(256 | 512)]
    public static float2_mt4 operator--(float2_mt4 a) => a - float_mt4.One;

    #endregion // Operators
}

#endregion // float2_mt4
#region float2_mt8

public partial struct float2_mt8
{
    #region Constants

    public static float2_mt8 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static float2_mt8 One
    {
        [MethodImpl(256 | 512)]
        get => new(1.0f);
    }

    public static float2_mt8 Two
    {
        [MethodImpl(256 | 512)]
        get => new(2.0f);
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static float2_mt8 operator-(float2_mt8 a) => new(-a.x, -a.y);

    [MethodImpl(256 | 512)]
    public static float2_mt8 operator+(float2_mt8 a, float2_mt8 b) => new(a.x + b.x, a.y + b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt8 operator+(float2_mt8 a, float_mt8 b) => new(a.x + b, a.y + b);

    [MethodImpl(256 | 512)]
    public static float2_mt8 operator+(float_mt8 a, float2_mt8 b) => new(a + b.x, a + b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt8 operator-(float2_mt8 a, float2_mt8 b) => new(a.x - b.x, a.y - b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt8 operator-(float2_mt8 a, float_mt8 b) => new(a.x - b, a.y - b);

    [MethodImpl(256 | 512)]
    public static float2_mt8 operator-(float_mt8 a, float2_mt8 b) => new(a - b.x, a - b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt8 operator*(float2_mt8 a, float2_mt8 b) => new(a.x * b.x, a.y * b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt8 operator*(float2_mt8 a, float_mt8 b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static float2_mt8 operator*(float_mt8 a, float2_mt8 b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt8 operator*(float2_mt8 a, float b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static float2_mt8 operator*(float a, float2_mt8 b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt8 operator/(float2_mt8 a, float2_mt8 b) => new(a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static float2_mt8 operator/(float_mt8 a, float2_mt8 b) => new(a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static float2_mt8 operator/(float2_mt8 a, float_mt8 b) => new(a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static float2_mt8 operator/(float2_mt8 a, float b) => new(a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static float2_mt8 operator%(float2_mt8 a, float2_mt8 b) => new(a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static float2_mt8 operator%(float_mt8 a, float2_mt8 b) => new(a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static float2_mt8 operator%(float2_mt8 a, float_mt8 b) => new(a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static float2_mt8 operator%(float2_mt8 a, float b) => new(a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static float2_mt8 operator++(float2_mt8 a) => a + float_mt8.One;

    [MethodImpl(256 | 512)]
    public static float2_mt8 operator--(float2_mt8 a) => a - float_mt8.One;

    #endregion // Operators
}

#endregion // float2_mt8
#region float2_mt16

public partial struct float2_mt16
{
    #region Constants

    public static float2_mt16 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static float2_mt16 One
    {
        [MethodImpl(256 | 512)]
        get => new(1.0f);
    }

    public static float2_mt16 Two
    {
        [MethodImpl(256 | 512)]
        get => new(2.0f);
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static float2_mt16 operator-(float2_mt16 a) => new(-a.x, -a.y);

    [MethodImpl(256 | 512)]
    public static float2_mt16 operator+(float2_mt16 a, float2_mt16 b) => new(a.x + b.x, a.y + b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt16 operator+(float2_mt16 a, float_mt16 b) => new(a.x + b, a.y + b);

    [MethodImpl(256 | 512)]
    public static float2_mt16 operator+(float_mt16 a, float2_mt16 b) => new(a + b.x, a + b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt16 operator-(float2_mt16 a, float2_mt16 b) => new(a.x - b.x, a.y - b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt16 operator-(float2_mt16 a, float_mt16 b) => new(a.x - b, a.y - b);

    [MethodImpl(256 | 512)]
    public static float2_mt16 operator-(float_mt16 a, float2_mt16 b) => new(a - b.x, a - b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt16 operator*(float2_mt16 a, float2_mt16 b) => new(a.x * b.x, a.y * b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt16 operator*(float2_mt16 a, float_mt16 b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static float2_mt16 operator*(float_mt16 a, float2_mt16 b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt16 operator*(float2_mt16 a, float b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static float2_mt16 operator*(float a, float2_mt16 b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt16 operator/(float2_mt16 a, float2_mt16 b) => new(a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static float2_mt16 operator/(float_mt16 a, float2_mt16 b) => new(a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static float2_mt16 operator/(float2_mt16 a, float_mt16 b) => new(a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static float2_mt16 operator/(float2_mt16 a, float b) => new(a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static float2_mt16 operator%(float2_mt16 a, float2_mt16 b) => new(a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static float2_mt16 operator%(float_mt16 a, float2_mt16 b) => new(a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static float2_mt16 operator%(float2_mt16 a, float_mt16 b) => new(a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static float2_mt16 operator%(float2_mt16 a, float b) => new(a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static float2_mt16 operator++(float2_mt16 a) => a + float_mt16.One;

    [MethodImpl(256 | 512)]
    public static float2_mt16 operator--(float2_mt16 a) => a - float_mt16.One;

    #endregion // Operators
}

#endregion // float2_mt16
#region float2_mt32

public partial struct float2_mt32
{
    #region Constants

    public static float2_mt32 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static float2_mt32 One
    {
        [MethodImpl(256 | 512)]
        get => new(1.0f);
    }

    public static float2_mt32 Two
    {
        [MethodImpl(256 | 512)]
        get => new(2.0f);
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static float2_mt32 operator-(float2_mt32 a) => new(-a.x, -a.y);

    [MethodImpl(256 | 512)]
    public static float2_mt32 operator+(float2_mt32 a, float2_mt32 b) => new(a.x + b.x, a.y + b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt32 operator+(float2_mt32 a, float_mt32 b) => new(a.x + b, a.y + b);

    [MethodImpl(256 | 512)]
    public static float2_mt32 operator+(float_mt32 a, float2_mt32 b) => new(a + b.x, a + b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt32 operator-(float2_mt32 a, float2_mt32 b) => new(a.x - b.x, a.y - b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt32 operator-(float2_mt32 a, float_mt32 b) => new(a.x - b, a.y - b);

    [MethodImpl(256 | 512)]
    public static float2_mt32 operator-(float_mt32 a, float2_mt32 b) => new(a - b.x, a - b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt32 operator*(float2_mt32 a, float2_mt32 b) => new(a.x * b.x, a.y * b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt32 operator*(float2_mt32 a, float_mt32 b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static float2_mt32 operator*(float_mt32 a, float2_mt32 b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt32 operator*(float2_mt32 a, float b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static float2_mt32 operator*(float a, float2_mt32 b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt32 operator/(float2_mt32 a, float2_mt32 b) => new(a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static float2_mt32 operator/(float_mt32 a, float2_mt32 b) => new(a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static float2_mt32 operator/(float2_mt32 a, float_mt32 b) => new(a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static float2_mt32 operator/(float2_mt32 a, float b) => new(a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static float2_mt32 operator%(float2_mt32 a, float2_mt32 b) => new(a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static float2_mt32 operator%(float_mt32 a, float2_mt32 b) => new(a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static float2_mt32 operator%(float2_mt32 a, float_mt32 b) => new(a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static float2_mt32 operator%(float2_mt32 a, float b) => new(a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static float2_mt32 operator++(float2_mt32 a) => a + float_mt32.One;

    [MethodImpl(256 | 512)]
    public static float2_mt32 operator--(float2_mt32 a) => a - float_mt32.One;

    #endregion // Operators
}

#endregion // float2_mt32
#region float3_mt4

public partial struct float3_mt4
{
    #region Constants

    public static float3_mt4 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static float3_mt4 One
    {
        [MethodImpl(256 | 512)]
        get => new(1.0f);
    }

    public static float3_mt4 Two
    {
        [MethodImpl(256 | 512)]
        get => new(2.0f);
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static float3_mt4 operator-(float3_mt4 a) => new(-a.x, -a.y, -a.z);

    [MethodImpl(256 | 512)]
    public static float3_mt4 operator+(float3_mt4 a, float3_mt4 b) => new(a.x + b.x, a.y + b.y, a.z + b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt4 operator+(float3_mt4 a, float_mt4 b) => new(a.x + b, a.y + b, a.z + b);

    [MethodImpl(256 | 512)]
    public static float3_mt4 operator+(float_mt4 a, float3_mt4 b) => new(a + b.x, a + b.y, a + b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt4 operator-(float3_mt4 a, float3_mt4 b) => new(a.x - b.x, a.y - b.y, a.z - b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt4 operator-(float3_mt4 a, float_mt4 b) => new(a.x - b, a.y - b, a.z - b);

    [MethodImpl(256 | 512)]
    public static float3_mt4 operator-(float_mt4 a, float3_mt4 b) => new(a - b.x, a - b.y, a - b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt4 operator*(float3_mt4 a, float3_mt4 b) => new(a.x * b.x, a.y * b.y, a.z * b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt4 operator*(float3_mt4 a, float_mt4 b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static float3_mt4 operator*(float_mt4 a, float3_mt4 b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt4 operator*(float3_mt4 a, float b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static float3_mt4 operator*(float a, float3_mt4 b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt4 operator/(float3_mt4 a, float3_mt4 b) => new(a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static float3_mt4 operator/(float_mt4 a, float3_mt4 b) => new(a / b.z, a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static float3_mt4 operator/(float3_mt4 a, float_mt4 b) => new(a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static float3_mt4 operator/(float3_mt4 a, float b) => new(a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static float3_mt4 operator%(float3_mt4 a, float3_mt4 b) => new(a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static float3_mt4 operator%(float_mt4 a, float3_mt4 b) => new(a % b.z, a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static float3_mt4 operator%(float3_mt4 a, float_mt4 b) => new(a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static float3_mt4 operator%(float3_mt4 a, float b) => new(a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static float3_mt4 operator++(float3_mt4 a) => a + float_mt4.One;

    [MethodImpl(256 | 512)]
    public static float3_mt4 operator--(float3_mt4 a) => a - float_mt4.One;

    #endregion // Operators
}

#endregion // float3_mt4
#region float3_mt8

public partial struct float3_mt8
{
    #region Constants

    public static float3_mt8 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static float3_mt8 One
    {
        [MethodImpl(256 | 512)]
        get => new(1.0f);
    }

    public static float3_mt8 Two
    {
        [MethodImpl(256 | 512)]
        get => new(2.0f);
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static float3_mt8 operator-(float3_mt8 a) => new(-a.x, -a.y, -a.z);

    [MethodImpl(256 | 512)]
    public static float3_mt8 operator+(float3_mt8 a, float3_mt8 b) => new(a.x + b.x, a.y + b.y, a.z + b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt8 operator+(float3_mt8 a, float_mt8 b) => new(a.x + b, a.y + b, a.z + b);

    [MethodImpl(256 | 512)]
    public static float3_mt8 operator+(float_mt8 a, float3_mt8 b) => new(a + b.x, a + b.y, a + b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt8 operator-(float3_mt8 a, float3_mt8 b) => new(a.x - b.x, a.y - b.y, a.z - b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt8 operator-(float3_mt8 a, float_mt8 b) => new(a.x - b, a.y - b, a.z - b);

    [MethodImpl(256 | 512)]
    public static float3_mt8 operator-(float_mt8 a, float3_mt8 b) => new(a - b.x, a - b.y, a - b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt8 operator*(float3_mt8 a, float3_mt8 b) => new(a.x * b.x, a.y * b.y, a.z * b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt8 operator*(float3_mt8 a, float_mt8 b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static float3_mt8 operator*(float_mt8 a, float3_mt8 b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt8 operator*(float3_mt8 a, float b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static float3_mt8 operator*(float a, float3_mt8 b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt8 operator/(float3_mt8 a, float3_mt8 b) => new(a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static float3_mt8 operator/(float_mt8 a, float3_mt8 b) => new(a / b.z, a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static float3_mt8 operator/(float3_mt8 a, float_mt8 b) => new(a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static float3_mt8 operator/(float3_mt8 a, float b) => new(a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static float3_mt8 operator%(float3_mt8 a, float3_mt8 b) => new(a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static float3_mt8 operator%(float_mt8 a, float3_mt8 b) => new(a % b.z, a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static float3_mt8 operator%(float3_mt8 a, float_mt8 b) => new(a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static float3_mt8 operator%(float3_mt8 a, float b) => new(a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static float3_mt8 operator++(float3_mt8 a) => a + float_mt8.One;

    [MethodImpl(256 | 512)]
    public static float3_mt8 operator--(float3_mt8 a) => a - float_mt8.One;

    #endregion // Operators
}

#endregion // float3_mt8
#region float3_mt16

public partial struct float3_mt16
{
    #region Constants

    public static float3_mt16 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static float3_mt16 One
    {
        [MethodImpl(256 | 512)]
        get => new(1.0f);
    }

    public static float3_mt16 Two
    {
        [MethodImpl(256 | 512)]
        get => new(2.0f);
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static float3_mt16 operator-(float3_mt16 a) => new(-a.x, -a.y, -a.z);

    [MethodImpl(256 | 512)]
    public static float3_mt16 operator+(float3_mt16 a, float3_mt16 b) => new(a.x + b.x, a.y + b.y, a.z + b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt16 operator+(float3_mt16 a, float_mt16 b) => new(a.x + b, a.y + b, a.z + b);

    [MethodImpl(256 | 512)]
    public static float3_mt16 operator+(float_mt16 a, float3_mt16 b) => new(a + b.x, a + b.y, a + b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt16 operator-(float3_mt16 a, float3_mt16 b) => new(a.x - b.x, a.y - b.y, a.z - b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt16 operator-(float3_mt16 a, float_mt16 b) => new(a.x - b, a.y - b, a.z - b);

    [MethodImpl(256 | 512)]
    public static float3_mt16 operator-(float_mt16 a, float3_mt16 b) => new(a - b.x, a - b.y, a - b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt16 operator*(float3_mt16 a, float3_mt16 b) => new(a.x * b.x, a.y * b.y, a.z * b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt16 operator*(float3_mt16 a, float_mt16 b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static float3_mt16 operator*(float_mt16 a, float3_mt16 b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt16 operator*(float3_mt16 a, float b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static float3_mt16 operator*(float a, float3_mt16 b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt16 operator/(float3_mt16 a, float3_mt16 b) => new(a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static float3_mt16 operator/(float_mt16 a, float3_mt16 b) => new(a / b.z, a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static float3_mt16 operator/(float3_mt16 a, float_mt16 b) => new(a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static float3_mt16 operator/(float3_mt16 a, float b) => new(a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static float3_mt16 operator%(float3_mt16 a, float3_mt16 b) => new(a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static float3_mt16 operator%(float_mt16 a, float3_mt16 b) => new(a % b.z, a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static float3_mt16 operator%(float3_mt16 a, float_mt16 b) => new(a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static float3_mt16 operator%(float3_mt16 a, float b) => new(a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static float3_mt16 operator++(float3_mt16 a) => a + float_mt16.One;

    [MethodImpl(256 | 512)]
    public static float3_mt16 operator--(float3_mt16 a) => a - float_mt16.One;

    #endregion // Operators
}

#endregion // float3_mt16
#region float3_mt32

public partial struct float3_mt32
{
    #region Constants

    public static float3_mt32 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static float3_mt32 One
    {
        [MethodImpl(256 | 512)]
        get => new(1.0f);
    }

    public static float3_mt32 Two
    {
        [MethodImpl(256 | 512)]
        get => new(2.0f);
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static float3_mt32 operator-(float3_mt32 a) => new(-a.x, -a.y, -a.z);

    [MethodImpl(256 | 512)]
    public static float3_mt32 operator+(float3_mt32 a, float3_mt32 b) => new(a.x + b.x, a.y + b.y, a.z + b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt32 operator+(float3_mt32 a, float_mt32 b) => new(a.x + b, a.y + b, a.z + b);

    [MethodImpl(256 | 512)]
    public static float3_mt32 operator+(float_mt32 a, float3_mt32 b) => new(a + b.x, a + b.y, a + b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt32 operator-(float3_mt32 a, float3_mt32 b) => new(a.x - b.x, a.y - b.y, a.z - b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt32 operator-(float3_mt32 a, float_mt32 b) => new(a.x - b, a.y - b, a.z - b);

    [MethodImpl(256 | 512)]
    public static float3_mt32 operator-(float_mt32 a, float3_mt32 b) => new(a - b.x, a - b.y, a - b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt32 operator*(float3_mt32 a, float3_mt32 b) => new(a.x * b.x, a.y * b.y, a.z * b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt32 operator*(float3_mt32 a, float_mt32 b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static float3_mt32 operator*(float_mt32 a, float3_mt32 b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt32 operator*(float3_mt32 a, float b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static float3_mt32 operator*(float a, float3_mt32 b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt32 operator/(float3_mt32 a, float3_mt32 b) => new(a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static float3_mt32 operator/(float_mt32 a, float3_mt32 b) => new(a / b.z, a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static float3_mt32 operator/(float3_mt32 a, float_mt32 b) => new(a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static float3_mt32 operator/(float3_mt32 a, float b) => new(a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static float3_mt32 operator%(float3_mt32 a, float3_mt32 b) => new(a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static float3_mt32 operator%(float_mt32 a, float3_mt32 b) => new(a % b.z, a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static float3_mt32 operator%(float3_mt32 a, float_mt32 b) => new(a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static float3_mt32 operator%(float3_mt32 a, float b) => new(a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static float3_mt32 operator++(float3_mt32 a) => a + float_mt32.One;

    [MethodImpl(256 | 512)]
    public static float3_mt32 operator--(float3_mt32 a) => a - float_mt32.One;

    #endregion // Operators
}

#endregion // float3_mt32
#region float4_mt4

public partial struct float4_mt4
{
    #region Constants

    public static float4_mt4 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static float4_mt4 One
    {
        [MethodImpl(256 | 512)]
        get => new(1.0f);
    }

    public static float4_mt4 Two
    {
        [MethodImpl(256 | 512)]
        get => new(2.0f);
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static float4_mt4 operator-(float4_mt4 a) => new(-a.x, -a.y, -a.z, -a.w);

    [MethodImpl(256 | 512)]
    public static float4_mt4 operator+(float4_mt4 a, float4_mt4 b) => new(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt4 operator+(float4_mt4 a, float_mt4 b) => new(a.x + b, a.y + b, a.z + b, a.w + b);

    [MethodImpl(256 | 512)]
    public static float4_mt4 operator+(float_mt4 a, float4_mt4 b) => new(a + b.x, a + b.y, a + b.z, a + b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt4 operator-(float4_mt4 a, float4_mt4 b) => new(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt4 operator-(float4_mt4 a, float_mt4 b) => new(a.x - b, a.y - b, a.z - b, a.w - b);

    [MethodImpl(256 | 512)]
    public static float4_mt4 operator-(float_mt4 a, float4_mt4 b) => new(a - b.x, a - b.y, a - b.z, a - b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt4 operator*(float4_mt4 a, float4_mt4 b) => new(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt4 operator*(float4_mt4 a, float_mt4 b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static float4_mt4 operator*(float_mt4 a, float4_mt4 b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt4 operator*(float4_mt4 a, float b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static float4_mt4 operator*(float a, float4_mt4 b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt4 operator/(float4_mt4 a, float4_mt4 b) => new(a.w / b.w, a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static float4_mt4 operator/(float_mt4 a, float4_mt4 b) => new(a / b.w, a / b.z, a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static float4_mt4 operator/(float4_mt4 a, float_mt4 b) => new(a.w / b, a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static float4_mt4 operator/(float4_mt4 a, float b) => new(a.w / b, a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static float4_mt4 operator%(float4_mt4 a, float4_mt4 b) => new(a.w % b.w, a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static float4_mt4 operator%(float_mt4 a, float4_mt4 b) => new(a % b.w, a % b.z, a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static float4_mt4 operator%(float4_mt4 a, float_mt4 b) => new(a.w % b, a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static float4_mt4 operator%(float4_mt4 a, float b) => new(a.w % b, a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static float4_mt4 operator++(float4_mt4 a) => a + float_mt4.One;

    [MethodImpl(256 | 512)]
    public static float4_mt4 operator--(float4_mt4 a) => a - float_mt4.One;

    #endregion // Operators
}

#endregion // float4_mt4
#region float4_mt8

public partial struct float4_mt8
{
    #region Constants

    public static float4_mt8 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static float4_mt8 One
    {
        [MethodImpl(256 | 512)]
        get => new(1.0f);
    }

    public static float4_mt8 Two
    {
        [MethodImpl(256 | 512)]
        get => new(2.0f);
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static float4_mt8 operator-(float4_mt8 a) => new(-a.x, -a.y, -a.z, -a.w);

    [MethodImpl(256 | 512)]
    public static float4_mt8 operator+(float4_mt8 a, float4_mt8 b) => new(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt8 operator+(float4_mt8 a, float_mt8 b) => new(a.x + b, a.y + b, a.z + b, a.w + b);

    [MethodImpl(256 | 512)]
    public static float4_mt8 operator+(float_mt8 a, float4_mt8 b) => new(a + b.x, a + b.y, a + b.z, a + b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt8 operator-(float4_mt8 a, float4_mt8 b) => new(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt8 operator-(float4_mt8 a, float_mt8 b) => new(a.x - b, a.y - b, a.z - b, a.w - b);

    [MethodImpl(256 | 512)]
    public static float4_mt8 operator-(float_mt8 a, float4_mt8 b) => new(a - b.x, a - b.y, a - b.z, a - b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt8 operator*(float4_mt8 a, float4_mt8 b) => new(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt8 operator*(float4_mt8 a, float_mt8 b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static float4_mt8 operator*(float_mt8 a, float4_mt8 b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt8 operator*(float4_mt8 a, float b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static float4_mt8 operator*(float a, float4_mt8 b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt8 operator/(float4_mt8 a, float4_mt8 b) => new(a.w / b.w, a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static float4_mt8 operator/(float_mt8 a, float4_mt8 b) => new(a / b.w, a / b.z, a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static float4_mt8 operator/(float4_mt8 a, float_mt8 b) => new(a.w / b, a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static float4_mt8 operator/(float4_mt8 a, float b) => new(a.w / b, a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static float4_mt8 operator%(float4_mt8 a, float4_mt8 b) => new(a.w % b.w, a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static float4_mt8 operator%(float_mt8 a, float4_mt8 b) => new(a % b.w, a % b.z, a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static float4_mt8 operator%(float4_mt8 a, float_mt8 b) => new(a.w % b, a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static float4_mt8 operator%(float4_mt8 a, float b) => new(a.w % b, a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static float4_mt8 operator++(float4_mt8 a) => a + float_mt8.One;

    [MethodImpl(256 | 512)]
    public static float4_mt8 operator--(float4_mt8 a) => a - float_mt8.One;

    #endregion // Operators
}

#endregion // float4_mt8
#region float4_mt16

public partial struct float4_mt16
{
    #region Constants

    public static float4_mt16 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static float4_mt16 One
    {
        [MethodImpl(256 | 512)]
        get => new(1.0f);
    }

    public static float4_mt16 Two
    {
        [MethodImpl(256 | 512)]
        get => new(2.0f);
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static float4_mt16 operator-(float4_mt16 a) => new(-a.x, -a.y, -a.z, -a.w);

    [MethodImpl(256 | 512)]
    public static float4_mt16 operator+(float4_mt16 a, float4_mt16 b) => new(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt16 operator+(float4_mt16 a, float_mt16 b) => new(a.x + b, a.y + b, a.z + b, a.w + b);

    [MethodImpl(256 | 512)]
    public static float4_mt16 operator+(float_mt16 a, float4_mt16 b) => new(a + b.x, a + b.y, a + b.z, a + b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt16 operator-(float4_mt16 a, float4_mt16 b) => new(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt16 operator-(float4_mt16 a, float_mt16 b) => new(a.x - b, a.y - b, a.z - b, a.w - b);

    [MethodImpl(256 | 512)]
    public static float4_mt16 operator-(float_mt16 a, float4_mt16 b) => new(a - b.x, a - b.y, a - b.z, a - b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt16 operator*(float4_mt16 a, float4_mt16 b) => new(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt16 operator*(float4_mt16 a, float_mt16 b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static float4_mt16 operator*(float_mt16 a, float4_mt16 b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt16 operator*(float4_mt16 a, float b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static float4_mt16 operator*(float a, float4_mt16 b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt16 operator/(float4_mt16 a, float4_mt16 b) => new(a.w / b.w, a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static float4_mt16 operator/(float_mt16 a, float4_mt16 b) => new(a / b.w, a / b.z, a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static float4_mt16 operator/(float4_mt16 a, float_mt16 b) => new(a.w / b, a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static float4_mt16 operator/(float4_mt16 a, float b) => new(a.w / b, a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static float4_mt16 operator%(float4_mt16 a, float4_mt16 b) => new(a.w % b.w, a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static float4_mt16 operator%(float_mt16 a, float4_mt16 b) => new(a % b.w, a % b.z, a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static float4_mt16 operator%(float4_mt16 a, float_mt16 b) => new(a.w % b, a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static float4_mt16 operator%(float4_mt16 a, float b) => new(a.w % b, a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static float4_mt16 operator++(float4_mt16 a) => a + float_mt16.One;

    [MethodImpl(256 | 512)]
    public static float4_mt16 operator--(float4_mt16 a) => a - float_mt16.One;

    #endregion // Operators
}

#endregion // float4_mt16
#region float4_mt32

public partial struct float4_mt32
{
    #region Constants

    public static float4_mt32 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static float4_mt32 One
    {
        [MethodImpl(256 | 512)]
        get => new(1.0f);
    }

    public static float4_mt32 Two
    {
        [MethodImpl(256 | 512)]
        get => new(2.0f);
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static float4_mt32 operator-(float4_mt32 a) => new(-a.x, -a.y, -a.z, -a.w);

    [MethodImpl(256 | 512)]
    public static float4_mt32 operator+(float4_mt32 a, float4_mt32 b) => new(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt32 operator+(float4_mt32 a, float_mt32 b) => new(a.x + b, a.y + b, a.z + b, a.w + b);

    [MethodImpl(256 | 512)]
    public static float4_mt32 operator+(float_mt32 a, float4_mt32 b) => new(a + b.x, a + b.y, a + b.z, a + b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt32 operator-(float4_mt32 a, float4_mt32 b) => new(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt32 operator-(float4_mt32 a, float_mt32 b) => new(a.x - b, a.y - b, a.z - b, a.w - b);

    [MethodImpl(256 | 512)]
    public static float4_mt32 operator-(float_mt32 a, float4_mt32 b) => new(a - b.x, a - b.y, a - b.z, a - b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt32 operator*(float4_mt32 a, float4_mt32 b) => new(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt32 operator*(float4_mt32 a, float_mt32 b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static float4_mt32 operator*(float_mt32 a, float4_mt32 b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt32 operator*(float4_mt32 a, float b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static float4_mt32 operator*(float a, float4_mt32 b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt32 operator/(float4_mt32 a, float4_mt32 b) => new(a.w / b.w, a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static float4_mt32 operator/(float_mt32 a, float4_mt32 b) => new(a / b.w, a / b.z, a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static float4_mt32 operator/(float4_mt32 a, float_mt32 b) => new(a.w / b, a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static float4_mt32 operator/(float4_mt32 a, float b) => new(a.w / b, a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static float4_mt32 operator%(float4_mt32 a, float4_mt32 b) => new(a.w % b.w, a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static float4_mt32 operator%(float_mt32 a, float4_mt32 b) => new(a % b.w, a % b.z, a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static float4_mt32 operator%(float4_mt32 a, float_mt32 b) => new(a.w % b, a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static float4_mt32 operator%(float4_mt32 a, float b) => new(a.w % b, a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static float4_mt32 operator++(float4_mt32 a) => a + float_mt32.One;

    [MethodImpl(256 | 512)]
    public static float4_mt32 operator--(float4_mt32 a) => a - float_mt32.One;

    #endregion // Operators
}

#endregion // float4_mt32
#region double2_mt4

public partial struct double2_mt4
{
    #region Constants

    public static double2_mt4 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static double2_mt4 One
    {
        [MethodImpl(256 | 512)]
        get => new(1.0);
    }

    public static double2_mt4 Two
    {
        [MethodImpl(256 | 512)]
        get => new(2.0);
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static double2_mt4 operator-(double2_mt4 a) => new(-a.x, -a.y);

    [MethodImpl(256 | 512)]
    public static double2_mt4 operator+(double2_mt4 a, double2_mt4 b) => new(a.x + b.x, a.y + b.y);

    [MethodImpl(256 | 512)]
    public static double2_mt4 operator+(double2_mt4 a, double_mt4 b) => new(a.x + b, a.y + b);

    [MethodImpl(256 | 512)]
    public static double2_mt4 operator+(double_mt4 a, double2_mt4 b) => new(a + b.x, a + b.y);

    [MethodImpl(256 | 512)]
    public static double2_mt4 operator-(double2_mt4 a, double2_mt4 b) => new(a.x - b.x, a.y - b.y);

    [MethodImpl(256 | 512)]
    public static double2_mt4 operator-(double2_mt4 a, double_mt4 b) => new(a.x - b, a.y - b);

    [MethodImpl(256 | 512)]
    public static double2_mt4 operator-(double_mt4 a, double2_mt4 b) => new(a - b.x, a - b.y);

    [MethodImpl(256 | 512)]
    public static double2_mt4 operator*(double2_mt4 a, double2_mt4 b) => new(a.x * b.x, a.y * b.y);

    [MethodImpl(256 | 512)]
    public static double2_mt4 operator*(double2_mt4 a, double_mt4 b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static double2_mt4 operator*(double_mt4 a, double2_mt4 b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static double2_mt4 operator*(double2_mt4 a, double b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static double2_mt4 operator*(double a, double2_mt4 b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static double2_mt4 operator/(double2_mt4 a, double2_mt4 b) => new(a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static double2_mt4 operator/(double_mt4 a, double2_mt4 b) => new(a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static double2_mt4 operator/(double2_mt4 a, double_mt4 b) => new(a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static double2_mt4 operator/(double2_mt4 a, double b) => new(a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static double2_mt4 operator%(double2_mt4 a, double2_mt4 b) => new(a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static double2_mt4 operator%(double_mt4 a, double2_mt4 b) => new(a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static double2_mt4 operator%(double2_mt4 a, double_mt4 b) => new(a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static double2_mt4 operator%(double2_mt4 a, double b) => new(a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static double2_mt4 operator++(double2_mt4 a) => a + double_mt4.One;

    [MethodImpl(256 | 512)]
    public static double2_mt4 operator--(double2_mt4 a) => a - double_mt4.One;

    #endregion // Operators
}

#endregion // double2_mt4
#region double2_mt8

public partial struct double2_mt8
{
    #region Constants

    public static double2_mt8 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static double2_mt8 One
    {
        [MethodImpl(256 | 512)]
        get => new(1.0);
    }

    public static double2_mt8 Two
    {
        [MethodImpl(256 | 512)]
        get => new(2.0);
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static double2_mt8 operator-(double2_mt8 a) => new(-a.x, -a.y);

    [MethodImpl(256 | 512)]
    public static double2_mt8 operator+(double2_mt8 a, double2_mt8 b) => new(a.x + b.x, a.y + b.y);

    [MethodImpl(256 | 512)]
    public static double2_mt8 operator+(double2_mt8 a, double_mt8 b) => new(a.x + b, a.y + b);

    [MethodImpl(256 | 512)]
    public static double2_mt8 operator+(double_mt8 a, double2_mt8 b) => new(a + b.x, a + b.y);

    [MethodImpl(256 | 512)]
    public static double2_mt8 operator-(double2_mt8 a, double2_mt8 b) => new(a.x - b.x, a.y - b.y);

    [MethodImpl(256 | 512)]
    public static double2_mt8 operator-(double2_mt8 a, double_mt8 b) => new(a.x - b, a.y - b);

    [MethodImpl(256 | 512)]
    public static double2_mt8 operator-(double_mt8 a, double2_mt8 b) => new(a - b.x, a - b.y);

    [MethodImpl(256 | 512)]
    public static double2_mt8 operator*(double2_mt8 a, double2_mt8 b) => new(a.x * b.x, a.y * b.y);

    [MethodImpl(256 | 512)]
    public static double2_mt8 operator*(double2_mt8 a, double_mt8 b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static double2_mt8 operator*(double_mt8 a, double2_mt8 b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static double2_mt8 operator*(double2_mt8 a, double b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static double2_mt8 operator*(double a, double2_mt8 b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static double2_mt8 operator/(double2_mt8 a, double2_mt8 b) => new(a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static double2_mt8 operator/(double_mt8 a, double2_mt8 b) => new(a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static double2_mt8 operator/(double2_mt8 a, double_mt8 b) => new(a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static double2_mt8 operator/(double2_mt8 a, double b) => new(a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static double2_mt8 operator%(double2_mt8 a, double2_mt8 b) => new(a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static double2_mt8 operator%(double_mt8 a, double2_mt8 b) => new(a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static double2_mt8 operator%(double2_mt8 a, double_mt8 b) => new(a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static double2_mt8 operator%(double2_mt8 a, double b) => new(a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static double2_mt8 operator++(double2_mt8 a) => a + double_mt8.One;

    [MethodImpl(256 | 512)]
    public static double2_mt8 operator--(double2_mt8 a) => a - double_mt8.One;

    #endregion // Operators
}

#endregion // double2_mt8
#region double2_mt16

public partial struct double2_mt16
{
    #region Constants

    public static double2_mt16 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static double2_mt16 One
    {
        [MethodImpl(256 | 512)]
        get => new(1.0);
    }

    public static double2_mt16 Two
    {
        [MethodImpl(256 | 512)]
        get => new(2.0);
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static double2_mt16 operator-(double2_mt16 a) => new(-a.x, -a.y);

    [MethodImpl(256 | 512)]
    public static double2_mt16 operator+(double2_mt16 a, double2_mt16 b) => new(a.x + b.x, a.y + b.y);

    [MethodImpl(256 | 512)]
    public static double2_mt16 operator+(double2_mt16 a, double_mt16 b) => new(a.x + b, a.y + b);

    [MethodImpl(256 | 512)]
    public static double2_mt16 operator+(double_mt16 a, double2_mt16 b) => new(a + b.x, a + b.y);

    [MethodImpl(256 | 512)]
    public static double2_mt16 operator-(double2_mt16 a, double2_mt16 b) => new(a.x - b.x, a.y - b.y);

    [MethodImpl(256 | 512)]
    public static double2_mt16 operator-(double2_mt16 a, double_mt16 b) => new(a.x - b, a.y - b);

    [MethodImpl(256 | 512)]
    public static double2_mt16 operator-(double_mt16 a, double2_mt16 b) => new(a - b.x, a - b.y);

    [MethodImpl(256 | 512)]
    public static double2_mt16 operator*(double2_mt16 a, double2_mt16 b) => new(a.x * b.x, a.y * b.y);

    [MethodImpl(256 | 512)]
    public static double2_mt16 operator*(double2_mt16 a, double_mt16 b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static double2_mt16 operator*(double_mt16 a, double2_mt16 b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static double2_mt16 operator*(double2_mt16 a, double b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static double2_mt16 operator*(double a, double2_mt16 b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static double2_mt16 operator/(double2_mt16 a, double2_mt16 b) => new(a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static double2_mt16 operator/(double_mt16 a, double2_mt16 b) => new(a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static double2_mt16 operator/(double2_mt16 a, double_mt16 b) => new(a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static double2_mt16 operator/(double2_mt16 a, double b) => new(a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static double2_mt16 operator%(double2_mt16 a, double2_mt16 b) => new(a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static double2_mt16 operator%(double_mt16 a, double2_mt16 b) => new(a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static double2_mt16 operator%(double2_mt16 a, double_mt16 b) => new(a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static double2_mt16 operator%(double2_mt16 a, double b) => new(a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static double2_mt16 operator++(double2_mt16 a) => a + double_mt16.One;

    [MethodImpl(256 | 512)]
    public static double2_mt16 operator--(double2_mt16 a) => a - double_mt16.One;

    #endregion // Operators
}

#endregion // double2_mt16
#region double2_mt32

public partial struct double2_mt32
{
    #region Constants

    public static double2_mt32 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static double2_mt32 One
    {
        [MethodImpl(256 | 512)]
        get => new(1.0);
    }

    public static double2_mt32 Two
    {
        [MethodImpl(256 | 512)]
        get => new(2.0);
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static double2_mt32 operator-(double2_mt32 a) => new(-a.x, -a.y);

    [MethodImpl(256 | 512)]
    public static double2_mt32 operator+(double2_mt32 a, double2_mt32 b) => new(a.x + b.x, a.y + b.y);

    [MethodImpl(256 | 512)]
    public static double2_mt32 operator+(double2_mt32 a, double_mt32 b) => new(a.x + b, a.y + b);

    [MethodImpl(256 | 512)]
    public static double2_mt32 operator+(double_mt32 a, double2_mt32 b) => new(a + b.x, a + b.y);

    [MethodImpl(256 | 512)]
    public static double2_mt32 operator-(double2_mt32 a, double2_mt32 b) => new(a.x - b.x, a.y - b.y);

    [MethodImpl(256 | 512)]
    public static double2_mt32 operator-(double2_mt32 a, double_mt32 b) => new(a.x - b, a.y - b);

    [MethodImpl(256 | 512)]
    public static double2_mt32 operator-(double_mt32 a, double2_mt32 b) => new(a - b.x, a - b.y);

    [MethodImpl(256 | 512)]
    public static double2_mt32 operator*(double2_mt32 a, double2_mt32 b) => new(a.x * b.x, a.y * b.y);

    [MethodImpl(256 | 512)]
    public static double2_mt32 operator*(double2_mt32 a, double_mt32 b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static double2_mt32 operator*(double_mt32 a, double2_mt32 b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static double2_mt32 operator*(double2_mt32 a, double b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static double2_mt32 operator*(double a, double2_mt32 b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static double2_mt32 operator/(double2_mt32 a, double2_mt32 b) => new(a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static double2_mt32 operator/(double_mt32 a, double2_mt32 b) => new(a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static double2_mt32 operator/(double2_mt32 a, double_mt32 b) => new(a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static double2_mt32 operator/(double2_mt32 a, double b) => new(a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static double2_mt32 operator%(double2_mt32 a, double2_mt32 b) => new(a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static double2_mt32 operator%(double_mt32 a, double2_mt32 b) => new(a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static double2_mt32 operator%(double2_mt32 a, double_mt32 b) => new(a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static double2_mt32 operator%(double2_mt32 a, double b) => new(a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static double2_mt32 operator++(double2_mt32 a) => a + double_mt32.One;

    [MethodImpl(256 | 512)]
    public static double2_mt32 operator--(double2_mt32 a) => a - double_mt32.One;

    #endregion // Operators
}

#endregion // double2_mt32
#region double3_mt4

public partial struct double3_mt4
{
    #region Constants

    public static double3_mt4 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static double3_mt4 One
    {
        [MethodImpl(256 | 512)]
        get => new(1.0);
    }

    public static double3_mt4 Two
    {
        [MethodImpl(256 | 512)]
        get => new(2.0);
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static double3_mt4 operator-(double3_mt4 a) => new(-a.x, -a.y, -a.z);

    [MethodImpl(256 | 512)]
    public static double3_mt4 operator+(double3_mt4 a, double3_mt4 b) => new(a.x + b.x, a.y + b.y, a.z + b.z);

    [MethodImpl(256 | 512)]
    public static double3_mt4 operator+(double3_mt4 a, double_mt4 b) => new(a.x + b, a.y + b, a.z + b);

    [MethodImpl(256 | 512)]
    public static double3_mt4 operator+(double_mt4 a, double3_mt4 b) => new(a + b.x, a + b.y, a + b.z);

    [MethodImpl(256 | 512)]
    public static double3_mt4 operator-(double3_mt4 a, double3_mt4 b) => new(a.x - b.x, a.y - b.y, a.z - b.z);

    [MethodImpl(256 | 512)]
    public static double3_mt4 operator-(double3_mt4 a, double_mt4 b) => new(a.x - b, a.y - b, a.z - b);

    [MethodImpl(256 | 512)]
    public static double3_mt4 operator-(double_mt4 a, double3_mt4 b) => new(a - b.x, a - b.y, a - b.z);

    [MethodImpl(256 | 512)]
    public static double3_mt4 operator*(double3_mt4 a, double3_mt4 b) => new(a.x * b.x, a.y * b.y, a.z * b.z);

    [MethodImpl(256 | 512)]
    public static double3_mt4 operator*(double3_mt4 a, double_mt4 b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static double3_mt4 operator*(double_mt4 a, double3_mt4 b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static double3_mt4 operator*(double3_mt4 a, double b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static double3_mt4 operator*(double a, double3_mt4 b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static double3_mt4 operator/(double3_mt4 a, double3_mt4 b) => new(a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static double3_mt4 operator/(double_mt4 a, double3_mt4 b) => new(a / b.z, a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static double3_mt4 operator/(double3_mt4 a, double_mt4 b) => new(a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static double3_mt4 operator/(double3_mt4 a, double b) => new(a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static double3_mt4 operator%(double3_mt4 a, double3_mt4 b) => new(a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static double3_mt4 operator%(double_mt4 a, double3_mt4 b) => new(a % b.z, a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static double3_mt4 operator%(double3_mt4 a, double_mt4 b) => new(a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static double3_mt4 operator%(double3_mt4 a, double b) => new(a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static double3_mt4 operator++(double3_mt4 a) => a + double_mt4.One;

    [MethodImpl(256 | 512)]
    public static double3_mt4 operator--(double3_mt4 a) => a - double_mt4.One;

    #endregion // Operators
}

#endregion // double3_mt4
#region double3_mt8

public partial struct double3_mt8
{
    #region Constants

    public static double3_mt8 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static double3_mt8 One
    {
        [MethodImpl(256 | 512)]
        get => new(1.0);
    }

    public static double3_mt8 Two
    {
        [MethodImpl(256 | 512)]
        get => new(2.0);
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static double3_mt8 operator-(double3_mt8 a) => new(-a.x, -a.y, -a.z);

    [MethodImpl(256 | 512)]
    public static double3_mt8 operator+(double3_mt8 a, double3_mt8 b) => new(a.x + b.x, a.y + b.y, a.z + b.z);

    [MethodImpl(256 | 512)]
    public static double3_mt8 operator+(double3_mt8 a, double_mt8 b) => new(a.x + b, a.y + b, a.z + b);

    [MethodImpl(256 | 512)]
    public static double3_mt8 operator+(double_mt8 a, double3_mt8 b) => new(a + b.x, a + b.y, a + b.z);

    [MethodImpl(256 | 512)]
    public static double3_mt8 operator-(double3_mt8 a, double3_mt8 b) => new(a.x - b.x, a.y - b.y, a.z - b.z);

    [MethodImpl(256 | 512)]
    public static double3_mt8 operator-(double3_mt8 a, double_mt8 b) => new(a.x - b, a.y - b, a.z - b);

    [MethodImpl(256 | 512)]
    public static double3_mt8 operator-(double_mt8 a, double3_mt8 b) => new(a - b.x, a - b.y, a - b.z);

    [MethodImpl(256 | 512)]
    public static double3_mt8 operator*(double3_mt8 a, double3_mt8 b) => new(a.x * b.x, a.y * b.y, a.z * b.z);

    [MethodImpl(256 | 512)]
    public static double3_mt8 operator*(double3_mt8 a, double_mt8 b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static double3_mt8 operator*(double_mt8 a, double3_mt8 b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static double3_mt8 operator*(double3_mt8 a, double b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static double3_mt8 operator*(double a, double3_mt8 b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static double3_mt8 operator/(double3_mt8 a, double3_mt8 b) => new(a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static double3_mt8 operator/(double_mt8 a, double3_mt8 b) => new(a / b.z, a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static double3_mt8 operator/(double3_mt8 a, double_mt8 b) => new(a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static double3_mt8 operator/(double3_mt8 a, double b) => new(a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static double3_mt8 operator%(double3_mt8 a, double3_mt8 b) => new(a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static double3_mt8 operator%(double_mt8 a, double3_mt8 b) => new(a % b.z, a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static double3_mt8 operator%(double3_mt8 a, double_mt8 b) => new(a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static double3_mt8 operator%(double3_mt8 a, double b) => new(a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static double3_mt8 operator++(double3_mt8 a) => a + double_mt8.One;

    [MethodImpl(256 | 512)]
    public static double3_mt8 operator--(double3_mt8 a) => a - double_mt8.One;

    #endregion // Operators
}

#endregion // double3_mt8
#region double3_mt16

public partial struct double3_mt16
{
    #region Constants

    public static double3_mt16 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static double3_mt16 One
    {
        [MethodImpl(256 | 512)]
        get => new(1.0);
    }

    public static double3_mt16 Two
    {
        [MethodImpl(256 | 512)]
        get => new(2.0);
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static double3_mt16 operator-(double3_mt16 a) => new(-a.x, -a.y, -a.z);

    [MethodImpl(256 | 512)]
    public static double3_mt16 operator+(double3_mt16 a, double3_mt16 b) => new(a.x + b.x, a.y + b.y, a.z + b.z);

    [MethodImpl(256 | 512)]
    public static double3_mt16 operator+(double3_mt16 a, double_mt16 b) => new(a.x + b, a.y + b, a.z + b);

    [MethodImpl(256 | 512)]
    public static double3_mt16 operator+(double_mt16 a, double3_mt16 b) => new(a + b.x, a + b.y, a + b.z);

    [MethodImpl(256 | 512)]
    public static double3_mt16 operator-(double3_mt16 a, double3_mt16 b) => new(a.x - b.x, a.y - b.y, a.z - b.z);

    [MethodImpl(256 | 512)]
    public static double3_mt16 operator-(double3_mt16 a, double_mt16 b) => new(a.x - b, a.y - b, a.z - b);

    [MethodImpl(256 | 512)]
    public static double3_mt16 operator-(double_mt16 a, double3_mt16 b) => new(a - b.x, a - b.y, a - b.z);

    [MethodImpl(256 | 512)]
    public static double3_mt16 operator*(double3_mt16 a, double3_mt16 b) => new(a.x * b.x, a.y * b.y, a.z * b.z);

    [MethodImpl(256 | 512)]
    public static double3_mt16 operator*(double3_mt16 a, double_mt16 b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static double3_mt16 operator*(double_mt16 a, double3_mt16 b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static double3_mt16 operator*(double3_mt16 a, double b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static double3_mt16 operator*(double a, double3_mt16 b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static double3_mt16 operator/(double3_mt16 a, double3_mt16 b) => new(a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static double3_mt16 operator/(double_mt16 a, double3_mt16 b) => new(a / b.z, a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static double3_mt16 operator/(double3_mt16 a, double_mt16 b) => new(a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static double3_mt16 operator/(double3_mt16 a, double b) => new(a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static double3_mt16 operator%(double3_mt16 a, double3_mt16 b) => new(a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static double3_mt16 operator%(double_mt16 a, double3_mt16 b) => new(a % b.z, a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static double3_mt16 operator%(double3_mt16 a, double_mt16 b) => new(a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static double3_mt16 operator%(double3_mt16 a, double b) => new(a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static double3_mt16 operator++(double3_mt16 a) => a + double_mt16.One;

    [MethodImpl(256 | 512)]
    public static double3_mt16 operator--(double3_mt16 a) => a - double_mt16.One;

    #endregion // Operators
}

#endregion // double3_mt16
#region double3_mt32

public partial struct double3_mt32
{
    #region Constants

    public static double3_mt32 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static double3_mt32 One
    {
        [MethodImpl(256 | 512)]
        get => new(1.0);
    }

    public static double3_mt32 Two
    {
        [MethodImpl(256 | 512)]
        get => new(2.0);
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static double3_mt32 operator-(double3_mt32 a) => new(-a.x, -a.y, -a.z);

    [MethodImpl(256 | 512)]
    public static double3_mt32 operator+(double3_mt32 a, double3_mt32 b) => new(a.x + b.x, a.y + b.y, a.z + b.z);

    [MethodImpl(256 | 512)]
    public static double3_mt32 operator+(double3_mt32 a, double_mt32 b) => new(a.x + b, a.y + b, a.z + b);

    [MethodImpl(256 | 512)]
    public static double3_mt32 operator+(double_mt32 a, double3_mt32 b) => new(a + b.x, a + b.y, a + b.z);

    [MethodImpl(256 | 512)]
    public static double3_mt32 operator-(double3_mt32 a, double3_mt32 b) => new(a.x - b.x, a.y - b.y, a.z - b.z);

    [MethodImpl(256 | 512)]
    public static double3_mt32 operator-(double3_mt32 a, double_mt32 b) => new(a.x - b, a.y - b, a.z - b);

    [MethodImpl(256 | 512)]
    public static double3_mt32 operator-(double_mt32 a, double3_mt32 b) => new(a - b.x, a - b.y, a - b.z);

    [MethodImpl(256 | 512)]
    public static double3_mt32 operator*(double3_mt32 a, double3_mt32 b) => new(a.x * b.x, a.y * b.y, a.z * b.z);

    [MethodImpl(256 | 512)]
    public static double3_mt32 operator*(double3_mt32 a, double_mt32 b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static double3_mt32 operator*(double_mt32 a, double3_mt32 b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static double3_mt32 operator*(double3_mt32 a, double b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static double3_mt32 operator*(double a, double3_mt32 b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static double3_mt32 operator/(double3_mt32 a, double3_mt32 b) => new(a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static double3_mt32 operator/(double_mt32 a, double3_mt32 b) => new(a / b.z, a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static double3_mt32 operator/(double3_mt32 a, double_mt32 b) => new(a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static double3_mt32 operator/(double3_mt32 a, double b) => new(a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static double3_mt32 operator%(double3_mt32 a, double3_mt32 b) => new(a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static double3_mt32 operator%(double_mt32 a, double3_mt32 b) => new(a % b.z, a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static double3_mt32 operator%(double3_mt32 a, double_mt32 b) => new(a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static double3_mt32 operator%(double3_mt32 a, double b) => new(a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static double3_mt32 operator++(double3_mt32 a) => a + double_mt32.One;

    [MethodImpl(256 | 512)]
    public static double3_mt32 operator--(double3_mt32 a) => a - double_mt32.One;

    #endregion // Operators
}

#endregion // double3_mt32
#region double4_mt4

public partial struct double4_mt4
{
    #region Constants

    public static double4_mt4 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static double4_mt4 One
    {
        [MethodImpl(256 | 512)]
        get => new(1.0);
    }

    public static double4_mt4 Two
    {
        [MethodImpl(256 | 512)]
        get => new(2.0);
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static double4_mt4 operator-(double4_mt4 a) => new(-a.x, -a.y, -a.z, -a.w);

    [MethodImpl(256 | 512)]
    public static double4_mt4 operator+(double4_mt4 a, double4_mt4 b) => new(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);

    [MethodImpl(256 | 512)]
    public static double4_mt4 operator+(double4_mt4 a, double_mt4 b) => new(a.x + b, a.y + b, a.z + b, a.w + b);

    [MethodImpl(256 | 512)]
    public static double4_mt4 operator+(double_mt4 a, double4_mt4 b) => new(a + b.x, a + b.y, a + b.z, a + b.w);

    [MethodImpl(256 | 512)]
    public static double4_mt4 operator-(double4_mt4 a, double4_mt4 b) => new(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);

    [MethodImpl(256 | 512)]
    public static double4_mt4 operator-(double4_mt4 a, double_mt4 b) => new(a.x - b, a.y - b, a.z - b, a.w - b);

    [MethodImpl(256 | 512)]
    public static double4_mt4 operator-(double_mt4 a, double4_mt4 b) => new(a - b.x, a - b.y, a - b.z, a - b.w);

    [MethodImpl(256 | 512)]
    public static double4_mt4 operator*(double4_mt4 a, double4_mt4 b) => new(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);

    [MethodImpl(256 | 512)]
    public static double4_mt4 operator*(double4_mt4 a, double_mt4 b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static double4_mt4 operator*(double_mt4 a, double4_mt4 b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static double4_mt4 operator*(double4_mt4 a, double b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static double4_mt4 operator*(double a, double4_mt4 b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static double4_mt4 operator/(double4_mt4 a, double4_mt4 b) => new(a.w / b.w, a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static double4_mt4 operator/(double_mt4 a, double4_mt4 b) => new(a / b.w, a / b.z, a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static double4_mt4 operator/(double4_mt4 a, double_mt4 b) => new(a.w / b, a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static double4_mt4 operator/(double4_mt4 a, double b) => new(a.w / b, a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static double4_mt4 operator%(double4_mt4 a, double4_mt4 b) => new(a.w % b.w, a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static double4_mt4 operator%(double_mt4 a, double4_mt4 b) => new(a % b.w, a % b.z, a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static double4_mt4 operator%(double4_mt4 a, double_mt4 b) => new(a.w % b, a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static double4_mt4 operator%(double4_mt4 a, double b) => new(a.w % b, a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static double4_mt4 operator++(double4_mt4 a) => a + double_mt4.One;

    [MethodImpl(256 | 512)]
    public static double4_mt4 operator--(double4_mt4 a) => a - double_mt4.One;

    #endregion // Operators
}

#endregion // double4_mt4
#region double4_mt8

public partial struct double4_mt8
{
    #region Constants

    public static double4_mt8 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static double4_mt8 One
    {
        [MethodImpl(256 | 512)]
        get => new(1.0);
    }

    public static double4_mt8 Two
    {
        [MethodImpl(256 | 512)]
        get => new(2.0);
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static double4_mt8 operator-(double4_mt8 a) => new(-a.x, -a.y, -a.z, -a.w);

    [MethodImpl(256 | 512)]
    public static double4_mt8 operator+(double4_mt8 a, double4_mt8 b) => new(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);

    [MethodImpl(256 | 512)]
    public static double4_mt8 operator+(double4_mt8 a, double_mt8 b) => new(a.x + b, a.y + b, a.z + b, a.w + b);

    [MethodImpl(256 | 512)]
    public static double4_mt8 operator+(double_mt8 a, double4_mt8 b) => new(a + b.x, a + b.y, a + b.z, a + b.w);

    [MethodImpl(256 | 512)]
    public static double4_mt8 operator-(double4_mt8 a, double4_mt8 b) => new(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);

    [MethodImpl(256 | 512)]
    public static double4_mt8 operator-(double4_mt8 a, double_mt8 b) => new(a.x - b, a.y - b, a.z - b, a.w - b);

    [MethodImpl(256 | 512)]
    public static double4_mt8 operator-(double_mt8 a, double4_mt8 b) => new(a - b.x, a - b.y, a - b.z, a - b.w);

    [MethodImpl(256 | 512)]
    public static double4_mt8 operator*(double4_mt8 a, double4_mt8 b) => new(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);

    [MethodImpl(256 | 512)]
    public static double4_mt8 operator*(double4_mt8 a, double_mt8 b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static double4_mt8 operator*(double_mt8 a, double4_mt8 b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static double4_mt8 operator*(double4_mt8 a, double b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static double4_mt8 operator*(double a, double4_mt8 b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static double4_mt8 operator/(double4_mt8 a, double4_mt8 b) => new(a.w / b.w, a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static double4_mt8 operator/(double_mt8 a, double4_mt8 b) => new(a / b.w, a / b.z, a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static double4_mt8 operator/(double4_mt8 a, double_mt8 b) => new(a.w / b, a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static double4_mt8 operator/(double4_mt8 a, double b) => new(a.w / b, a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static double4_mt8 operator%(double4_mt8 a, double4_mt8 b) => new(a.w % b.w, a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static double4_mt8 operator%(double_mt8 a, double4_mt8 b) => new(a % b.w, a % b.z, a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static double4_mt8 operator%(double4_mt8 a, double_mt8 b) => new(a.w % b, a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static double4_mt8 operator%(double4_mt8 a, double b) => new(a.w % b, a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static double4_mt8 operator++(double4_mt8 a) => a + double_mt8.One;

    [MethodImpl(256 | 512)]
    public static double4_mt8 operator--(double4_mt8 a) => a - double_mt8.One;

    #endregion // Operators
}

#endregion // double4_mt8
#region double4_mt16

public partial struct double4_mt16
{
    #region Constants

    public static double4_mt16 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static double4_mt16 One
    {
        [MethodImpl(256 | 512)]
        get => new(1.0);
    }

    public static double4_mt16 Two
    {
        [MethodImpl(256 | 512)]
        get => new(2.0);
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static double4_mt16 operator-(double4_mt16 a) => new(-a.x, -a.y, -a.z, -a.w);

    [MethodImpl(256 | 512)]
    public static double4_mt16 operator+(double4_mt16 a, double4_mt16 b) => new(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);

    [MethodImpl(256 | 512)]
    public static double4_mt16 operator+(double4_mt16 a, double_mt16 b) => new(a.x + b, a.y + b, a.z + b, a.w + b);

    [MethodImpl(256 | 512)]
    public static double4_mt16 operator+(double_mt16 a, double4_mt16 b) => new(a + b.x, a + b.y, a + b.z, a + b.w);

    [MethodImpl(256 | 512)]
    public static double4_mt16 operator-(double4_mt16 a, double4_mt16 b) => new(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);

    [MethodImpl(256 | 512)]
    public static double4_mt16 operator-(double4_mt16 a, double_mt16 b) => new(a.x - b, a.y - b, a.z - b, a.w - b);

    [MethodImpl(256 | 512)]
    public static double4_mt16 operator-(double_mt16 a, double4_mt16 b) => new(a - b.x, a - b.y, a - b.z, a - b.w);

    [MethodImpl(256 | 512)]
    public static double4_mt16 operator*(double4_mt16 a, double4_mt16 b) => new(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);

    [MethodImpl(256 | 512)]
    public static double4_mt16 operator*(double4_mt16 a, double_mt16 b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static double4_mt16 operator*(double_mt16 a, double4_mt16 b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static double4_mt16 operator*(double4_mt16 a, double b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static double4_mt16 operator*(double a, double4_mt16 b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static double4_mt16 operator/(double4_mt16 a, double4_mt16 b) => new(a.w / b.w, a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static double4_mt16 operator/(double_mt16 a, double4_mt16 b) => new(a / b.w, a / b.z, a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static double4_mt16 operator/(double4_mt16 a, double_mt16 b) => new(a.w / b, a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static double4_mt16 operator/(double4_mt16 a, double b) => new(a.w / b, a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static double4_mt16 operator%(double4_mt16 a, double4_mt16 b) => new(a.w % b.w, a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static double4_mt16 operator%(double_mt16 a, double4_mt16 b) => new(a % b.w, a % b.z, a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static double4_mt16 operator%(double4_mt16 a, double_mt16 b) => new(a.w % b, a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static double4_mt16 operator%(double4_mt16 a, double b) => new(a.w % b, a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static double4_mt16 operator++(double4_mt16 a) => a + double_mt16.One;

    [MethodImpl(256 | 512)]
    public static double4_mt16 operator--(double4_mt16 a) => a - double_mt16.One;

    #endregion // Operators
}

#endregion // double4_mt16
#region double4_mt32

public partial struct double4_mt32
{
    #region Constants

    public static double4_mt32 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static double4_mt32 One
    {
        [MethodImpl(256 | 512)]
        get => new(1.0);
    }

    public static double4_mt32 Two
    {
        [MethodImpl(256 | 512)]
        get => new(2.0);
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static double4_mt32 operator-(double4_mt32 a) => new(-a.x, -a.y, -a.z, -a.w);

    [MethodImpl(256 | 512)]
    public static double4_mt32 operator+(double4_mt32 a, double4_mt32 b) => new(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);

    [MethodImpl(256 | 512)]
    public static double4_mt32 operator+(double4_mt32 a, double_mt32 b) => new(a.x + b, a.y + b, a.z + b, a.w + b);

    [MethodImpl(256 | 512)]
    public static double4_mt32 operator+(double_mt32 a, double4_mt32 b) => new(a + b.x, a + b.y, a + b.z, a + b.w);

    [MethodImpl(256 | 512)]
    public static double4_mt32 operator-(double4_mt32 a, double4_mt32 b) => new(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);

    [MethodImpl(256 | 512)]
    public static double4_mt32 operator-(double4_mt32 a, double_mt32 b) => new(a.x - b, a.y - b, a.z - b, a.w - b);

    [MethodImpl(256 | 512)]
    public static double4_mt32 operator-(double_mt32 a, double4_mt32 b) => new(a - b.x, a - b.y, a - b.z, a - b.w);

    [MethodImpl(256 | 512)]
    public static double4_mt32 operator*(double4_mt32 a, double4_mt32 b) => new(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);

    [MethodImpl(256 | 512)]
    public static double4_mt32 operator*(double4_mt32 a, double_mt32 b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static double4_mt32 operator*(double_mt32 a, double4_mt32 b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static double4_mt32 operator*(double4_mt32 a, double b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static double4_mt32 operator*(double a, double4_mt32 b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static double4_mt32 operator/(double4_mt32 a, double4_mt32 b) => new(a.w / b.w, a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static double4_mt32 operator/(double_mt32 a, double4_mt32 b) => new(a / b.w, a / b.z, a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static double4_mt32 operator/(double4_mt32 a, double_mt32 b) => new(a.w / b, a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static double4_mt32 operator/(double4_mt32 a, double b) => new(a.w / b, a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static double4_mt32 operator%(double4_mt32 a, double4_mt32 b) => new(a.w % b.w, a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static double4_mt32 operator%(double_mt32 a, double4_mt32 b) => new(a % b.w, a % b.z, a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static double4_mt32 operator%(double4_mt32 a, double_mt32 b) => new(a.w % b, a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static double4_mt32 operator%(double4_mt32 a, double b) => new(a.w % b, a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static double4_mt32 operator++(double4_mt32 a) => a + double_mt32.One;

    [MethodImpl(256 | 512)]
    public static double4_mt32 operator--(double4_mt32 a) => a - double_mt32.One;

    #endregion // Operators
}

#endregion // double4_mt32
#region int2_mt4

public partial struct int2_mt4
{
    #region Constants

    public static int2_mt4 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static int2_mt4 One
    {
        [MethodImpl(256 | 512)]
        get => new(1);
    }

    public static int2_mt4 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1 + 1));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static int2_mt4 operator-(int2_mt4 a) => new(-a.x, -a.y);

    [MethodImpl(256 | 512)]
    public static int2_mt4 operator+(int2_mt4 a, int2_mt4 b) => new(a.x + b.x, a.y + b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt4 operator+(int2_mt4 a, int_mt4 b) => new(a.x + b, a.y + b);

    [MethodImpl(256 | 512)]
    public static int2_mt4 operator+(int_mt4 a, int2_mt4 b) => new(a + b.x, a + b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt4 operator-(int2_mt4 a, int2_mt4 b) => new(a.x - b.x, a.y - b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt4 operator-(int2_mt4 a, int_mt4 b) => new(a.x - b, a.y - b);

    [MethodImpl(256 | 512)]
    public static int2_mt4 operator-(int_mt4 a, int2_mt4 b) => new(a - b.x, a - b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt4 operator*(int2_mt4 a, int2_mt4 b) => new(a.x * b.x, a.y * b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt4 operator*(int2_mt4 a, int_mt4 b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static int2_mt4 operator*(int_mt4 a, int2_mt4 b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt4 operator*(int2_mt4 a, int b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static int2_mt4 operator*(int a, int2_mt4 b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt4 operator/(int2_mt4 a, int2_mt4 b) => new(a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static int2_mt4 operator/(int_mt4 a, int2_mt4 b) => new(a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static int2_mt4 operator/(int2_mt4 a, int_mt4 b) => new(a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static int2_mt4 operator/(int2_mt4 a, int b) => new(a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static int2_mt4 operator%(int2_mt4 a, int2_mt4 b) => new(a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static int2_mt4 operator%(int_mt4 a, int2_mt4 b) => new(a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static int2_mt4 operator%(int2_mt4 a, int_mt4 b) => new(a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static int2_mt4 operator%(int2_mt4 a, int b) => new(a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static int2_mt4 operator++(int2_mt4 a) => a + int_mt4.One;

    [MethodImpl(256 | 512)]
    public static int2_mt4 operator--(int2_mt4 a) => a - int_mt4.One;

    #endregion // Operators
}

#endregion // int2_mt4
#region int2_mt8

public partial struct int2_mt8
{
    #region Constants

    public static int2_mt8 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static int2_mt8 One
    {
        [MethodImpl(256 | 512)]
        get => new(1);
    }

    public static int2_mt8 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1 + 1));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static int2_mt8 operator-(int2_mt8 a) => new(-a.x, -a.y);

    [MethodImpl(256 | 512)]
    public static int2_mt8 operator+(int2_mt8 a, int2_mt8 b) => new(a.x + b.x, a.y + b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt8 operator+(int2_mt8 a, int_mt8 b) => new(a.x + b, a.y + b);

    [MethodImpl(256 | 512)]
    public static int2_mt8 operator+(int_mt8 a, int2_mt8 b) => new(a + b.x, a + b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt8 operator-(int2_mt8 a, int2_mt8 b) => new(a.x - b.x, a.y - b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt8 operator-(int2_mt8 a, int_mt8 b) => new(a.x - b, a.y - b);

    [MethodImpl(256 | 512)]
    public static int2_mt8 operator-(int_mt8 a, int2_mt8 b) => new(a - b.x, a - b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt8 operator*(int2_mt8 a, int2_mt8 b) => new(a.x * b.x, a.y * b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt8 operator*(int2_mt8 a, int_mt8 b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static int2_mt8 operator*(int_mt8 a, int2_mt8 b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt8 operator*(int2_mt8 a, int b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static int2_mt8 operator*(int a, int2_mt8 b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt8 operator/(int2_mt8 a, int2_mt8 b) => new(a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static int2_mt8 operator/(int_mt8 a, int2_mt8 b) => new(a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static int2_mt8 operator/(int2_mt8 a, int_mt8 b) => new(a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static int2_mt8 operator/(int2_mt8 a, int b) => new(a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static int2_mt8 operator%(int2_mt8 a, int2_mt8 b) => new(a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static int2_mt8 operator%(int_mt8 a, int2_mt8 b) => new(a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static int2_mt8 operator%(int2_mt8 a, int_mt8 b) => new(a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static int2_mt8 operator%(int2_mt8 a, int b) => new(a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static int2_mt8 operator++(int2_mt8 a) => a + int_mt8.One;

    [MethodImpl(256 | 512)]
    public static int2_mt8 operator--(int2_mt8 a) => a - int_mt8.One;

    #endregion // Operators
}

#endregion // int2_mt8
#region int2_mt16

public partial struct int2_mt16
{
    #region Constants

    public static int2_mt16 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static int2_mt16 One
    {
        [MethodImpl(256 | 512)]
        get => new(1);
    }

    public static int2_mt16 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1 + 1));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static int2_mt16 operator-(int2_mt16 a) => new(-a.x, -a.y);

    [MethodImpl(256 | 512)]
    public static int2_mt16 operator+(int2_mt16 a, int2_mt16 b) => new(a.x + b.x, a.y + b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt16 operator+(int2_mt16 a, int_mt16 b) => new(a.x + b, a.y + b);

    [MethodImpl(256 | 512)]
    public static int2_mt16 operator+(int_mt16 a, int2_mt16 b) => new(a + b.x, a + b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt16 operator-(int2_mt16 a, int2_mt16 b) => new(a.x - b.x, a.y - b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt16 operator-(int2_mt16 a, int_mt16 b) => new(a.x - b, a.y - b);

    [MethodImpl(256 | 512)]
    public static int2_mt16 operator-(int_mt16 a, int2_mt16 b) => new(a - b.x, a - b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt16 operator*(int2_mt16 a, int2_mt16 b) => new(a.x * b.x, a.y * b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt16 operator*(int2_mt16 a, int_mt16 b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static int2_mt16 operator*(int_mt16 a, int2_mt16 b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt16 operator*(int2_mt16 a, int b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static int2_mt16 operator*(int a, int2_mt16 b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt16 operator/(int2_mt16 a, int2_mt16 b) => new(a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static int2_mt16 operator/(int_mt16 a, int2_mt16 b) => new(a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static int2_mt16 operator/(int2_mt16 a, int_mt16 b) => new(a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static int2_mt16 operator/(int2_mt16 a, int b) => new(a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static int2_mt16 operator%(int2_mt16 a, int2_mt16 b) => new(a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static int2_mt16 operator%(int_mt16 a, int2_mt16 b) => new(a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static int2_mt16 operator%(int2_mt16 a, int_mt16 b) => new(a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static int2_mt16 operator%(int2_mt16 a, int b) => new(a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static int2_mt16 operator++(int2_mt16 a) => a + int_mt16.One;

    [MethodImpl(256 | 512)]
    public static int2_mt16 operator--(int2_mt16 a) => a - int_mt16.One;

    #endregion // Operators
}

#endregion // int2_mt16
#region int2_mt32

public partial struct int2_mt32
{
    #region Constants

    public static int2_mt32 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static int2_mt32 One
    {
        [MethodImpl(256 | 512)]
        get => new(1);
    }

    public static int2_mt32 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1 + 1));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static int2_mt32 operator-(int2_mt32 a) => new(-a.x, -a.y);

    [MethodImpl(256 | 512)]
    public static int2_mt32 operator+(int2_mt32 a, int2_mt32 b) => new(a.x + b.x, a.y + b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt32 operator+(int2_mt32 a, int_mt32 b) => new(a.x + b, a.y + b);

    [MethodImpl(256 | 512)]
    public static int2_mt32 operator+(int_mt32 a, int2_mt32 b) => new(a + b.x, a + b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt32 operator-(int2_mt32 a, int2_mt32 b) => new(a.x - b.x, a.y - b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt32 operator-(int2_mt32 a, int_mt32 b) => new(a.x - b, a.y - b);

    [MethodImpl(256 | 512)]
    public static int2_mt32 operator-(int_mt32 a, int2_mt32 b) => new(a - b.x, a - b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt32 operator*(int2_mt32 a, int2_mt32 b) => new(a.x * b.x, a.y * b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt32 operator*(int2_mt32 a, int_mt32 b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static int2_mt32 operator*(int_mt32 a, int2_mt32 b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt32 operator*(int2_mt32 a, int b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static int2_mt32 operator*(int a, int2_mt32 b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt32 operator/(int2_mt32 a, int2_mt32 b) => new(a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static int2_mt32 operator/(int_mt32 a, int2_mt32 b) => new(a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static int2_mt32 operator/(int2_mt32 a, int_mt32 b) => new(a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static int2_mt32 operator/(int2_mt32 a, int b) => new(a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static int2_mt32 operator%(int2_mt32 a, int2_mt32 b) => new(a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static int2_mt32 operator%(int_mt32 a, int2_mt32 b) => new(a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static int2_mt32 operator%(int2_mt32 a, int_mt32 b) => new(a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static int2_mt32 operator%(int2_mt32 a, int b) => new(a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static int2_mt32 operator++(int2_mt32 a) => a + int_mt32.One;

    [MethodImpl(256 | 512)]
    public static int2_mt32 operator--(int2_mt32 a) => a - int_mt32.One;

    #endregion // Operators
}

#endregion // int2_mt32
#region int3_mt4

public partial struct int3_mt4
{
    #region Constants

    public static int3_mt4 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static int3_mt4 One
    {
        [MethodImpl(256 | 512)]
        get => new(1);
    }

    public static int3_mt4 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1 + 1));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static int3_mt4 operator-(int3_mt4 a) => new(-a.x, -a.y, -a.z);

    [MethodImpl(256 | 512)]
    public static int3_mt4 operator+(int3_mt4 a, int3_mt4 b) => new(a.x + b.x, a.y + b.y, a.z + b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt4 operator+(int3_mt4 a, int_mt4 b) => new(a.x + b, a.y + b, a.z + b);

    [MethodImpl(256 | 512)]
    public static int3_mt4 operator+(int_mt4 a, int3_mt4 b) => new(a + b.x, a + b.y, a + b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt4 operator-(int3_mt4 a, int3_mt4 b) => new(a.x - b.x, a.y - b.y, a.z - b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt4 operator-(int3_mt4 a, int_mt4 b) => new(a.x - b, a.y - b, a.z - b);

    [MethodImpl(256 | 512)]
    public static int3_mt4 operator-(int_mt4 a, int3_mt4 b) => new(a - b.x, a - b.y, a - b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt4 operator*(int3_mt4 a, int3_mt4 b) => new(a.x * b.x, a.y * b.y, a.z * b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt4 operator*(int3_mt4 a, int_mt4 b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static int3_mt4 operator*(int_mt4 a, int3_mt4 b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt4 operator*(int3_mt4 a, int b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static int3_mt4 operator*(int a, int3_mt4 b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt4 operator/(int3_mt4 a, int3_mt4 b) => new(a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static int3_mt4 operator/(int_mt4 a, int3_mt4 b) => new(a / b.z, a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static int3_mt4 operator/(int3_mt4 a, int_mt4 b) => new(a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static int3_mt4 operator/(int3_mt4 a, int b) => new(a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static int3_mt4 operator%(int3_mt4 a, int3_mt4 b) => new(a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static int3_mt4 operator%(int_mt4 a, int3_mt4 b) => new(a % b.z, a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static int3_mt4 operator%(int3_mt4 a, int_mt4 b) => new(a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static int3_mt4 operator%(int3_mt4 a, int b) => new(a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static int3_mt4 operator++(int3_mt4 a) => a + int_mt4.One;

    [MethodImpl(256 | 512)]
    public static int3_mt4 operator--(int3_mt4 a) => a - int_mt4.One;

    #endregion // Operators
}

#endregion // int3_mt4
#region int3_mt8

public partial struct int3_mt8
{
    #region Constants

    public static int3_mt8 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static int3_mt8 One
    {
        [MethodImpl(256 | 512)]
        get => new(1);
    }

    public static int3_mt8 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1 + 1));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static int3_mt8 operator-(int3_mt8 a) => new(-a.x, -a.y, -a.z);

    [MethodImpl(256 | 512)]
    public static int3_mt8 operator+(int3_mt8 a, int3_mt8 b) => new(a.x + b.x, a.y + b.y, a.z + b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt8 operator+(int3_mt8 a, int_mt8 b) => new(a.x + b, a.y + b, a.z + b);

    [MethodImpl(256 | 512)]
    public static int3_mt8 operator+(int_mt8 a, int3_mt8 b) => new(a + b.x, a + b.y, a + b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt8 operator-(int3_mt8 a, int3_mt8 b) => new(a.x - b.x, a.y - b.y, a.z - b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt8 operator-(int3_mt8 a, int_mt8 b) => new(a.x - b, a.y - b, a.z - b);

    [MethodImpl(256 | 512)]
    public static int3_mt8 operator-(int_mt8 a, int3_mt8 b) => new(a - b.x, a - b.y, a - b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt8 operator*(int3_mt8 a, int3_mt8 b) => new(a.x * b.x, a.y * b.y, a.z * b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt8 operator*(int3_mt8 a, int_mt8 b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static int3_mt8 operator*(int_mt8 a, int3_mt8 b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt8 operator*(int3_mt8 a, int b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static int3_mt8 operator*(int a, int3_mt8 b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt8 operator/(int3_mt8 a, int3_mt8 b) => new(a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static int3_mt8 operator/(int_mt8 a, int3_mt8 b) => new(a / b.z, a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static int3_mt8 operator/(int3_mt8 a, int_mt8 b) => new(a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static int3_mt8 operator/(int3_mt8 a, int b) => new(a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static int3_mt8 operator%(int3_mt8 a, int3_mt8 b) => new(a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static int3_mt8 operator%(int_mt8 a, int3_mt8 b) => new(a % b.z, a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static int3_mt8 operator%(int3_mt8 a, int_mt8 b) => new(a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static int3_mt8 operator%(int3_mt8 a, int b) => new(a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static int3_mt8 operator++(int3_mt8 a) => a + int_mt8.One;

    [MethodImpl(256 | 512)]
    public static int3_mt8 operator--(int3_mt8 a) => a - int_mt8.One;

    #endregion // Operators
}

#endregion // int3_mt8
#region int3_mt16

public partial struct int3_mt16
{
    #region Constants

    public static int3_mt16 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static int3_mt16 One
    {
        [MethodImpl(256 | 512)]
        get => new(1);
    }

    public static int3_mt16 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1 + 1));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static int3_mt16 operator-(int3_mt16 a) => new(-a.x, -a.y, -a.z);

    [MethodImpl(256 | 512)]
    public static int3_mt16 operator+(int3_mt16 a, int3_mt16 b) => new(a.x + b.x, a.y + b.y, a.z + b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt16 operator+(int3_mt16 a, int_mt16 b) => new(a.x + b, a.y + b, a.z + b);

    [MethodImpl(256 | 512)]
    public static int3_mt16 operator+(int_mt16 a, int3_mt16 b) => new(a + b.x, a + b.y, a + b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt16 operator-(int3_mt16 a, int3_mt16 b) => new(a.x - b.x, a.y - b.y, a.z - b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt16 operator-(int3_mt16 a, int_mt16 b) => new(a.x - b, a.y - b, a.z - b);

    [MethodImpl(256 | 512)]
    public static int3_mt16 operator-(int_mt16 a, int3_mt16 b) => new(a - b.x, a - b.y, a - b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt16 operator*(int3_mt16 a, int3_mt16 b) => new(a.x * b.x, a.y * b.y, a.z * b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt16 operator*(int3_mt16 a, int_mt16 b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static int3_mt16 operator*(int_mt16 a, int3_mt16 b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt16 operator*(int3_mt16 a, int b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static int3_mt16 operator*(int a, int3_mt16 b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt16 operator/(int3_mt16 a, int3_mt16 b) => new(a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static int3_mt16 operator/(int_mt16 a, int3_mt16 b) => new(a / b.z, a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static int3_mt16 operator/(int3_mt16 a, int_mt16 b) => new(a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static int3_mt16 operator/(int3_mt16 a, int b) => new(a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static int3_mt16 operator%(int3_mt16 a, int3_mt16 b) => new(a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static int3_mt16 operator%(int_mt16 a, int3_mt16 b) => new(a % b.z, a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static int3_mt16 operator%(int3_mt16 a, int_mt16 b) => new(a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static int3_mt16 operator%(int3_mt16 a, int b) => new(a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static int3_mt16 operator++(int3_mt16 a) => a + int_mt16.One;

    [MethodImpl(256 | 512)]
    public static int3_mt16 operator--(int3_mt16 a) => a - int_mt16.One;

    #endregion // Operators
}

#endregion // int3_mt16
#region int3_mt32

public partial struct int3_mt32
{
    #region Constants

    public static int3_mt32 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static int3_mt32 One
    {
        [MethodImpl(256 | 512)]
        get => new(1);
    }

    public static int3_mt32 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1 + 1));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static int3_mt32 operator-(int3_mt32 a) => new(-a.x, -a.y, -a.z);

    [MethodImpl(256 | 512)]
    public static int3_mt32 operator+(int3_mt32 a, int3_mt32 b) => new(a.x + b.x, a.y + b.y, a.z + b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt32 operator+(int3_mt32 a, int_mt32 b) => new(a.x + b, a.y + b, a.z + b);

    [MethodImpl(256 | 512)]
    public static int3_mt32 operator+(int_mt32 a, int3_mt32 b) => new(a + b.x, a + b.y, a + b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt32 operator-(int3_mt32 a, int3_mt32 b) => new(a.x - b.x, a.y - b.y, a.z - b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt32 operator-(int3_mt32 a, int_mt32 b) => new(a.x - b, a.y - b, a.z - b);

    [MethodImpl(256 | 512)]
    public static int3_mt32 operator-(int_mt32 a, int3_mt32 b) => new(a - b.x, a - b.y, a - b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt32 operator*(int3_mt32 a, int3_mt32 b) => new(a.x * b.x, a.y * b.y, a.z * b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt32 operator*(int3_mt32 a, int_mt32 b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static int3_mt32 operator*(int_mt32 a, int3_mt32 b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt32 operator*(int3_mt32 a, int b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static int3_mt32 operator*(int a, int3_mt32 b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt32 operator/(int3_mt32 a, int3_mt32 b) => new(a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static int3_mt32 operator/(int_mt32 a, int3_mt32 b) => new(a / b.z, a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static int3_mt32 operator/(int3_mt32 a, int_mt32 b) => new(a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static int3_mt32 operator/(int3_mt32 a, int b) => new(a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static int3_mt32 operator%(int3_mt32 a, int3_mt32 b) => new(a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static int3_mt32 operator%(int_mt32 a, int3_mt32 b) => new(a % b.z, a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static int3_mt32 operator%(int3_mt32 a, int_mt32 b) => new(a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static int3_mt32 operator%(int3_mt32 a, int b) => new(a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static int3_mt32 operator++(int3_mt32 a) => a + int_mt32.One;

    [MethodImpl(256 | 512)]
    public static int3_mt32 operator--(int3_mt32 a) => a - int_mt32.One;

    #endregion // Operators
}

#endregion // int3_mt32
#region int4_mt4

public partial struct int4_mt4
{
    #region Constants

    public static int4_mt4 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static int4_mt4 One
    {
        [MethodImpl(256 | 512)]
        get => new(1);
    }

    public static int4_mt4 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1 + 1));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static int4_mt4 operator-(int4_mt4 a) => new(-a.x, -a.y, -a.z, -a.w);

    [MethodImpl(256 | 512)]
    public static int4_mt4 operator+(int4_mt4 a, int4_mt4 b) => new(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt4 operator+(int4_mt4 a, int_mt4 b) => new(a.x + b, a.y + b, a.z + b, a.w + b);

    [MethodImpl(256 | 512)]
    public static int4_mt4 operator+(int_mt4 a, int4_mt4 b) => new(a + b.x, a + b.y, a + b.z, a + b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt4 operator-(int4_mt4 a, int4_mt4 b) => new(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt4 operator-(int4_mt4 a, int_mt4 b) => new(a.x - b, a.y - b, a.z - b, a.w - b);

    [MethodImpl(256 | 512)]
    public static int4_mt4 operator-(int_mt4 a, int4_mt4 b) => new(a - b.x, a - b.y, a - b.z, a - b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt4 operator*(int4_mt4 a, int4_mt4 b) => new(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt4 operator*(int4_mt4 a, int_mt4 b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static int4_mt4 operator*(int_mt4 a, int4_mt4 b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt4 operator*(int4_mt4 a, int b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static int4_mt4 operator*(int a, int4_mt4 b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt4 operator/(int4_mt4 a, int4_mt4 b) => new(a.w / b.w, a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static int4_mt4 operator/(int_mt4 a, int4_mt4 b) => new(a / b.w, a / b.z, a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static int4_mt4 operator/(int4_mt4 a, int_mt4 b) => new(a.w / b, a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static int4_mt4 operator/(int4_mt4 a, int b) => new(a.w / b, a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static int4_mt4 operator%(int4_mt4 a, int4_mt4 b) => new(a.w % b.w, a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static int4_mt4 operator%(int_mt4 a, int4_mt4 b) => new(a % b.w, a % b.z, a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static int4_mt4 operator%(int4_mt4 a, int_mt4 b) => new(a.w % b, a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static int4_mt4 operator%(int4_mt4 a, int b) => new(a.w % b, a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static int4_mt4 operator++(int4_mt4 a) => a + int_mt4.One;

    [MethodImpl(256 | 512)]
    public static int4_mt4 operator--(int4_mt4 a) => a - int_mt4.One;

    #endregion // Operators
}

#endregion // int4_mt4
#region int4_mt8

public partial struct int4_mt8
{
    #region Constants

    public static int4_mt8 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static int4_mt8 One
    {
        [MethodImpl(256 | 512)]
        get => new(1);
    }

    public static int4_mt8 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1 + 1));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static int4_mt8 operator-(int4_mt8 a) => new(-a.x, -a.y, -a.z, -a.w);

    [MethodImpl(256 | 512)]
    public static int4_mt8 operator+(int4_mt8 a, int4_mt8 b) => new(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt8 operator+(int4_mt8 a, int_mt8 b) => new(a.x + b, a.y + b, a.z + b, a.w + b);

    [MethodImpl(256 | 512)]
    public static int4_mt8 operator+(int_mt8 a, int4_mt8 b) => new(a + b.x, a + b.y, a + b.z, a + b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt8 operator-(int4_mt8 a, int4_mt8 b) => new(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt8 operator-(int4_mt8 a, int_mt8 b) => new(a.x - b, a.y - b, a.z - b, a.w - b);

    [MethodImpl(256 | 512)]
    public static int4_mt8 operator-(int_mt8 a, int4_mt8 b) => new(a - b.x, a - b.y, a - b.z, a - b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt8 operator*(int4_mt8 a, int4_mt8 b) => new(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt8 operator*(int4_mt8 a, int_mt8 b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static int4_mt8 operator*(int_mt8 a, int4_mt8 b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt8 operator*(int4_mt8 a, int b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static int4_mt8 operator*(int a, int4_mt8 b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt8 operator/(int4_mt8 a, int4_mt8 b) => new(a.w / b.w, a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static int4_mt8 operator/(int_mt8 a, int4_mt8 b) => new(a / b.w, a / b.z, a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static int4_mt8 operator/(int4_mt8 a, int_mt8 b) => new(a.w / b, a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static int4_mt8 operator/(int4_mt8 a, int b) => new(a.w / b, a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static int4_mt8 operator%(int4_mt8 a, int4_mt8 b) => new(a.w % b.w, a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static int4_mt8 operator%(int_mt8 a, int4_mt8 b) => new(a % b.w, a % b.z, a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static int4_mt8 operator%(int4_mt8 a, int_mt8 b) => new(a.w % b, a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static int4_mt8 operator%(int4_mt8 a, int b) => new(a.w % b, a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static int4_mt8 operator++(int4_mt8 a) => a + int_mt8.One;

    [MethodImpl(256 | 512)]
    public static int4_mt8 operator--(int4_mt8 a) => a - int_mt8.One;

    #endregion // Operators
}

#endregion // int4_mt8
#region int4_mt16

public partial struct int4_mt16
{
    #region Constants

    public static int4_mt16 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static int4_mt16 One
    {
        [MethodImpl(256 | 512)]
        get => new(1);
    }

    public static int4_mt16 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1 + 1));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static int4_mt16 operator-(int4_mt16 a) => new(-a.x, -a.y, -a.z, -a.w);

    [MethodImpl(256 | 512)]
    public static int4_mt16 operator+(int4_mt16 a, int4_mt16 b) => new(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt16 operator+(int4_mt16 a, int_mt16 b) => new(a.x + b, a.y + b, a.z + b, a.w + b);

    [MethodImpl(256 | 512)]
    public static int4_mt16 operator+(int_mt16 a, int4_mt16 b) => new(a + b.x, a + b.y, a + b.z, a + b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt16 operator-(int4_mt16 a, int4_mt16 b) => new(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt16 operator-(int4_mt16 a, int_mt16 b) => new(a.x - b, a.y - b, a.z - b, a.w - b);

    [MethodImpl(256 | 512)]
    public static int4_mt16 operator-(int_mt16 a, int4_mt16 b) => new(a - b.x, a - b.y, a - b.z, a - b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt16 operator*(int4_mt16 a, int4_mt16 b) => new(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt16 operator*(int4_mt16 a, int_mt16 b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static int4_mt16 operator*(int_mt16 a, int4_mt16 b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt16 operator*(int4_mt16 a, int b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static int4_mt16 operator*(int a, int4_mt16 b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt16 operator/(int4_mt16 a, int4_mt16 b) => new(a.w / b.w, a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static int4_mt16 operator/(int_mt16 a, int4_mt16 b) => new(a / b.w, a / b.z, a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static int4_mt16 operator/(int4_mt16 a, int_mt16 b) => new(a.w / b, a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static int4_mt16 operator/(int4_mt16 a, int b) => new(a.w / b, a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static int4_mt16 operator%(int4_mt16 a, int4_mt16 b) => new(a.w % b.w, a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static int4_mt16 operator%(int_mt16 a, int4_mt16 b) => new(a % b.w, a % b.z, a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static int4_mt16 operator%(int4_mt16 a, int_mt16 b) => new(a.w % b, a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static int4_mt16 operator%(int4_mt16 a, int b) => new(a.w % b, a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static int4_mt16 operator++(int4_mt16 a) => a + int_mt16.One;

    [MethodImpl(256 | 512)]
    public static int4_mt16 operator--(int4_mt16 a) => a - int_mt16.One;

    #endregion // Operators
}

#endregion // int4_mt16
#region int4_mt32

public partial struct int4_mt32
{
    #region Constants

    public static int4_mt32 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static int4_mt32 One
    {
        [MethodImpl(256 | 512)]
        get => new(1);
    }

    public static int4_mt32 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1 + 1));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static int4_mt32 operator-(int4_mt32 a) => new(-a.x, -a.y, -a.z, -a.w);

    [MethodImpl(256 | 512)]
    public static int4_mt32 operator+(int4_mt32 a, int4_mt32 b) => new(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt32 operator+(int4_mt32 a, int_mt32 b) => new(a.x + b, a.y + b, a.z + b, a.w + b);

    [MethodImpl(256 | 512)]
    public static int4_mt32 operator+(int_mt32 a, int4_mt32 b) => new(a + b.x, a + b.y, a + b.z, a + b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt32 operator-(int4_mt32 a, int4_mt32 b) => new(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt32 operator-(int4_mt32 a, int_mt32 b) => new(a.x - b, a.y - b, a.z - b, a.w - b);

    [MethodImpl(256 | 512)]
    public static int4_mt32 operator-(int_mt32 a, int4_mt32 b) => new(a - b.x, a - b.y, a - b.z, a - b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt32 operator*(int4_mt32 a, int4_mt32 b) => new(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt32 operator*(int4_mt32 a, int_mt32 b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static int4_mt32 operator*(int_mt32 a, int4_mt32 b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt32 operator*(int4_mt32 a, int b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static int4_mt32 operator*(int a, int4_mt32 b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt32 operator/(int4_mt32 a, int4_mt32 b) => new(a.w / b.w, a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static int4_mt32 operator/(int_mt32 a, int4_mt32 b) => new(a / b.w, a / b.z, a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static int4_mt32 operator/(int4_mt32 a, int_mt32 b) => new(a.w / b, a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static int4_mt32 operator/(int4_mt32 a, int b) => new(a.w / b, a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static int4_mt32 operator%(int4_mt32 a, int4_mt32 b) => new(a.w % b.w, a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static int4_mt32 operator%(int_mt32 a, int4_mt32 b) => new(a % b.w, a % b.z, a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static int4_mt32 operator%(int4_mt32 a, int_mt32 b) => new(a.w % b, a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static int4_mt32 operator%(int4_mt32 a, int b) => new(a.w % b, a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static int4_mt32 operator++(int4_mt32 a) => a + int_mt32.One;

    [MethodImpl(256 | 512)]
    public static int4_mt32 operator--(int4_mt32 a) => a - int_mt32.One;

    #endregion // Operators
}

#endregion // int4_mt32
#region uint2_mt4

public partial struct uint2_mt4
{
    #region Constants

    public static uint2_mt4 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static uint2_mt4 One
    {
        [MethodImpl(256 | 512)]
        get => new(1u);
    }

    public static uint2_mt4 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1u + 1u));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static uint2_mt4 operator-(uint2_mt4 a) => new(-a.x, -a.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt4 operator+(uint2_mt4 a, uint2_mt4 b) => new(a.x + b.x, a.y + b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt4 operator+(uint2_mt4 a, uint_mt4 b) => new(a.x + b, a.y + b);

    [MethodImpl(256 | 512)]
    public static uint2_mt4 operator+(uint_mt4 a, uint2_mt4 b) => new(a + b.x, a + b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt4 operator-(uint2_mt4 a, uint2_mt4 b) => new(a.x - b.x, a.y - b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt4 operator-(uint2_mt4 a, uint_mt4 b) => new(a.x - b, a.y - b);

    [MethodImpl(256 | 512)]
    public static uint2_mt4 operator-(uint_mt4 a, uint2_mt4 b) => new(a - b.x, a - b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt4 operator*(uint2_mt4 a, uint2_mt4 b) => new(a.x * b.x, a.y * b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt4 operator*(uint2_mt4 a, uint_mt4 b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static uint2_mt4 operator*(uint_mt4 a, uint2_mt4 b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt4 operator*(uint2_mt4 a, uint b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static uint2_mt4 operator*(uint a, uint2_mt4 b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt4 operator/(uint2_mt4 a, uint2_mt4 b) => new(a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static uint2_mt4 operator/(uint_mt4 a, uint2_mt4 b) => new(a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static uint2_mt4 operator/(uint2_mt4 a, uint_mt4 b) => new(a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static uint2_mt4 operator/(uint2_mt4 a, uint b) => new(a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static uint2_mt4 operator%(uint2_mt4 a, uint2_mt4 b) => new(a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static uint2_mt4 operator%(uint_mt4 a, uint2_mt4 b) => new(a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static uint2_mt4 operator%(uint2_mt4 a, uint_mt4 b) => new(a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static uint2_mt4 operator%(uint2_mt4 a, uint b) => new(a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static uint2_mt4 operator++(uint2_mt4 a) => a + uint_mt4.One;

    [MethodImpl(256 | 512)]
    public static uint2_mt4 operator--(uint2_mt4 a) => a - uint_mt4.One;

    #endregion // Operators
}

#endregion // uint2_mt4
#region uint2_mt8

public partial struct uint2_mt8
{
    #region Constants

    public static uint2_mt8 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static uint2_mt8 One
    {
        [MethodImpl(256 | 512)]
        get => new(1u);
    }

    public static uint2_mt8 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1u + 1u));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static uint2_mt8 operator-(uint2_mt8 a) => new(-a.x, -a.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt8 operator+(uint2_mt8 a, uint2_mt8 b) => new(a.x + b.x, a.y + b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt8 operator+(uint2_mt8 a, uint_mt8 b) => new(a.x + b, a.y + b);

    [MethodImpl(256 | 512)]
    public static uint2_mt8 operator+(uint_mt8 a, uint2_mt8 b) => new(a + b.x, a + b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt8 operator-(uint2_mt8 a, uint2_mt8 b) => new(a.x - b.x, a.y - b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt8 operator-(uint2_mt8 a, uint_mt8 b) => new(a.x - b, a.y - b);

    [MethodImpl(256 | 512)]
    public static uint2_mt8 operator-(uint_mt8 a, uint2_mt8 b) => new(a - b.x, a - b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt8 operator*(uint2_mt8 a, uint2_mt8 b) => new(a.x * b.x, a.y * b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt8 operator*(uint2_mt8 a, uint_mt8 b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static uint2_mt8 operator*(uint_mt8 a, uint2_mt8 b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt8 operator*(uint2_mt8 a, uint b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static uint2_mt8 operator*(uint a, uint2_mt8 b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt8 operator/(uint2_mt8 a, uint2_mt8 b) => new(a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static uint2_mt8 operator/(uint_mt8 a, uint2_mt8 b) => new(a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static uint2_mt8 operator/(uint2_mt8 a, uint_mt8 b) => new(a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static uint2_mt8 operator/(uint2_mt8 a, uint b) => new(a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static uint2_mt8 operator%(uint2_mt8 a, uint2_mt8 b) => new(a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static uint2_mt8 operator%(uint_mt8 a, uint2_mt8 b) => new(a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static uint2_mt8 operator%(uint2_mt8 a, uint_mt8 b) => new(a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static uint2_mt8 operator%(uint2_mt8 a, uint b) => new(a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static uint2_mt8 operator++(uint2_mt8 a) => a + uint_mt8.One;

    [MethodImpl(256 | 512)]
    public static uint2_mt8 operator--(uint2_mt8 a) => a - uint_mt8.One;

    #endregion // Operators
}

#endregion // uint2_mt8
#region uint2_mt16

public partial struct uint2_mt16
{
    #region Constants

    public static uint2_mt16 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static uint2_mt16 One
    {
        [MethodImpl(256 | 512)]
        get => new(1u);
    }

    public static uint2_mt16 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1u + 1u));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static uint2_mt16 operator-(uint2_mt16 a) => new(-a.x, -a.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt16 operator+(uint2_mt16 a, uint2_mt16 b) => new(a.x + b.x, a.y + b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt16 operator+(uint2_mt16 a, uint_mt16 b) => new(a.x + b, a.y + b);

    [MethodImpl(256 | 512)]
    public static uint2_mt16 operator+(uint_mt16 a, uint2_mt16 b) => new(a + b.x, a + b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt16 operator-(uint2_mt16 a, uint2_mt16 b) => new(a.x - b.x, a.y - b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt16 operator-(uint2_mt16 a, uint_mt16 b) => new(a.x - b, a.y - b);

    [MethodImpl(256 | 512)]
    public static uint2_mt16 operator-(uint_mt16 a, uint2_mt16 b) => new(a - b.x, a - b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt16 operator*(uint2_mt16 a, uint2_mt16 b) => new(a.x * b.x, a.y * b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt16 operator*(uint2_mt16 a, uint_mt16 b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static uint2_mt16 operator*(uint_mt16 a, uint2_mt16 b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt16 operator*(uint2_mt16 a, uint b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static uint2_mt16 operator*(uint a, uint2_mt16 b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt16 operator/(uint2_mt16 a, uint2_mt16 b) => new(a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static uint2_mt16 operator/(uint_mt16 a, uint2_mt16 b) => new(a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static uint2_mt16 operator/(uint2_mt16 a, uint_mt16 b) => new(a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static uint2_mt16 operator/(uint2_mt16 a, uint b) => new(a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static uint2_mt16 operator%(uint2_mt16 a, uint2_mt16 b) => new(a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static uint2_mt16 operator%(uint_mt16 a, uint2_mt16 b) => new(a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static uint2_mt16 operator%(uint2_mt16 a, uint_mt16 b) => new(a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static uint2_mt16 operator%(uint2_mt16 a, uint b) => new(a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static uint2_mt16 operator++(uint2_mt16 a) => a + uint_mt16.One;

    [MethodImpl(256 | 512)]
    public static uint2_mt16 operator--(uint2_mt16 a) => a - uint_mt16.One;

    #endregion // Operators
}

#endregion // uint2_mt16
#region uint2_mt32

public partial struct uint2_mt32
{
    #region Constants

    public static uint2_mt32 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static uint2_mt32 One
    {
        [MethodImpl(256 | 512)]
        get => new(1u);
    }

    public static uint2_mt32 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1u + 1u));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static uint2_mt32 operator-(uint2_mt32 a) => new(-a.x, -a.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt32 operator+(uint2_mt32 a, uint2_mt32 b) => new(a.x + b.x, a.y + b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt32 operator+(uint2_mt32 a, uint_mt32 b) => new(a.x + b, a.y + b);

    [MethodImpl(256 | 512)]
    public static uint2_mt32 operator+(uint_mt32 a, uint2_mt32 b) => new(a + b.x, a + b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt32 operator-(uint2_mt32 a, uint2_mt32 b) => new(a.x - b.x, a.y - b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt32 operator-(uint2_mt32 a, uint_mt32 b) => new(a.x - b, a.y - b);

    [MethodImpl(256 | 512)]
    public static uint2_mt32 operator-(uint_mt32 a, uint2_mt32 b) => new(a - b.x, a - b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt32 operator*(uint2_mt32 a, uint2_mt32 b) => new(a.x * b.x, a.y * b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt32 operator*(uint2_mt32 a, uint_mt32 b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static uint2_mt32 operator*(uint_mt32 a, uint2_mt32 b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt32 operator*(uint2_mt32 a, uint b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static uint2_mt32 operator*(uint a, uint2_mt32 b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt32 operator/(uint2_mt32 a, uint2_mt32 b) => new(a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static uint2_mt32 operator/(uint_mt32 a, uint2_mt32 b) => new(a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static uint2_mt32 operator/(uint2_mt32 a, uint_mt32 b) => new(a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static uint2_mt32 operator/(uint2_mt32 a, uint b) => new(a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static uint2_mt32 operator%(uint2_mt32 a, uint2_mt32 b) => new(a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static uint2_mt32 operator%(uint_mt32 a, uint2_mt32 b) => new(a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static uint2_mt32 operator%(uint2_mt32 a, uint_mt32 b) => new(a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static uint2_mt32 operator%(uint2_mt32 a, uint b) => new(a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static uint2_mt32 operator++(uint2_mt32 a) => a + uint_mt32.One;

    [MethodImpl(256 | 512)]
    public static uint2_mt32 operator--(uint2_mt32 a) => a - uint_mt32.One;

    #endregion // Operators
}

#endregion // uint2_mt32
#region uint3_mt4

public partial struct uint3_mt4
{
    #region Constants

    public static uint3_mt4 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static uint3_mt4 One
    {
        [MethodImpl(256 | 512)]
        get => new(1u);
    }

    public static uint3_mt4 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1u + 1u));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static uint3_mt4 operator-(uint3_mt4 a) => new(-a.x, -a.y, -a.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt4 operator+(uint3_mt4 a, uint3_mt4 b) => new(a.x + b.x, a.y + b.y, a.z + b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt4 operator+(uint3_mt4 a, uint_mt4 b) => new(a.x + b, a.y + b, a.z + b);

    [MethodImpl(256 | 512)]
    public static uint3_mt4 operator+(uint_mt4 a, uint3_mt4 b) => new(a + b.x, a + b.y, a + b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt4 operator-(uint3_mt4 a, uint3_mt4 b) => new(a.x - b.x, a.y - b.y, a.z - b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt4 operator-(uint3_mt4 a, uint_mt4 b) => new(a.x - b, a.y - b, a.z - b);

    [MethodImpl(256 | 512)]
    public static uint3_mt4 operator-(uint_mt4 a, uint3_mt4 b) => new(a - b.x, a - b.y, a - b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt4 operator*(uint3_mt4 a, uint3_mt4 b) => new(a.x * b.x, a.y * b.y, a.z * b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt4 operator*(uint3_mt4 a, uint_mt4 b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static uint3_mt4 operator*(uint_mt4 a, uint3_mt4 b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt4 operator*(uint3_mt4 a, uint b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static uint3_mt4 operator*(uint a, uint3_mt4 b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt4 operator/(uint3_mt4 a, uint3_mt4 b) => new(a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static uint3_mt4 operator/(uint_mt4 a, uint3_mt4 b) => new(a / b.z, a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static uint3_mt4 operator/(uint3_mt4 a, uint_mt4 b) => new(a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static uint3_mt4 operator/(uint3_mt4 a, uint b) => new(a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static uint3_mt4 operator%(uint3_mt4 a, uint3_mt4 b) => new(a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static uint3_mt4 operator%(uint_mt4 a, uint3_mt4 b) => new(a % b.z, a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static uint3_mt4 operator%(uint3_mt4 a, uint_mt4 b) => new(a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static uint3_mt4 operator%(uint3_mt4 a, uint b) => new(a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static uint3_mt4 operator++(uint3_mt4 a) => a + uint_mt4.One;

    [MethodImpl(256 | 512)]
    public static uint3_mt4 operator--(uint3_mt4 a) => a - uint_mt4.One;

    #endregion // Operators
}

#endregion // uint3_mt4
#region uint3_mt8

public partial struct uint3_mt8
{
    #region Constants

    public static uint3_mt8 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static uint3_mt8 One
    {
        [MethodImpl(256 | 512)]
        get => new(1u);
    }

    public static uint3_mt8 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1u + 1u));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static uint3_mt8 operator-(uint3_mt8 a) => new(-a.x, -a.y, -a.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt8 operator+(uint3_mt8 a, uint3_mt8 b) => new(a.x + b.x, a.y + b.y, a.z + b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt8 operator+(uint3_mt8 a, uint_mt8 b) => new(a.x + b, a.y + b, a.z + b);

    [MethodImpl(256 | 512)]
    public static uint3_mt8 operator+(uint_mt8 a, uint3_mt8 b) => new(a + b.x, a + b.y, a + b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt8 operator-(uint3_mt8 a, uint3_mt8 b) => new(a.x - b.x, a.y - b.y, a.z - b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt8 operator-(uint3_mt8 a, uint_mt8 b) => new(a.x - b, a.y - b, a.z - b);

    [MethodImpl(256 | 512)]
    public static uint3_mt8 operator-(uint_mt8 a, uint3_mt8 b) => new(a - b.x, a - b.y, a - b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt8 operator*(uint3_mt8 a, uint3_mt8 b) => new(a.x * b.x, a.y * b.y, a.z * b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt8 operator*(uint3_mt8 a, uint_mt8 b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static uint3_mt8 operator*(uint_mt8 a, uint3_mt8 b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt8 operator*(uint3_mt8 a, uint b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static uint3_mt8 operator*(uint a, uint3_mt8 b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt8 operator/(uint3_mt8 a, uint3_mt8 b) => new(a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static uint3_mt8 operator/(uint_mt8 a, uint3_mt8 b) => new(a / b.z, a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static uint3_mt8 operator/(uint3_mt8 a, uint_mt8 b) => new(a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static uint3_mt8 operator/(uint3_mt8 a, uint b) => new(a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static uint3_mt8 operator%(uint3_mt8 a, uint3_mt8 b) => new(a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static uint3_mt8 operator%(uint_mt8 a, uint3_mt8 b) => new(a % b.z, a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static uint3_mt8 operator%(uint3_mt8 a, uint_mt8 b) => new(a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static uint3_mt8 operator%(uint3_mt8 a, uint b) => new(a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static uint3_mt8 operator++(uint3_mt8 a) => a + uint_mt8.One;

    [MethodImpl(256 | 512)]
    public static uint3_mt8 operator--(uint3_mt8 a) => a - uint_mt8.One;

    #endregion // Operators
}

#endregion // uint3_mt8
#region uint3_mt16

public partial struct uint3_mt16
{
    #region Constants

    public static uint3_mt16 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static uint3_mt16 One
    {
        [MethodImpl(256 | 512)]
        get => new(1u);
    }

    public static uint3_mt16 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1u + 1u));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static uint3_mt16 operator-(uint3_mt16 a) => new(-a.x, -a.y, -a.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt16 operator+(uint3_mt16 a, uint3_mt16 b) => new(a.x + b.x, a.y + b.y, a.z + b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt16 operator+(uint3_mt16 a, uint_mt16 b) => new(a.x + b, a.y + b, a.z + b);

    [MethodImpl(256 | 512)]
    public static uint3_mt16 operator+(uint_mt16 a, uint3_mt16 b) => new(a + b.x, a + b.y, a + b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt16 operator-(uint3_mt16 a, uint3_mt16 b) => new(a.x - b.x, a.y - b.y, a.z - b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt16 operator-(uint3_mt16 a, uint_mt16 b) => new(a.x - b, a.y - b, a.z - b);

    [MethodImpl(256 | 512)]
    public static uint3_mt16 operator-(uint_mt16 a, uint3_mt16 b) => new(a - b.x, a - b.y, a - b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt16 operator*(uint3_mt16 a, uint3_mt16 b) => new(a.x * b.x, a.y * b.y, a.z * b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt16 operator*(uint3_mt16 a, uint_mt16 b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static uint3_mt16 operator*(uint_mt16 a, uint3_mt16 b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt16 operator*(uint3_mt16 a, uint b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static uint3_mt16 operator*(uint a, uint3_mt16 b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt16 operator/(uint3_mt16 a, uint3_mt16 b) => new(a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static uint3_mt16 operator/(uint_mt16 a, uint3_mt16 b) => new(a / b.z, a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static uint3_mt16 operator/(uint3_mt16 a, uint_mt16 b) => new(a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static uint3_mt16 operator/(uint3_mt16 a, uint b) => new(a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static uint3_mt16 operator%(uint3_mt16 a, uint3_mt16 b) => new(a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static uint3_mt16 operator%(uint_mt16 a, uint3_mt16 b) => new(a % b.z, a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static uint3_mt16 operator%(uint3_mt16 a, uint_mt16 b) => new(a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static uint3_mt16 operator%(uint3_mt16 a, uint b) => new(a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static uint3_mt16 operator++(uint3_mt16 a) => a + uint_mt16.One;

    [MethodImpl(256 | 512)]
    public static uint3_mt16 operator--(uint3_mt16 a) => a - uint_mt16.One;

    #endregion // Operators
}

#endregion // uint3_mt16
#region uint3_mt32

public partial struct uint3_mt32
{
    #region Constants

    public static uint3_mt32 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static uint3_mt32 One
    {
        [MethodImpl(256 | 512)]
        get => new(1u);
    }

    public static uint3_mt32 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1u + 1u));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static uint3_mt32 operator-(uint3_mt32 a) => new(-a.x, -a.y, -a.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt32 operator+(uint3_mt32 a, uint3_mt32 b) => new(a.x + b.x, a.y + b.y, a.z + b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt32 operator+(uint3_mt32 a, uint_mt32 b) => new(a.x + b, a.y + b, a.z + b);

    [MethodImpl(256 | 512)]
    public static uint3_mt32 operator+(uint_mt32 a, uint3_mt32 b) => new(a + b.x, a + b.y, a + b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt32 operator-(uint3_mt32 a, uint3_mt32 b) => new(a.x - b.x, a.y - b.y, a.z - b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt32 operator-(uint3_mt32 a, uint_mt32 b) => new(a.x - b, a.y - b, a.z - b);

    [MethodImpl(256 | 512)]
    public static uint3_mt32 operator-(uint_mt32 a, uint3_mt32 b) => new(a - b.x, a - b.y, a - b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt32 operator*(uint3_mt32 a, uint3_mt32 b) => new(a.x * b.x, a.y * b.y, a.z * b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt32 operator*(uint3_mt32 a, uint_mt32 b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static uint3_mt32 operator*(uint_mt32 a, uint3_mt32 b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt32 operator*(uint3_mt32 a, uint b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static uint3_mt32 operator*(uint a, uint3_mt32 b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt32 operator/(uint3_mt32 a, uint3_mt32 b) => new(a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static uint3_mt32 operator/(uint_mt32 a, uint3_mt32 b) => new(a / b.z, a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static uint3_mt32 operator/(uint3_mt32 a, uint_mt32 b) => new(a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static uint3_mt32 operator/(uint3_mt32 a, uint b) => new(a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static uint3_mt32 operator%(uint3_mt32 a, uint3_mt32 b) => new(a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static uint3_mt32 operator%(uint_mt32 a, uint3_mt32 b) => new(a % b.z, a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static uint3_mt32 operator%(uint3_mt32 a, uint_mt32 b) => new(a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static uint3_mt32 operator%(uint3_mt32 a, uint b) => new(a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static uint3_mt32 operator++(uint3_mt32 a) => a + uint_mt32.One;

    [MethodImpl(256 | 512)]
    public static uint3_mt32 operator--(uint3_mt32 a) => a - uint_mt32.One;

    #endregion // Operators
}

#endregion // uint3_mt32
#region uint4_mt4

public partial struct uint4_mt4
{
    #region Constants

    public static uint4_mt4 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static uint4_mt4 One
    {
        [MethodImpl(256 | 512)]
        get => new(1u);
    }

    public static uint4_mt4 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1u + 1u));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static uint4_mt4 operator-(uint4_mt4 a) => new(-a.x, -a.y, -a.z, -a.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt4 operator+(uint4_mt4 a, uint4_mt4 b) => new(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt4 operator+(uint4_mt4 a, uint_mt4 b) => new(a.x + b, a.y + b, a.z + b, a.w + b);

    [MethodImpl(256 | 512)]
    public static uint4_mt4 operator+(uint_mt4 a, uint4_mt4 b) => new(a + b.x, a + b.y, a + b.z, a + b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt4 operator-(uint4_mt4 a, uint4_mt4 b) => new(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt4 operator-(uint4_mt4 a, uint_mt4 b) => new(a.x - b, a.y - b, a.z - b, a.w - b);

    [MethodImpl(256 | 512)]
    public static uint4_mt4 operator-(uint_mt4 a, uint4_mt4 b) => new(a - b.x, a - b.y, a - b.z, a - b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt4 operator*(uint4_mt4 a, uint4_mt4 b) => new(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt4 operator*(uint4_mt4 a, uint_mt4 b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static uint4_mt4 operator*(uint_mt4 a, uint4_mt4 b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt4 operator*(uint4_mt4 a, uint b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static uint4_mt4 operator*(uint a, uint4_mt4 b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt4 operator/(uint4_mt4 a, uint4_mt4 b) => new(a.w / b.w, a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static uint4_mt4 operator/(uint_mt4 a, uint4_mt4 b) => new(a / b.w, a / b.z, a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static uint4_mt4 operator/(uint4_mt4 a, uint_mt4 b) => new(a.w / b, a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static uint4_mt4 operator/(uint4_mt4 a, uint b) => new(a.w / b, a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static uint4_mt4 operator%(uint4_mt4 a, uint4_mt4 b) => new(a.w % b.w, a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static uint4_mt4 operator%(uint_mt4 a, uint4_mt4 b) => new(a % b.w, a % b.z, a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static uint4_mt4 operator%(uint4_mt4 a, uint_mt4 b) => new(a.w % b, a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static uint4_mt4 operator%(uint4_mt4 a, uint b) => new(a.w % b, a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static uint4_mt4 operator++(uint4_mt4 a) => a + uint_mt4.One;

    [MethodImpl(256 | 512)]
    public static uint4_mt4 operator--(uint4_mt4 a) => a - uint_mt4.One;

    #endregion // Operators
}

#endregion // uint4_mt4
#region uint4_mt8

public partial struct uint4_mt8
{
    #region Constants

    public static uint4_mt8 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static uint4_mt8 One
    {
        [MethodImpl(256 | 512)]
        get => new(1u);
    }

    public static uint4_mt8 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1u + 1u));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static uint4_mt8 operator-(uint4_mt8 a) => new(-a.x, -a.y, -a.z, -a.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt8 operator+(uint4_mt8 a, uint4_mt8 b) => new(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt8 operator+(uint4_mt8 a, uint_mt8 b) => new(a.x + b, a.y + b, a.z + b, a.w + b);

    [MethodImpl(256 | 512)]
    public static uint4_mt8 operator+(uint_mt8 a, uint4_mt8 b) => new(a + b.x, a + b.y, a + b.z, a + b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt8 operator-(uint4_mt8 a, uint4_mt8 b) => new(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt8 operator-(uint4_mt8 a, uint_mt8 b) => new(a.x - b, a.y - b, a.z - b, a.w - b);

    [MethodImpl(256 | 512)]
    public static uint4_mt8 operator-(uint_mt8 a, uint4_mt8 b) => new(a - b.x, a - b.y, a - b.z, a - b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt8 operator*(uint4_mt8 a, uint4_mt8 b) => new(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt8 operator*(uint4_mt8 a, uint_mt8 b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static uint4_mt8 operator*(uint_mt8 a, uint4_mt8 b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt8 operator*(uint4_mt8 a, uint b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static uint4_mt8 operator*(uint a, uint4_mt8 b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt8 operator/(uint4_mt8 a, uint4_mt8 b) => new(a.w / b.w, a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static uint4_mt8 operator/(uint_mt8 a, uint4_mt8 b) => new(a / b.w, a / b.z, a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static uint4_mt8 operator/(uint4_mt8 a, uint_mt8 b) => new(a.w / b, a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static uint4_mt8 operator/(uint4_mt8 a, uint b) => new(a.w / b, a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static uint4_mt8 operator%(uint4_mt8 a, uint4_mt8 b) => new(a.w % b.w, a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static uint4_mt8 operator%(uint_mt8 a, uint4_mt8 b) => new(a % b.w, a % b.z, a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static uint4_mt8 operator%(uint4_mt8 a, uint_mt8 b) => new(a.w % b, a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static uint4_mt8 operator%(uint4_mt8 a, uint b) => new(a.w % b, a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static uint4_mt8 operator++(uint4_mt8 a) => a + uint_mt8.One;

    [MethodImpl(256 | 512)]
    public static uint4_mt8 operator--(uint4_mt8 a) => a - uint_mt8.One;

    #endregion // Operators
}

#endregion // uint4_mt8
#region uint4_mt16

public partial struct uint4_mt16
{
    #region Constants

    public static uint4_mt16 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static uint4_mt16 One
    {
        [MethodImpl(256 | 512)]
        get => new(1u);
    }

    public static uint4_mt16 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1u + 1u));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static uint4_mt16 operator-(uint4_mt16 a) => new(-a.x, -a.y, -a.z, -a.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt16 operator+(uint4_mt16 a, uint4_mt16 b) => new(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt16 operator+(uint4_mt16 a, uint_mt16 b) => new(a.x + b, a.y + b, a.z + b, a.w + b);

    [MethodImpl(256 | 512)]
    public static uint4_mt16 operator+(uint_mt16 a, uint4_mt16 b) => new(a + b.x, a + b.y, a + b.z, a + b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt16 operator-(uint4_mt16 a, uint4_mt16 b) => new(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt16 operator-(uint4_mt16 a, uint_mt16 b) => new(a.x - b, a.y - b, a.z - b, a.w - b);

    [MethodImpl(256 | 512)]
    public static uint4_mt16 operator-(uint_mt16 a, uint4_mt16 b) => new(a - b.x, a - b.y, a - b.z, a - b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt16 operator*(uint4_mt16 a, uint4_mt16 b) => new(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt16 operator*(uint4_mt16 a, uint_mt16 b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static uint4_mt16 operator*(uint_mt16 a, uint4_mt16 b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt16 operator*(uint4_mt16 a, uint b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static uint4_mt16 operator*(uint a, uint4_mt16 b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt16 operator/(uint4_mt16 a, uint4_mt16 b) => new(a.w / b.w, a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static uint4_mt16 operator/(uint_mt16 a, uint4_mt16 b) => new(a / b.w, a / b.z, a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static uint4_mt16 operator/(uint4_mt16 a, uint_mt16 b) => new(a.w / b, a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static uint4_mt16 operator/(uint4_mt16 a, uint b) => new(a.w / b, a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static uint4_mt16 operator%(uint4_mt16 a, uint4_mt16 b) => new(a.w % b.w, a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static uint4_mt16 operator%(uint_mt16 a, uint4_mt16 b) => new(a % b.w, a % b.z, a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static uint4_mt16 operator%(uint4_mt16 a, uint_mt16 b) => new(a.w % b, a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static uint4_mt16 operator%(uint4_mt16 a, uint b) => new(a.w % b, a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static uint4_mt16 operator++(uint4_mt16 a) => a + uint_mt16.One;

    [MethodImpl(256 | 512)]
    public static uint4_mt16 operator--(uint4_mt16 a) => a - uint_mt16.One;

    #endregion // Operators
}

#endregion // uint4_mt16
#region uint4_mt32

public partial struct uint4_mt32
{
    #region Constants

    public static uint4_mt32 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static uint4_mt32 One
    {
        [MethodImpl(256 | 512)]
        get => new(1u);
    }

    public static uint4_mt32 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1u + 1u));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static uint4_mt32 operator-(uint4_mt32 a) => new(-a.x, -a.y, -a.z, -a.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt32 operator+(uint4_mt32 a, uint4_mt32 b) => new(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt32 operator+(uint4_mt32 a, uint_mt32 b) => new(a.x + b, a.y + b, a.z + b, a.w + b);

    [MethodImpl(256 | 512)]
    public static uint4_mt32 operator+(uint_mt32 a, uint4_mt32 b) => new(a + b.x, a + b.y, a + b.z, a + b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt32 operator-(uint4_mt32 a, uint4_mt32 b) => new(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt32 operator-(uint4_mt32 a, uint_mt32 b) => new(a.x - b, a.y - b, a.z - b, a.w - b);

    [MethodImpl(256 | 512)]
    public static uint4_mt32 operator-(uint_mt32 a, uint4_mt32 b) => new(a - b.x, a - b.y, a - b.z, a - b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt32 operator*(uint4_mt32 a, uint4_mt32 b) => new(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt32 operator*(uint4_mt32 a, uint_mt32 b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static uint4_mt32 operator*(uint_mt32 a, uint4_mt32 b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt32 operator*(uint4_mt32 a, uint b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static uint4_mt32 operator*(uint a, uint4_mt32 b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt32 operator/(uint4_mt32 a, uint4_mt32 b) => new(a.w / b.w, a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static uint4_mt32 operator/(uint_mt32 a, uint4_mt32 b) => new(a / b.w, a / b.z, a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static uint4_mt32 operator/(uint4_mt32 a, uint_mt32 b) => new(a.w / b, a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static uint4_mt32 operator/(uint4_mt32 a, uint b) => new(a.w / b, a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static uint4_mt32 operator%(uint4_mt32 a, uint4_mt32 b) => new(a.w % b.w, a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static uint4_mt32 operator%(uint_mt32 a, uint4_mt32 b) => new(a % b.w, a % b.z, a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static uint4_mt32 operator%(uint4_mt32 a, uint_mt32 b) => new(a.w % b, a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static uint4_mt32 operator%(uint4_mt32 a, uint b) => new(a.w % b, a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static uint4_mt32 operator++(uint4_mt32 a) => a + uint_mt32.One;

    [MethodImpl(256 | 512)]
    public static uint4_mt32 operator--(uint4_mt32 a) => a - uint_mt32.One;

    #endregion // Operators
}

#endregion // uint4_mt32
#region long2_mt4

public partial struct long2_mt4
{
    #region Constants

    public static long2_mt4 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static long2_mt4 One
    {
        [MethodImpl(256 | 512)]
        get => new(1L);
    }

    public static long2_mt4 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1L + 1L));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static long2_mt4 operator-(long2_mt4 a) => new(-a.x, -a.y);

    [MethodImpl(256 | 512)]
    public static long2_mt4 operator+(long2_mt4 a, long2_mt4 b) => new(a.x + b.x, a.y + b.y);

    [MethodImpl(256 | 512)]
    public static long2_mt4 operator+(long2_mt4 a, long_mt4 b) => new(a.x + b, a.y + b);

    [MethodImpl(256 | 512)]
    public static long2_mt4 operator+(long_mt4 a, long2_mt4 b) => new(a + b.x, a + b.y);

    [MethodImpl(256 | 512)]
    public static long2_mt4 operator-(long2_mt4 a, long2_mt4 b) => new(a.x - b.x, a.y - b.y);

    [MethodImpl(256 | 512)]
    public static long2_mt4 operator-(long2_mt4 a, long_mt4 b) => new(a.x - b, a.y - b);

    [MethodImpl(256 | 512)]
    public static long2_mt4 operator-(long_mt4 a, long2_mt4 b) => new(a - b.x, a - b.y);

    [MethodImpl(256 | 512)]
    public static long2_mt4 operator*(long2_mt4 a, long2_mt4 b) => new(a.x * b.x, a.y * b.y);

    [MethodImpl(256 | 512)]
    public static long2_mt4 operator*(long2_mt4 a, long_mt4 b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static long2_mt4 operator*(long_mt4 a, long2_mt4 b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static long2_mt4 operator*(long2_mt4 a, long b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static long2_mt4 operator*(long a, long2_mt4 b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static long2_mt4 operator/(long2_mt4 a, long2_mt4 b) => new(a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static long2_mt4 operator/(long_mt4 a, long2_mt4 b) => new(a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static long2_mt4 operator/(long2_mt4 a, long_mt4 b) => new(a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static long2_mt4 operator/(long2_mt4 a, long b) => new(a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static long2_mt4 operator%(long2_mt4 a, long2_mt4 b) => new(a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static long2_mt4 operator%(long_mt4 a, long2_mt4 b) => new(a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static long2_mt4 operator%(long2_mt4 a, long_mt4 b) => new(a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static long2_mt4 operator%(long2_mt4 a, long b) => new(a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static long2_mt4 operator++(long2_mt4 a) => a + long_mt4.One;

    [MethodImpl(256 | 512)]
    public static long2_mt4 operator--(long2_mt4 a) => a - long_mt4.One;

    #endregion // Operators
}

#endregion // long2_mt4
#region long2_mt8

public partial struct long2_mt8
{
    #region Constants

    public static long2_mt8 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static long2_mt8 One
    {
        [MethodImpl(256 | 512)]
        get => new(1L);
    }

    public static long2_mt8 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1L + 1L));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static long2_mt8 operator-(long2_mt8 a) => new(-a.x, -a.y);

    [MethodImpl(256 | 512)]
    public static long2_mt8 operator+(long2_mt8 a, long2_mt8 b) => new(a.x + b.x, a.y + b.y);

    [MethodImpl(256 | 512)]
    public static long2_mt8 operator+(long2_mt8 a, long_mt8 b) => new(a.x + b, a.y + b);

    [MethodImpl(256 | 512)]
    public static long2_mt8 operator+(long_mt8 a, long2_mt8 b) => new(a + b.x, a + b.y);

    [MethodImpl(256 | 512)]
    public static long2_mt8 operator-(long2_mt8 a, long2_mt8 b) => new(a.x - b.x, a.y - b.y);

    [MethodImpl(256 | 512)]
    public static long2_mt8 operator-(long2_mt8 a, long_mt8 b) => new(a.x - b, a.y - b);

    [MethodImpl(256 | 512)]
    public static long2_mt8 operator-(long_mt8 a, long2_mt8 b) => new(a - b.x, a - b.y);

    [MethodImpl(256 | 512)]
    public static long2_mt8 operator*(long2_mt8 a, long2_mt8 b) => new(a.x * b.x, a.y * b.y);

    [MethodImpl(256 | 512)]
    public static long2_mt8 operator*(long2_mt8 a, long_mt8 b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static long2_mt8 operator*(long_mt8 a, long2_mt8 b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static long2_mt8 operator*(long2_mt8 a, long b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static long2_mt8 operator*(long a, long2_mt8 b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static long2_mt8 operator/(long2_mt8 a, long2_mt8 b) => new(a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static long2_mt8 operator/(long_mt8 a, long2_mt8 b) => new(a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static long2_mt8 operator/(long2_mt8 a, long_mt8 b) => new(a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static long2_mt8 operator/(long2_mt8 a, long b) => new(a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static long2_mt8 operator%(long2_mt8 a, long2_mt8 b) => new(a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static long2_mt8 operator%(long_mt8 a, long2_mt8 b) => new(a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static long2_mt8 operator%(long2_mt8 a, long_mt8 b) => new(a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static long2_mt8 operator%(long2_mt8 a, long b) => new(a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static long2_mt8 operator++(long2_mt8 a) => a + long_mt8.One;

    [MethodImpl(256 | 512)]
    public static long2_mt8 operator--(long2_mt8 a) => a - long_mt8.One;

    #endregion // Operators
}

#endregion // long2_mt8
#region long2_mt16

public partial struct long2_mt16
{
    #region Constants

    public static long2_mt16 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static long2_mt16 One
    {
        [MethodImpl(256 | 512)]
        get => new(1L);
    }

    public static long2_mt16 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1L + 1L));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static long2_mt16 operator-(long2_mt16 a) => new(-a.x, -a.y);

    [MethodImpl(256 | 512)]
    public static long2_mt16 operator+(long2_mt16 a, long2_mt16 b) => new(a.x + b.x, a.y + b.y);

    [MethodImpl(256 | 512)]
    public static long2_mt16 operator+(long2_mt16 a, long_mt16 b) => new(a.x + b, a.y + b);

    [MethodImpl(256 | 512)]
    public static long2_mt16 operator+(long_mt16 a, long2_mt16 b) => new(a + b.x, a + b.y);

    [MethodImpl(256 | 512)]
    public static long2_mt16 operator-(long2_mt16 a, long2_mt16 b) => new(a.x - b.x, a.y - b.y);

    [MethodImpl(256 | 512)]
    public static long2_mt16 operator-(long2_mt16 a, long_mt16 b) => new(a.x - b, a.y - b);

    [MethodImpl(256 | 512)]
    public static long2_mt16 operator-(long_mt16 a, long2_mt16 b) => new(a - b.x, a - b.y);

    [MethodImpl(256 | 512)]
    public static long2_mt16 operator*(long2_mt16 a, long2_mt16 b) => new(a.x * b.x, a.y * b.y);

    [MethodImpl(256 | 512)]
    public static long2_mt16 operator*(long2_mt16 a, long_mt16 b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static long2_mt16 operator*(long_mt16 a, long2_mt16 b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static long2_mt16 operator*(long2_mt16 a, long b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static long2_mt16 operator*(long a, long2_mt16 b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static long2_mt16 operator/(long2_mt16 a, long2_mt16 b) => new(a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static long2_mt16 operator/(long_mt16 a, long2_mt16 b) => new(a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static long2_mt16 operator/(long2_mt16 a, long_mt16 b) => new(a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static long2_mt16 operator/(long2_mt16 a, long b) => new(a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static long2_mt16 operator%(long2_mt16 a, long2_mt16 b) => new(a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static long2_mt16 operator%(long_mt16 a, long2_mt16 b) => new(a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static long2_mt16 operator%(long2_mt16 a, long_mt16 b) => new(a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static long2_mt16 operator%(long2_mt16 a, long b) => new(a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static long2_mt16 operator++(long2_mt16 a) => a + long_mt16.One;

    [MethodImpl(256 | 512)]
    public static long2_mt16 operator--(long2_mt16 a) => a - long_mt16.One;

    #endregion // Operators
}

#endregion // long2_mt16
#region long2_mt32

public partial struct long2_mt32
{
    #region Constants

    public static long2_mt32 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static long2_mt32 One
    {
        [MethodImpl(256 | 512)]
        get => new(1L);
    }

    public static long2_mt32 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1L + 1L));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static long2_mt32 operator-(long2_mt32 a) => new(-a.x, -a.y);

    [MethodImpl(256 | 512)]
    public static long2_mt32 operator+(long2_mt32 a, long2_mt32 b) => new(a.x + b.x, a.y + b.y);

    [MethodImpl(256 | 512)]
    public static long2_mt32 operator+(long2_mt32 a, long_mt32 b) => new(a.x + b, a.y + b);

    [MethodImpl(256 | 512)]
    public static long2_mt32 operator+(long_mt32 a, long2_mt32 b) => new(a + b.x, a + b.y);

    [MethodImpl(256 | 512)]
    public static long2_mt32 operator-(long2_mt32 a, long2_mt32 b) => new(a.x - b.x, a.y - b.y);

    [MethodImpl(256 | 512)]
    public static long2_mt32 operator-(long2_mt32 a, long_mt32 b) => new(a.x - b, a.y - b);

    [MethodImpl(256 | 512)]
    public static long2_mt32 operator-(long_mt32 a, long2_mt32 b) => new(a - b.x, a - b.y);

    [MethodImpl(256 | 512)]
    public static long2_mt32 operator*(long2_mt32 a, long2_mt32 b) => new(a.x * b.x, a.y * b.y);

    [MethodImpl(256 | 512)]
    public static long2_mt32 operator*(long2_mt32 a, long_mt32 b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static long2_mt32 operator*(long_mt32 a, long2_mt32 b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static long2_mt32 operator*(long2_mt32 a, long b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static long2_mt32 operator*(long a, long2_mt32 b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static long2_mt32 operator/(long2_mt32 a, long2_mt32 b) => new(a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static long2_mt32 operator/(long_mt32 a, long2_mt32 b) => new(a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static long2_mt32 operator/(long2_mt32 a, long_mt32 b) => new(a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static long2_mt32 operator/(long2_mt32 a, long b) => new(a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static long2_mt32 operator%(long2_mt32 a, long2_mt32 b) => new(a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static long2_mt32 operator%(long_mt32 a, long2_mt32 b) => new(a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static long2_mt32 operator%(long2_mt32 a, long_mt32 b) => new(a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static long2_mt32 operator%(long2_mt32 a, long b) => new(a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static long2_mt32 operator++(long2_mt32 a) => a + long_mt32.One;

    [MethodImpl(256 | 512)]
    public static long2_mt32 operator--(long2_mt32 a) => a - long_mt32.One;

    #endregion // Operators
}

#endregion // long2_mt32
#region long3_mt4

public partial struct long3_mt4
{
    #region Constants

    public static long3_mt4 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static long3_mt4 One
    {
        [MethodImpl(256 | 512)]
        get => new(1L);
    }

    public static long3_mt4 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1L + 1L));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static long3_mt4 operator-(long3_mt4 a) => new(-a.x, -a.y, -a.z);

    [MethodImpl(256 | 512)]
    public static long3_mt4 operator+(long3_mt4 a, long3_mt4 b) => new(a.x + b.x, a.y + b.y, a.z + b.z);

    [MethodImpl(256 | 512)]
    public static long3_mt4 operator+(long3_mt4 a, long_mt4 b) => new(a.x + b, a.y + b, a.z + b);

    [MethodImpl(256 | 512)]
    public static long3_mt4 operator+(long_mt4 a, long3_mt4 b) => new(a + b.x, a + b.y, a + b.z);

    [MethodImpl(256 | 512)]
    public static long3_mt4 operator-(long3_mt4 a, long3_mt4 b) => new(a.x - b.x, a.y - b.y, a.z - b.z);

    [MethodImpl(256 | 512)]
    public static long3_mt4 operator-(long3_mt4 a, long_mt4 b) => new(a.x - b, a.y - b, a.z - b);

    [MethodImpl(256 | 512)]
    public static long3_mt4 operator-(long_mt4 a, long3_mt4 b) => new(a - b.x, a - b.y, a - b.z);

    [MethodImpl(256 | 512)]
    public static long3_mt4 operator*(long3_mt4 a, long3_mt4 b) => new(a.x * b.x, a.y * b.y, a.z * b.z);

    [MethodImpl(256 | 512)]
    public static long3_mt4 operator*(long3_mt4 a, long_mt4 b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static long3_mt4 operator*(long_mt4 a, long3_mt4 b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static long3_mt4 operator*(long3_mt4 a, long b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static long3_mt4 operator*(long a, long3_mt4 b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static long3_mt4 operator/(long3_mt4 a, long3_mt4 b) => new(a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static long3_mt4 operator/(long_mt4 a, long3_mt4 b) => new(a / b.z, a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static long3_mt4 operator/(long3_mt4 a, long_mt4 b) => new(a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static long3_mt4 operator/(long3_mt4 a, long b) => new(a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static long3_mt4 operator%(long3_mt4 a, long3_mt4 b) => new(a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static long3_mt4 operator%(long_mt4 a, long3_mt4 b) => new(a % b.z, a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static long3_mt4 operator%(long3_mt4 a, long_mt4 b) => new(a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static long3_mt4 operator%(long3_mt4 a, long b) => new(a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static long3_mt4 operator++(long3_mt4 a) => a + long_mt4.One;

    [MethodImpl(256 | 512)]
    public static long3_mt4 operator--(long3_mt4 a) => a - long_mt4.One;

    #endregion // Operators
}

#endregion // long3_mt4
#region long3_mt8

public partial struct long3_mt8
{
    #region Constants

    public static long3_mt8 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static long3_mt8 One
    {
        [MethodImpl(256 | 512)]
        get => new(1L);
    }

    public static long3_mt8 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1L + 1L));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static long3_mt8 operator-(long3_mt8 a) => new(-a.x, -a.y, -a.z);

    [MethodImpl(256 | 512)]
    public static long3_mt8 operator+(long3_mt8 a, long3_mt8 b) => new(a.x + b.x, a.y + b.y, a.z + b.z);

    [MethodImpl(256 | 512)]
    public static long3_mt8 operator+(long3_mt8 a, long_mt8 b) => new(a.x + b, a.y + b, a.z + b);

    [MethodImpl(256 | 512)]
    public static long3_mt8 operator+(long_mt8 a, long3_mt8 b) => new(a + b.x, a + b.y, a + b.z);

    [MethodImpl(256 | 512)]
    public static long3_mt8 operator-(long3_mt8 a, long3_mt8 b) => new(a.x - b.x, a.y - b.y, a.z - b.z);

    [MethodImpl(256 | 512)]
    public static long3_mt8 operator-(long3_mt8 a, long_mt8 b) => new(a.x - b, a.y - b, a.z - b);

    [MethodImpl(256 | 512)]
    public static long3_mt8 operator-(long_mt8 a, long3_mt8 b) => new(a - b.x, a - b.y, a - b.z);

    [MethodImpl(256 | 512)]
    public static long3_mt8 operator*(long3_mt8 a, long3_mt8 b) => new(a.x * b.x, a.y * b.y, a.z * b.z);

    [MethodImpl(256 | 512)]
    public static long3_mt8 operator*(long3_mt8 a, long_mt8 b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static long3_mt8 operator*(long_mt8 a, long3_mt8 b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static long3_mt8 operator*(long3_mt8 a, long b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static long3_mt8 operator*(long a, long3_mt8 b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static long3_mt8 operator/(long3_mt8 a, long3_mt8 b) => new(a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static long3_mt8 operator/(long_mt8 a, long3_mt8 b) => new(a / b.z, a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static long3_mt8 operator/(long3_mt8 a, long_mt8 b) => new(a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static long3_mt8 operator/(long3_mt8 a, long b) => new(a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static long3_mt8 operator%(long3_mt8 a, long3_mt8 b) => new(a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static long3_mt8 operator%(long_mt8 a, long3_mt8 b) => new(a % b.z, a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static long3_mt8 operator%(long3_mt8 a, long_mt8 b) => new(a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static long3_mt8 operator%(long3_mt8 a, long b) => new(a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static long3_mt8 operator++(long3_mt8 a) => a + long_mt8.One;

    [MethodImpl(256 | 512)]
    public static long3_mt8 operator--(long3_mt8 a) => a - long_mt8.One;

    #endregion // Operators
}

#endregion // long3_mt8
#region long3_mt16

public partial struct long3_mt16
{
    #region Constants

    public static long3_mt16 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static long3_mt16 One
    {
        [MethodImpl(256 | 512)]
        get => new(1L);
    }

    public static long3_mt16 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1L + 1L));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static long3_mt16 operator-(long3_mt16 a) => new(-a.x, -a.y, -a.z);

    [MethodImpl(256 | 512)]
    public static long3_mt16 operator+(long3_mt16 a, long3_mt16 b) => new(a.x + b.x, a.y + b.y, a.z + b.z);

    [MethodImpl(256 | 512)]
    public static long3_mt16 operator+(long3_mt16 a, long_mt16 b) => new(a.x + b, a.y + b, a.z + b);

    [MethodImpl(256 | 512)]
    public static long3_mt16 operator+(long_mt16 a, long3_mt16 b) => new(a + b.x, a + b.y, a + b.z);

    [MethodImpl(256 | 512)]
    public static long3_mt16 operator-(long3_mt16 a, long3_mt16 b) => new(a.x - b.x, a.y - b.y, a.z - b.z);

    [MethodImpl(256 | 512)]
    public static long3_mt16 operator-(long3_mt16 a, long_mt16 b) => new(a.x - b, a.y - b, a.z - b);

    [MethodImpl(256 | 512)]
    public static long3_mt16 operator-(long_mt16 a, long3_mt16 b) => new(a - b.x, a - b.y, a - b.z);

    [MethodImpl(256 | 512)]
    public static long3_mt16 operator*(long3_mt16 a, long3_mt16 b) => new(a.x * b.x, a.y * b.y, a.z * b.z);

    [MethodImpl(256 | 512)]
    public static long3_mt16 operator*(long3_mt16 a, long_mt16 b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static long3_mt16 operator*(long_mt16 a, long3_mt16 b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static long3_mt16 operator*(long3_mt16 a, long b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static long3_mt16 operator*(long a, long3_mt16 b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static long3_mt16 operator/(long3_mt16 a, long3_mt16 b) => new(a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static long3_mt16 operator/(long_mt16 a, long3_mt16 b) => new(a / b.z, a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static long3_mt16 operator/(long3_mt16 a, long_mt16 b) => new(a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static long3_mt16 operator/(long3_mt16 a, long b) => new(a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static long3_mt16 operator%(long3_mt16 a, long3_mt16 b) => new(a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static long3_mt16 operator%(long_mt16 a, long3_mt16 b) => new(a % b.z, a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static long3_mt16 operator%(long3_mt16 a, long_mt16 b) => new(a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static long3_mt16 operator%(long3_mt16 a, long b) => new(a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static long3_mt16 operator++(long3_mt16 a) => a + long_mt16.One;

    [MethodImpl(256 | 512)]
    public static long3_mt16 operator--(long3_mt16 a) => a - long_mt16.One;

    #endregion // Operators
}

#endregion // long3_mt16
#region long3_mt32

public partial struct long3_mt32
{
    #region Constants

    public static long3_mt32 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static long3_mt32 One
    {
        [MethodImpl(256 | 512)]
        get => new(1L);
    }

    public static long3_mt32 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1L + 1L));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static long3_mt32 operator-(long3_mt32 a) => new(-a.x, -a.y, -a.z);

    [MethodImpl(256 | 512)]
    public static long3_mt32 operator+(long3_mt32 a, long3_mt32 b) => new(a.x + b.x, a.y + b.y, a.z + b.z);

    [MethodImpl(256 | 512)]
    public static long3_mt32 operator+(long3_mt32 a, long_mt32 b) => new(a.x + b, a.y + b, a.z + b);

    [MethodImpl(256 | 512)]
    public static long3_mt32 operator+(long_mt32 a, long3_mt32 b) => new(a + b.x, a + b.y, a + b.z);

    [MethodImpl(256 | 512)]
    public static long3_mt32 operator-(long3_mt32 a, long3_mt32 b) => new(a.x - b.x, a.y - b.y, a.z - b.z);

    [MethodImpl(256 | 512)]
    public static long3_mt32 operator-(long3_mt32 a, long_mt32 b) => new(a.x - b, a.y - b, a.z - b);

    [MethodImpl(256 | 512)]
    public static long3_mt32 operator-(long_mt32 a, long3_mt32 b) => new(a - b.x, a - b.y, a - b.z);

    [MethodImpl(256 | 512)]
    public static long3_mt32 operator*(long3_mt32 a, long3_mt32 b) => new(a.x * b.x, a.y * b.y, a.z * b.z);

    [MethodImpl(256 | 512)]
    public static long3_mt32 operator*(long3_mt32 a, long_mt32 b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static long3_mt32 operator*(long_mt32 a, long3_mt32 b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static long3_mt32 operator*(long3_mt32 a, long b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static long3_mt32 operator*(long a, long3_mt32 b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static long3_mt32 operator/(long3_mt32 a, long3_mt32 b) => new(a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static long3_mt32 operator/(long_mt32 a, long3_mt32 b) => new(a / b.z, a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static long3_mt32 operator/(long3_mt32 a, long_mt32 b) => new(a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static long3_mt32 operator/(long3_mt32 a, long b) => new(a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static long3_mt32 operator%(long3_mt32 a, long3_mt32 b) => new(a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static long3_mt32 operator%(long_mt32 a, long3_mt32 b) => new(a % b.z, a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static long3_mt32 operator%(long3_mt32 a, long_mt32 b) => new(a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static long3_mt32 operator%(long3_mt32 a, long b) => new(a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static long3_mt32 operator++(long3_mt32 a) => a + long_mt32.One;

    [MethodImpl(256 | 512)]
    public static long3_mt32 operator--(long3_mt32 a) => a - long_mt32.One;

    #endregion // Operators
}

#endregion // long3_mt32
#region long4_mt4

public partial struct long4_mt4
{
    #region Constants

    public static long4_mt4 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static long4_mt4 One
    {
        [MethodImpl(256 | 512)]
        get => new(1L);
    }

    public static long4_mt4 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1L + 1L));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static long4_mt4 operator-(long4_mt4 a) => new(-a.x, -a.y, -a.z, -a.w);

    [MethodImpl(256 | 512)]
    public static long4_mt4 operator+(long4_mt4 a, long4_mt4 b) => new(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);

    [MethodImpl(256 | 512)]
    public static long4_mt4 operator+(long4_mt4 a, long_mt4 b) => new(a.x + b, a.y + b, a.z + b, a.w + b);

    [MethodImpl(256 | 512)]
    public static long4_mt4 operator+(long_mt4 a, long4_mt4 b) => new(a + b.x, a + b.y, a + b.z, a + b.w);

    [MethodImpl(256 | 512)]
    public static long4_mt4 operator-(long4_mt4 a, long4_mt4 b) => new(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);

    [MethodImpl(256 | 512)]
    public static long4_mt4 operator-(long4_mt4 a, long_mt4 b) => new(a.x - b, a.y - b, a.z - b, a.w - b);

    [MethodImpl(256 | 512)]
    public static long4_mt4 operator-(long_mt4 a, long4_mt4 b) => new(a - b.x, a - b.y, a - b.z, a - b.w);

    [MethodImpl(256 | 512)]
    public static long4_mt4 operator*(long4_mt4 a, long4_mt4 b) => new(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);

    [MethodImpl(256 | 512)]
    public static long4_mt4 operator*(long4_mt4 a, long_mt4 b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static long4_mt4 operator*(long_mt4 a, long4_mt4 b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static long4_mt4 operator*(long4_mt4 a, long b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static long4_mt4 operator*(long a, long4_mt4 b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static long4_mt4 operator/(long4_mt4 a, long4_mt4 b) => new(a.w / b.w, a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static long4_mt4 operator/(long_mt4 a, long4_mt4 b) => new(a / b.w, a / b.z, a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static long4_mt4 operator/(long4_mt4 a, long_mt4 b) => new(a.w / b, a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static long4_mt4 operator/(long4_mt4 a, long b) => new(a.w / b, a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static long4_mt4 operator%(long4_mt4 a, long4_mt4 b) => new(a.w % b.w, a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static long4_mt4 operator%(long_mt4 a, long4_mt4 b) => new(a % b.w, a % b.z, a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static long4_mt4 operator%(long4_mt4 a, long_mt4 b) => new(a.w % b, a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static long4_mt4 operator%(long4_mt4 a, long b) => new(a.w % b, a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static long4_mt4 operator++(long4_mt4 a) => a + long_mt4.One;

    [MethodImpl(256 | 512)]
    public static long4_mt4 operator--(long4_mt4 a) => a - long_mt4.One;

    #endregion // Operators
}

#endregion // long4_mt4
#region long4_mt8

public partial struct long4_mt8
{
    #region Constants

    public static long4_mt8 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static long4_mt8 One
    {
        [MethodImpl(256 | 512)]
        get => new(1L);
    }

    public static long4_mt8 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1L + 1L));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static long4_mt8 operator-(long4_mt8 a) => new(-a.x, -a.y, -a.z, -a.w);

    [MethodImpl(256 | 512)]
    public static long4_mt8 operator+(long4_mt8 a, long4_mt8 b) => new(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);

    [MethodImpl(256 | 512)]
    public static long4_mt8 operator+(long4_mt8 a, long_mt8 b) => new(a.x + b, a.y + b, a.z + b, a.w + b);

    [MethodImpl(256 | 512)]
    public static long4_mt8 operator+(long_mt8 a, long4_mt8 b) => new(a + b.x, a + b.y, a + b.z, a + b.w);

    [MethodImpl(256 | 512)]
    public static long4_mt8 operator-(long4_mt8 a, long4_mt8 b) => new(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);

    [MethodImpl(256 | 512)]
    public static long4_mt8 operator-(long4_mt8 a, long_mt8 b) => new(a.x - b, a.y - b, a.z - b, a.w - b);

    [MethodImpl(256 | 512)]
    public static long4_mt8 operator-(long_mt8 a, long4_mt8 b) => new(a - b.x, a - b.y, a - b.z, a - b.w);

    [MethodImpl(256 | 512)]
    public static long4_mt8 operator*(long4_mt8 a, long4_mt8 b) => new(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);

    [MethodImpl(256 | 512)]
    public static long4_mt8 operator*(long4_mt8 a, long_mt8 b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static long4_mt8 operator*(long_mt8 a, long4_mt8 b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static long4_mt8 operator*(long4_mt8 a, long b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static long4_mt8 operator*(long a, long4_mt8 b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static long4_mt8 operator/(long4_mt8 a, long4_mt8 b) => new(a.w / b.w, a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static long4_mt8 operator/(long_mt8 a, long4_mt8 b) => new(a / b.w, a / b.z, a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static long4_mt8 operator/(long4_mt8 a, long_mt8 b) => new(a.w / b, a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static long4_mt8 operator/(long4_mt8 a, long b) => new(a.w / b, a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static long4_mt8 operator%(long4_mt8 a, long4_mt8 b) => new(a.w % b.w, a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static long4_mt8 operator%(long_mt8 a, long4_mt8 b) => new(a % b.w, a % b.z, a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static long4_mt8 operator%(long4_mt8 a, long_mt8 b) => new(a.w % b, a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static long4_mt8 operator%(long4_mt8 a, long b) => new(a.w % b, a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static long4_mt8 operator++(long4_mt8 a) => a + long_mt8.One;

    [MethodImpl(256 | 512)]
    public static long4_mt8 operator--(long4_mt8 a) => a - long_mt8.One;

    #endregion // Operators
}

#endregion // long4_mt8
#region long4_mt16

public partial struct long4_mt16
{
    #region Constants

    public static long4_mt16 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static long4_mt16 One
    {
        [MethodImpl(256 | 512)]
        get => new(1L);
    }

    public static long4_mt16 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1L + 1L));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static long4_mt16 operator-(long4_mt16 a) => new(-a.x, -a.y, -a.z, -a.w);

    [MethodImpl(256 | 512)]
    public static long4_mt16 operator+(long4_mt16 a, long4_mt16 b) => new(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);

    [MethodImpl(256 | 512)]
    public static long4_mt16 operator+(long4_mt16 a, long_mt16 b) => new(a.x + b, a.y + b, a.z + b, a.w + b);

    [MethodImpl(256 | 512)]
    public static long4_mt16 operator+(long_mt16 a, long4_mt16 b) => new(a + b.x, a + b.y, a + b.z, a + b.w);

    [MethodImpl(256 | 512)]
    public static long4_mt16 operator-(long4_mt16 a, long4_mt16 b) => new(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);

    [MethodImpl(256 | 512)]
    public static long4_mt16 operator-(long4_mt16 a, long_mt16 b) => new(a.x - b, a.y - b, a.z - b, a.w - b);

    [MethodImpl(256 | 512)]
    public static long4_mt16 operator-(long_mt16 a, long4_mt16 b) => new(a - b.x, a - b.y, a - b.z, a - b.w);

    [MethodImpl(256 | 512)]
    public static long4_mt16 operator*(long4_mt16 a, long4_mt16 b) => new(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);

    [MethodImpl(256 | 512)]
    public static long4_mt16 operator*(long4_mt16 a, long_mt16 b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static long4_mt16 operator*(long_mt16 a, long4_mt16 b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static long4_mt16 operator*(long4_mt16 a, long b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static long4_mt16 operator*(long a, long4_mt16 b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static long4_mt16 operator/(long4_mt16 a, long4_mt16 b) => new(a.w / b.w, a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static long4_mt16 operator/(long_mt16 a, long4_mt16 b) => new(a / b.w, a / b.z, a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static long4_mt16 operator/(long4_mt16 a, long_mt16 b) => new(a.w / b, a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static long4_mt16 operator/(long4_mt16 a, long b) => new(a.w / b, a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static long4_mt16 operator%(long4_mt16 a, long4_mt16 b) => new(a.w % b.w, a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static long4_mt16 operator%(long_mt16 a, long4_mt16 b) => new(a % b.w, a % b.z, a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static long4_mt16 operator%(long4_mt16 a, long_mt16 b) => new(a.w % b, a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static long4_mt16 operator%(long4_mt16 a, long b) => new(a.w % b, a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static long4_mt16 operator++(long4_mt16 a) => a + long_mt16.One;

    [MethodImpl(256 | 512)]
    public static long4_mt16 operator--(long4_mt16 a) => a - long_mt16.One;

    #endregion // Operators
}

#endregion // long4_mt16
#region long4_mt32

public partial struct long4_mt32
{
    #region Constants

    public static long4_mt32 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static long4_mt32 One
    {
        [MethodImpl(256 | 512)]
        get => new(1L);
    }

    public static long4_mt32 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1L + 1L));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static long4_mt32 operator-(long4_mt32 a) => new(-a.x, -a.y, -a.z, -a.w);

    [MethodImpl(256 | 512)]
    public static long4_mt32 operator+(long4_mt32 a, long4_mt32 b) => new(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);

    [MethodImpl(256 | 512)]
    public static long4_mt32 operator+(long4_mt32 a, long_mt32 b) => new(a.x + b, a.y + b, a.z + b, a.w + b);

    [MethodImpl(256 | 512)]
    public static long4_mt32 operator+(long_mt32 a, long4_mt32 b) => new(a + b.x, a + b.y, a + b.z, a + b.w);

    [MethodImpl(256 | 512)]
    public static long4_mt32 operator-(long4_mt32 a, long4_mt32 b) => new(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);

    [MethodImpl(256 | 512)]
    public static long4_mt32 operator-(long4_mt32 a, long_mt32 b) => new(a.x - b, a.y - b, a.z - b, a.w - b);

    [MethodImpl(256 | 512)]
    public static long4_mt32 operator-(long_mt32 a, long4_mt32 b) => new(a - b.x, a - b.y, a - b.z, a - b.w);

    [MethodImpl(256 | 512)]
    public static long4_mt32 operator*(long4_mt32 a, long4_mt32 b) => new(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);

    [MethodImpl(256 | 512)]
    public static long4_mt32 operator*(long4_mt32 a, long_mt32 b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static long4_mt32 operator*(long_mt32 a, long4_mt32 b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static long4_mt32 operator*(long4_mt32 a, long b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static long4_mt32 operator*(long a, long4_mt32 b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static long4_mt32 operator/(long4_mt32 a, long4_mt32 b) => new(a.w / b.w, a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static long4_mt32 operator/(long_mt32 a, long4_mt32 b) => new(a / b.w, a / b.z, a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static long4_mt32 operator/(long4_mt32 a, long_mt32 b) => new(a.w / b, a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static long4_mt32 operator/(long4_mt32 a, long b) => new(a.w / b, a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static long4_mt32 operator%(long4_mt32 a, long4_mt32 b) => new(a.w % b.w, a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static long4_mt32 operator%(long_mt32 a, long4_mt32 b) => new(a % b.w, a % b.z, a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static long4_mt32 operator%(long4_mt32 a, long_mt32 b) => new(a.w % b, a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static long4_mt32 operator%(long4_mt32 a, long b) => new(a.w % b, a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static long4_mt32 operator++(long4_mt32 a) => a + long_mt32.One;

    [MethodImpl(256 | 512)]
    public static long4_mt32 operator--(long4_mt32 a) => a - long_mt32.One;

    #endregion // Operators
}

#endregion // long4_mt32
#region ulong2_mt4

public partial struct ulong2_mt4
{
    #region Constants

    public static ulong2_mt4 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static ulong2_mt4 One
    {
        [MethodImpl(256 | 512)]
        get => new(1UL);
    }

    public static ulong2_mt4 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1UL + 1UL));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static ulong2_mt4 operator-(ulong2_mt4 a) => new(-a.x, -a.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt4 operator+(ulong2_mt4 a, ulong2_mt4 b) => new(a.x + b.x, a.y + b.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt4 operator+(ulong2_mt4 a, ulong_mt4 b) => new(a.x + b, a.y + b);

    [MethodImpl(256 | 512)]
    public static ulong2_mt4 operator+(ulong_mt4 a, ulong2_mt4 b) => new(a + b.x, a + b.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt4 operator-(ulong2_mt4 a, ulong2_mt4 b) => new(a.x - b.x, a.y - b.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt4 operator-(ulong2_mt4 a, ulong_mt4 b) => new(a.x - b, a.y - b);

    [MethodImpl(256 | 512)]
    public static ulong2_mt4 operator-(ulong_mt4 a, ulong2_mt4 b) => new(a - b.x, a - b.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt4 operator*(ulong2_mt4 a, ulong2_mt4 b) => new(a.x * b.x, a.y * b.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt4 operator*(ulong2_mt4 a, ulong_mt4 b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static ulong2_mt4 operator*(ulong_mt4 a, ulong2_mt4 b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt4 operator*(ulong2_mt4 a, ulong b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static ulong2_mt4 operator*(ulong a, ulong2_mt4 b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt4 operator/(ulong2_mt4 a, ulong2_mt4 b) => new(a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static ulong2_mt4 operator/(ulong_mt4 a, ulong2_mt4 b) => new(a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static ulong2_mt4 operator/(ulong2_mt4 a, ulong_mt4 b) => new(a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static ulong2_mt4 operator/(ulong2_mt4 a, ulong b) => new(a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static ulong2_mt4 operator%(ulong2_mt4 a, ulong2_mt4 b) => new(a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static ulong2_mt4 operator%(ulong_mt4 a, ulong2_mt4 b) => new(a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static ulong2_mt4 operator%(ulong2_mt4 a, ulong_mt4 b) => new(a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static ulong2_mt4 operator%(ulong2_mt4 a, ulong b) => new(a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static ulong2_mt4 operator++(ulong2_mt4 a) => a + ulong_mt4.One;

    [MethodImpl(256 | 512)]
    public static ulong2_mt4 operator--(ulong2_mt4 a) => a - ulong_mt4.One;

    #endregion // Operators
}

#endregion // ulong2_mt4
#region ulong2_mt8

public partial struct ulong2_mt8
{
    #region Constants

    public static ulong2_mt8 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static ulong2_mt8 One
    {
        [MethodImpl(256 | 512)]
        get => new(1UL);
    }

    public static ulong2_mt8 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1UL + 1UL));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static ulong2_mt8 operator-(ulong2_mt8 a) => new(-a.x, -a.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt8 operator+(ulong2_mt8 a, ulong2_mt8 b) => new(a.x + b.x, a.y + b.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt8 operator+(ulong2_mt8 a, ulong_mt8 b) => new(a.x + b, a.y + b);

    [MethodImpl(256 | 512)]
    public static ulong2_mt8 operator+(ulong_mt8 a, ulong2_mt8 b) => new(a + b.x, a + b.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt8 operator-(ulong2_mt8 a, ulong2_mt8 b) => new(a.x - b.x, a.y - b.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt8 operator-(ulong2_mt8 a, ulong_mt8 b) => new(a.x - b, a.y - b);

    [MethodImpl(256 | 512)]
    public static ulong2_mt8 operator-(ulong_mt8 a, ulong2_mt8 b) => new(a - b.x, a - b.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt8 operator*(ulong2_mt8 a, ulong2_mt8 b) => new(a.x * b.x, a.y * b.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt8 operator*(ulong2_mt8 a, ulong_mt8 b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static ulong2_mt8 operator*(ulong_mt8 a, ulong2_mt8 b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt8 operator*(ulong2_mt8 a, ulong b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static ulong2_mt8 operator*(ulong a, ulong2_mt8 b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt8 operator/(ulong2_mt8 a, ulong2_mt8 b) => new(a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static ulong2_mt8 operator/(ulong_mt8 a, ulong2_mt8 b) => new(a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static ulong2_mt8 operator/(ulong2_mt8 a, ulong_mt8 b) => new(a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static ulong2_mt8 operator/(ulong2_mt8 a, ulong b) => new(a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static ulong2_mt8 operator%(ulong2_mt8 a, ulong2_mt8 b) => new(a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static ulong2_mt8 operator%(ulong_mt8 a, ulong2_mt8 b) => new(a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static ulong2_mt8 operator%(ulong2_mt8 a, ulong_mt8 b) => new(a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static ulong2_mt8 operator%(ulong2_mt8 a, ulong b) => new(a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static ulong2_mt8 operator++(ulong2_mt8 a) => a + ulong_mt8.One;

    [MethodImpl(256 | 512)]
    public static ulong2_mt8 operator--(ulong2_mt8 a) => a - ulong_mt8.One;

    #endregion // Operators
}

#endregion // ulong2_mt8
#region ulong2_mt16

public partial struct ulong2_mt16
{
    #region Constants

    public static ulong2_mt16 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static ulong2_mt16 One
    {
        [MethodImpl(256 | 512)]
        get => new(1UL);
    }

    public static ulong2_mt16 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1UL + 1UL));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static ulong2_mt16 operator-(ulong2_mt16 a) => new(-a.x, -a.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt16 operator+(ulong2_mt16 a, ulong2_mt16 b) => new(a.x + b.x, a.y + b.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt16 operator+(ulong2_mt16 a, ulong_mt16 b) => new(a.x + b, a.y + b);

    [MethodImpl(256 | 512)]
    public static ulong2_mt16 operator+(ulong_mt16 a, ulong2_mt16 b) => new(a + b.x, a + b.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt16 operator-(ulong2_mt16 a, ulong2_mt16 b) => new(a.x - b.x, a.y - b.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt16 operator-(ulong2_mt16 a, ulong_mt16 b) => new(a.x - b, a.y - b);

    [MethodImpl(256 | 512)]
    public static ulong2_mt16 operator-(ulong_mt16 a, ulong2_mt16 b) => new(a - b.x, a - b.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt16 operator*(ulong2_mt16 a, ulong2_mt16 b) => new(a.x * b.x, a.y * b.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt16 operator*(ulong2_mt16 a, ulong_mt16 b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static ulong2_mt16 operator*(ulong_mt16 a, ulong2_mt16 b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt16 operator*(ulong2_mt16 a, ulong b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static ulong2_mt16 operator*(ulong a, ulong2_mt16 b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt16 operator/(ulong2_mt16 a, ulong2_mt16 b) => new(a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static ulong2_mt16 operator/(ulong_mt16 a, ulong2_mt16 b) => new(a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static ulong2_mt16 operator/(ulong2_mt16 a, ulong_mt16 b) => new(a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static ulong2_mt16 operator/(ulong2_mt16 a, ulong b) => new(a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static ulong2_mt16 operator%(ulong2_mt16 a, ulong2_mt16 b) => new(a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static ulong2_mt16 operator%(ulong_mt16 a, ulong2_mt16 b) => new(a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static ulong2_mt16 operator%(ulong2_mt16 a, ulong_mt16 b) => new(a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static ulong2_mt16 operator%(ulong2_mt16 a, ulong b) => new(a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static ulong2_mt16 operator++(ulong2_mt16 a) => a + ulong_mt16.One;

    [MethodImpl(256 | 512)]
    public static ulong2_mt16 operator--(ulong2_mt16 a) => a - ulong_mt16.One;

    #endregion // Operators
}

#endregion // ulong2_mt16
#region ulong2_mt32

public partial struct ulong2_mt32
{
    #region Constants

    public static ulong2_mt32 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static ulong2_mt32 One
    {
        [MethodImpl(256 | 512)]
        get => new(1UL);
    }

    public static ulong2_mt32 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1UL + 1UL));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static ulong2_mt32 operator-(ulong2_mt32 a) => new(-a.x, -a.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt32 operator+(ulong2_mt32 a, ulong2_mt32 b) => new(a.x + b.x, a.y + b.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt32 operator+(ulong2_mt32 a, ulong_mt32 b) => new(a.x + b, a.y + b);

    [MethodImpl(256 | 512)]
    public static ulong2_mt32 operator+(ulong_mt32 a, ulong2_mt32 b) => new(a + b.x, a + b.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt32 operator-(ulong2_mt32 a, ulong2_mt32 b) => new(a.x - b.x, a.y - b.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt32 operator-(ulong2_mt32 a, ulong_mt32 b) => new(a.x - b, a.y - b);

    [MethodImpl(256 | 512)]
    public static ulong2_mt32 operator-(ulong_mt32 a, ulong2_mt32 b) => new(a - b.x, a - b.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt32 operator*(ulong2_mt32 a, ulong2_mt32 b) => new(a.x * b.x, a.y * b.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt32 operator*(ulong2_mt32 a, ulong_mt32 b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static ulong2_mt32 operator*(ulong_mt32 a, ulong2_mt32 b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt32 operator*(ulong2_mt32 a, ulong b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static ulong2_mt32 operator*(ulong a, ulong2_mt32 b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt32 operator/(ulong2_mt32 a, ulong2_mt32 b) => new(a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static ulong2_mt32 operator/(ulong_mt32 a, ulong2_mt32 b) => new(a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static ulong2_mt32 operator/(ulong2_mt32 a, ulong_mt32 b) => new(a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static ulong2_mt32 operator/(ulong2_mt32 a, ulong b) => new(a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static ulong2_mt32 operator%(ulong2_mt32 a, ulong2_mt32 b) => new(a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static ulong2_mt32 operator%(ulong_mt32 a, ulong2_mt32 b) => new(a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static ulong2_mt32 operator%(ulong2_mt32 a, ulong_mt32 b) => new(a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static ulong2_mt32 operator%(ulong2_mt32 a, ulong b) => new(a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static ulong2_mt32 operator++(ulong2_mt32 a) => a + ulong_mt32.One;

    [MethodImpl(256 | 512)]
    public static ulong2_mt32 operator--(ulong2_mt32 a) => a - ulong_mt32.One;

    #endregion // Operators
}

#endregion // ulong2_mt32
#region ulong3_mt4

public partial struct ulong3_mt4
{
    #region Constants

    public static ulong3_mt4 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static ulong3_mt4 One
    {
        [MethodImpl(256 | 512)]
        get => new(1UL);
    }

    public static ulong3_mt4 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1UL + 1UL));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static ulong3_mt4 operator-(ulong3_mt4 a) => new(-a.x, -a.y, -a.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt4 operator+(ulong3_mt4 a, ulong3_mt4 b) => new(a.x + b.x, a.y + b.y, a.z + b.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt4 operator+(ulong3_mt4 a, ulong_mt4 b) => new(a.x + b, a.y + b, a.z + b);

    [MethodImpl(256 | 512)]
    public static ulong3_mt4 operator+(ulong_mt4 a, ulong3_mt4 b) => new(a + b.x, a + b.y, a + b.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt4 operator-(ulong3_mt4 a, ulong3_mt4 b) => new(a.x - b.x, a.y - b.y, a.z - b.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt4 operator-(ulong3_mt4 a, ulong_mt4 b) => new(a.x - b, a.y - b, a.z - b);

    [MethodImpl(256 | 512)]
    public static ulong3_mt4 operator-(ulong_mt4 a, ulong3_mt4 b) => new(a - b.x, a - b.y, a - b.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt4 operator*(ulong3_mt4 a, ulong3_mt4 b) => new(a.x * b.x, a.y * b.y, a.z * b.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt4 operator*(ulong3_mt4 a, ulong_mt4 b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static ulong3_mt4 operator*(ulong_mt4 a, ulong3_mt4 b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt4 operator*(ulong3_mt4 a, ulong b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static ulong3_mt4 operator*(ulong a, ulong3_mt4 b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt4 operator/(ulong3_mt4 a, ulong3_mt4 b) => new(a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static ulong3_mt4 operator/(ulong_mt4 a, ulong3_mt4 b) => new(a / b.z, a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static ulong3_mt4 operator/(ulong3_mt4 a, ulong_mt4 b) => new(a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static ulong3_mt4 operator/(ulong3_mt4 a, ulong b) => new(a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static ulong3_mt4 operator%(ulong3_mt4 a, ulong3_mt4 b) => new(a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static ulong3_mt4 operator%(ulong_mt4 a, ulong3_mt4 b) => new(a % b.z, a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static ulong3_mt4 operator%(ulong3_mt4 a, ulong_mt4 b) => new(a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static ulong3_mt4 operator%(ulong3_mt4 a, ulong b) => new(a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static ulong3_mt4 operator++(ulong3_mt4 a) => a + ulong_mt4.One;

    [MethodImpl(256 | 512)]
    public static ulong3_mt4 operator--(ulong3_mt4 a) => a - ulong_mt4.One;

    #endregion // Operators
}

#endregion // ulong3_mt4
#region ulong3_mt8

public partial struct ulong3_mt8
{
    #region Constants

    public static ulong3_mt8 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static ulong3_mt8 One
    {
        [MethodImpl(256 | 512)]
        get => new(1UL);
    }

    public static ulong3_mt8 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1UL + 1UL));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static ulong3_mt8 operator-(ulong3_mt8 a) => new(-a.x, -a.y, -a.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt8 operator+(ulong3_mt8 a, ulong3_mt8 b) => new(a.x + b.x, a.y + b.y, a.z + b.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt8 operator+(ulong3_mt8 a, ulong_mt8 b) => new(a.x + b, a.y + b, a.z + b);

    [MethodImpl(256 | 512)]
    public static ulong3_mt8 operator+(ulong_mt8 a, ulong3_mt8 b) => new(a + b.x, a + b.y, a + b.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt8 operator-(ulong3_mt8 a, ulong3_mt8 b) => new(a.x - b.x, a.y - b.y, a.z - b.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt8 operator-(ulong3_mt8 a, ulong_mt8 b) => new(a.x - b, a.y - b, a.z - b);

    [MethodImpl(256 | 512)]
    public static ulong3_mt8 operator-(ulong_mt8 a, ulong3_mt8 b) => new(a - b.x, a - b.y, a - b.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt8 operator*(ulong3_mt8 a, ulong3_mt8 b) => new(a.x * b.x, a.y * b.y, a.z * b.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt8 operator*(ulong3_mt8 a, ulong_mt8 b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static ulong3_mt8 operator*(ulong_mt8 a, ulong3_mt8 b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt8 operator*(ulong3_mt8 a, ulong b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static ulong3_mt8 operator*(ulong a, ulong3_mt8 b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt8 operator/(ulong3_mt8 a, ulong3_mt8 b) => new(a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static ulong3_mt8 operator/(ulong_mt8 a, ulong3_mt8 b) => new(a / b.z, a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static ulong3_mt8 operator/(ulong3_mt8 a, ulong_mt8 b) => new(a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static ulong3_mt8 operator/(ulong3_mt8 a, ulong b) => new(a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static ulong3_mt8 operator%(ulong3_mt8 a, ulong3_mt8 b) => new(a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static ulong3_mt8 operator%(ulong_mt8 a, ulong3_mt8 b) => new(a % b.z, a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static ulong3_mt8 operator%(ulong3_mt8 a, ulong_mt8 b) => new(a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static ulong3_mt8 operator%(ulong3_mt8 a, ulong b) => new(a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static ulong3_mt8 operator++(ulong3_mt8 a) => a + ulong_mt8.One;

    [MethodImpl(256 | 512)]
    public static ulong3_mt8 operator--(ulong3_mt8 a) => a - ulong_mt8.One;

    #endregion // Operators
}

#endregion // ulong3_mt8
#region ulong3_mt16

public partial struct ulong3_mt16
{
    #region Constants

    public static ulong3_mt16 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static ulong3_mt16 One
    {
        [MethodImpl(256 | 512)]
        get => new(1UL);
    }

    public static ulong3_mt16 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1UL + 1UL));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static ulong3_mt16 operator-(ulong3_mt16 a) => new(-a.x, -a.y, -a.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt16 operator+(ulong3_mt16 a, ulong3_mt16 b) => new(a.x + b.x, a.y + b.y, a.z + b.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt16 operator+(ulong3_mt16 a, ulong_mt16 b) => new(a.x + b, a.y + b, a.z + b);

    [MethodImpl(256 | 512)]
    public static ulong3_mt16 operator+(ulong_mt16 a, ulong3_mt16 b) => new(a + b.x, a + b.y, a + b.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt16 operator-(ulong3_mt16 a, ulong3_mt16 b) => new(a.x - b.x, a.y - b.y, a.z - b.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt16 operator-(ulong3_mt16 a, ulong_mt16 b) => new(a.x - b, a.y - b, a.z - b);

    [MethodImpl(256 | 512)]
    public static ulong3_mt16 operator-(ulong_mt16 a, ulong3_mt16 b) => new(a - b.x, a - b.y, a - b.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt16 operator*(ulong3_mt16 a, ulong3_mt16 b) => new(a.x * b.x, a.y * b.y, a.z * b.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt16 operator*(ulong3_mt16 a, ulong_mt16 b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static ulong3_mt16 operator*(ulong_mt16 a, ulong3_mt16 b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt16 operator*(ulong3_mt16 a, ulong b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static ulong3_mt16 operator*(ulong a, ulong3_mt16 b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt16 operator/(ulong3_mt16 a, ulong3_mt16 b) => new(a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static ulong3_mt16 operator/(ulong_mt16 a, ulong3_mt16 b) => new(a / b.z, a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static ulong3_mt16 operator/(ulong3_mt16 a, ulong_mt16 b) => new(a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static ulong3_mt16 operator/(ulong3_mt16 a, ulong b) => new(a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static ulong3_mt16 operator%(ulong3_mt16 a, ulong3_mt16 b) => new(a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static ulong3_mt16 operator%(ulong_mt16 a, ulong3_mt16 b) => new(a % b.z, a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static ulong3_mt16 operator%(ulong3_mt16 a, ulong_mt16 b) => new(a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static ulong3_mt16 operator%(ulong3_mt16 a, ulong b) => new(a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static ulong3_mt16 operator++(ulong3_mt16 a) => a + ulong_mt16.One;

    [MethodImpl(256 | 512)]
    public static ulong3_mt16 operator--(ulong3_mt16 a) => a - ulong_mt16.One;

    #endregion // Operators
}

#endregion // ulong3_mt16
#region ulong3_mt32

public partial struct ulong3_mt32
{
    #region Constants

    public static ulong3_mt32 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static ulong3_mt32 One
    {
        [MethodImpl(256 | 512)]
        get => new(1UL);
    }

    public static ulong3_mt32 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1UL + 1UL));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static ulong3_mt32 operator-(ulong3_mt32 a) => new(-a.x, -a.y, -a.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt32 operator+(ulong3_mt32 a, ulong3_mt32 b) => new(a.x + b.x, a.y + b.y, a.z + b.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt32 operator+(ulong3_mt32 a, ulong_mt32 b) => new(a.x + b, a.y + b, a.z + b);

    [MethodImpl(256 | 512)]
    public static ulong3_mt32 operator+(ulong_mt32 a, ulong3_mt32 b) => new(a + b.x, a + b.y, a + b.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt32 operator-(ulong3_mt32 a, ulong3_mt32 b) => new(a.x - b.x, a.y - b.y, a.z - b.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt32 operator-(ulong3_mt32 a, ulong_mt32 b) => new(a.x - b, a.y - b, a.z - b);

    [MethodImpl(256 | 512)]
    public static ulong3_mt32 operator-(ulong_mt32 a, ulong3_mt32 b) => new(a - b.x, a - b.y, a - b.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt32 operator*(ulong3_mt32 a, ulong3_mt32 b) => new(a.x * b.x, a.y * b.y, a.z * b.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt32 operator*(ulong3_mt32 a, ulong_mt32 b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static ulong3_mt32 operator*(ulong_mt32 a, ulong3_mt32 b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt32 operator*(ulong3_mt32 a, ulong b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static ulong3_mt32 operator*(ulong a, ulong3_mt32 b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt32 operator/(ulong3_mt32 a, ulong3_mt32 b) => new(a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static ulong3_mt32 operator/(ulong_mt32 a, ulong3_mt32 b) => new(a / b.z, a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static ulong3_mt32 operator/(ulong3_mt32 a, ulong_mt32 b) => new(a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static ulong3_mt32 operator/(ulong3_mt32 a, ulong b) => new(a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static ulong3_mt32 operator%(ulong3_mt32 a, ulong3_mt32 b) => new(a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static ulong3_mt32 operator%(ulong_mt32 a, ulong3_mt32 b) => new(a % b.z, a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static ulong3_mt32 operator%(ulong3_mt32 a, ulong_mt32 b) => new(a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static ulong3_mt32 operator%(ulong3_mt32 a, ulong b) => new(a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static ulong3_mt32 operator++(ulong3_mt32 a) => a + ulong_mt32.One;

    [MethodImpl(256 | 512)]
    public static ulong3_mt32 operator--(ulong3_mt32 a) => a - ulong_mt32.One;

    #endregion // Operators
}

#endregion // ulong3_mt32
#region ulong4_mt4

public partial struct ulong4_mt4
{
    #region Constants

    public static ulong4_mt4 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static ulong4_mt4 One
    {
        [MethodImpl(256 | 512)]
        get => new(1UL);
    }

    public static ulong4_mt4 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1UL + 1UL));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static ulong4_mt4 operator-(ulong4_mt4 a) => new(-a.x, -a.y, -a.z, -a.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt4 operator+(ulong4_mt4 a, ulong4_mt4 b) => new(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt4 operator+(ulong4_mt4 a, ulong_mt4 b) => new(a.x + b, a.y + b, a.z + b, a.w + b);

    [MethodImpl(256 | 512)]
    public static ulong4_mt4 operator+(ulong_mt4 a, ulong4_mt4 b) => new(a + b.x, a + b.y, a + b.z, a + b.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt4 operator-(ulong4_mt4 a, ulong4_mt4 b) => new(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt4 operator-(ulong4_mt4 a, ulong_mt4 b) => new(a.x - b, a.y - b, a.z - b, a.w - b);

    [MethodImpl(256 | 512)]
    public static ulong4_mt4 operator-(ulong_mt4 a, ulong4_mt4 b) => new(a - b.x, a - b.y, a - b.z, a - b.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt4 operator*(ulong4_mt4 a, ulong4_mt4 b) => new(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt4 operator*(ulong4_mt4 a, ulong_mt4 b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static ulong4_mt4 operator*(ulong_mt4 a, ulong4_mt4 b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt4 operator*(ulong4_mt4 a, ulong b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static ulong4_mt4 operator*(ulong a, ulong4_mt4 b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt4 operator/(ulong4_mt4 a, ulong4_mt4 b) => new(a.w / b.w, a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static ulong4_mt4 operator/(ulong_mt4 a, ulong4_mt4 b) => new(a / b.w, a / b.z, a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static ulong4_mt4 operator/(ulong4_mt4 a, ulong_mt4 b) => new(a.w / b, a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static ulong4_mt4 operator/(ulong4_mt4 a, ulong b) => new(a.w / b, a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static ulong4_mt4 operator%(ulong4_mt4 a, ulong4_mt4 b) => new(a.w % b.w, a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static ulong4_mt4 operator%(ulong_mt4 a, ulong4_mt4 b) => new(a % b.w, a % b.z, a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static ulong4_mt4 operator%(ulong4_mt4 a, ulong_mt4 b) => new(a.w % b, a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static ulong4_mt4 operator%(ulong4_mt4 a, ulong b) => new(a.w % b, a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static ulong4_mt4 operator++(ulong4_mt4 a) => a + ulong_mt4.One;

    [MethodImpl(256 | 512)]
    public static ulong4_mt4 operator--(ulong4_mt4 a) => a - ulong_mt4.One;

    #endregion // Operators
}

#endregion // ulong4_mt4
#region ulong4_mt8

public partial struct ulong4_mt8
{
    #region Constants

    public static ulong4_mt8 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static ulong4_mt8 One
    {
        [MethodImpl(256 | 512)]
        get => new(1UL);
    }

    public static ulong4_mt8 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1UL + 1UL));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static ulong4_mt8 operator-(ulong4_mt8 a) => new(-a.x, -a.y, -a.z, -a.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt8 operator+(ulong4_mt8 a, ulong4_mt8 b) => new(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt8 operator+(ulong4_mt8 a, ulong_mt8 b) => new(a.x + b, a.y + b, a.z + b, a.w + b);

    [MethodImpl(256 | 512)]
    public static ulong4_mt8 operator+(ulong_mt8 a, ulong4_mt8 b) => new(a + b.x, a + b.y, a + b.z, a + b.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt8 operator-(ulong4_mt8 a, ulong4_mt8 b) => new(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt8 operator-(ulong4_mt8 a, ulong_mt8 b) => new(a.x - b, a.y - b, a.z - b, a.w - b);

    [MethodImpl(256 | 512)]
    public static ulong4_mt8 operator-(ulong_mt8 a, ulong4_mt8 b) => new(a - b.x, a - b.y, a - b.z, a - b.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt8 operator*(ulong4_mt8 a, ulong4_mt8 b) => new(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt8 operator*(ulong4_mt8 a, ulong_mt8 b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static ulong4_mt8 operator*(ulong_mt8 a, ulong4_mt8 b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt8 operator*(ulong4_mt8 a, ulong b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static ulong4_mt8 operator*(ulong a, ulong4_mt8 b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt8 operator/(ulong4_mt8 a, ulong4_mt8 b) => new(a.w / b.w, a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static ulong4_mt8 operator/(ulong_mt8 a, ulong4_mt8 b) => new(a / b.w, a / b.z, a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static ulong4_mt8 operator/(ulong4_mt8 a, ulong_mt8 b) => new(a.w / b, a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static ulong4_mt8 operator/(ulong4_mt8 a, ulong b) => new(a.w / b, a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static ulong4_mt8 operator%(ulong4_mt8 a, ulong4_mt8 b) => new(a.w % b.w, a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static ulong4_mt8 operator%(ulong_mt8 a, ulong4_mt8 b) => new(a % b.w, a % b.z, a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static ulong4_mt8 operator%(ulong4_mt8 a, ulong_mt8 b) => new(a.w % b, a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static ulong4_mt8 operator%(ulong4_mt8 a, ulong b) => new(a.w % b, a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static ulong4_mt8 operator++(ulong4_mt8 a) => a + ulong_mt8.One;

    [MethodImpl(256 | 512)]
    public static ulong4_mt8 operator--(ulong4_mt8 a) => a - ulong_mt8.One;

    #endregion // Operators
}

#endregion // ulong4_mt8
#region ulong4_mt16

public partial struct ulong4_mt16
{
    #region Constants

    public static ulong4_mt16 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static ulong4_mt16 One
    {
        [MethodImpl(256 | 512)]
        get => new(1UL);
    }

    public static ulong4_mt16 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1UL + 1UL));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static ulong4_mt16 operator-(ulong4_mt16 a) => new(-a.x, -a.y, -a.z, -a.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt16 operator+(ulong4_mt16 a, ulong4_mt16 b) => new(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt16 operator+(ulong4_mt16 a, ulong_mt16 b) => new(a.x + b, a.y + b, a.z + b, a.w + b);

    [MethodImpl(256 | 512)]
    public static ulong4_mt16 operator+(ulong_mt16 a, ulong4_mt16 b) => new(a + b.x, a + b.y, a + b.z, a + b.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt16 operator-(ulong4_mt16 a, ulong4_mt16 b) => new(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt16 operator-(ulong4_mt16 a, ulong_mt16 b) => new(a.x - b, a.y - b, a.z - b, a.w - b);

    [MethodImpl(256 | 512)]
    public static ulong4_mt16 operator-(ulong_mt16 a, ulong4_mt16 b) => new(a - b.x, a - b.y, a - b.z, a - b.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt16 operator*(ulong4_mt16 a, ulong4_mt16 b) => new(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt16 operator*(ulong4_mt16 a, ulong_mt16 b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static ulong4_mt16 operator*(ulong_mt16 a, ulong4_mt16 b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt16 operator*(ulong4_mt16 a, ulong b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static ulong4_mt16 operator*(ulong a, ulong4_mt16 b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt16 operator/(ulong4_mt16 a, ulong4_mt16 b) => new(a.w / b.w, a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static ulong4_mt16 operator/(ulong_mt16 a, ulong4_mt16 b) => new(a / b.w, a / b.z, a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static ulong4_mt16 operator/(ulong4_mt16 a, ulong_mt16 b) => new(a.w / b, a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static ulong4_mt16 operator/(ulong4_mt16 a, ulong b) => new(a.w / b, a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static ulong4_mt16 operator%(ulong4_mt16 a, ulong4_mt16 b) => new(a.w % b.w, a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static ulong4_mt16 operator%(ulong_mt16 a, ulong4_mt16 b) => new(a % b.w, a % b.z, a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static ulong4_mt16 operator%(ulong4_mt16 a, ulong_mt16 b) => new(a.w % b, a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static ulong4_mt16 operator%(ulong4_mt16 a, ulong b) => new(a.w % b, a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static ulong4_mt16 operator++(ulong4_mt16 a) => a + ulong_mt16.One;

    [MethodImpl(256 | 512)]
    public static ulong4_mt16 operator--(ulong4_mt16 a) => a - ulong_mt16.One;

    #endregion // Operators
}

#endregion // ulong4_mt16
#region ulong4_mt32

public partial struct ulong4_mt32
{
    #region Constants

    public static ulong4_mt32 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static ulong4_mt32 One
    {
        [MethodImpl(256 | 512)]
        get => new(1UL);
    }

    public static ulong4_mt32 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1UL + 1UL));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static ulong4_mt32 operator-(ulong4_mt32 a) => new(-a.x, -a.y, -a.z, -a.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt32 operator+(ulong4_mt32 a, ulong4_mt32 b) => new(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt32 operator+(ulong4_mt32 a, ulong_mt32 b) => new(a.x + b, a.y + b, a.z + b, a.w + b);

    [MethodImpl(256 | 512)]
    public static ulong4_mt32 operator+(ulong_mt32 a, ulong4_mt32 b) => new(a + b.x, a + b.y, a + b.z, a + b.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt32 operator-(ulong4_mt32 a, ulong4_mt32 b) => new(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt32 operator-(ulong4_mt32 a, ulong_mt32 b) => new(a.x - b, a.y - b, a.z - b, a.w - b);

    [MethodImpl(256 | 512)]
    public static ulong4_mt32 operator-(ulong_mt32 a, ulong4_mt32 b) => new(a - b.x, a - b.y, a - b.z, a - b.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt32 operator*(ulong4_mt32 a, ulong4_mt32 b) => new(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt32 operator*(ulong4_mt32 a, ulong_mt32 b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static ulong4_mt32 operator*(ulong_mt32 a, ulong4_mt32 b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt32 operator*(ulong4_mt32 a, ulong b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static ulong4_mt32 operator*(ulong a, ulong4_mt32 b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt32 operator/(ulong4_mt32 a, ulong4_mt32 b) => new(a.w / b.w, a.z / b.z, a.y / b.y, a.x / b.x);

    [MethodImpl(256 | 512)]
    public static ulong4_mt32 operator/(ulong_mt32 a, ulong4_mt32 b) => new(a / b.w, a / b.z, a / b.y, a / b.x);

    [MethodImpl(256 | 512)]
    public static ulong4_mt32 operator/(ulong4_mt32 a, ulong_mt32 b) => new(a.w / b, a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static ulong4_mt32 operator/(ulong4_mt32 a, ulong b) => new(a.w / b, a.z / b, a.y / b, a.x / b);

    [MethodImpl(256 | 512)]
    public static ulong4_mt32 operator%(ulong4_mt32 a, ulong4_mt32 b) => new(a.w % b.w, a.z % b.z, a.y % b.y, a.x % b.x);

    [MethodImpl(256 | 512)]
    public static ulong4_mt32 operator%(ulong_mt32 a, ulong4_mt32 b) => new(a % b.w, a % b.z, a % b.y, a % b.x);

    [MethodImpl(256 | 512)]
    public static ulong4_mt32 operator%(ulong4_mt32 a, ulong_mt32 b) => new(a.w % b, a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static ulong4_mt32 operator%(ulong4_mt32 a, ulong b) => new(a.w % b, a.z % b, a.y % b, a.x % b);

    [MethodImpl(256 | 512)]
    public static ulong4_mt32 operator++(ulong4_mt32 a) => a + ulong_mt32.One;

    [MethodImpl(256 | 512)]
    public static ulong4_mt32 operator--(ulong4_mt32 a) => a - ulong_mt32.One;

    #endregion // Operators
}

#endregion // ulong4_mt32
