<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="../../Coplt.Mathematics/types.ttinclude" #><#@ import namespace="System.Linq" #>// generated by template, do not modify manually

namespace Coplt.Mathematics.SIMT;

<#
    foreach (var typ in Typ.Typs)
    {
        if (!typ.simd) continue;
        if (typ.size != 4) continue;
        for (var i = 2; i <= 4; i++)
        {
            var byteSize = typ.size * (i is 3 ? 4 : i);
            var bitSize = 8 * byteSize;

            var typeName = $"{typ.name}{i}_mt";
            var simd_typeName = $"{typ.name}{i}";
#>
#region <#= typeName #>

[Serializable]
//[JsonConverter(typeof(<#= typeName #>JsonConverter))]
public partial struct <#= typeName #>
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => Vector<<#= typ.simdComp #>>.Count;
    }

    #endregion

    #region Fields

<#
            foreach (var n in Enumerable.Range(0, i))
            {
#>
    public <#= typ.compType #>_mt <#= Typ.xyzw[n] #>;
<#
            }
#>

    #endregion // Fields

    #region Properties

    public <#= simd_typeName #> this[int index]
    {
        [MethodImpl(256 | 512)]
        get => new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"{Typ.xyzw[n]}[index]")) #>);
        set 
        {
<#
            foreach (var n in Enumerable.Range(0, i))
            {
#>
           <#= Typ.xyzw[n] #>[index] = value.<#= Typ.xyzw[n] #>;
<#
            }
#>
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public <#= typeName #>(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"{typ.compType}_mt {Typ.xyzw[n]}")) #>)
    {
<#
            foreach (var n in Enumerable.Range(0, i))
            {
#>
        this.<#= Typ.xyzw[n] #> = <#= Typ.xyzw[n] #>;
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public <#= typeName #>(<#= typ.compType #>_mt value)
    {
        <#= string.Join(" = ", Enumerable.Range(0, i).Reverse().Select(n => $"{Typ.xyzw[n]}")) #> = value;
    }

    [MethodImpl(256 | 512)]
    public <#= typeName #>(<#= simd_typeName #> value)
    {
<#
            foreach (var n in Enumerable.Range(0, i))
            {
#>
        <#= Typ.xyzw[n] #> = new(value.<#= Typ.xyzw[n] #>);
<#
            }
#>
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator <#= typeName #>(<#= typ.compType #> value) => new <#= typ.compType #>_mt(value);

    [MethodImpl(256 | 512)]
    public static implicit operator <#= typeName #>(<#= typ.compType #>_mt value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator <#= typeName #>(<#= simd_typeName #> value) => new(value);

<#
            if (typ.arith)
            {
#>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator-(<#= typeName #> a) => new(<#=
                    string.Join(", ", Enumerable.Range(0, i).Select(n => $"-a.{Typ.xyzw[n]}")) #>);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator+(<#= typeName #> a, <#= typeName #> b) => new(<#=
                    string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]} + b.{Typ.xyzw[n]}")) #>);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator-(<#= typeName #> a, <#= typeName #> b) => new(<#=
                    string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]} - b.{Typ.xyzw[n]}")) #>);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator*(<#= typeName #> a, <#= typeName #> b) => new(<#=
                    string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]} * b.{Typ.xyzw[n]}")) #>);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator/(<#= typeName #> a, <#= typeName #> b) => new(<#=
                    string.Join(", ", Enumerable.Range(0, i).Reverse().Select(n => $"a.{Typ.xyzw[n]} / b.{Typ.xyzw[n]}")) #>);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator/(<#= typeName #> a, <#= typ.compType #> b) => new(<#=
                    string.Join(", ", Enumerable.Range(0, i).Reverse().Select(n => $"a.{Typ.xyzw[n]} / b")) #>);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator%(<#= typeName #> a, <#= typeName #> b) => new(<#=
                    string.Join(", ", Enumerable.Range(0, i).Reverse().Select(n => $"a.{Typ.xyzw[n]} % b.{Typ.xyzw[n]}")) #>);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator%(<#= typeName #> a, <#= typ.compType #> b) => new(<#=
                    string.Join(", ", Enumerable.Range(0, i).Reverse().Select(n => $"a.{Typ.xyzw[n]} % b")) #>);

<#
            }
#>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator~(<#= typeName #> a) => new(<#=
                    string.Join(", ", Enumerable.Range(0, i).Select(n => $"~a.{Typ.xyzw[n]}")) #>);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator|(<#= typeName #> a, <#= typeName #> b) => new(<#=
                    string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]} | b.{Typ.xyzw[n]}")) #>);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator&(<#= typeName #> a, <#= typeName #> b) => new(<#=
                    string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]} & b.{Typ.xyzw[n]}")) #>);

    #endregion // Operators
}

#endregion // <#= typeName #>
<#
        }
    }
#>
