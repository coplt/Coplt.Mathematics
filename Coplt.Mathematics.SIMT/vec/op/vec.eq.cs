// generated by template, do not modify manually

namespace Coplt.Mathematics.SIMT;

#region float2_mt4

public partial struct float2_mt4
    : IEqualityOperators<float2_mt4, float2_mt4, bool>
    , IEqualityOperators<float2_mt4, float2_mt4, b32v2_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is float2_mt4 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(float2_mt4 other) => x.Equals(other.x) && y.Equals(other.y);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(float2_mt4 other) => !x.Equals(other.x) || !y.Equals(other.y);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<float2_mt4, float2_mt4, bool>.operator ==(float2_mt4 left, float2_mt4 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<float2_mt4, float2_mt4, bool>.operator !=(float2_mt4 left, float2_mt4 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b32v2_mt4 VectorEquals(float2_mt4 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y));
    }

    [MethodImpl(256 | 512)]
    public readonly b32v2_mt4 VectorNotEquals(float2_mt4 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y));
    }

    [MethodImpl(256 | 512)]
    public static b32v2_mt4 operator ==(float2_mt4 left, float2_mt4 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b32v2_mt4 operator !=(float2_mt4 left, float2_mt4 right) => left.VectorNotEquals(right);
}

#endregion // float2_mt4
#region float2_mt8

public partial struct float2_mt8
    : IEqualityOperators<float2_mt8, float2_mt8, bool>
    , IEqualityOperators<float2_mt8, float2_mt8, b32v2_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is float2_mt8 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(float2_mt8 other) => x.Equals(other.x) && y.Equals(other.y);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(float2_mt8 other) => !x.Equals(other.x) || !y.Equals(other.y);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<float2_mt8, float2_mt8, bool>.operator ==(float2_mt8 left, float2_mt8 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<float2_mt8, float2_mt8, bool>.operator !=(float2_mt8 left, float2_mt8 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b32v2_mt8 VectorEquals(float2_mt8 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y));
    }

    [MethodImpl(256 | 512)]
    public readonly b32v2_mt8 VectorNotEquals(float2_mt8 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y));
    }

    [MethodImpl(256 | 512)]
    public static b32v2_mt8 operator ==(float2_mt8 left, float2_mt8 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b32v2_mt8 operator !=(float2_mt8 left, float2_mt8 right) => left.VectorNotEquals(right);
}

#endregion // float2_mt8
#region float2_mt16

public partial struct float2_mt16
    : IEqualityOperators<float2_mt16, float2_mt16, bool>
    , IEqualityOperators<float2_mt16, float2_mt16, b32v2_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is float2_mt16 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(float2_mt16 other) => x.Equals(other.x) && y.Equals(other.y);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(float2_mt16 other) => !x.Equals(other.x) || !y.Equals(other.y);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<float2_mt16, float2_mt16, bool>.operator ==(float2_mt16 left, float2_mt16 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<float2_mt16, float2_mt16, bool>.operator !=(float2_mt16 left, float2_mt16 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b32v2_mt16 VectorEquals(float2_mt16 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y));
    }

    [MethodImpl(256 | 512)]
    public readonly b32v2_mt16 VectorNotEquals(float2_mt16 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y));
    }

    [MethodImpl(256 | 512)]
    public static b32v2_mt16 operator ==(float2_mt16 left, float2_mt16 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b32v2_mt16 operator !=(float2_mt16 left, float2_mt16 right) => left.VectorNotEquals(right);
}

#endregion // float2_mt16
#region float2_mt32

public partial struct float2_mt32
    : IEqualityOperators<float2_mt32, float2_mt32, bool>
    , IEqualityOperators<float2_mt32, float2_mt32, b32v2_mt32>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is float2_mt32 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(float2_mt32 other) => x.Equals(other.x) && y.Equals(other.y);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(float2_mt32 other) => !x.Equals(other.x) || !y.Equals(other.y);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<float2_mt32, float2_mt32, bool>.operator ==(float2_mt32 left, float2_mt32 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<float2_mt32, float2_mt32, bool>.operator !=(float2_mt32 left, float2_mt32 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b32v2_mt32 VectorEquals(float2_mt32 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y));
    }

    [MethodImpl(256 | 512)]
    public readonly b32v2_mt32 VectorNotEquals(float2_mt32 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y));
    }

    [MethodImpl(256 | 512)]
    public static b32v2_mt32 operator ==(float2_mt32 left, float2_mt32 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b32v2_mt32 operator !=(float2_mt32 left, float2_mt32 right) => left.VectorNotEquals(right);
}

#endregion // float2_mt32
#region float3_mt4

public partial struct float3_mt4
    : IEqualityOperators<float3_mt4, float3_mt4, bool>
    , IEqualityOperators<float3_mt4, float3_mt4, b32v3_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y, z);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is float3_mt4 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(float3_mt4 other) => x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(float3_mt4 other) => !x.Equals(other.x) || !y.Equals(other.y) || !z.Equals(other.z);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<float3_mt4, float3_mt4, bool>.operator ==(float3_mt4 left, float3_mt4 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<float3_mt4, float3_mt4, bool>.operator !=(float3_mt4 left, float3_mt4 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b32v3_mt4 VectorEquals(float3_mt4 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y), z.LaneEquals(other.z));
    }

    [MethodImpl(256 | 512)]
    public readonly b32v3_mt4 VectorNotEquals(float3_mt4 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y), z.LaneNotEquals(other.z));
    }

    [MethodImpl(256 | 512)]
    public static b32v3_mt4 operator ==(float3_mt4 left, float3_mt4 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b32v3_mt4 operator !=(float3_mt4 left, float3_mt4 right) => left.VectorNotEquals(right);
}

#endregion // float3_mt4
#region float3_mt8

public partial struct float3_mt8
    : IEqualityOperators<float3_mt8, float3_mt8, bool>
    , IEqualityOperators<float3_mt8, float3_mt8, b32v3_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y, z);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is float3_mt8 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(float3_mt8 other) => x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(float3_mt8 other) => !x.Equals(other.x) || !y.Equals(other.y) || !z.Equals(other.z);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<float3_mt8, float3_mt8, bool>.operator ==(float3_mt8 left, float3_mt8 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<float3_mt8, float3_mt8, bool>.operator !=(float3_mt8 left, float3_mt8 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b32v3_mt8 VectorEquals(float3_mt8 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y), z.LaneEquals(other.z));
    }

    [MethodImpl(256 | 512)]
    public readonly b32v3_mt8 VectorNotEquals(float3_mt8 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y), z.LaneNotEquals(other.z));
    }

    [MethodImpl(256 | 512)]
    public static b32v3_mt8 operator ==(float3_mt8 left, float3_mt8 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b32v3_mt8 operator !=(float3_mt8 left, float3_mt8 right) => left.VectorNotEquals(right);
}

#endregion // float3_mt8
#region float3_mt16

public partial struct float3_mt16
    : IEqualityOperators<float3_mt16, float3_mt16, bool>
    , IEqualityOperators<float3_mt16, float3_mt16, b32v3_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y, z);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is float3_mt16 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(float3_mt16 other) => x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(float3_mt16 other) => !x.Equals(other.x) || !y.Equals(other.y) || !z.Equals(other.z);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<float3_mt16, float3_mt16, bool>.operator ==(float3_mt16 left, float3_mt16 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<float3_mt16, float3_mt16, bool>.operator !=(float3_mt16 left, float3_mt16 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b32v3_mt16 VectorEquals(float3_mt16 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y), z.LaneEquals(other.z));
    }

    [MethodImpl(256 | 512)]
    public readonly b32v3_mt16 VectorNotEquals(float3_mt16 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y), z.LaneNotEquals(other.z));
    }

    [MethodImpl(256 | 512)]
    public static b32v3_mt16 operator ==(float3_mt16 left, float3_mt16 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b32v3_mt16 operator !=(float3_mt16 left, float3_mt16 right) => left.VectorNotEquals(right);
}

#endregion // float3_mt16
#region float3_mt32

public partial struct float3_mt32
    : IEqualityOperators<float3_mt32, float3_mt32, bool>
    , IEqualityOperators<float3_mt32, float3_mt32, b32v3_mt32>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y, z);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is float3_mt32 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(float3_mt32 other) => x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(float3_mt32 other) => !x.Equals(other.x) || !y.Equals(other.y) || !z.Equals(other.z);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<float3_mt32, float3_mt32, bool>.operator ==(float3_mt32 left, float3_mt32 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<float3_mt32, float3_mt32, bool>.operator !=(float3_mt32 left, float3_mt32 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b32v3_mt32 VectorEquals(float3_mt32 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y), z.LaneEquals(other.z));
    }

    [MethodImpl(256 | 512)]
    public readonly b32v3_mt32 VectorNotEquals(float3_mt32 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y), z.LaneNotEquals(other.z));
    }

    [MethodImpl(256 | 512)]
    public static b32v3_mt32 operator ==(float3_mt32 left, float3_mt32 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b32v3_mt32 operator !=(float3_mt32 left, float3_mt32 right) => left.VectorNotEquals(right);
}

#endregion // float3_mt32
#region float4_mt4

public partial struct float4_mt4
    : IEqualityOperators<float4_mt4, float4_mt4, bool>
    , IEqualityOperators<float4_mt4, float4_mt4, b32v4_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y, z, w);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is float4_mt4 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(float4_mt4 other) => x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z) && w.Equals(other.w);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(float4_mt4 other) => !x.Equals(other.x) || !y.Equals(other.y) || !z.Equals(other.z) || !w.Equals(other.w);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<float4_mt4, float4_mt4, bool>.operator ==(float4_mt4 left, float4_mt4 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<float4_mt4, float4_mt4, bool>.operator !=(float4_mt4 left, float4_mt4 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b32v4_mt4 VectorEquals(float4_mt4 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y), z.LaneEquals(other.z), w.LaneEquals(other.w));
    }

    [MethodImpl(256 | 512)]
    public readonly b32v4_mt4 VectorNotEquals(float4_mt4 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y), z.LaneNotEquals(other.z), w.LaneNotEquals(other.w));
    }

    [MethodImpl(256 | 512)]
    public static b32v4_mt4 operator ==(float4_mt4 left, float4_mt4 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b32v4_mt4 operator !=(float4_mt4 left, float4_mt4 right) => left.VectorNotEquals(right);
}

#endregion // float4_mt4
#region float4_mt8

public partial struct float4_mt8
    : IEqualityOperators<float4_mt8, float4_mt8, bool>
    , IEqualityOperators<float4_mt8, float4_mt8, b32v4_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y, z, w);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is float4_mt8 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(float4_mt8 other) => x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z) && w.Equals(other.w);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(float4_mt8 other) => !x.Equals(other.x) || !y.Equals(other.y) || !z.Equals(other.z) || !w.Equals(other.w);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<float4_mt8, float4_mt8, bool>.operator ==(float4_mt8 left, float4_mt8 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<float4_mt8, float4_mt8, bool>.operator !=(float4_mt8 left, float4_mt8 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b32v4_mt8 VectorEquals(float4_mt8 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y), z.LaneEquals(other.z), w.LaneEquals(other.w));
    }

    [MethodImpl(256 | 512)]
    public readonly b32v4_mt8 VectorNotEquals(float4_mt8 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y), z.LaneNotEquals(other.z), w.LaneNotEquals(other.w));
    }

    [MethodImpl(256 | 512)]
    public static b32v4_mt8 operator ==(float4_mt8 left, float4_mt8 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b32v4_mt8 operator !=(float4_mt8 left, float4_mt8 right) => left.VectorNotEquals(right);
}

#endregion // float4_mt8
#region float4_mt16

public partial struct float4_mt16
    : IEqualityOperators<float4_mt16, float4_mt16, bool>
    , IEqualityOperators<float4_mt16, float4_mt16, b32v4_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y, z, w);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is float4_mt16 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(float4_mt16 other) => x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z) && w.Equals(other.w);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(float4_mt16 other) => !x.Equals(other.x) || !y.Equals(other.y) || !z.Equals(other.z) || !w.Equals(other.w);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<float4_mt16, float4_mt16, bool>.operator ==(float4_mt16 left, float4_mt16 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<float4_mt16, float4_mt16, bool>.operator !=(float4_mt16 left, float4_mt16 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b32v4_mt16 VectorEquals(float4_mt16 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y), z.LaneEquals(other.z), w.LaneEquals(other.w));
    }

    [MethodImpl(256 | 512)]
    public readonly b32v4_mt16 VectorNotEquals(float4_mt16 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y), z.LaneNotEquals(other.z), w.LaneNotEquals(other.w));
    }

    [MethodImpl(256 | 512)]
    public static b32v4_mt16 operator ==(float4_mt16 left, float4_mt16 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b32v4_mt16 operator !=(float4_mt16 left, float4_mt16 right) => left.VectorNotEquals(right);
}

#endregion // float4_mt16
#region float4_mt32

public partial struct float4_mt32
    : IEqualityOperators<float4_mt32, float4_mt32, bool>
    , IEqualityOperators<float4_mt32, float4_mt32, b32v4_mt32>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y, z, w);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is float4_mt32 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(float4_mt32 other) => x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z) && w.Equals(other.w);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(float4_mt32 other) => !x.Equals(other.x) || !y.Equals(other.y) || !z.Equals(other.z) || !w.Equals(other.w);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<float4_mt32, float4_mt32, bool>.operator ==(float4_mt32 left, float4_mt32 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<float4_mt32, float4_mt32, bool>.operator !=(float4_mt32 left, float4_mt32 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b32v4_mt32 VectorEquals(float4_mt32 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y), z.LaneEquals(other.z), w.LaneEquals(other.w));
    }

    [MethodImpl(256 | 512)]
    public readonly b32v4_mt32 VectorNotEquals(float4_mt32 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y), z.LaneNotEquals(other.z), w.LaneNotEquals(other.w));
    }

    [MethodImpl(256 | 512)]
    public static b32v4_mt32 operator ==(float4_mt32 left, float4_mt32 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b32v4_mt32 operator !=(float4_mt32 left, float4_mt32 right) => left.VectorNotEquals(right);
}

#endregion // float4_mt32
#region double2_mt4

public partial struct double2_mt4
    : IEqualityOperators<double2_mt4, double2_mt4, bool>
    , IEqualityOperators<double2_mt4, double2_mt4, b64v2_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is double2_mt4 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(double2_mt4 other) => x.Equals(other.x) && y.Equals(other.y);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(double2_mt4 other) => !x.Equals(other.x) || !y.Equals(other.y);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<double2_mt4, double2_mt4, bool>.operator ==(double2_mt4 left, double2_mt4 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<double2_mt4, double2_mt4, bool>.operator !=(double2_mt4 left, double2_mt4 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b64v2_mt4 VectorEquals(double2_mt4 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y));
    }

    [MethodImpl(256 | 512)]
    public readonly b64v2_mt4 VectorNotEquals(double2_mt4 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y));
    }

    [MethodImpl(256 | 512)]
    public static b64v2_mt4 operator ==(double2_mt4 left, double2_mt4 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b64v2_mt4 operator !=(double2_mt4 left, double2_mt4 right) => left.VectorNotEquals(right);
}

#endregion // double2_mt4
#region double2_mt8

public partial struct double2_mt8
    : IEqualityOperators<double2_mt8, double2_mt8, bool>
    , IEqualityOperators<double2_mt8, double2_mt8, b64v2_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is double2_mt8 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(double2_mt8 other) => x.Equals(other.x) && y.Equals(other.y);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(double2_mt8 other) => !x.Equals(other.x) || !y.Equals(other.y);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<double2_mt8, double2_mt8, bool>.operator ==(double2_mt8 left, double2_mt8 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<double2_mt8, double2_mt8, bool>.operator !=(double2_mt8 left, double2_mt8 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b64v2_mt8 VectorEquals(double2_mt8 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y));
    }

    [MethodImpl(256 | 512)]
    public readonly b64v2_mt8 VectorNotEquals(double2_mt8 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y));
    }

    [MethodImpl(256 | 512)]
    public static b64v2_mt8 operator ==(double2_mt8 left, double2_mt8 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b64v2_mt8 operator !=(double2_mt8 left, double2_mt8 right) => left.VectorNotEquals(right);
}

#endregion // double2_mt8
#region double2_mt16

public partial struct double2_mt16
    : IEqualityOperators<double2_mt16, double2_mt16, bool>
    , IEqualityOperators<double2_mt16, double2_mt16, b64v2_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is double2_mt16 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(double2_mt16 other) => x.Equals(other.x) && y.Equals(other.y);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(double2_mt16 other) => !x.Equals(other.x) || !y.Equals(other.y);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<double2_mt16, double2_mt16, bool>.operator ==(double2_mt16 left, double2_mt16 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<double2_mt16, double2_mt16, bool>.operator !=(double2_mt16 left, double2_mt16 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b64v2_mt16 VectorEquals(double2_mt16 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y));
    }

    [MethodImpl(256 | 512)]
    public readonly b64v2_mt16 VectorNotEquals(double2_mt16 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y));
    }

    [MethodImpl(256 | 512)]
    public static b64v2_mt16 operator ==(double2_mt16 left, double2_mt16 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b64v2_mt16 operator !=(double2_mt16 left, double2_mt16 right) => left.VectorNotEquals(right);
}

#endregion // double2_mt16
#region double2_mt32

public partial struct double2_mt32
    : IEqualityOperators<double2_mt32, double2_mt32, bool>
    , IEqualityOperators<double2_mt32, double2_mt32, b64v2_mt32>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is double2_mt32 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(double2_mt32 other) => x.Equals(other.x) && y.Equals(other.y);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(double2_mt32 other) => !x.Equals(other.x) || !y.Equals(other.y);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<double2_mt32, double2_mt32, bool>.operator ==(double2_mt32 left, double2_mt32 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<double2_mt32, double2_mt32, bool>.operator !=(double2_mt32 left, double2_mt32 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b64v2_mt32 VectorEquals(double2_mt32 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y));
    }

    [MethodImpl(256 | 512)]
    public readonly b64v2_mt32 VectorNotEquals(double2_mt32 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y));
    }

    [MethodImpl(256 | 512)]
    public static b64v2_mt32 operator ==(double2_mt32 left, double2_mt32 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b64v2_mt32 operator !=(double2_mt32 left, double2_mt32 right) => left.VectorNotEquals(right);
}

#endregion // double2_mt32
#region double3_mt4

public partial struct double3_mt4
    : IEqualityOperators<double3_mt4, double3_mt4, bool>
    , IEqualityOperators<double3_mt4, double3_mt4, b64v3_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y, z);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is double3_mt4 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(double3_mt4 other) => x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(double3_mt4 other) => !x.Equals(other.x) || !y.Equals(other.y) || !z.Equals(other.z);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<double3_mt4, double3_mt4, bool>.operator ==(double3_mt4 left, double3_mt4 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<double3_mt4, double3_mt4, bool>.operator !=(double3_mt4 left, double3_mt4 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b64v3_mt4 VectorEquals(double3_mt4 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y), z.LaneEquals(other.z));
    }

    [MethodImpl(256 | 512)]
    public readonly b64v3_mt4 VectorNotEquals(double3_mt4 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y), z.LaneNotEquals(other.z));
    }

    [MethodImpl(256 | 512)]
    public static b64v3_mt4 operator ==(double3_mt4 left, double3_mt4 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b64v3_mt4 operator !=(double3_mt4 left, double3_mt4 right) => left.VectorNotEquals(right);
}

#endregion // double3_mt4
#region double3_mt8

public partial struct double3_mt8
    : IEqualityOperators<double3_mt8, double3_mt8, bool>
    , IEqualityOperators<double3_mt8, double3_mt8, b64v3_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y, z);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is double3_mt8 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(double3_mt8 other) => x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(double3_mt8 other) => !x.Equals(other.x) || !y.Equals(other.y) || !z.Equals(other.z);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<double3_mt8, double3_mt8, bool>.operator ==(double3_mt8 left, double3_mt8 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<double3_mt8, double3_mt8, bool>.operator !=(double3_mt8 left, double3_mt8 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b64v3_mt8 VectorEquals(double3_mt8 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y), z.LaneEquals(other.z));
    }

    [MethodImpl(256 | 512)]
    public readonly b64v3_mt8 VectorNotEquals(double3_mt8 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y), z.LaneNotEquals(other.z));
    }

    [MethodImpl(256 | 512)]
    public static b64v3_mt8 operator ==(double3_mt8 left, double3_mt8 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b64v3_mt8 operator !=(double3_mt8 left, double3_mt8 right) => left.VectorNotEquals(right);
}

#endregion // double3_mt8
#region double3_mt16

public partial struct double3_mt16
    : IEqualityOperators<double3_mt16, double3_mt16, bool>
    , IEqualityOperators<double3_mt16, double3_mt16, b64v3_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y, z);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is double3_mt16 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(double3_mt16 other) => x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(double3_mt16 other) => !x.Equals(other.x) || !y.Equals(other.y) || !z.Equals(other.z);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<double3_mt16, double3_mt16, bool>.operator ==(double3_mt16 left, double3_mt16 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<double3_mt16, double3_mt16, bool>.operator !=(double3_mt16 left, double3_mt16 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b64v3_mt16 VectorEquals(double3_mt16 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y), z.LaneEquals(other.z));
    }

    [MethodImpl(256 | 512)]
    public readonly b64v3_mt16 VectorNotEquals(double3_mt16 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y), z.LaneNotEquals(other.z));
    }

    [MethodImpl(256 | 512)]
    public static b64v3_mt16 operator ==(double3_mt16 left, double3_mt16 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b64v3_mt16 operator !=(double3_mt16 left, double3_mt16 right) => left.VectorNotEquals(right);
}

#endregion // double3_mt16
#region double3_mt32

public partial struct double3_mt32
    : IEqualityOperators<double3_mt32, double3_mt32, bool>
    , IEqualityOperators<double3_mt32, double3_mt32, b64v3_mt32>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y, z);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is double3_mt32 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(double3_mt32 other) => x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(double3_mt32 other) => !x.Equals(other.x) || !y.Equals(other.y) || !z.Equals(other.z);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<double3_mt32, double3_mt32, bool>.operator ==(double3_mt32 left, double3_mt32 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<double3_mt32, double3_mt32, bool>.operator !=(double3_mt32 left, double3_mt32 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b64v3_mt32 VectorEquals(double3_mt32 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y), z.LaneEquals(other.z));
    }

    [MethodImpl(256 | 512)]
    public readonly b64v3_mt32 VectorNotEquals(double3_mt32 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y), z.LaneNotEquals(other.z));
    }

    [MethodImpl(256 | 512)]
    public static b64v3_mt32 operator ==(double3_mt32 left, double3_mt32 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b64v3_mt32 operator !=(double3_mt32 left, double3_mt32 right) => left.VectorNotEquals(right);
}

#endregion // double3_mt32
#region double4_mt4

public partial struct double4_mt4
    : IEqualityOperators<double4_mt4, double4_mt4, bool>
    , IEqualityOperators<double4_mt4, double4_mt4, b64v4_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y, z, w);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is double4_mt4 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(double4_mt4 other) => x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z) && w.Equals(other.w);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(double4_mt4 other) => !x.Equals(other.x) || !y.Equals(other.y) || !z.Equals(other.z) || !w.Equals(other.w);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<double4_mt4, double4_mt4, bool>.operator ==(double4_mt4 left, double4_mt4 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<double4_mt4, double4_mt4, bool>.operator !=(double4_mt4 left, double4_mt4 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b64v4_mt4 VectorEquals(double4_mt4 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y), z.LaneEquals(other.z), w.LaneEquals(other.w));
    }

    [MethodImpl(256 | 512)]
    public readonly b64v4_mt4 VectorNotEquals(double4_mt4 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y), z.LaneNotEquals(other.z), w.LaneNotEquals(other.w));
    }

    [MethodImpl(256 | 512)]
    public static b64v4_mt4 operator ==(double4_mt4 left, double4_mt4 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b64v4_mt4 operator !=(double4_mt4 left, double4_mt4 right) => left.VectorNotEquals(right);
}

#endregion // double4_mt4
#region double4_mt8

public partial struct double4_mt8
    : IEqualityOperators<double4_mt8, double4_mt8, bool>
    , IEqualityOperators<double4_mt8, double4_mt8, b64v4_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y, z, w);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is double4_mt8 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(double4_mt8 other) => x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z) && w.Equals(other.w);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(double4_mt8 other) => !x.Equals(other.x) || !y.Equals(other.y) || !z.Equals(other.z) || !w.Equals(other.w);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<double4_mt8, double4_mt8, bool>.operator ==(double4_mt8 left, double4_mt8 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<double4_mt8, double4_mt8, bool>.operator !=(double4_mt8 left, double4_mt8 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b64v4_mt8 VectorEquals(double4_mt8 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y), z.LaneEquals(other.z), w.LaneEquals(other.w));
    }

    [MethodImpl(256 | 512)]
    public readonly b64v4_mt8 VectorNotEquals(double4_mt8 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y), z.LaneNotEquals(other.z), w.LaneNotEquals(other.w));
    }

    [MethodImpl(256 | 512)]
    public static b64v4_mt8 operator ==(double4_mt8 left, double4_mt8 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b64v4_mt8 operator !=(double4_mt8 left, double4_mt8 right) => left.VectorNotEquals(right);
}

#endregion // double4_mt8
#region double4_mt16

public partial struct double4_mt16
    : IEqualityOperators<double4_mt16, double4_mt16, bool>
    , IEqualityOperators<double4_mt16, double4_mt16, b64v4_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y, z, w);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is double4_mt16 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(double4_mt16 other) => x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z) && w.Equals(other.w);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(double4_mt16 other) => !x.Equals(other.x) || !y.Equals(other.y) || !z.Equals(other.z) || !w.Equals(other.w);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<double4_mt16, double4_mt16, bool>.operator ==(double4_mt16 left, double4_mt16 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<double4_mt16, double4_mt16, bool>.operator !=(double4_mt16 left, double4_mt16 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b64v4_mt16 VectorEquals(double4_mt16 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y), z.LaneEquals(other.z), w.LaneEquals(other.w));
    }

    [MethodImpl(256 | 512)]
    public readonly b64v4_mt16 VectorNotEquals(double4_mt16 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y), z.LaneNotEquals(other.z), w.LaneNotEquals(other.w));
    }

    [MethodImpl(256 | 512)]
    public static b64v4_mt16 operator ==(double4_mt16 left, double4_mt16 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b64v4_mt16 operator !=(double4_mt16 left, double4_mt16 right) => left.VectorNotEquals(right);
}

#endregion // double4_mt16
#region double4_mt32

public partial struct double4_mt32
    : IEqualityOperators<double4_mt32, double4_mt32, bool>
    , IEqualityOperators<double4_mt32, double4_mt32, b64v4_mt32>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y, z, w);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is double4_mt32 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(double4_mt32 other) => x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z) && w.Equals(other.w);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(double4_mt32 other) => !x.Equals(other.x) || !y.Equals(other.y) || !z.Equals(other.z) || !w.Equals(other.w);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<double4_mt32, double4_mt32, bool>.operator ==(double4_mt32 left, double4_mt32 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<double4_mt32, double4_mt32, bool>.operator !=(double4_mt32 left, double4_mt32 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b64v4_mt32 VectorEquals(double4_mt32 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y), z.LaneEquals(other.z), w.LaneEquals(other.w));
    }

    [MethodImpl(256 | 512)]
    public readonly b64v4_mt32 VectorNotEquals(double4_mt32 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y), z.LaneNotEquals(other.z), w.LaneNotEquals(other.w));
    }

    [MethodImpl(256 | 512)]
    public static b64v4_mt32 operator ==(double4_mt32 left, double4_mt32 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b64v4_mt32 operator !=(double4_mt32 left, double4_mt32 right) => left.VectorNotEquals(right);
}

#endregion // double4_mt32
#region int2_mt4

public partial struct int2_mt4
    : IEqualityOperators<int2_mt4, int2_mt4, bool>
    , IEqualityOperators<int2_mt4, int2_mt4, b32v2_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is int2_mt4 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(int2_mt4 other) => x.Equals(other.x) && y.Equals(other.y);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(int2_mt4 other) => !x.Equals(other.x) || !y.Equals(other.y);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<int2_mt4, int2_mt4, bool>.operator ==(int2_mt4 left, int2_mt4 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<int2_mt4, int2_mt4, bool>.operator !=(int2_mt4 left, int2_mt4 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b32v2_mt4 VectorEquals(int2_mt4 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y));
    }

    [MethodImpl(256 | 512)]
    public readonly b32v2_mt4 VectorNotEquals(int2_mt4 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y));
    }

    [MethodImpl(256 | 512)]
    public static b32v2_mt4 operator ==(int2_mt4 left, int2_mt4 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b32v2_mt4 operator !=(int2_mt4 left, int2_mt4 right) => left.VectorNotEquals(right);
}

#endregion // int2_mt4
#region int2_mt8

public partial struct int2_mt8
    : IEqualityOperators<int2_mt8, int2_mt8, bool>
    , IEqualityOperators<int2_mt8, int2_mt8, b32v2_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is int2_mt8 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(int2_mt8 other) => x.Equals(other.x) && y.Equals(other.y);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(int2_mt8 other) => !x.Equals(other.x) || !y.Equals(other.y);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<int2_mt8, int2_mt8, bool>.operator ==(int2_mt8 left, int2_mt8 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<int2_mt8, int2_mt8, bool>.operator !=(int2_mt8 left, int2_mt8 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b32v2_mt8 VectorEquals(int2_mt8 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y));
    }

    [MethodImpl(256 | 512)]
    public readonly b32v2_mt8 VectorNotEquals(int2_mt8 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y));
    }

    [MethodImpl(256 | 512)]
    public static b32v2_mt8 operator ==(int2_mt8 left, int2_mt8 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b32v2_mt8 operator !=(int2_mt8 left, int2_mt8 right) => left.VectorNotEquals(right);
}

#endregion // int2_mt8
#region int2_mt16

public partial struct int2_mt16
    : IEqualityOperators<int2_mt16, int2_mt16, bool>
    , IEqualityOperators<int2_mt16, int2_mt16, b32v2_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is int2_mt16 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(int2_mt16 other) => x.Equals(other.x) && y.Equals(other.y);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(int2_mt16 other) => !x.Equals(other.x) || !y.Equals(other.y);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<int2_mt16, int2_mt16, bool>.operator ==(int2_mt16 left, int2_mt16 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<int2_mt16, int2_mt16, bool>.operator !=(int2_mt16 left, int2_mt16 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b32v2_mt16 VectorEquals(int2_mt16 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y));
    }

    [MethodImpl(256 | 512)]
    public readonly b32v2_mt16 VectorNotEquals(int2_mt16 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y));
    }

    [MethodImpl(256 | 512)]
    public static b32v2_mt16 operator ==(int2_mt16 left, int2_mt16 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b32v2_mt16 operator !=(int2_mt16 left, int2_mt16 right) => left.VectorNotEquals(right);
}

#endregion // int2_mt16
#region int2_mt32

public partial struct int2_mt32
    : IEqualityOperators<int2_mt32, int2_mt32, bool>
    , IEqualityOperators<int2_mt32, int2_mt32, b32v2_mt32>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is int2_mt32 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(int2_mt32 other) => x.Equals(other.x) && y.Equals(other.y);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(int2_mt32 other) => !x.Equals(other.x) || !y.Equals(other.y);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<int2_mt32, int2_mt32, bool>.operator ==(int2_mt32 left, int2_mt32 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<int2_mt32, int2_mt32, bool>.operator !=(int2_mt32 left, int2_mt32 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b32v2_mt32 VectorEquals(int2_mt32 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y));
    }

    [MethodImpl(256 | 512)]
    public readonly b32v2_mt32 VectorNotEquals(int2_mt32 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y));
    }

    [MethodImpl(256 | 512)]
    public static b32v2_mt32 operator ==(int2_mt32 left, int2_mt32 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b32v2_mt32 operator !=(int2_mt32 left, int2_mt32 right) => left.VectorNotEquals(right);
}

#endregion // int2_mt32
#region int3_mt4

public partial struct int3_mt4
    : IEqualityOperators<int3_mt4, int3_mt4, bool>
    , IEqualityOperators<int3_mt4, int3_mt4, b32v3_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y, z);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is int3_mt4 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(int3_mt4 other) => x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(int3_mt4 other) => !x.Equals(other.x) || !y.Equals(other.y) || !z.Equals(other.z);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<int3_mt4, int3_mt4, bool>.operator ==(int3_mt4 left, int3_mt4 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<int3_mt4, int3_mt4, bool>.operator !=(int3_mt4 left, int3_mt4 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b32v3_mt4 VectorEquals(int3_mt4 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y), z.LaneEquals(other.z));
    }

    [MethodImpl(256 | 512)]
    public readonly b32v3_mt4 VectorNotEquals(int3_mt4 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y), z.LaneNotEquals(other.z));
    }

    [MethodImpl(256 | 512)]
    public static b32v3_mt4 operator ==(int3_mt4 left, int3_mt4 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b32v3_mt4 operator !=(int3_mt4 left, int3_mt4 right) => left.VectorNotEquals(right);
}

#endregion // int3_mt4
#region int3_mt8

public partial struct int3_mt8
    : IEqualityOperators<int3_mt8, int3_mt8, bool>
    , IEqualityOperators<int3_mt8, int3_mt8, b32v3_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y, z);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is int3_mt8 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(int3_mt8 other) => x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(int3_mt8 other) => !x.Equals(other.x) || !y.Equals(other.y) || !z.Equals(other.z);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<int3_mt8, int3_mt8, bool>.operator ==(int3_mt8 left, int3_mt8 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<int3_mt8, int3_mt8, bool>.operator !=(int3_mt8 left, int3_mt8 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b32v3_mt8 VectorEquals(int3_mt8 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y), z.LaneEquals(other.z));
    }

    [MethodImpl(256 | 512)]
    public readonly b32v3_mt8 VectorNotEquals(int3_mt8 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y), z.LaneNotEquals(other.z));
    }

    [MethodImpl(256 | 512)]
    public static b32v3_mt8 operator ==(int3_mt8 left, int3_mt8 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b32v3_mt8 operator !=(int3_mt8 left, int3_mt8 right) => left.VectorNotEquals(right);
}

#endregion // int3_mt8
#region int3_mt16

public partial struct int3_mt16
    : IEqualityOperators<int3_mt16, int3_mt16, bool>
    , IEqualityOperators<int3_mt16, int3_mt16, b32v3_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y, z);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is int3_mt16 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(int3_mt16 other) => x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(int3_mt16 other) => !x.Equals(other.x) || !y.Equals(other.y) || !z.Equals(other.z);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<int3_mt16, int3_mt16, bool>.operator ==(int3_mt16 left, int3_mt16 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<int3_mt16, int3_mt16, bool>.operator !=(int3_mt16 left, int3_mt16 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b32v3_mt16 VectorEquals(int3_mt16 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y), z.LaneEquals(other.z));
    }

    [MethodImpl(256 | 512)]
    public readonly b32v3_mt16 VectorNotEquals(int3_mt16 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y), z.LaneNotEquals(other.z));
    }

    [MethodImpl(256 | 512)]
    public static b32v3_mt16 operator ==(int3_mt16 left, int3_mt16 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b32v3_mt16 operator !=(int3_mt16 left, int3_mt16 right) => left.VectorNotEquals(right);
}

#endregion // int3_mt16
#region int3_mt32

public partial struct int3_mt32
    : IEqualityOperators<int3_mt32, int3_mt32, bool>
    , IEqualityOperators<int3_mt32, int3_mt32, b32v3_mt32>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y, z);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is int3_mt32 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(int3_mt32 other) => x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(int3_mt32 other) => !x.Equals(other.x) || !y.Equals(other.y) || !z.Equals(other.z);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<int3_mt32, int3_mt32, bool>.operator ==(int3_mt32 left, int3_mt32 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<int3_mt32, int3_mt32, bool>.operator !=(int3_mt32 left, int3_mt32 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b32v3_mt32 VectorEquals(int3_mt32 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y), z.LaneEquals(other.z));
    }

    [MethodImpl(256 | 512)]
    public readonly b32v3_mt32 VectorNotEquals(int3_mt32 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y), z.LaneNotEquals(other.z));
    }

    [MethodImpl(256 | 512)]
    public static b32v3_mt32 operator ==(int3_mt32 left, int3_mt32 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b32v3_mt32 operator !=(int3_mt32 left, int3_mt32 right) => left.VectorNotEquals(right);
}

#endregion // int3_mt32
#region int4_mt4

public partial struct int4_mt4
    : IEqualityOperators<int4_mt4, int4_mt4, bool>
    , IEqualityOperators<int4_mt4, int4_mt4, b32v4_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y, z, w);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is int4_mt4 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(int4_mt4 other) => x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z) && w.Equals(other.w);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(int4_mt4 other) => !x.Equals(other.x) || !y.Equals(other.y) || !z.Equals(other.z) || !w.Equals(other.w);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<int4_mt4, int4_mt4, bool>.operator ==(int4_mt4 left, int4_mt4 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<int4_mt4, int4_mt4, bool>.operator !=(int4_mt4 left, int4_mt4 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b32v4_mt4 VectorEquals(int4_mt4 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y), z.LaneEquals(other.z), w.LaneEquals(other.w));
    }

    [MethodImpl(256 | 512)]
    public readonly b32v4_mt4 VectorNotEquals(int4_mt4 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y), z.LaneNotEquals(other.z), w.LaneNotEquals(other.w));
    }

    [MethodImpl(256 | 512)]
    public static b32v4_mt4 operator ==(int4_mt4 left, int4_mt4 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b32v4_mt4 operator !=(int4_mt4 left, int4_mt4 right) => left.VectorNotEquals(right);
}

#endregion // int4_mt4
#region int4_mt8

public partial struct int4_mt8
    : IEqualityOperators<int4_mt8, int4_mt8, bool>
    , IEqualityOperators<int4_mt8, int4_mt8, b32v4_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y, z, w);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is int4_mt8 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(int4_mt8 other) => x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z) && w.Equals(other.w);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(int4_mt8 other) => !x.Equals(other.x) || !y.Equals(other.y) || !z.Equals(other.z) || !w.Equals(other.w);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<int4_mt8, int4_mt8, bool>.operator ==(int4_mt8 left, int4_mt8 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<int4_mt8, int4_mt8, bool>.operator !=(int4_mt8 left, int4_mt8 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b32v4_mt8 VectorEquals(int4_mt8 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y), z.LaneEquals(other.z), w.LaneEquals(other.w));
    }

    [MethodImpl(256 | 512)]
    public readonly b32v4_mt8 VectorNotEquals(int4_mt8 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y), z.LaneNotEquals(other.z), w.LaneNotEquals(other.w));
    }

    [MethodImpl(256 | 512)]
    public static b32v4_mt8 operator ==(int4_mt8 left, int4_mt8 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b32v4_mt8 operator !=(int4_mt8 left, int4_mt8 right) => left.VectorNotEquals(right);
}

#endregion // int4_mt8
#region int4_mt16

public partial struct int4_mt16
    : IEqualityOperators<int4_mt16, int4_mt16, bool>
    , IEqualityOperators<int4_mt16, int4_mt16, b32v4_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y, z, w);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is int4_mt16 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(int4_mt16 other) => x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z) && w.Equals(other.w);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(int4_mt16 other) => !x.Equals(other.x) || !y.Equals(other.y) || !z.Equals(other.z) || !w.Equals(other.w);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<int4_mt16, int4_mt16, bool>.operator ==(int4_mt16 left, int4_mt16 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<int4_mt16, int4_mt16, bool>.operator !=(int4_mt16 left, int4_mt16 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b32v4_mt16 VectorEquals(int4_mt16 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y), z.LaneEquals(other.z), w.LaneEquals(other.w));
    }

    [MethodImpl(256 | 512)]
    public readonly b32v4_mt16 VectorNotEquals(int4_mt16 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y), z.LaneNotEquals(other.z), w.LaneNotEquals(other.w));
    }

    [MethodImpl(256 | 512)]
    public static b32v4_mt16 operator ==(int4_mt16 left, int4_mt16 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b32v4_mt16 operator !=(int4_mt16 left, int4_mt16 right) => left.VectorNotEquals(right);
}

#endregion // int4_mt16
#region int4_mt32

public partial struct int4_mt32
    : IEqualityOperators<int4_mt32, int4_mt32, bool>
    , IEqualityOperators<int4_mt32, int4_mt32, b32v4_mt32>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y, z, w);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is int4_mt32 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(int4_mt32 other) => x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z) && w.Equals(other.w);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(int4_mt32 other) => !x.Equals(other.x) || !y.Equals(other.y) || !z.Equals(other.z) || !w.Equals(other.w);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<int4_mt32, int4_mt32, bool>.operator ==(int4_mt32 left, int4_mt32 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<int4_mt32, int4_mt32, bool>.operator !=(int4_mt32 left, int4_mt32 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b32v4_mt32 VectorEquals(int4_mt32 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y), z.LaneEquals(other.z), w.LaneEquals(other.w));
    }

    [MethodImpl(256 | 512)]
    public readonly b32v4_mt32 VectorNotEquals(int4_mt32 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y), z.LaneNotEquals(other.z), w.LaneNotEquals(other.w));
    }

    [MethodImpl(256 | 512)]
    public static b32v4_mt32 operator ==(int4_mt32 left, int4_mt32 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b32v4_mt32 operator !=(int4_mt32 left, int4_mt32 right) => left.VectorNotEquals(right);
}

#endregion // int4_mt32
#region uint2_mt4

public partial struct uint2_mt4
    : IEqualityOperators<uint2_mt4, uint2_mt4, bool>
    , IEqualityOperators<uint2_mt4, uint2_mt4, b32v2_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is uint2_mt4 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(uint2_mt4 other) => x.Equals(other.x) && y.Equals(other.y);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(uint2_mt4 other) => !x.Equals(other.x) || !y.Equals(other.y);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<uint2_mt4, uint2_mt4, bool>.operator ==(uint2_mt4 left, uint2_mt4 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<uint2_mt4, uint2_mt4, bool>.operator !=(uint2_mt4 left, uint2_mt4 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b32v2_mt4 VectorEquals(uint2_mt4 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y));
    }

    [MethodImpl(256 | 512)]
    public readonly b32v2_mt4 VectorNotEquals(uint2_mt4 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y));
    }

    [MethodImpl(256 | 512)]
    public static b32v2_mt4 operator ==(uint2_mt4 left, uint2_mt4 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b32v2_mt4 operator !=(uint2_mt4 left, uint2_mt4 right) => left.VectorNotEquals(right);
}

#endregion // uint2_mt4
#region uint2_mt8

public partial struct uint2_mt8
    : IEqualityOperators<uint2_mt8, uint2_mt8, bool>
    , IEqualityOperators<uint2_mt8, uint2_mt8, b32v2_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is uint2_mt8 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(uint2_mt8 other) => x.Equals(other.x) && y.Equals(other.y);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(uint2_mt8 other) => !x.Equals(other.x) || !y.Equals(other.y);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<uint2_mt8, uint2_mt8, bool>.operator ==(uint2_mt8 left, uint2_mt8 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<uint2_mt8, uint2_mt8, bool>.operator !=(uint2_mt8 left, uint2_mt8 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b32v2_mt8 VectorEquals(uint2_mt8 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y));
    }

    [MethodImpl(256 | 512)]
    public readonly b32v2_mt8 VectorNotEquals(uint2_mt8 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y));
    }

    [MethodImpl(256 | 512)]
    public static b32v2_mt8 operator ==(uint2_mt8 left, uint2_mt8 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b32v2_mt8 operator !=(uint2_mt8 left, uint2_mt8 right) => left.VectorNotEquals(right);
}

#endregion // uint2_mt8
#region uint2_mt16

public partial struct uint2_mt16
    : IEqualityOperators<uint2_mt16, uint2_mt16, bool>
    , IEqualityOperators<uint2_mt16, uint2_mt16, b32v2_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is uint2_mt16 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(uint2_mt16 other) => x.Equals(other.x) && y.Equals(other.y);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(uint2_mt16 other) => !x.Equals(other.x) || !y.Equals(other.y);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<uint2_mt16, uint2_mt16, bool>.operator ==(uint2_mt16 left, uint2_mt16 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<uint2_mt16, uint2_mt16, bool>.operator !=(uint2_mt16 left, uint2_mt16 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b32v2_mt16 VectorEquals(uint2_mt16 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y));
    }

    [MethodImpl(256 | 512)]
    public readonly b32v2_mt16 VectorNotEquals(uint2_mt16 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y));
    }

    [MethodImpl(256 | 512)]
    public static b32v2_mt16 operator ==(uint2_mt16 left, uint2_mt16 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b32v2_mt16 operator !=(uint2_mt16 left, uint2_mt16 right) => left.VectorNotEquals(right);
}

#endregion // uint2_mt16
#region uint2_mt32

public partial struct uint2_mt32
    : IEqualityOperators<uint2_mt32, uint2_mt32, bool>
    , IEqualityOperators<uint2_mt32, uint2_mt32, b32v2_mt32>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is uint2_mt32 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(uint2_mt32 other) => x.Equals(other.x) && y.Equals(other.y);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(uint2_mt32 other) => !x.Equals(other.x) || !y.Equals(other.y);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<uint2_mt32, uint2_mt32, bool>.operator ==(uint2_mt32 left, uint2_mt32 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<uint2_mt32, uint2_mt32, bool>.operator !=(uint2_mt32 left, uint2_mt32 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b32v2_mt32 VectorEquals(uint2_mt32 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y));
    }

    [MethodImpl(256 | 512)]
    public readonly b32v2_mt32 VectorNotEquals(uint2_mt32 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y));
    }

    [MethodImpl(256 | 512)]
    public static b32v2_mt32 operator ==(uint2_mt32 left, uint2_mt32 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b32v2_mt32 operator !=(uint2_mt32 left, uint2_mt32 right) => left.VectorNotEquals(right);
}

#endregion // uint2_mt32
#region uint3_mt4

public partial struct uint3_mt4
    : IEqualityOperators<uint3_mt4, uint3_mt4, bool>
    , IEqualityOperators<uint3_mt4, uint3_mt4, b32v3_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y, z);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is uint3_mt4 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(uint3_mt4 other) => x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(uint3_mt4 other) => !x.Equals(other.x) || !y.Equals(other.y) || !z.Equals(other.z);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<uint3_mt4, uint3_mt4, bool>.operator ==(uint3_mt4 left, uint3_mt4 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<uint3_mt4, uint3_mt4, bool>.operator !=(uint3_mt4 left, uint3_mt4 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b32v3_mt4 VectorEquals(uint3_mt4 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y), z.LaneEquals(other.z));
    }

    [MethodImpl(256 | 512)]
    public readonly b32v3_mt4 VectorNotEquals(uint3_mt4 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y), z.LaneNotEquals(other.z));
    }

    [MethodImpl(256 | 512)]
    public static b32v3_mt4 operator ==(uint3_mt4 left, uint3_mt4 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b32v3_mt4 operator !=(uint3_mt4 left, uint3_mt4 right) => left.VectorNotEquals(right);
}

#endregion // uint3_mt4
#region uint3_mt8

public partial struct uint3_mt8
    : IEqualityOperators<uint3_mt8, uint3_mt8, bool>
    , IEqualityOperators<uint3_mt8, uint3_mt8, b32v3_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y, z);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is uint3_mt8 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(uint3_mt8 other) => x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(uint3_mt8 other) => !x.Equals(other.x) || !y.Equals(other.y) || !z.Equals(other.z);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<uint3_mt8, uint3_mt8, bool>.operator ==(uint3_mt8 left, uint3_mt8 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<uint3_mt8, uint3_mt8, bool>.operator !=(uint3_mt8 left, uint3_mt8 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b32v3_mt8 VectorEquals(uint3_mt8 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y), z.LaneEquals(other.z));
    }

    [MethodImpl(256 | 512)]
    public readonly b32v3_mt8 VectorNotEquals(uint3_mt8 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y), z.LaneNotEquals(other.z));
    }

    [MethodImpl(256 | 512)]
    public static b32v3_mt8 operator ==(uint3_mt8 left, uint3_mt8 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b32v3_mt8 operator !=(uint3_mt8 left, uint3_mt8 right) => left.VectorNotEquals(right);
}

#endregion // uint3_mt8
#region uint3_mt16

public partial struct uint3_mt16
    : IEqualityOperators<uint3_mt16, uint3_mt16, bool>
    , IEqualityOperators<uint3_mt16, uint3_mt16, b32v3_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y, z);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is uint3_mt16 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(uint3_mt16 other) => x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(uint3_mt16 other) => !x.Equals(other.x) || !y.Equals(other.y) || !z.Equals(other.z);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<uint3_mt16, uint3_mt16, bool>.operator ==(uint3_mt16 left, uint3_mt16 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<uint3_mt16, uint3_mt16, bool>.operator !=(uint3_mt16 left, uint3_mt16 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b32v3_mt16 VectorEquals(uint3_mt16 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y), z.LaneEquals(other.z));
    }

    [MethodImpl(256 | 512)]
    public readonly b32v3_mt16 VectorNotEquals(uint3_mt16 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y), z.LaneNotEquals(other.z));
    }

    [MethodImpl(256 | 512)]
    public static b32v3_mt16 operator ==(uint3_mt16 left, uint3_mt16 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b32v3_mt16 operator !=(uint3_mt16 left, uint3_mt16 right) => left.VectorNotEquals(right);
}

#endregion // uint3_mt16
#region uint3_mt32

public partial struct uint3_mt32
    : IEqualityOperators<uint3_mt32, uint3_mt32, bool>
    , IEqualityOperators<uint3_mt32, uint3_mt32, b32v3_mt32>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y, z);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is uint3_mt32 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(uint3_mt32 other) => x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(uint3_mt32 other) => !x.Equals(other.x) || !y.Equals(other.y) || !z.Equals(other.z);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<uint3_mt32, uint3_mt32, bool>.operator ==(uint3_mt32 left, uint3_mt32 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<uint3_mt32, uint3_mt32, bool>.operator !=(uint3_mt32 left, uint3_mt32 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b32v3_mt32 VectorEquals(uint3_mt32 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y), z.LaneEquals(other.z));
    }

    [MethodImpl(256 | 512)]
    public readonly b32v3_mt32 VectorNotEquals(uint3_mt32 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y), z.LaneNotEquals(other.z));
    }

    [MethodImpl(256 | 512)]
    public static b32v3_mt32 operator ==(uint3_mt32 left, uint3_mt32 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b32v3_mt32 operator !=(uint3_mt32 left, uint3_mt32 right) => left.VectorNotEquals(right);
}

#endregion // uint3_mt32
#region uint4_mt4

public partial struct uint4_mt4
    : IEqualityOperators<uint4_mt4, uint4_mt4, bool>
    , IEqualityOperators<uint4_mt4, uint4_mt4, b32v4_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y, z, w);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is uint4_mt4 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(uint4_mt4 other) => x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z) && w.Equals(other.w);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(uint4_mt4 other) => !x.Equals(other.x) || !y.Equals(other.y) || !z.Equals(other.z) || !w.Equals(other.w);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<uint4_mt4, uint4_mt4, bool>.operator ==(uint4_mt4 left, uint4_mt4 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<uint4_mt4, uint4_mt4, bool>.operator !=(uint4_mt4 left, uint4_mt4 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b32v4_mt4 VectorEquals(uint4_mt4 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y), z.LaneEquals(other.z), w.LaneEquals(other.w));
    }

    [MethodImpl(256 | 512)]
    public readonly b32v4_mt4 VectorNotEquals(uint4_mt4 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y), z.LaneNotEquals(other.z), w.LaneNotEquals(other.w));
    }

    [MethodImpl(256 | 512)]
    public static b32v4_mt4 operator ==(uint4_mt4 left, uint4_mt4 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b32v4_mt4 operator !=(uint4_mt4 left, uint4_mt4 right) => left.VectorNotEquals(right);
}

#endregion // uint4_mt4
#region uint4_mt8

public partial struct uint4_mt8
    : IEqualityOperators<uint4_mt8, uint4_mt8, bool>
    , IEqualityOperators<uint4_mt8, uint4_mt8, b32v4_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y, z, w);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is uint4_mt8 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(uint4_mt8 other) => x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z) && w.Equals(other.w);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(uint4_mt8 other) => !x.Equals(other.x) || !y.Equals(other.y) || !z.Equals(other.z) || !w.Equals(other.w);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<uint4_mt8, uint4_mt8, bool>.operator ==(uint4_mt8 left, uint4_mt8 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<uint4_mt8, uint4_mt8, bool>.operator !=(uint4_mt8 left, uint4_mt8 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b32v4_mt8 VectorEquals(uint4_mt8 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y), z.LaneEquals(other.z), w.LaneEquals(other.w));
    }

    [MethodImpl(256 | 512)]
    public readonly b32v4_mt8 VectorNotEquals(uint4_mt8 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y), z.LaneNotEquals(other.z), w.LaneNotEquals(other.w));
    }

    [MethodImpl(256 | 512)]
    public static b32v4_mt8 operator ==(uint4_mt8 left, uint4_mt8 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b32v4_mt8 operator !=(uint4_mt8 left, uint4_mt8 right) => left.VectorNotEquals(right);
}

#endregion // uint4_mt8
#region uint4_mt16

public partial struct uint4_mt16
    : IEqualityOperators<uint4_mt16, uint4_mt16, bool>
    , IEqualityOperators<uint4_mt16, uint4_mt16, b32v4_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y, z, w);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is uint4_mt16 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(uint4_mt16 other) => x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z) && w.Equals(other.w);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(uint4_mt16 other) => !x.Equals(other.x) || !y.Equals(other.y) || !z.Equals(other.z) || !w.Equals(other.w);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<uint4_mt16, uint4_mt16, bool>.operator ==(uint4_mt16 left, uint4_mt16 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<uint4_mt16, uint4_mt16, bool>.operator !=(uint4_mt16 left, uint4_mt16 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b32v4_mt16 VectorEquals(uint4_mt16 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y), z.LaneEquals(other.z), w.LaneEquals(other.w));
    }

    [MethodImpl(256 | 512)]
    public readonly b32v4_mt16 VectorNotEquals(uint4_mt16 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y), z.LaneNotEquals(other.z), w.LaneNotEquals(other.w));
    }

    [MethodImpl(256 | 512)]
    public static b32v4_mt16 operator ==(uint4_mt16 left, uint4_mt16 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b32v4_mt16 operator !=(uint4_mt16 left, uint4_mt16 right) => left.VectorNotEquals(right);
}

#endregion // uint4_mt16
#region uint4_mt32

public partial struct uint4_mt32
    : IEqualityOperators<uint4_mt32, uint4_mt32, bool>
    , IEqualityOperators<uint4_mt32, uint4_mt32, b32v4_mt32>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y, z, w);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is uint4_mt32 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(uint4_mt32 other) => x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z) && w.Equals(other.w);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(uint4_mt32 other) => !x.Equals(other.x) || !y.Equals(other.y) || !z.Equals(other.z) || !w.Equals(other.w);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<uint4_mt32, uint4_mt32, bool>.operator ==(uint4_mt32 left, uint4_mt32 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<uint4_mt32, uint4_mt32, bool>.operator !=(uint4_mt32 left, uint4_mt32 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b32v4_mt32 VectorEquals(uint4_mt32 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y), z.LaneEquals(other.z), w.LaneEquals(other.w));
    }

    [MethodImpl(256 | 512)]
    public readonly b32v4_mt32 VectorNotEquals(uint4_mt32 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y), z.LaneNotEquals(other.z), w.LaneNotEquals(other.w));
    }

    [MethodImpl(256 | 512)]
    public static b32v4_mt32 operator ==(uint4_mt32 left, uint4_mt32 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b32v4_mt32 operator !=(uint4_mt32 left, uint4_mt32 right) => left.VectorNotEquals(right);
}

#endregion // uint4_mt32
#region long2_mt4

public partial struct long2_mt4
    : IEqualityOperators<long2_mt4, long2_mt4, bool>
    , IEqualityOperators<long2_mt4, long2_mt4, b64v2_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is long2_mt4 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(long2_mt4 other) => x.Equals(other.x) && y.Equals(other.y);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(long2_mt4 other) => !x.Equals(other.x) || !y.Equals(other.y);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<long2_mt4, long2_mt4, bool>.operator ==(long2_mt4 left, long2_mt4 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<long2_mt4, long2_mt4, bool>.operator !=(long2_mt4 left, long2_mt4 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b64v2_mt4 VectorEquals(long2_mt4 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y));
    }

    [MethodImpl(256 | 512)]
    public readonly b64v2_mt4 VectorNotEquals(long2_mt4 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y));
    }

    [MethodImpl(256 | 512)]
    public static b64v2_mt4 operator ==(long2_mt4 left, long2_mt4 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b64v2_mt4 operator !=(long2_mt4 left, long2_mt4 right) => left.VectorNotEquals(right);
}

#endregion // long2_mt4
#region long2_mt8

public partial struct long2_mt8
    : IEqualityOperators<long2_mt8, long2_mt8, bool>
    , IEqualityOperators<long2_mt8, long2_mt8, b64v2_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is long2_mt8 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(long2_mt8 other) => x.Equals(other.x) && y.Equals(other.y);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(long2_mt8 other) => !x.Equals(other.x) || !y.Equals(other.y);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<long2_mt8, long2_mt8, bool>.operator ==(long2_mt8 left, long2_mt8 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<long2_mt8, long2_mt8, bool>.operator !=(long2_mt8 left, long2_mt8 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b64v2_mt8 VectorEquals(long2_mt8 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y));
    }

    [MethodImpl(256 | 512)]
    public readonly b64v2_mt8 VectorNotEquals(long2_mt8 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y));
    }

    [MethodImpl(256 | 512)]
    public static b64v2_mt8 operator ==(long2_mt8 left, long2_mt8 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b64v2_mt8 operator !=(long2_mt8 left, long2_mt8 right) => left.VectorNotEquals(right);
}

#endregion // long2_mt8
#region long2_mt16

public partial struct long2_mt16
    : IEqualityOperators<long2_mt16, long2_mt16, bool>
    , IEqualityOperators<long2_mt16, long2_mt16, b64v2_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is long2_mt16 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(long2_mt16 other) => x.Equals(other.x) && y.Equals(other.y);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(long2_mt16 other) => !x.Equals(other.x) || !y.Equals(other.y);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<long2_mt16, long2_mt16, bool>.operator ==(long2_mt16 left, long2_mt16 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<long2_mt16, long2_mt16, bool>.operator !=(long2_mt16 left, long2_mt16 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b64v2_mt16 VectorEquals(long2_mt16 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y));
    }

    [MethodImpl(256 | 512)]
    public readonly b64v2_mt16 VectorNotEquals(long2_mt16 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y));
    }

    [MethodImpl(256 | 512)]
    public static b64v2_mt16 operator ==(long2_mt16 left, long2_mt16 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b64v2_mt16 operator !=(long2_mt16 left, long2_mt16 right) => left.VectorNotEquals(right);
}

#endregion // long2_mt16
#region long2_mt32

public partial struct long2_mt32
    : IEqualityOperators<long2_mt32, long2_mt32, bool>
    , IEqualityOperators<long2_mt32, long2_mt32, b64v2_mt32>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is long2_mt32 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(long2_mt32 other) => x.Equals(other.x) && y.Equals(other.y);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(long2_mt32 other) => !x.Equals(other.x) || !y.Equals(other.y);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<long2_mt32, long2_mt32, bool>.operator ==(long2_mt32 left, long2_mt32 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<long2_mt32, long2_mt32, bool>.operator !=(long2_mt32 left, long2_mt32 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b64v2_mt32 VectorEquals(long2_mt32 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y));
    }

    [MethodImpl(256 | 512)]
    public readonly b64v2_mt32 VectorNotEquals(long2_mt32 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y));
    }

    [MethodImpl(256 | 512)]
    public static b64v2_mt32 operator ==(long2_mt32 left, long2_mt32 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b64v2_mt32 operator !=(long2_mt32 left, long2_mt32 right) => left.VectorNotEquals(right);
}

#endregion // long2_mt32
#region long3_mt4

public partial struct long3_mt4
    : IEqualityOperators<long3_mt4, long3_mt4, bool>
    , IEqualityOperators<long3_mt4, long3_mt4, b64v3_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y, z);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is long3_mt4 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(long3_mt4 other) => x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(long3_mt4 other) => !x.Equals(other.x) || !y.Equals(other.y) || !z.Equals(other.z);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<long3_mt4, long3_mt4, bool>.operator ==(long3_mt4 left, long3_mt4 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<long3_mt4, long3_mt4, bool>.operator !=(long3_mt4 left, long3_mt4 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b64v3_mt4 VectorEquals(long3_mt4 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y), z.LaneEquals(other.z));
    }

    [MethodImpl(256 | 512)]
    public readonly b64v3_mt4 VectorNotEquals(long3_mt4 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y), z.LaneNotEquals(other.z));
    }

    [MethodImpl(256 | 512)]
    public static b64v3_mt4 operator ==(long3_mt4 left, long3_mt4 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b64v3_mt4 operator !=(long3_mt4 left, long3_mt4 right) => left.VectorNotEquals(right);
}

#endregion // long3_mt4
#region long3_mt8

public partial struct long3_mt8
    : IEqualityOperators<long3_mt8, long3_mt8, bool>
    , IEqualityOperators<long3_mt8, long3_mt8, b64v3_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y, z);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is long3_mt8 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(long3_mt8 other) => x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(long3_mt8 other) => !x.Equals(other.x) || !y.Equals(other.y) || !z.Equals(other.z);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<long3_mt8, long3_mt8, bool>.operator ==(long3_mt8 left, long3_mt8 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<long3_mt8, long3_mt8, bool>.operator !=(long3_mt8 left, long3_mt8 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b64v3_mt8 VectorEquals(long3_mt8 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y), z.LaneEquals(other.z));
    }

    [MethodImpl(256 | 512)]
    public readonly b64v3_mt8 VectorNotEquals(long3_mt8 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y), z.LaneNotEquals(other.z));
    }

    [MethodImpl(256 | 512)]
    public static b64v3_mt8 operator ==(long3_mt8 left, long3_mt8 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b64v3_mt8 operator !=(long3_mt8 left, long3_mt8 right) => left.VectorNotEquals(right);
}

#endregion // long3_mt8
#region long3_mt16

public partial struct long3_mt16
    : IEqualityOperators<long3_mt16, long3_mt16, bool>
    , IEqualityOperators<long3_mt16, long3_mt16, b64v3_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y, z);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is long3_mt16 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(long3_mt16 other) => x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(long3_mt16 other) => !x.Equals(other.x) || !y.Equals(other.y) || !z.Equals(other.z);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<long3_mt16, long3_mt16, bool>.operator ==(long3_mt16 left, long3_mt16 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<long3_mt16, long3_mt16, bool>.operator !=(long3_mt16 left, long3_mt16 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b64v3_mt16 VectorEquals(long3_mt16 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y), z.LaneEquals(other.z));
    }

    [MethodImpl(256 | 512)]
    public readonly b64v3_mt16 VectorNotEquals(long3_mt16 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y), z.LaneNotEquals(other.z));
    }

    [MethodImpl(256 | 512)]
    public static b64v3_mt16 operator ==(long3_mt16 left, long3_mt16 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b64v3_mt16 operator !=(long3_mt16 left, long3_mt16 right) => left.VectorNotEquals(right);
}

#endregion // long3_mt16
#region long3_mt32

public partial struct long3_mt32
    : IEqualityOperators<long3_mt32, long3_mt32, bool>
    , IEqualityOperators<long3_mt32, long3_mt32, b64v3_mt32>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y, z);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is long3_mt32 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(long3_mt32 other) => x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(long3_mt32 other) => !x.Equals(other.x) || !y.Equals(other.y) || !z.Equals(other.z);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<long3_mt32, long3_mt32, bool>.operator ==(long3_mt32 left, long3_mt32 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<long3_mt32, long3_mt32, bool>.operator !=(long3_mt32 left, long3_mt32 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b64v3_mt32 VectorEquals(long3_mt32 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y), z.LaneEquals(other.z));
    }

    [MethodImpl(256 | 512)]
    public readonly b64v3_mt32 VectorNotEquals(long3_mt32 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y), z.LaneNotEquals(other.z));
    }

    [MethodImpl(256 | 512)]
    public static b64v3_mt32 operator ==(long3_mt32 left, long3_mt32 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b64v3_mt32 operator !=(long3_mt32 left, long3_mt32 right) => left.VectorNotEquals(right);
}

#endregion // long3_mt32
#region long4_mt4

public partial struct long4_mt4
    : IEqualityOperators<long4_mt4, long4_mt4, bool>
    , IEqualityOperators<long4_mt4, long4_mt4, b64v4_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y, z, w);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is long4_mt4 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(long4_mt4 other) => x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z) && w.Equals(other.w);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(long4_mt4 other) => !x.Equals(other.x) || !y.Equals(other.y) || !z.Equals(other.z) || !w.Equals(other.w);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<long4_mt4, long4_mt4, bool>.operator ==(long4_mt4 left, long4_mt4 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<long4_mt4, long4_mt4, bool>.operator !=(long4_mt4 left, long4_mt4 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b64v4_mt4 VectorEquals(long4_mt4 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y), z.LaneEquals(other.z), w.LaneEquals(other.w));
    }

    [MethodImpl(256 | 512)]
    public readonly b64v4_mt4 VectorNotEquals(long4_mt4 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y), z.LaneNotEquals(other.z), w.LaneNotEquals(other.w));
    }

    [MethodImpl(256 | 512)]
    public static b64v4_mt4 operator ==(long4_mt4 left, long4_mt4 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b64v4_mt4 operator !=(long4_mt4 left, long4_mt4 right) => left.VectorNotEquals(right);
}

#endregion // long4_mt4
#region long4_mt8

public partial struct long4_mt8
    : IEqualityOperators<long4_mt8, long4_mt8, bool>
    , IEqualityOperators<long4_mt8, long4_mt8, b64v4_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y, z, w);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is long4_mt8 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(long4_mt8 other) => x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z) && w.Equals(other.w);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(long4_mt8 other) => !x.Equals(other.x) || !y.Equals(other.y) || !z.Equals(other.z) || !w.Equals(other.w);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<long4_mt8, long4_mt8, bool>.operator ==(long4_mt8 left, long4_mt8 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<long4_mt8, long4_mt8, bool>.operator !=(long4_mt8 left, long4_mt8 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b64v4_mt8 VectorEquals(long4_mt8 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y), z.LaneEquals(other.z), w.LaneEquals(other.w));
    }

    [MethodImpl(256 | 512)]
    public readonly b64v4_mt8 VectorNotEquals(long4_mt8 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y), z.LaneNotEquals(other.z), w.LaneNotEquals(other.w));
    }

    [MethodImpl(256 | 512)]
    public static b64v4_mt8 operator ==(long4_mt8 left, long4_mt8 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b64v4_mt8 operator !=(long4_mt8 left, long4_mt8 right) => left.VectorNotEquals(right);
}

#endregion // long4_mt8
#region long4_mt16

public partial struct long4_mt16
    : IEqualityOperators<long4_mt16, long4_mt16, bool>
    , IEqualityOperators<long4_mt16, long4_mt16, b64v4_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y, z, w);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is long4_mt16 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(long4_mt16 other) => x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z) && w.Equals(other.w);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(long4_mt16 other) => !x.Equals(other.x) || !y.Equals(other.y) || !z.Equals(other.z) || !w.Equals(other.w);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<long4_mt16, long4_mt16, bool>.operator ==(long4_mt16 left, long4_mt16 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<long4_mt16, long4_mt16, bool>.operator !=(long4_mt16 left, long4_mt16 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b64v4_mt16 VectorEquals(long4_mt16 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y), z.LaneEquals(other.z), w.LaneEquals(other.w));
    }

    [MethodImpl(256 | 512)]
    public readonly b64v4_mt16 VectorNotEquals(long4_mt16 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y), z.LaneNotEquals(other.z), w.LaneNotEquals(other.w));
    }

    [MethodImpl(256 | 512)]
    public static b64v4_mt16 operator ==(long4_mt16 left, long4_mt16 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b64v4_mt16 operator !=(long4_mt16 left, long4_mt16 right) => left.VectorNotEquals(right);
}

#endregion // long4_mt16
#region long4_mt32

public partial struct long4_mt32
    : IEqualityOperators<long4_mt32, long4_mt32, bool>
    , IEqualityOperators<long4_mt32, long4_mt32, b64v4_mt32>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y, z, w);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is long4_mt32 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(long4_mt32 other) => x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z) && w.Equals(other.w);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(long4_mt32 other) => !x.Equals(other.x) || !y.Equals(other.y) || !z.Equals(other.z) || !w.Equals(other.w);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<long4_mt32, long4_mt32, bool>.operator ==(long4_mt32 left, long4_mt32 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<long4_mt32, long4_mt32, bool>.operator !=(long4_mt32 left, long4_mt32 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b64v4_mt32 VectorEquals(long4_mt32 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y), z.LaneEquals(other.z), w.LaneEquals(other.w));
    }

    [MethodImpl(256 | 512)]
    public readonly b64v4_mt32 VectorNotEquals(long4_mt32 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y), z.LaneNotEquals(other.z), w.LaneNotEquals(other.w));
    }

    [MethodImpl(256 | 512)]
    public static b64v4_mt32 operator ==(long4_mt32 left, long4_mt32 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b64v4_mt32 operator !=(long4_mt32 left, long4_mt32 right) => left.VectorNotEquals(right);
}

#endregion // long4_mt32
#region ulong2_mt4

public partial struct ulong2_mt4
    : IEqualityOperators<ulong2_mt4, ulong2_mt4, bool>
    , IEqualityOperators<ulong2_mt4, ulong2_mt4, b64v2_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is ulong2_mt4 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(ulong2_mt4 other) => x.Equals(other.x) && y.Equals(other.y);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(ulong2_mt4 other) => !x.Equals(other.x) || !y.Equals(other.y);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<ulong2_mt4, ulong2_mt4, bool>.operator ==(ulong2_mt4 left, ulong2_mt4 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<ulong2_mt4, ulong2_mt4, bool>.operator !=(ulong2_mt4 left, ulong2_mt4 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b64v2_mt4 VectorEquals(ulong2_mt4 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y));
    }

    [MethodImpl(256 | 512)]
    public readonly b64v2_mt4 VectorNotEquals(ulong2_mt4 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y));
    }

    [MethodImpl(256 | 512)]
    public static b64v2_mt4 operator ==(ulong2_mt4 left, ulong2_mt4 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b64v2_mt4 operator !=(ulong2_mt4 left, ulong2_mt4 right) => left.VectorNotEquals(right);
}

#endregion // ulong2_mt4
#region ulong2_mt8

public partial struct ulong2_mt8
    : IEqualityOperators<ulong2_mt8, ulong2_mt8, bool>
    , IEqualityOperators<ulong2_mt8, ulong2_mt8, b64v2_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is ulong2_mt8 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(ulong2_mt8 other) => x.Equals(other.x) && y.Equals(other.y);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(ulong2_mt8 other) => !x.Equals(other.x) || !y.Equals(other.y);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<ulong2_mt8, ulong2_mt8, bool>.operator ==(ulong2_mt8 left, ulong2_mt8 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<ulong2_mt8, ulong2_mt8, bool>.operator !=(ulong2_mt8 left, ulong2_mt8 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b64v2_mt8 VectorEquals(ulong2_mt8 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y));
    }

    [MethodImpl(256 | 512)]
    public readonly b64v2_mt8 VectorNotEquals(ulong2_mt8 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y));
    }

    [MethodImpl(256 | 512)]
    public static b64v2_mt8 operator ==(ulong2_mt8 left, ulong2_mt8 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b64v2_mt8 operator !=(ulong2_mt8 left, ulong2_mt8 right) => left.VectorNotEquals(right);
}

#endregion // ulong2_mt8
#region ulong2_mt16

public partial struct ulong2_mt16
    : IEqualityOperators<ulong2_mt16, ulong2_mt16, bool>
    , IEqualityOperators<ulong2_mt16, ulong2_mt16, b64v2_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is ulong2_mt16 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(ulong2_mt16 other) => x.Equals(other.x) && y.Equals(other.y);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(ulong2_mt16 other) => !x.Equals(other.x) || !y.Equals(other.y);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<ulong2_mt16, ulong2_mt16, bool>.operator ==(ulong2_mt16 left, ulong2_mt16 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<ulong2_mt16, ulong2_mt16, bool>.operator !=(ulong2_mt16 left, ulong2_mt16 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b64v2_mt16 VectorEquals(ulong2_mt16 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y));
    }

    [MethodImpl(256 | 512)]
    public readonly b64v2_mt16 VectorNotEquals(ulong2_mt16 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y));
    }

    [MethodImpl(256 | 512)]
    public static b64v2_mt16 operator ==(ulong2_mt16 left, ulong2_mt16 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b64v2_mt16 operator !=(ulong2_mt16 left, ulong2_mt16 right) => left.VectorNotEquals(right);
}

#endregion // ulong2_mt16
#region ulong2_mt32

public partial struct ulong2_mt32
    : IEqualityOperators<ulong2_mt32, ulong2_mt32, bool>
    , IEqualityOperators<ulong2_mt32, ulong2_mt32, b64v2_mt32>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is ulong2_mt32 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(ulong2_mt32 other) => x.Equals(other.x) && y.Equals(other.y);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(ulong2_mt32 other) => !x.Equals(other.x) || !y.Equals(other.y);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<ulong2_mt32, ulong2_mt32, bool>.operator ==(ulong2_mt32 left, ulong2_mt32 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<ulong2_mt32, ulong2_mt32, bool>.operator !=(ulong2_mt32 left, ulong2_mt32 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b64v2_mt32 VectorEquals(ulong2_mt32 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y));
    }

    [MethodImpl(256 | 512)]
    public readonly b64v2_mt32 VectorNotEquals(ulong2_mt32 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y));
    }

    [MethodImpl(256 | 512)]
    public static b64v2_mt32 operator ==(ulong2_mt32 left, ulong2_mt32 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b64v2_mt32 operator !=(ulong2_mt32 left, ulong2_mt32 right) => left.VectorNotEquals(right);
}

#endregion // ulong2_mt32
#region ulong3_mt4

public partial struct ulong3_mt4
    : IEqualityOperators<ulong3_mt4, ulong3_mt4, bool>
    , IEqualityOperators<ulong3_mt4, ulong3_mt4, b64v3_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y, z);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is ulong3_mt4 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(ulong3_mt4 other) => x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(ulong3_mt4 other) => !x.Equals(other.x) || !y.Equals(other.y) || !z.Equals(other.z);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<ulong3_mt4, ulong3_mt4, bool>.operator ==(ulong3_mt4 left, ulong3_mt4 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<ulong3_mt4, ulong3_mt4, bool>.operator !=(ulong3_mt4 left, ulong3_mt4 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b64v3_mt4 VectorEquals(ulong3_mt4 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y), z.LaneEquals(other.z));
    }

    [MethodImpl(256 | 512)]
    public readonly b64v3_mt4 VectorNotEquals(ulong3_mt4 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y), z.LaneNotEquals(other.z));
    }

    [MethodImpl(256 | 512)]
    public static b64v3_mt4 operator ==(ulong3_mt4 left, ulong3_mt4 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b64v3_mt4 operator !=(ulong3_mt4 left, ulong3_mt4 right) => left.VectorNotEquals(right);
}

#endregion // ulong3_mt4
#region ulong3_mt8

public partial struct ulong3_mt8
    : IEqualityOperators<ulong3_mt8, ulong3_mt8, bool>
    , IEqualityOperators<ulong3_mt8, ulong3_mt8, b64v3_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y, z);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is ulong3_mt8 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(ulong3_mt8 other) => x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(ulong3_mt8 other) => !x.Equals(other.x) || !y.Equals(other.y) || !z.Equals(other.z);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<ulong3_mt8, ulong3_mt8, bool>.operator ==(ulong3_mt8 left, ulong3_mt8 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<ulong3_mt8, ulong3_mt8, bool>.operator !=(ulong3_mt8 left, ulong3_mt8 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b64v3_mt8 VectorEquals(ulong3_mt8 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y), z.LaneEquals(other.z));
    }

    [MethodImpl(256 | 512)]
    public readonly b64v3_mt8 VectorNotEquals(ulong3_mt8 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y), z.LaneNotEquals(other.z));
    }

    [MethodImpl(256 | 512)]
    public static b64v3_mt8 operator ==(ulong3_mt8 left, ulong3_mt8 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b64v3_mt8 operator !=(ulong3_mt8 left, ulong3_mt8 right) => left.VectorNotEquals(right);
}

#endregion // ulong3_mt8
#region ulong3_mt16

public partial struct ulong3_mt16
    : IEqualityOperators<ulong3_mt16, ulong3_mt16, bool>
    , IEqualityOperators<ulong3_mt16, ulong3_mt16, b64v3_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y, z);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is ulong3_mt16 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(ulong3_mt16 other) => x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(ulong3_mt16 other) => !x.Equals(other.x) || !y.Equals(other.y) || !z.Equals(other.z);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<ulong3_mt16, ulong3_mt16, bool>.operator ==(ulong3_mt16 left, ulong3_mt16 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<ulong3_mt16, ulong3_mt16, bool>.operator !=(ulong3_mt16 left, ulong3_mt16 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b64v3_mt16 VectorEquals(ulong3_mt16 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y), z.LaneEquals(other.z));
    }

    [MethodImpl(256 | 512)]
    public readonly b64v3_mt16 VectorNotEquals(ulong3_mt16 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y), z.LaneNotEquals(other.z));
    }

    [MethodImpl(256 | 512)]
    public static b64v3_mt16 operator ==(ulong3_mt16 left, ulong3_mt16 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b64v3_mt16 operator !=(ulong3_mt16 left, ulong3_mt16 right) => left.VectorNotEquals(right);
}

#endregion // ulong3_mt16
#region ulong3_mt32

public partial struct ulong3_mt32
    : IEqualityOperators<ulong3_mt32, ulong3_mt32, bool>
    , IEqualityOperators<ulong3_mt32, ulong3_mt32, b64v3_mt32>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y, z);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is ulong3_mt32 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(ulong3_mt32 other) => x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(ulong3_mt32 other) => !x.Equals(other.x) || !y.Equals(other.y) || !z.Equals(other.z);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<ulong3_mt32, ulong3_mt32, bool>.operator ==(ulong3_mt32 left, ulong3_mt32 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<ulong3_mt32, ulong3_mt32, bool>.operator !=(ulong3_mt32 left, ulong3_mt32 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b64v3_mt32 VectorEquals(ulong3_mt32 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y), z.LaneEquals(other.z));
    }

    [MethodImpl(256 | 512)]
    public readonly b64v3_mt32 VectorNotEquals(ulong3_mt32 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y), z.LaneNotEquals(other.z));
    }

    [MethodImpl(256 | 512)]
    public static b64v3_mt32 operator ==(ulong3_mt32 left, ulong3_mt32 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b64v3_mt32 operator !=(ulong3_mt32 left, ulong3_mt32 right) => left.VectorNotEquals(right);
}

#endregion // ulong3_mt32
#region ulong4_mt4

public partial struct ulong4_mt4
    : IEqualityOperators<ulong4_mt4, ulong4_mt4, bool>
    , IEqualityOperators<ulong4_mt4, ulong4_mt4, b64v4_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y, z, w);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is ulong4_mt4 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(ulong4_mt4 other) => x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z) && w.Equals(other.w);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(ulong4_mt4 other) => !x.Equals(other.x) || !y.Equals(other.y) || !z.Equals(other.z) || !w.Equals(other.w);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<ulong4_mt4, ulong4_mt4, bool>.operator ==(ulong4_mt4 left, ulong4_mt4 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<ulong4_mt4, ulong4_mt4, bool>.operator !=(ulong4_mt4 left, ulong4_mt4 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b64v4_mt4 VectorEquals(ulong4_mt4 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y), z.LaneEquals(other.z), w.LaneEquals(other.w));
    }

    [MethodImpl(256 | 512)]
    public readonly b64v4_mt4 VectorNotEquals(ulong4_mt4 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y), z.LaneNotEquals(other.z), w.LaneNotEquals(other.w));
    }

    [MethodImpl(256 | 512)]
    public static b64v4_mt4 operator ==(ulong4_mt4 left, ulong4_mt4 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b64v4_mt4 operator !=(ulong4_mt4 left, ulong4_mt4 right) => left.VectorNotEquals(right);
}

#endregion // ulong4_mt4
#region ulong4_mt8

public partial struct ulong4_mt8
    : IEqualityOperators<ulong4_mt8, ulong4_mt8, bool>
    , IEqualityOperators<ulong4_mt8, ulong4_mt8, b64v4_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y, z, w);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is ulong4_mt8 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(ulong4_mt8 other) => x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z) && w.Equals(other.w);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(ulong4_mt8 other) => !x.Equals(other.x) || !y.Equals(other.y) || !z.Equals(other.z) || !w.Equals(other.w);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<ulong4_mt8, ulong4_mt8, bool>.operator ==(ulong4_mt8 left, ulong4_mt8 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<ulong4_mt8, ulong4_mt8, bool>.operator !=(ulong4_mt8 left, ulong4_mt8 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b64v4_mt8 VectorEquals(ulong4_mt8 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y), z.LaneEquals(other.z), w.LaneEquals(other.w));
    }

    [MethodImpl(256 | 512)]
    public readonly b64v4_mt8 VectorNotEquals(ulong4_mt8 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y), z.LaneNotEquals(other.z), w.LaneNotEquals(other.w));
    }

    [MethodImpl(256 | 512)]
    public static b64v4_mt8 operator ==(ulong4_mt8 left, ulong4_mt8 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b64v4_mt8 operator !=(ulong4_mt8 left, ulong4_mt8 right) => left.VectorNotEquals(right);
}

#endregion // ulong4_mt8
#region ulong4_mt16

public partial struct ulong4_mt16
    : IEqualityOperators<ulong4_mt16, ulong4_mt16, bool>
    , IEqualityOperators<ulong4_mt16, ulong4_mt16, b64v4_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y, z, w);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is ulong4_mt16 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(ulong4_mt16 other) => x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z) && w.Equals(other.w);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(ulong4_mt16 other) => !x.Equals(other.x) || !y.Equals(other.y) || !z.Equals(other.z) || !w.Equals(other.w);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<ulong4_mt16, ulong4_mt16, bool>.operator ==(ulong4_mt16 left, ulong4_mt16 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<ulong4_mt16, ulong4_mt16, bool>.operator !=(ulong4_mt16 left, ulong4_mt16 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b64v4_mt16 VectorEquals(ulong4_mt16 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y), z.LaneEquals(other.z), w.LaneEquals(other.w));
    }

    [MethodImpl(256 | 512)]
    public readonly b64v4_mt16 VectorNotEquals(ulong4_mt16 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y), z.LaneNotEquals(other.z), w.LaneNotEquals(other.w));
    }

    [MethodImpl(256 | 512)]
    public static b64v4_mt16 operator ==(ulong4_mt16 left, ulong4_mt16 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b64v4_mt16 operator !=(ulong4_mt16 left, ulong4_mt16 right) => left.VectorNotEquals(right);
}

#endregion // ulong4_mt16
#region ulong4_mt32

public partial struct ulong4_mt32
    : IEqualityOperators<ulong4_mt32, ulong4_mt32, bool>
    , IEqualityOperators<ulong4_mt32, ulong4_mt32, b64v4_mt32>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode() => HashCode.Combine(x, y, z, w);

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is ulong4_mt32 other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(ulong4_mt32 other) => x.Equals(other.x) && y.Equals(other.y) && z.Equals(other.z) && w.Equals(other.w);

    [MethodImpl(256 | 512)]
    public readonly bool NotEquals(ulong4_mt32 other) => !x.Equals(other.x) || !y.Equals(other.y) || !z.Equals(other.z) || !w.Equals(other.w);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<ulong4_mt32, ulong4_mt32, bool>.operator ==(ulong4_mt32 left, ulong4_mt32 right) => left.Equals(right);

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<ulong4_mt32, ulong4_mt32, bool>.operator !=(ulong4_mt32 left, ulong4_mt32 right) => left.NotEquals(right);

    [MethodImpl(256 | 512)]
    public readonly b64v4_mt32 VectorEquals(ulong4_mt32 other)
    {
        return new(x.LaneEquals(other.x), y.LaneEquals(other.y), z.LaneEquals(other.z), w.LaneEquals(other.w));
    }

    [MethodImpl(256 | 512)]
    public readonly b64v4_mt32 VectorNotEquals(ulong4_mt32 other)
    {
        return new(x.LaneNotEquals(other.x), y.LaneNotEquals(other.y), z.LaneNotEquals(other.z), w.LaneNotEquals(other.w));
    }

    [MethodImpl(256 | 512)]
    public static b64v4_mt32 operator ==(ulong4_mt32 left, ulong4_mt32 right) => left.VectorEquals(right);

    [MethodImpl(256 | 512)]
    public static b64v4_mt32 operator !=(ulong4_mt32 left, ulong4_mt32 right) => left.VectorNotEquals(right);
}

#endregion // ulong4_mt32
