<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="../Coplt.Mathematics/types.ttinclude" #><#@ import namespace="System.Linq" #>// generated by template, do not modify manually

namespace Coplt.Mathematics.SIMT;

<#
    foreach (var typ in Typ.Typs)
    {
        if (!typ.simd) continue;
        if (typ.size != 4) continue;
        var typeName = $"{typ.compType}_mt";
#>
#region <#= typeName #>

[Serializable]
//[JsonConverter(typeof(<#= typeName #>JsonConverter))]
public partial struct <#= typeName #>
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => Vector<<#= typ.simdComp #>>.Count;
    }

    #endregion

    #region Fields

    public Vector<<#= typ.simdComp #>> vector;

    #endregion // Fields

    #region Properties

    public <#= typ.compType #> this[int index]
    {
        [MethodImpl(256 | 512)]
        get => vector[index];
        [MethodImpl(256 | 512)]
        set => vector = vector.WithElement(index, value);
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public <#= typeName #>(Vector<<#= typ.simdComp #>> vector)
    {
        this.vector = vector;
    }

    [MethodImpl(256 | 512)]
    private <#= typeName #>(ref readonly <#= typ.compType #> values)
    {
<#
        if (typ.compType == typ.simdComp)
        {
#>
        vector = Vector.LoadUnsafe(in values);
<#
        }
        else
        {
#>
        vector = Vector.LoadUnsafe(in Unsafe.As<<#= typ.compType #>, <#= typ.simdComp #>>(ref Unsafe.AsRef(in values)));
<#
        }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> LoadUnsafe(ref readonly <#= typ.compType #> values) => new(in values);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> LoadUnsafe(params ReadOnlySpan<<#= typ.compType #>> values) => new(in values.GetPinnableReference());

    [MethodImpl(256 | 512)]
    public <#= typeName #>(<#= typ.compType #> value)
    {
<#
        if (typ.compType == typ.simdComp)
        {
#>
        vector = new(value);
<#
        }
        else
        {
#>
        vector = new((<#= typ.simdComp #>)value);
<#
        }
#>
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator <#= typeName #>(<#= typ.compType #> value) => new(value);

<#
        if (typ.arith)
        {
#>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator-(<#= typeName #> a) => new(-a.vector);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator+(<#= typeName #> a, <#= typeName #> b) => new(a.vector + b.vector);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator-(<#= typeName #> a, <#= typeName #> b) => new(a.vector - b.vector);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator*(<#= typeName #> a, <#= typeName #> b) => new(a.vector * b.vector);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator/(<#= typeName #> a, <#= typeName #> b) => new(a.vector / b.vector);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator/(<#= typeName #> a, <#= typ.compType #> b) => new(a.vector / b);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator%(<#= typeName #> a, <#= typeName #> b) => new(simt.Rem(a.vector, b.vector));

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator%(<#= typeName #> a, <#= typ.compType #> b) => new(simt.Rem(a.vector, b));

<#
        }
#>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator~(<#= typeName #> a) => new(~a.vector);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator|(<#= typeName #> a, <#= typeName #> b) => new(a.vector | b.vector);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator&(<#= typeName #> a, <#= typeName #> b) => new(a.vector & b.vector);

    #endregion
}

#endregion // <#= typeName #>
<#
    }
#>
