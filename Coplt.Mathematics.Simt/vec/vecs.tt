<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="../../Coplt.Mathematics/types.ttinclude" #><#@ import namespace="System.Linq" #>// generated by template, do not modify manually

namespace Coplt.Mathematics.Simt;

<#
    var sizes = new[] { 16 };
    foreach (var typ in Typ.Typs)
    {
        if (!typ.simd) continue;
        if (typ.size < 4) continue;
        for (var i = 2; i <= 4; i++)
        {
            foreach (var size in sizes)
            {
                var byteSize = typ.size * size;
                var bitSize = 8 * byteSize;
                var num_vectors = Math.Max(1, bitSize / 512);
                bitSize = Math.Min(512, bitSize);

                var typeName = $"{typ.name}{i}_mt";
                var scalarName = $"{typ.compType}_mt";
                var simd_typeName = $"{typ.name}{i}";
#>
#region <#= typeName #>

[CpuOnly]
public partial struct <#= typeName #>
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => <#= scalarName #>.LineCount;
    }

    #endregion

    #region Fields

<#
                foreach (var n in Enumerable.Range(0, i))
                {
#>
    public <#= scalarName #> <#= Typ.xyzw[n] #>;
<#
                }
#>

    #endregion // Fields

    #region Properties

<#
                foreach (var n in Enumerable.Range(0, i))
                {
#>
    public <#= scalarName #> <#= Typ.rgba[n] #>
    {
        [MethodImpl(256 | 512)]
        readonly get => <#= Typ.xyzw[n] #>;
        [MethodImpl(256 | 512)]
        set => <#= Typ.xyzw[n] #> = value;
    }
<#
                }
#>

    [MethodImpl(256 | 512)]
    public readonly <#= simd_typeName #> LaneGet(int index) => new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"{Typ.xyzw[n]}[index]")) #>);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, <#= simd_typeName #> value)
    {
<#
                foreach (var n in Enumerable.Range(0, i))
                {
#>
        <#= Typ.xyzw[n] #>[index] = value.<#= Typ.xyzw[n] #>;
<#
                }
#>
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public <#= typeName #>(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"{scalarName} {Typ.xyzw[n]}")) #>)
    {
<#
                foreach (var n in Enumerable.Range(0, i))
                {
#>
        this.<#= Typ.xyzw[n] #> = <#= Typ.xyzw[n] #>;
<#
                }
#>
    }

    [MethodImpl(256 | 512)]
    public <#= typeName #>(<#= typ.compType #> value)
    {
        <#= string.Join(" = ", Enumerable.Range(0, i).Reverse().Select(n => $"{Typ.xyzw[n]}")) #> = value;
    }

    [MethodImpl(256 | 512)]
    public <#= typeName #>(<#= scalarName #> value)
    {
        <#= string.Join(" = ", Enumerable.Range(0, i).Reverse().Select(n => $"{Typ.xyzw[n]}")) #> = value;
    }

    [MethodImpl(256 | 512)]
    public <#= typeName #>(<#= simd_typeName #> value)
    {
<#
                foreach (var n in Enumerable.Range(0, i))
                {
#>
        <#= Typ.xyzw[n] #> = new(value.<#= Typ.xyzw[n] #>);
<#
                }
#>
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator <#= typeName #>(<#= typ.compType #> value) => new <#= scalarName #>(value);
<#
                if (typ.bol)
                {
#>

    [MethodImpl(256 | 512)]
    public static implicit operator <#= typeName #>(bool value) => (<#= typ.compType #>)(value);
<#
                }
#>

    [MethodImpl(256 | 512)]
    public static implicit operator <#= typeName #>(<#= scalarName #> value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator <#= typeName #>(<#= simd_typeName #> value) => new(value);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator~(<#= typeName #> a) => new(<#=
                    string.Join(", ", Enumerable.Range(0, i).Select(n => $"~a.{Typ.xyzw[n]}")) #>);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator|(<#= typeName #> a, <#= typeName #> b) => new(<#=
                    string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]} | b.{Typ.xyzw[n]}")) #>);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator&(<#= typeName #> a, <#= typeName #> b) => new(<#=
                    string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]} & b.{Typ.xyzw[n]}")) #>);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator^(<#= typeName #> a, <#= typeName #> b) => new(<#=
                    string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]} ^ b.{Typ.xyzw[n]}")) #>);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator<<(<#= typeName #> a, int b) => new(<#=
                    string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]} << b")) #>);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator>>(<#= typeName #> a, int b) => new(<#=
                    string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]} >> b")) #>);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator>>>(<#= typeName #> a, int b) => new(<#=
                    string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]} >>> b")) #>);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"out {scalarName} {Typ.xyzw[n]}")) #>)
    {
<#
                for (var n = 0; n < i; n++)
                {
#>
        <#= Typ.xyzw[n] #> = this.<#= Typ.xyzw[n] #>;
<#
                }
#>
    }

    #endregion // Deconstruct

    #region Index

    public <#= scalarName #> this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
<#
                for (var j = 0; j < i; j++)
                {
#>
            <#= j #> => <#= Typ.xyzw[j] #>,
<#
                }
#>
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
<#
                for (var j = 0; j < i; j++)
                {
#>
                case <#= j #>:
                    <#= Typ.xyzw[j] #> = value;
                    break;
<#
                }
#>
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"<#= typeName #> {{ <#=
                    string.Join(", ", Enumerable.Range(0, size).Select(l => $"t{l} = {{this.LaneGet({l})}}")) #> }}";
    
    #endregion // ToString
}

#endregion // <#= typeName #>
<#
            }
        }
    }
#>
