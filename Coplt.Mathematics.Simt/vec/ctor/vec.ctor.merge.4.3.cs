// generated by template, do not modify manually

namespace Coplt.Mathematics.Simt;

#region float4_mt4

[Ex]
public static partial class math
{
    /// <summary>
    /// Unchecked convert (reinterpret if simd) to float3_mt4, must ensure that the w component is 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float3_mt4 as3([This] float4_mt4 xyzw)
    {
        return xyzw.xyz;
    }

    /// <summary>
    /// Unchecked convert (reinterpret if simd) to float4_mt4, the w component will be 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float4_mt4 as4([This] float3_mt4 xyz) => new(xyz);
}

public partial struct float4_mt4 
{
    [MethodImpl(256 | 512)]
    internal float4_mt4(float3_mt4 xyz)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = default;
    }

    [MethodImpl(256 | 512)]
    public float4_mt4(float3_mt4 xyz, float_mt4 w)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public float4_mt4(float_mt4 x, float3_mt4 yzw)
    {
        this.x = x;
        this.y = yzw.x;
        this.z = yzw.y;
        this.w = yzw.z;
    }

    [MethodImpl(256 | 512)]
    internal float4_mt4(float3_mt4 xzw, float_mt4 y, insert_y _)
    {
        this.x = xzw.x;
        this.y = y;
        this.z = xzw.y;
        this.w = xzw.z;
    }

    [MethodImpl(256 | 512)]
    internal float4_mt4(float3_mt4 xyw, float_mt4 z, insert_z _)
    {
        this.x = xyw.x;
        this.y = xyw.y;
        this.z = z;
        this.w = xyw.z;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static float4_mt4 float4_mt4(float3_mt4 xyz, float_mt4 w) => new(xyz, w);

    [MethodImpl(256 | 512)]
    public static float4_mt4 float4_mt4(float_mt4 x, float3_mt4 yzw) => new(x, yzw);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z, w) => (X, y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float4_mt4 Ix(this float3_mt4 yzw, float_mt4 x) => new(x, yzw);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z, w) => (x, Y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float4_mt4 Iy(this float3_mt4 xzw, float_mt4 y) => new(xzw, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y, w) => (x, y, Z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float4_mt4 Iz(this float3_mt4 xyw, float_mt4 z) => new(xyw, z, new insert_z());

    /// <summary>
    /// Insert W component
    /// <code>W -> (x, y, z) => (x, y, z, W)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float4_mt4 Iw(this float3_mt4 xyz, float_mt4 w) => new(xyz, w);
}

#endregion // float4_mt4

#region float4_mt8

[Ex]
public static partial class math
{
    /// <summary>
    /// Unchecked convert (reinterpret if simd) to float3_mt8, must ensure that the w component is 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float3_mt8 as3([This] float4_mt8 xyzw)
    {
        return xyzw.xyz;
    }

    /// <summary>
    /// Unchecked convert (reinterpret if simd) to float4_mt8, the w component will be 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float4_mt8 as4([This] float3_mt8 xyz) => new(xyz);
}

public partial struct float4_mt8 
{
    [MethodImpl(256 | 512)]
    internal float4_mt8(float3_mt8 xyz)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = default;
    }

    [MethodImpl(256 | 512)]
    public float4_mt8(float3_mt8 xyz, float_mt8 w)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public float4_mt8(float_mt8 x, float3_mt8 yzw)
    {
        this.x = x;
        this.y = yzw.x;
        this.z = yzw.y;
        this.w = yzw.z;
    }

    [MethodImpl(256 | 512)]
    internal float4_mt8(float3_mt8 xzw, float_mt8 y, insert_y _)
    {
        this.x = xzw.x;
        this.y = y;
        this.z = xzw.y;
        this.w = xzw.z;
    }

    [MethodImpl(256 | 512)]
    internal float4_mt8(float3_mt8 xyw, float_mt8 z, insert_z _)
    {
        this.x = xyw.x;
        this.y = xyw.y;
        this.z = z;
        this.w = xyw.z;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static float4_mt8 float4_mt8(float3_mt8 xyz, float_mt8 w) => new(xyz, w);

    [MethodImpl(256 | 512)]
    public static float4_mt8 float4_mt8(float_mt8 x, float3_mt8 yzw) => new(x, yzw);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z, w) => (X, y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float4_mt8 Ix(this float3_mt8 yzw, float_mt8 x) => new(x, yzw);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z, w) => (x, Y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float4_mt8 Iy(this float3_mt8 xzw, float_mt8 y) => new(xzw, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y, w) => (x, y, Z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float4_mt8 Iz(this float3_mt8 xyw, float_mt8 z) => new(xyw, z, new insert_z());

    /// <summary>
    /// Insert W component
    /// <code>W -> (x, y, z) => (x, y, z, W)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float4_mt8 Iw(this float3_mt8 xyz, float_mt8 w) => new(xyz, w);
}

#endregion // float4_mt8

#region float4_mt16

[Ex]
public static partial class math
{
    /// <summary>
    /// Unchecked convert (reinterpret if simd) to float3_mt16, must ensure that the w component is 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float3_mt16 as3([This] float4_mt16 xyzw)
    {
        return xyzw.xyz;
    }

    /// <summary>
    /// Unchecked convert (reinterpret if simd) to float4_mt16, the w component will be 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float4_mt16 as4([This] float3_mt16 xyz) => new(xyz);
}

public partial struct float4_mt16 
{
    [MethodImpl(256 | 512)]
    internal float4_mt16(float3_mt16 xyz)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = default;
    }

    [MethodImpl(256 | 512)]
    public float4_mt16(float3_mt16 xyz, float_mt16 w)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public float4_mt16(float_mt16 x, float3_mt16 yzw)
    {
        this.x = x;
        this.y = yzw.x;
        this.z = yzw.y;
        this.w = yzw.z;
    }

    [MethodImpl(256 | 512)]
    internal float4_mt16(float3_mt16 xzw, float_mt16 y, insert_y _)
    {
        this.x = xzw.x;
        this.y = y;
        this.z = xzw.y;
        this.w = xzw.z;
    }

    [MethodImpl(256 | 512)]
    internal float4_mt16(float3_mt16 xyw, float_mt16 z, insert_z _)
    {
        this.x = xyw.x;
        this.y = xyw.y;
        this.z = z;
        this.w = xyw.z;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static float4_mt16 float4_mt16(float3_mt16 xyz, float_mt16 w) => new(xyz, w);

    [MethodImpl(256 | 512)]
    public static float4_mt16 float4_mt16(float_mt16 x, float3_mt16 yzw) => new(x, yzw);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z, w) => (X, y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float4_mt16 Ix(this float3_mt16 yzw, float_mt16 x) => new(x, yzw);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z, w) => (x, Y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float4_mt16 Iy(this float3_mt16 xzw, float_mt16 y) => new(xzw, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y, w) => (x, y, Z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float4_mt16 Iz(this float3_mt16 xyw, float_mt16 z) => new(xyw, z, new insert_z());

    /// <summary>
    /// Insert W component
    /// <code>W -> (x, y, z) => (x, y, z, W)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float4_mt16 Iw(this float3_mt16 xyz, float_mt16 w) => new(xyz, w);
}

#endregion // float4_mt16

#region double4_mt4

[Ex]
public static partial class math
{
    /// <summary>
    /// Unchecked convert (reinterpret if simd) to double3_mt4, must ensure that the w component is 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double3_mt4 as3([This] double4_mt4 xyzw)
    {
        return xyzw.xyz;
    }

    /// <summary>
    /// Unchecked convert (reinterpret if simd) to double4_mt4, the w component will be 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double4_mt4 as4([This] double3_mt4 xyz) => new(xyz);
}

public partial struct double4_mt4 
{
    [MethodImpl(256 | 512)]
    internal double4_mt4(double3_mt4 xyz)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = default;
    }

    [MethodImpl(256 | 512)]
    public double4_mt4(double3_mt4 xyz, double_mt4 w)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public double4_mt4(double_mt4 x, double3_mt4 yzw)
    {
        this.x = x;
        this.y = yzw.x;
        this.z = yzw.y;
        this.w = yzw.z;
    }

    [MethodImpl(256 | 512)]
    internal double4_mt4(double3_mt4 xzw, double_mt4 y, insert_y _)
    {
        this.x = xzw.x;
        this.y = y;
        this.z = xzw.y;
        this.w = xzw.z;
    }

    [MethodImpl(256 | 512)]
    internal double4_mt4(double3_mt4 xyw, double_mt4 z, insert_z _)
    {
        this.x = xyw.x;
        this.y = xyw.y;
        this.z = z;
        this.w = xyw.z;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static double4_mt4 double4_mt4(double3_mt4 xyz, double_mt4 w) => new(xyz, w);

    [MethodImpl(256 | 512)]
    public static double4_mt4 double4_mt4(double_mt4 x, double3_mt4 yzw) => new(x, yzw);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z, w) => (X, y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double4_mt4 Ix(this double3_mt4 yzw, double_mt4 x) => new(x, yzw);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z, w) => (x, Y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double4_mt4 Iy(this double3_mt4 xzw, double_mt4 y) => new(xzw, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y, w) => (x, y, Z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double4_mt4 Iz(this double3_mt4 xyw, double_mt4 z) => new(xyw, z, new insert_z());

    /// <summary>
    /// Insert W component
    /// <code>W -> (x, y, z) => (x, y, z, W)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double4_mt4 Iw(this double3_mt4 xyz, double_mt4 w) => new(xyz, w);
}

#endregion // double4_mt4

#region double4_mt8

[Ex]
public static partial class math
{
    /// <summary>
    /// Unchecked convert (reinterpret if simd) to double3_mt8, must ensure that the w component is 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double3_mt8 as3([This] double4_mt8 xyzw)
    {
        return xyzw.xyz;
    }

    /// <summary>
    /// Unchecked convert (reinterpret if simd) to double4_mt8, the w component will be 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double4_mt8 as4([This] double3_mt8 xyz) => new(xyz);
}

public partial struct double4_mt8 
{
    [MethodImpl(256 | 512)]
    internal double4_mt8(double3_mt8 xyz)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = default;
    }

    [MethodImpl(256 | 512)]
    public double4_mt8(double3_mt8 xyz, double_mt8 w)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public double4_mt8(double_mt8 x, double3_mt8 yzw)
    {
        this.x = x;
        this.y = yzw.x;
        this.z = yzw.y;
        this.w = yzw.z;
    }

    [MethodImpl(256 | 512)]
    internal double4_mt8(double3_mt8 xzw, double_mt8 y, insert_y _)
    {
        this.x = xzw.x;
        this.y = y;
        this.z = xzw.y;
        this.w = xzw.z;
    }

    [MethodImpl(256 | 512)]
    internal double4_mt8(double3_mt8 xyw, double_mt8 z, insert_z _)
    {
        this.x = xyw.x;
        this.y = xyw.y;
        this.z = z;
        this.w = xyw.z;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static double4_mt8 double4_mt8(double3_mt8 xyz, double_mt8 w) => new(xyz, w);

    [MethodImpl(256 | 512)]
    public static double4_mt8 double4_mt8(double_mt8 x, double3_mt8 yzw) => new(x, yzw);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z, w) => (X, y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double4_mt8 Ix(this double3_mt8 yzw, double_mt8 x) => new(x, yzw);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z, w) => (x, Y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double4_mt8 Iy(this double3_mt8 xzw, double_mt8 y) => new(xzw, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y, w) => (x, y, Z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double4_mt8 Iz(this double3_mt8 xyw, double_mt8 z) => new(xyw, z, new insert_z());

    /// <summary>
    /// Insert W component
    /// <code>W -> (x, y, z) => (x, y, z, W)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double4_mt8 Iw(this double3_mt8 xyz, double_mt8 w) => new(xyz, w);
}

#endregion // double4_mt8

#region double4_mt16

[Ex]
public static partial class math
{
    /// <summary>
    /// Unchecked convert (reinterpret if simd) to double3_mt16, must ensure that the w component is 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double3_mt16 as3([This] double4_mt16 xyzw)
    {
        return xyzw.xyz;
    }

    /// <summary>
    /// Unchecked convert (reinterpret if simd) to double4_mt16, the w component will be 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double4_mt16 as4([This] double3_mt16 xyz) => new(xyz);
}

public partial struct double4_mt16 
{
    [MethodImpl(256 | 512)]
    internal double4_mt16(double3_mt16 xyz)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = default;
    }

    [MethodImpl(256 | 512)]
    public double4_mt16(double3_mt16 xyz, double_mt16 w)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public double4_mt16(double_mt16 x, double3_mt16 yzw)
    {
        this.x = x;
        this.y = yzw.x;
        this.z = yzw.y;
        this.w = yzw.z;
    }

    [MethodImpl(256 | 512)]
    internal double4_mt16(double3_mt16 xzw, double_mt16 y, insert_y _)
    {
        this.x = xzw.x;
        this.y = y;
        this.z = xzw.y;
        this.w = xzw.z;
    }

    [MethodImpl(256 | 512)]
    internal double4_mt16(double3_mt16 xyw, double_mt16 z, insert_z _)
    {
        this.x = xyw.x;
        this.y = xyw.y;
        this.z = z;
        this.w = xyw.z;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static double4_mt16 double4_mt16(double3_mt16 xyz, double_mt16 w) => new(xyz, w);

    [MethodImpl(256 | 512)]
    public static double4_mt16 double4_mt16(double_mt16 x, double3_mt16 yzw) => new(x, yzw);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z, w) => (X, y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double4_mt16 Ix(this double3_mt16 yzw, double_mt16 x) => new(x, yzw);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z, w) => (x, Y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double4_mt16 Iy(this double3_mt16 xzw, double_mt16 y) => new(xzw, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y, w) => (x, y, Z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double4_mt16 Iz(this double3_mt16 xyw, double_mt16 z) => new(xyw, z, new insert_z());

    /// <summary>
    /// Insert W component
    /// <code>W -> (x, y, z) => (x, y, z, W)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double4_mt16 Iw(this double3_mt16 xyz, double_mt16 w) => new(xyz, w);
}

#endregion // double4_mt16

#region int4_mt4

[Ex]
public static partial class math
{
    /// <summary>
    /// Unchecked convert (reinterpret if simd) to int3_mt4, must ensure that the w component is 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int3_mt4 as3([This] int4_mt4 xyzw)
    {
        return xyzw.xyz;
    }

    /// <summary>
    /// Unchecked convert (reinterpret if simd) to int4_mt4, the w component will be 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int4_mt4 as4([This] int3_mt4 xyz) => new(xyz);
}

public partial struct int4_mt4 
{
    [MethodImpl(256 | 512)]
    internal int4_mt4(int3_mt4 xyz)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = default;
    }

    [MethodImpl(256 | 512)]
    public int4_mt4(int3_mt4 xyz, int_mt4 w)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public int4_mt4(int_mt4 x, int3_mt4 yzw)
    {
        this.x = x;
        this.y = yzw.x;
        this.z = yzw.y;
        this.w = yzw.z;
    }

    [MethodImpl(256 | 512)]
    internal int4_mt4(int3_mt4 xzw, int_mt4 y, insert_y _)
    {
        this.x = xzw.x;
        this.y = y;
        this.z = xzw.y;
        this.w = xzw.z;
    }

    [MethodImpl(256 | 512)]
    internal int4_mt4(int3_mt4 xyw, int_mt4 z, insert_z _)
    {
        this.x = xyw.x;
        this.y = xyw.y;
        this.z = z;
        this.w = xyw.z;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static int4_mt4 int4_mt4(int3_mt4 xyz, int_mt4 w) => new(xyz, w);

    [MethodImpl(256 | 512)]
    public static int4_mt4 int4_mt4(int_mt4 x, int3_mt4 yzw) => new(x, yzw);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z, w) => (X, y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int4_mt4 Ix(this int3_mt4 yzw, int_mt4 x) => new(x, yzw);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z, w) => (x, Y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int4_mt4 Iy(this int3_mt4 xzw, int_mt4 y) => new(xzw, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y, w) => (x, y, Z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int4_mt4 Iz(this int3_mt4 xyw, int_mt4 z) => new(xyw, z, new insert_z());

    /// <summary>
    /// Insert W component
    /// <code>W -> (x, y, z) => (x, y, z, W)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int4_mt4 Iw(this int3_mt4 xyz, int_mt4 w) => new(xyz, w);
}

#endregion // int4_mt4

#region int4_mt8

[Ex]
public static partial class math
{
    /// <summary>
    /// Unchecked convert (reinterpret if simd) to int3_mt8, must ensure that the w component is 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int3_mt8 as3([This] int4_mt8 xyzw)
    {
        return xyzw.xyz;
    }

    /// <summary>
    /// Unchecked convert (reinterpret if simd) to int4_mt8, the w component will be 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int4_mt8 as4([This] int3_mt8 xyz) => new(xyz);
}

public partial struct int4_mt8 
{
    [MethodImpl(256 | 512)]
    internal int4_mt8(int3_mt8 xyz)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = default;
    }

    [MethodImpl(256 | 512)]
    public int4_mt8(int3_mt8 xyz, int_mt8 w)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public int4_mt8(int_mt8 x, int3_mt8 yzw)
    {
        this.x = x;
        this.y = yzw.x;
        this.z = yzw.y;
        this.w = yzw.z;
    }

    [MethodImpl(256 | 512)]
    internal int4_mt8(int3_mt8 xzw, int_mt8 y, insert_y _)
    {
        this.x = xzw.x;
        this.y = y;
        this.z = xzw.y;
        this.w = xzw.z;
    }

    [MethodImpl(256 | 512)]
    internal int4_mt8(int3_mt8 xyw, int_mt8 z, insert_z _)
    {
        this.x = xyw.x;
        this.y = xyw.y;
        this.z = z;
        this.w = xyw.z;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static int4_mt8 int4_mt8(int3_mt8 xyz, int_mt8 w) => new(xyz, w);

    [MethodImpl(256 | 512)]
    public static int4_mt8 int4_mt8(int_mt8 x, int3_mt8 yzw) => new(x, yzw);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z, w) => (X, y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int4_mt8 Ix(this int3_mt8 yzw, int_mt8 x) => new(x, yzw);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z, w) => (x, Y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int4_mt8 Iy(this int3_mt8 xzw, int_mt8 y) => new(xzw, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y, w) => (x, y, Z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int4_mt8 Iz(this int3_mt8 xyw, int_mt8 z) => new(xyw, z, new insert_z());

    /// <summary>
    /// Insert W component
    /// <code>W -> (x, y, z) => (x, y, z, W)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int4_mt8 Iw(this int3_mt8 xyz, int_mt8 w) => new(xyz, w);
}

#endregion // int4_mt8

#region int4_mt16

[Ex]
public static partial class math
{
    /// <summary>
    /// Unchecked convert (reinterpret if simd) to int3_mt16, must ensure that the w component is 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int3_mt16 as3([This] int4_mt16 xyzw)
    {
        return xyzw.xyz;
    }

    /// <summary>
    /// Unchecked convert (reinterpret if simd) to int4_mt16, the w component will be 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int4_mt16 as4([This] int3_mt16 xyz) => new(xyz);
}

public partial struct int4_mt16 
{
    [MethodImpl(256 | 512)]
    internal int4_mt16(int3_mt16 xyz)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = default;
    }

    [MethodImpl(256 | 512)]
    public int4_mt16(int3_mt16 xyz, int_mt16 w)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public int4_mt16(int_mt16 x, int3_mt16 yzw)
    {
        this.x = x;
        this.y = yzw.x;
        this.z = yzw.y;
        this.w = yzw.z;
    }

    [MethodImpl(256 | 512)]
    internal int4_mt16(int3_mt16 xzw, int_mt16 y, insert_y _)
    {
        this.x = xzw.x;
        this.y = y;
        this.z = xzw.y;
        this.w = xzw.z;
    }

    [MethodImpl(256 | 512)]
    internal int4_mt16(int3_mt16 xyw, int_mt16 z, insert_z _)
    {
        this.x = xyw.x;
        this.y = xyw.y;
        this.z = z;
        this.w = xyw.z;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static int4_mt16 int4_mt16(int3_mt16 xyz, int_mt16 w) => new(xyz, w);

    [MethodImpl(256 | 512)]
    public static int4_mt16 int4_mt16(int_mt16 x, int3_mt16 yzw) => new(x, yzw);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z, w) => (X, y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int4_mt16 Ix(this int3_mt16 yzw, int_mt16 x) => new(x, yzw);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z, w) => (x, Y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int4_mt16 Iy(this int3_mt16 xzw, int_mt16 y) => new(xzw, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y, w) => (x, y, Z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int4_mt16 Iz(this int3_mt16 xyw, int_mt16 z) => new(xyw, z, new insert_z());

    /// <summary>
    /// Insert W component
    /// <code>W -> (x, y, z) => (x, y, z, W)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int4_mt16 Iw(this int3_mt16 xyz, int_mt16 w) => new(xyz, w);
}

#endregion // int4_mt16

#region uint4_mt4

[Ex]
public static partial class math
{
    /// <summary>
    /// Unchecked convert (reinterpret if simd) to uint3_mt4, must ensure that the w component is 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint3_mt4 as3([This] uint4_mt4 xyzw)
    {
        return xyzw.xyz;
    }

    /// <summary>
    /// Unchecked convert (reinterpret if simd) to uint4_mt4, the w component will be 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint4_mt4 as4([This] uint3_mt4 xyz) => new(xyz);
}

public partial struct uint4_mt4 
{
    [MethodImpl(256 | 512)]
    internal uint4_mt4(uint3_mt4 xyz)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = default;
    }

    [MethodImpl(256 | 512)]
    public uint4_mt4(uint3_mt4 xyz, uint_mt4 w)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public uint4_mt4(uint_mt4 x, uint3_mt4 yzw)
    {
        this.x = x;
        this.y = yzw.x;
        this.z = yzw.y;
        this.w = yzw.z;
    }

    [MethodImpl(256 | 512)]
    internal uint4_mt4(uint3_mt4 xzw, uint_mt4 y, insert_y _)
    {
        this.x = xzw.x;
        this.y = y;
        this.z = xzw.y;
        this.w = xzw.z;
    }

    [MethodImpl(256 | 512)]
    internal uint4_mt4(uint3_mt4 xyw, uint_mt4 z, insert_z _)
    {
        this.x = xyw.x;
        this.y = xyw.y;
        this.z = z;
        this.w = xyw.z;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static uint4_mt4 uint4_mt4(uint3_mt4 xyz, uint_mt4 w) => new(xyz, w);

    [MethodImpl(256 | 512)]
    public static uint4_mt4 uint4_mt4(uint_mt4 x, uint3_mt4 yzw) => new(x, yzw);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z, w) => (X, y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint4_mt4 Ix(this uint3_mt4 yzw, uint_mt4 x) => new(x, yzw);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z, w) => (x, Y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint4_mt4 Iy(this uint3_mt4 xzw, uint_mt4 y) => new(xzw, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y, w) => (x, y, Z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint4_mt4 Iz(this uint3_mt4 xyw, uint_mt4 z) => new(xyw, z, new insert_z());

    /// <summary>
    /// Insert W component
    /// <code>W -> (x, y, z) => (x, y, z, W)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint4_mt4 Iw(this uint3_mt4 xyz, uint_mt4 w) => new(xyz, w);
}

#endregion // uint4_mt4

#region uint4_mt8

[Ex]
public static partial class math
{
    /// <summary>
    /// Unchecked convert (reinterpret if simd) to uint3_mt8, must ensure that the w component is 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint3_mt8 as3([This] uint4_mt8 xyzw)
    {
        return xyzw.xyz;
    }

    /// <summary>
    /// Unchecked convert (reinterpret if simd) to uint4_mt8, the w component will be 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint4_mt8 as4([This] uint3_mt8 xyz) => new(xyz);
}

public partial struct uint4_mt8 
{
    [MethodImpl(256 | 512)]
    internal uint4_mt8(uint3_mt8 xyz)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = default;
    }

    [MethodImpl(256 | 512)]
    public uint4_mt8(uint3_mt8 xyz, uint_mt8 w)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public uint4_mt8(uint_mt8 x, uint3_mt8 yzw)
    {
        this.x = x;
        this.y = yzw.x;
        this.z = yzw.y;
        this.w = yzw.z;
    }

    [MethodImpl(256 | 512)]
    internal uint4_mt8(uint3_mt8 xzw, uint_mt8 y, insert_y _)
    {
        this.x = xzw.x;
        this.y = y;
        this.z = xzw.y;
        this.w = xzw.z;
    }

    [MethodImpl(256 | 512)]
    internal uint4_mt8(uint3_mt8 xyw, uint_mt8 z, insert_z _)
    {
        this.x = xyw.x;
        this.y = xyw.y;
        this.z = z;
        this.w = xyw.z;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static uint4_mt8 uint4_mt8(uint3_mt8 xyz, uint_mt8 w) => new(xyz, w);

    [MethodImpl(256 | 512)]
    public static uint4_mt8 uint4_mt8(uint_mt8 x, uint3_mt8 yzw) => new(x, yzw);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z, w) => (X, y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint4_mt8 Ix(this uint3_mt8 yzw, uint_mt8 x) => new(x, yzw);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z, w) => (x, Y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint4_mt8 Iy(this uint3_mt8 xzw, uint_mt8 y) => new(xzw, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y, w) => (x, y, Z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint4_mt8 Iz(this uint3_mt8 xyw, uint_mt8 z) => new(xyw, z, new insert_z());

    /// <summary>
    /// Insert W component
    /// <code>W -> (x, y, z) => (x, y, z, W)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint4_mt8 Iw(this uint3_mt8 xyz, uint_mt8 w) => new(xyz, w);
}

#endregion // uint4_mt8

#region uint4_mt16

[Ex]
public static partial class math
{
    /// <summary>
    /// Unchecked convert (reinterpret if simd) to uint3_mt16, must ensure that the w component is 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint3_mt16 as3([This] uint4_mt16 xyzw)
    {
        return xyzw.xyz;
    }

    /// <summary>
    /// Unchecked convert (reinterpret if simd) to uint4_mt16, the w component will be 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint4_mt16 as4([This] uint3_mt16 xyz) => new(xyz);
}

public partial struct uint4_mt16 
{
    [MethodImpl(256 | 512)]
    internal uint4_mt16(uint3_mt16 xyz)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = default;
    }

    [MethodImpl(256 | 512)]
    public uint4_mt16(uint3_mt16 xyz, uint_mt16 w)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public uint4_mt16(uint_mt16 x, uint3_mt16 yzw)
    {
        this.x = x;
        this.y = yzw.x;
        this.z = yzw.y;
        this.w = yzw.z;
    }

    [MethodImpl(256 | 512)]
    internal uint4_mt16(uint3_mt16 xzw, uint_mt16 y, insert_y _)
    {
        this.x = xzw.x;
        this.y = y;
        this.z = xzw.y;
        this.w = xzw.z;
    }

    [MethodImpl(256 | 512)]
    internal uint4_mt16(uint3_mt16 xyw, uint_mt16 z, insert_z _)
    {
        this.x = xyw.x;
        this.y = xyw.y;
        this.z = z;
        this.w = xyw.z;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static uint4_mt16 uint4_mt16(uint3_mt16 xyz, uint_mt16 w) => new(xyz, w);

    [MethodImpl(256 | 512)]
    public static uint4_mt16 uint4_mt16(uint_mt16 x, uint3_mt16 yzw) => new(x, yzw);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z, w) => (X, y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint4_mt16 Ix(this uint3_mt16 yzw, uint_mt16 x) => new(x, yzw);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z, w) => (x, Y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint4_mt16 Iy(this uint3_mt16 xzw, uint_mt16 y) => new(xzw, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y, w) => (x, y, Z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint4_mt16 Iz(this uint3_mt16 xyw, uint_mt16 z) => new(xyw, z, new insert_z());

    /// <summary>
    /// Insert W component
    /// <code>W -> (x, y, z) => (x, y, z, W)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint4_mt16 Iw(this uint3_mt16 xyz, uint_mt16 w) => new(xyz, w);
}

#endregion // uint4_mt16

#region long4_mt4

[Ex]
public static partial class math
{
    /// <summary>
    /// Unchecked convert (reinterpret if simd) to long3_mt4, must ensure that the w component is 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long3_mt4 as3([This] long4_mt4 xyzw)
    {
        return xyzw.xyz;
    }

    /// <summary>
    /// Unchecked convert (reinterpret if simd) to long4_mt4, the w component will be 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long4_mt4 as4([This] long3_mt4 xyz) => new(xyz);
}

public partial struct long4_mt4 
{
    [MethodImpl(256 | 512)]
    internal long4_mt4(long3_mt4 xyz)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = default;
    }

    [MethodImpl(256 | 512)]
    public long4_mt4(long3_mt4 xyz, long_mt4 w)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public long4_mt4(long_mt4 x, long3_mt4 yzw)
    {
        this.x = x;
        this.y = yzw.x;
        this.z = yzw.y;
        this.w = yzw.z;
    }

    [MethodImpl(256 | 512)]
    internal long4_mt4(long3_mt4 xzw, long_mt4 y, insert_y _)
    {
        this.x = xzw.x;
        this.y = y;
        this.z = xzw.y;
        this.w = xzw.z;
    }

    [MethodImpl(256 | 512)]
    internal long4_mt4(long3_mt4 xyw, long_mt4 z, insert_z _)
    {
        this.x = xyw.x;
        this.y = xyw.y;
        this.z = z;
        this.w = xyw.z;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static long4_mt4 long4_mt4(long3_mt4 xyz, long_mt4 w) => new(xyz, w);

    [MethodImpl(256 | 512)]
    public static long4_mt4 long4_mt4(long_mt4 x, long3_mt4 yzw) => new(x, yzw);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z, w) => (X, y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long4_mt4 Ix(this long3_mt4 yzw, long_mt4 x) => new(x, yzw);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z, w) => (x, Y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long4_mt4 Iy(this long3_mt4 xzw, long_mt4 y) => new(xzw, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y, w) => (x, y, Z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long4_mt4 Iz(this long3_mt4 xyw, long_mt4 z) => new(xyw, z, new insert_z());

    /// <summary>
    /// Insert W component
    /// <code>W -> (x, y, z) => (x, y, z, W)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long4_mt4 Iw(this long3_mt4 xyz, long_mt4 w) => new(xyz, w);
}

#endregion // long4_mt4

#region long4_mt8

[Ex]
public static partial class math
{
    /// <summary>
    /// Unchecked convert (reinterpret if simd) to long3_mt8, must ensure that the w component is 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long3_mt8 as3([This] long4_mt8 xyzw)
    {
        return xyzw.xyz;
    }

    /// <summary>
    /// Unchecked convert (reinterpret if simd) to long4_mt8, the w component will be 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long4_mt8 as4([This] long3_mt8 xyz) => new(xyz);
}

public partial struct long4_mt8 
{
    [MethodImpl(256 | 512)]
    internal long4_mt8(long3_mt8 xyz)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = default;
    }

    [MethodImpl(256 | 512)]
    public long4_mt8(long3_mt8 xyz, long_mt8 w)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public long4_mt8(long_mt8 x, long3_mt8 yzw)
    {
        this.x = x;
        this.y = yzw.x;
        this.z = yzw.y;
        this.w = yzw.z;
    }

    [MethodImpl(256 | 512)]
    internal long4_mt8(long3_mt8 xzw, long_mt8 y, insert_y _)
    {
        this.x = xzw.x;
        this.y = y;
        this.z = xzw.y;
        this.w = xzw.z;
    }

    [MethodImpl(256 | 512)]
    internal long4_mt8(long3_mt8 xyw, long_mt8 z, insert_z _)
    {
        this.x = xyw.x;
        this.y = xyw.y;
        this.z = z;
        this.w = xyw.z;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static long4_mt8 long4_mt8(long3_mt8 xyz, long_mt8 w) => new(xyz, w);

    [MethodImpl(256 | 512)]
    public static long4_mt8 long4_mt8(long_mt8 x, long3_mt8 yzw) => new(x, yzw);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z, w) => (X, y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long4_mt8 Ix(this long3_mt8 yzw, long_mt8 x) => new(x, yzw);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z, w) => (x, Y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long4_mt8 Iy(this long3_mt8 xzw, long_mt8 y) => new(xzw, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y, w) => (x, y, Z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long4_mt8 Iz(this long3_mt8 xyw, long_mt8 z) => new(xyw, z, new insert_z());

    /// <summary>
    /// Insert W component
    /// <code>W -> (x, y, z) => (x, y, z, W)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long4_mt8 Iw(this long3_mt8 xyz, long_mt8 w) => new(xyz, w);
}

#endregion // long4_mt8

#region long4_mt16

[Ex]
public static partial class math
{
    /// <summary>
    /// Unchecked convert (reinterpret if simd) to long3_mt16, must ensure that the w component is 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long3_mt16 as3([This] long4_mt16 xyzw)
    {
        return xyzw.xyz;
    }

    /// <summary>
    /// Unchecked convert (reinterpret if simd) to long4_mt16, the w component will be 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long4_mt16 as4([This] long3_mt16 xyz) => new(xyz);
}

public partial struct long4_mt16 
{
    [MethodImpl(256 | 512)]
    internal long4_mt16(long3_mt16 xyz)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = default;
    }

    [MethodImpl(256 | 512)]
    public long4_mt16(long3_mt16 xyz, long_mt16 w)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public long4_mt16(long_mt16 x, long3_mt16 yzw)
    {
        this.x = x;
        this.y = yzw.x;
        this.z = yzw.y;
        this.w = yzw.z;
    }

    [MethodImpl(256 | 512)]
    internal long4_mt16(long3_mt16 xzw, long_mt16 y, insert_y _)
    {
        this.x = xzw.x;
        this.y = y;
        this.z = xzw.y;
        this.w = xzw.z;
    }

    [MethodImpl(256 | 512)]
    internal long4_mt16(long3_mt16 xyw, long_mt16 z, insert_z _)
    {
        this.x = xyw.x;
        this.y = xyw.y;
        this.z = z;
        this.w = xyw.z;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static long4_mt16 long4_mt16(long3_mt16 xyz, long_mt16 w) => new(xyz, w);

    [MethodImpl(256 | 512)]
    public static long4_mt16 long4_mt16(long_mt16 x, long3_mt16 yzw) => new(x, yzw);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z, w) => (X, y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long4_mt16 Ix(this long3_mt16 yzw, long_mt16 x) => new(x, yzw);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z, w) => (x, Y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long4_mt16 Iy(this long3_mt16 xzw, long_mt16 y) => new(xzw, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y, w) => (x, y, Z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long4_mt16 Iz(this long3_mt16 xyw, long_mt16 z) => new(xyw, z, new insert_z());

    /// <summary>
    /// Insert W component
    /// <code>W -> (x, y, z) => (x, y, z, W)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long4_mt16 Iw(this long3_mt16 xyz, long_mt16 w) => new(xyz, w);
}

#endregion // long4_mt16

#region ulong4_mt4

[Ex]
public static partial class math
{
    /// <summary>
    /// Unchecked convert (reinterpret if simd) to ulong3_mt4, must ensure that the w component is 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong3_mt4 as3([This] ulong4_mt4 xyzw)
    {
        return xyzw.xyz;
    }

    /// <summary>
    /// Unchecked convert (reinterpret if simd) to ulong4_mt4, the w component will be 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong4_mt4 as4([This] ulong3_mt4 xyz) => new(xyz);
}

public partial struct ulong4_mt4 
{
    [MethodImpl(256 | 512)]
    internal ulong4_mt4(ulong3_mt4 xyz)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = default;
    }

    [MethodImpl(256 | 512)]
    public ulong4_mt4(ulong3_mt4 xyz, ulong_mt4 w)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public ulong4_mt4(ulong_mt4 x, ulong3_mt4 yzw)
    {
        this.x = x;
        this.y = yzw.x;
        this.z = yzw.y;
        this.w = yzw.z;
    }

    [MethodImpl(256 | 512)]
    internal ulong4_mt4(ulong3_mt4 xzw, ulong_mt4 y, insert_y _)
    {
        this.x = xzw.x;
        this.y = y;
        this.z = xzw.y;
        this.w = xzw.z;
    }

    [MethodImpl(256 | 512)]
    internal ulong4_mt4(ulong3_mt4 xyw, ulong_mt4 z, insert_z _)
    {
        this.x = xyw.x;
        this.y = xyw.y;
        this.z = z;
        this.w = xyw.z;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static ulong4_mt4 ulong4_mt4(ulong3_mt4 xyz, ulong_mt4 w) => new(xyz, w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt4 ulong4_mt4(ulong_mt4 x, ulong3_mt4 yzw) => new(x, yzw);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z, w) => (X, y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong4_mt4 Ix(this ulong3_mt4 yzw, ulong_mt4 x) => new(x, yzw);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z, w) => (x, Y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong4_mt4 Iy(this ulong3_mt4 xzw, ulong_mt4 y) => new(xzw, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y, w) => (x, y, Z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong4_mt4 Iz(this ulong3_mt4 xyw, ulong_mt4 z) => new(xyw, z, new insert_z());

    /// <summary>
    /// Insert W component
    /// <code>W -> (x, y, z) => (x, y, z, W)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong4_mt4 Iw(this ulong3_mt4 xyz, ulong_mt4 w) => new(xyz, w);
}

#endregion // ulong4_mt4

#region ulong4_mt8

[Ex]
public static partial class math
{
    /// <summary>
    /// Unchecked convert (reinterpret if simd) to ulong3_mt8, must ensure that the w component is 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong3_mt8 as3([This] ulong4_mt8 xyzw)
    {
        return xyzw.xyz;
    }

    /// <summary>
    /// Unchecked convert (reinterpret if simd) to ulong4_mt8, the w component will be 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong4_mt8 as4([This] ulong3_mt8 xyz) => new(xyz);
}

public partial struct ulong4_mt8 
{
    [MethodImpl(256 | 512)]
    internal ulong4_mt8(ulong3_mt8 xyz)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = default;
    }

    [MethodImpl(256 | 512)]
    public ulong4_mt8(ulong3_mt8 xyz, ulong_mt8 w)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public ulong4_mt8(ulong_mt8 x, ulong3_mt8 yzw)
    {
        this.x = x;
        this.y = yzw.x;
        this.z = yzw.y;
        this.w = yzw.z;
    }

    [MethodImpl(256 | 512)]
    internal ulong4_mt8(ulong3_mt8 xzw, ulong_mt8 y, insert_y _)
    {
        this.x = xzw.x;
        this.y = y;
        this.z = xzw.y;
        this.w = xzw.z;
    }

    [MethodImpl(256 | 512)]
    internal ulong4_mt8(ulong3_mt8 xyw, ulong_mt8 z, insert_z _)
    {
        this.x = xyw.x;
        this.y = xyw.y;
        this.z = z;
        this.w = xyw.z;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static ulong4_mt8 ulong4_mt8(ulong3_mt8 xyz, ulong_mt8 w) => new(xyz, w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt8 ulong4_mt8(ulong_mt8 x, ulong3_mt8 yzw) => new(x, yzw);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z, w) => (X, y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong4_mt8 Ix(this ulong3_mt8 yzw, ulong_mt8 x) => new(x, yzw);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z, w) => (x, Y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong4_mt8 Iy(this ulong3_mt8 xzw, ulong_mt8 y) => new(xzw, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y, w) => (x, y, Z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong4_mt8 Iz(this ulong3_mt8 xyw, ulong_mt8 z) => new(xyw, z, new insert_z());

    /// <summary>
    /// Insert W component
    /// <code>W -> (x, y, z) => (x, y, z, W)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong4_mt8 Iw(this ulong3_mt8 xyz, ulong_mt8 w) => new(xyz, w);
}

#endregion // ulong4_mt8

#region ulong4_mt16

[Ex]
public static partial class math
{
    /// <summary>
    /// Unchecked convert (reinterpret if simd) to ulong3_mt16, must ensure that the w component is 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong3_mt16 as3([This] ulong4_mt16 xyzw)
    {
        return xyzw.xyz;
    }

    /// <summary>
    /// Unchecked convert (reinterpret if simd) to ulong4_mt16, the w component will be 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong4_mt16 as4([This] ulong3_mt16 xyz) => new(xyz);
}

public partial struct ulong4_mt16 
{
    [MethodImpl(256 | 512)]
    internal ulong4_mt16(ulong3_mt16 xyz)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = default;
    }

    [MethodImpl(256 | 512)]
    public ulong4_mt16(ulong3_mt16 xyz, ulong_mt16 w)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public ulong4_mt16(ulong_mt16 x, ulong3_mt16 yzw)
    {
        this.x = x;
        this.y = yzw.x;
        this.z = yzw.y;
        this.w = yzw.z;
    }

    [MethodImpl(256 | 512)]
    internal ulong4_mt16(ulong3_mt16 xzw, ulong_mt16 y, insert_y _)
    {
        this.x = xzw.x;
        this.y = y;
        this.z = xzw.y;
        this.w = xzw.z;
    }

    [MethodImpl(256 | 512)]
    internal ulong4_mt16(ulong3_mt16 xyw, ulong_mt16 z, insert_z _)
    {
        this.x = xyw.x;
        this.y = xyw.y;
        this.z = z;
        this.w = xyw.z;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static ulong4_mt16 ulong4_mt16(ulong3_mt16 xyz, ulong_mt16 w) => new(xyz, w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt16 ulong4_mt16(ulong_mt16 x, ulong3_mt16 yzw) => new(x, yzw);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z, w) => (X, y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong4_mt16 Ix(this ulong3_mt16 yzw, ulong_mt16 x) => new(x, yzw);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z, w) => (x, Y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong4_mt16 Iy(this ulong3_mt16 xzw, ulong_mt16 y) => new(xzw, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y, w) => (x, y, Z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong4_mt16 Iz(this ulong3_mt16 xyw, ulong_mt16 z) => new(xyw, z, new insert_z());

    /// <summary>
    /// Insert W component
    /// <code>W -> (x, y, z) => (x, y, z, W)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong4_mt16 Iw(this ulong3_mt16 xyz, ulong_mt16 w) => new(xyz, w);
}

#endregion // ulong4_mt16

#region b32v4_mt4

[Ex]
public static partial class math
{
    /// <summary>
    /// Unchecked convert (reinterpret if simd) to b32v3_mt4, must ensure that the w component is 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v3_mt4 as3([This] b32v4_mt4 xyzw)
    {
        return xyzw.xyz;
    }

    /// <summary>
    /// Unchecked convert (reinterpret if simd) to b32v4_mt4, the w component will be 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v4_mt4 as4([This] b32v3_mt4 xyz) => new(xyz);
}

public partial struct b32v4_mt4 
{
    [MethodImpl(256 | 512)]
    internal b32v4_mt4(b32v3_mt4 xyz)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = default;
    }

    [MethodImpl(256 | 512)]
    public b32v4_mt4(b32v3_mt4 xyz, b32_mt4 w)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public b32v4_mt4(b32_mt4 x, b32v3_mt4 yzw)
    {
        this.x = x;
        this.y = yzw.x;
        this.z = yzw.y;
        this.w = yzw.z;
    }

    [MethodImpl(256 | 512)]
    internal b32v4_mt4(b32v3_mt4 xzw, b32_mt4 y, insert_y _)
    {
        this.x = xzw.x;
        this.y = y;
        this.z = xzw.y;
        this.w = xzw.z;
    }

    [MethodImpl(256 | 512)]
    internal b32v4_mt4(b32v3_mt4 xyw, b32_mt4 z, insert_z _)
    {
        this.x = xyw.x;
        this.y = xyw.y;
        this.z = z;
        this.w = xyw.z;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static b32v4_mt4 b32v4_mt4(b32v3_mt4 xyz, b32_mt4 w) => new(xyz, w);

    [MethodImpl(256 | 512)]
    public static b32v4_mt4 b32v4_mt4(b32_mt4 x, b32v3_mt4 yzw) => new(x, yzw);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z, w) => (X, y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v4_mt4 Ix(this b32v3_mt4 yzw, b32_mt4 x) => new(x, yzw);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z, w) => (x, Y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v4_mt4 Iy(this b32v3_mt4 xzw, b32_mt4 y) => new(xzw, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y, w) => (x, y, Z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v4_mt4 Iz(this b32v3_mt4 xyw, b32_mt4 z) => new(xyw, z, new insert_z());

    /// <summary>
    /// Insert W component
    /// <code>W -> (x, y, z) => (x, y, z, W)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v4_mt4 Iw(this b32v3_mt4 xyz, b32_mt4 w) => new(xyz, w);
}

#endregion // b32v4_mt4

#region b32v4_mt8

[Ex]
public static partial class math
{
    /// <summary>
    /// Unchecked convert (reinterpret if simd) to b32v3_mt8, must ensure that the w component is 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v3_mt8 as3([This] b32v4_mt8 xyzw)
    {
        return xyzw.xyz;
    }

    /// <summary>
    /// Unchecked convert (reinterpret if simd) to b32v4_mt8, the w component will be 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v4_mt8 as4([This] b32v3_mt8 xyz) => new(xyz);
}

public partial struct b32v4_mt8 
{
    [MethodImpl(256 | 512)]
    internal b32v4_mt8(b32v3_mt8 xyz)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = default;
    }

    [MethodImpl(256 | 512)]
    public b32v4_mt8(b32v3_mt8 xyz, b32_mt8 w)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public b32v4_mt8(b32_mt8 x, b32v3_mt8 yzw)
    {
        this.x = x;
        this.y = yzw.x;
        this.z = yzw.y;
        this.w = yzw.z;
    }

    [MethodImpl(256 | 512)]
    internal b32v4_mt8(b32v3_mt8 xzw, b32_mt8 y, insert_y _)
    {
        this.x = xzw.x;
        this.y = y;
        this.z = xzw.y;
        this.w = xzw.z;
    }

    [MethodImpl(256 | 512)]
    internal b32v4_mt8(b32v3_mt8 xyw, b32_mt8 z, insert_z _)
    {
        this.x = xyw.x;
        this.y = xyw.y;
        this.z = z;
        this.w = xyw.z;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static b32v4_mt8 b32v4_mt8(b32v3_mt8 xyz, b32_mt8 w) => new(xyz, w);

    [MethodImpl(256 | 512)]
    public static b32v4_mt8 b32v4_mt8(b32_mt8 x, b32v3_mt8 yzw) => new(x, yzw);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z, w) => (X, y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v4_mt8 Ix(this b32v3_mt8 yzw, b32_mt8 x) => new(x, yzw);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z, w) => (x, Y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v4_mt8 Iy(this b32v3_mt8 xzw, b32_mt8 y) => new(xzw, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y, w) => (x, y, Z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v4_mt8 Iz(this b32v3_mt8 xyw, b32_mt8 z) => new(xyw, z, new insert_z());

    /// <summary>
    /// Insert W component
    /// <code>W -> (x, y, z) => (x, y, z, W)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v4_mt8 Iw(this b32v3_mt8 xyz, b32_mt8 w) => new(xyz, w);
}

#endregion // b32v4_mt8

#region b32v4_mt16

[Ex]
public static partial class math
{
    /// <summary>
    /// Unchecked convert (reinterpret if simd) to b32v3_mt16, must ensure that the w component is 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v3_mt16 as3([This] b32v4_mt16 xyzw)
    {
        return xyzw.xyz;
    }

    /// <summary>
    /// Unchecked convert (reinterpret if simd) to b32v4_mt16, the w component will be 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v4_mt16 as4([This] b32v3_mt16 xyz) => new(xyz);
}

public partial struct b32v4_mt16 
{
    [MethodImpl(256 | 512)]
    internal b32v4_mt16(b32v3_mt16 xyz)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = default;
    }

    [MethodImpl(256 | 512)]
    public b32v4_mt16(b32v3_mt16 xyz, b32_mt16 w)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public b32v4_mt16(b32_mt16 x, b32v3_mt16 yzw)
    {
        this.x = x;
        this.y = yzw.x;
        this.z = yzw.y;
        this.w = yzw.z;
    }

    [MethodImpl(256 | 512)]
    internal b32v4_mt16(b32v3_mt16 xzw, b32_mt16 y, insert_y _)
    {
        this.x = xzw.x;
        this.y = y;
        this.z = xzw.y;
        this.w = xzw.z;
    }

    [MethodImpl(256 | 512)]
    internal b32v4_mt16(b32v3_mt16 xyw, b32_mt16 z, insert_z _)
    {
        this.x = xyw.x;
        this.y = xyw.y;
        this.z = z;
        this.w = xyw.z;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static b32v4_mt16 b32v4_mt16(b32v3_mt16 xyz, b32_mt16 w) => new(xyz, w);

    [MethodImpl(256 | 512)]
    public static b32v4_mt16 b32v4_mt16(b32_mt16 x, b32v3_mt16 yzw) => new(x, yzw);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z, w) => (X, y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v4_mt16 Ix(this b32v3_mt16 yzw, b32_mt16 x) => new(x, yzw);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z, w) => (x, Y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v4_mt16 Iy(this b32v3_mt16 xzw, b32_mt16 y) => new(xzw, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y, w) => (x, y, Z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v4_mt16 Iz(this b32v3_mt16 xyw, b32_mt16 z) => new(xyw, z, new insert_z());

    /// <summary>
    /// Insert W component
    /// <code>W -> (x, y, z) => (x, y, z, W)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v4_mt16 Iw(this b32v3_mt16 xyz, b32_mt16 w) => new(xyz, w);
}

#endregion // b32v4_mt16

#region b64v4_mt4

[Ex]
public static partial class math
{
    /// <summary>
    /// Unchecked convert (reinterpret if simd) to b64v3_mt4, must ensure that the w component is 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v3_mt4 as3([This] b64v4_mt4 xyzw)
    {
        return xyzw.xyz;
    }

    /// <summary>
    /// Unchecked convert (reinterpret if simd) to b64v4_mt4, the w component will be 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v4_mt4 as4([This] b64v3_mt4 xyz) => new(xyz);
}

public partial struct b64v4_mt4 
{
    [MethodImpl(256 | 512)]
    internal b64v4_mt4(b64v3_mt4 xyz)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = default;
    }

    [MethodImpl(256 | 512)]
    public b64v4_mt4(b64v3_mt4 xyz, b64_mt4 w)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public b64v4_mt4(b64_mt4 x, b64v3_mt4 yzw)
    {
        this.x = x;
        this.y = yzw.x;
        this.z = yzw.y;
        this.w = yzw.z;
    }

    [MethodImpl(256 | 512)]
    internal b64v4_mt4(b64v3_mt4 xzw, b64_mt4 y, insert_y _)
    {
        this.x = xzw.x;
        this.y = y;
        this.z = xzw.y;
        this.w = xzw.z;
    }

    [MethodImpl(256 | 512)]
    internal b64v4_mt4(b64v3_mt4 xyw, b64_mt4 z, insert_z _)
    {
        this.x = xyw.x;
        this.y = xyw.y;
        this.z = z;
        this.w = xyw.z;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static b64v4_mt4 b64v4_mt4(b64v3_mt4 xyz, b64_mt4 w) => new(xyz, w);

    [MethodImpl(256 | 512)]
    public static b64v4_mt4 b64v4_mt4(b64_mt4 x, b64v3_mt4 yzw) => new(x, yzw);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z, w) => (X, y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v4_mt4 Ix(this b64v3_mt4 yzw, b64_mt4 x) => new(x, yzw);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z, w) => (x, Y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v4_mt4 Iy(this b64v3_mt4 xzw, b64_mt4 y) => new(xzw, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y, w) => (x, y, Z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v4_mt4 Iz(this b64v3_mt4 xyw, b64_mt4 z) => new(xyw, z, new insert_z());

    /// <summary>
    /// Insert W component
    /// <code>W -> (x, y, z) => (x, y, z, W)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v4_mt4 Iw(this b64v3_mt4 xyz, b64_mt4 w) => new(xyz, w);
}

#endregion // b64v4_mt4

#region b64v4_mt8

[Ex]
public static partial class math
{
    /// <summary>
    /// Unchecked convert (reinterpret if simd) to b64v3_mt8, must ensure that the w component is 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v3_mt8 as3([This] b64v4_mt8 xyzw)
    {
        return xyzw.xyz;
    }

    /// <summary>
    /// Unchecked convert (reinterpret if simd) to b64v4_mt8, the w component will be 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v4_mt8 as4([This] b64v3_mt8 xyz) => new(xyz);
}

public partial struct b64v4_mt8 
{
    [MethodImpl(256 | 512)]
    internal b64v4_mt8(b64v3_mt8 xyz)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = default;
    }

    [MethodImpl(256 | 512)]
    public b64v4_mt8(b64v3_mt8 xyz, b64_mt8 w)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public b64v4_mt8(b64_mt8 x, b64v3_mt8 yzw)
    {
        this.x = x;
        this.y = yzw.x;
        this.z = yzw.y;
        this.w = yzw.z;
    }

    [MethodImpl(256 | 512)]
    internal b64v4_mt8(b64v3_mt8 xzw, b64_mt8 y, insert_y _)
    {
        this.x = xzw.x;
        this.y = y;
        this.z = xzw.y;
        this.w = xzw.z;
    }

    [MethodImpl(256 | 512)]
    internal b64v4_mt8(b64v3_mt8 xyw, b64_mt8 z, insert_z _)
    {
        this.x = xyw.x;
        this.y = xyw.y;
        this.z = z;
        this.w = xyw.z;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static b64v4_mt8 b64v4_mt8(b64v3_mt8 xyz, b64_mt8 w) => new(xyz, w);

    [MethodImpl(256 | 512)]
    public static b64v4_mt8 b64v4_mt8(b64_mt8 x, b64v3_mt8 yzw) => new(x, yzw);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z, w) => (X, y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v4_mt8 Ix(this b64v3_mt8 yzw, b64_mt8 x) => new(x, yzw);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z, w) => (x, Y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v4_mt8 Iy(this b64v3_mt8 xzw, b64_mt8 y) => new(xzw, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y, w) => (x, y, Z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v4_mt8 Iz(this b64v3_mt8 xyw, b64_mt8 z) => new(xyw, z, new insert_z());

    /// <summary>
    /// Insert W component
    /// <code>W -> (x, y, z) => (x, y, z, W)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v4_mt8 Iw(this b64v3_mt8 xyz, b64_mt8 w) => new(xyz, w);
}

#endregion // b64v4_mt8

#region b64v4_mt16

[Ex]
public static partial class math
{
    /// <summary>
    /// Unchecked convert (reinterpret if simd) to b64v3_mt16, must ensure that the w component is 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v3_mt16 as3([This] b64v4_mt16 xyzw)
    {
        return xyzw.xyz;
    }

    /// <summary>
    /// Unchecked convert (reinterpret if simd) to b64v4_mt16, the w component will be 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v4_mt16 as4([This] b64v3_mt16 xyz) => new(xyz);
}

public partial struct b64v4_mt16 
{
    [MethodImpl(256 | 512)]
    internal b64v4_mt16(b64v3_mt16 xyz)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = default;
    }

    [MethodImpl(256 | 512)]
    public b64v4_mt16(b64v3_mt16 xyz, b64_mt16 w)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public b64v4_mt16(b64_mt16 x, b64v3_mt16 yzw)
    {
        this.x = x;
        this.y = yzw.x;
        this.z = yzw.y;
        this.w = yzw.z;
    }

    [MethodImpl(256 | 512)]
    internal b64v4_mt16(b64v3_mt16 xzw, b64_mt16 y, insert_y _)
    {
        this.x = xzw.x;
        this.y = y;
        this.z = xzw.y;
        this.w = xzw.z;
    }

    [MethodImpl(256 | 512)]
    internal b64v4_mt16(b64v3_mt16 xyw, b64_mt16 z, insert_z _)
    {
        this.x = xyw.x;
        this.y = xyw.y;
        this.z = z;
        this.w = xyw.z;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static b64v4_mt16 b64v4_mt16(b64v3_mt16 xyz, b64_mt16 w) => new(xyz, w);

    [MethodImpl(256 | 512)]
    public static b64v4_mt16 b64v4_mt16(b64_mt16 x, b64v3_mt16 yzw) => new(x, yzw);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z, w) => (X, y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v4_mt16 Ix(this b64v3_mt16 yzw, b64_mt16 x) => new(x, yzw);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z, w) => (x, Y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v4_mt16 Iy(this b64v3_mt16 xzw, b64_mt16 y) => new(xzw, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y, w) => (x, y, Z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v4_mt16 Iz(this b64v3_mt16 xyw, b64_mt16 z) => new(xyw, z, new insert_z());

    /// <summary>
    /// Insert W component
    /// <code>W -> (x, y, z) => (x, y, z, W)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v4_mt16 Iw(this b64v3_mt16 xyz, b64_mt16 w) => new(xyz, w);
}

#endregion // b64v4_mt16
