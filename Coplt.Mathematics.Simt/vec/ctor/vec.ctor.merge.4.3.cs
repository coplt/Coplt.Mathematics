// generated by template, do not modify manually

namespace Coplt.Mathematics.Simt;

#region float4_mt

[Ex]
public static partial class math_mt
{
    /// <summary>
    /// Unchecked convert (reinterpret if simd) to float3_mt, must ensure that the w component is 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float3_mt as3([This] float4_mt xyzw)
    {
        return xyzw.xyz;
    }

    /// <summary>
    /// Unchecked convert (reinterpret if simd) to float4_mt, the w component will be 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float4_mt as4([This] float3_mt xyz) => new(xyz);
}

public partial struct float4_mt 
{
    [MethodImpl(256 | 512)]
    internal float4_mt(float3_mt xyz)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = default;
    }

    [MethodImpl(256 | 512)]
    public float4_mt(float3_mt xyz, float_mt w)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public float4_mt(float_mt x, float3_mt yzw)
    {
        this.x = x;
        this.y = yzw.x;
        this.z = yzw.y;
        this.w = yzw.z;
    }

    [MethodImpl(256 | 512)]
    internal float4_mt(float3_mt xzw, float_mt y, insert_y _)
    {
        this.x = xzw.x;
        this.y = y;
        this.z = xzw.y;
        this.w = xzw.z;
    }

    [MethodImpl(256 | 512)]
    internal float4_mt(float3_mt xyw, float_mt z, insert_z _)
    {
        this.x = xyw.x;
        this.y = xyw.y;
        this.z = z;
        this.w = xyw.z;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static float4_mt float4_mt(float3_mt xyz, float_mt w) => new(xyz, w);

    [MethodImpl(256 | 512)]
    public static float4_mt float4_mt(float_mt x, float3_mt yzw) => new(x, yzw);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z, w) => (X, y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float4_mt Ix(this float3_mt yzw, float_mt x) => new(x, yzw);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z, w) => (x, Y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float4_mt Iy(this float3_mt xzw, float_mt y) => new(xzw, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y, w) => (x, y, Z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float4_mt Iz(this float3_mt xyw, float_mt z) => new(xyw, z, new insert_z());

    /// <summary>
    /// Insert W component
    /// <code>W -> (x, y, z) => (x, y, z, W)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float4_mt Iw(this float3_mt xyz, float_mt w) => new(xyz, w);
}

#endregion // float4_mt

#region double4_mt

[Ex]
public static partial class math_mt
{
    /// <summary>
    /// Unchecked convert (reinterpret if simd) to double3_mt, must ensure that the w component is 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double3_mt as3([This] double4_mt xyzw)
    {
        return xyzw.xyz;
    }

    /// <summary>
    /// Unchecked convert (reinterpret if simd) to double4_mt, the w component will be 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double4_mt as4([This] double3_mt xyz) => new(xyz);
}

public partial struct double4_mt 
{
    [MethodImpl(256 | 512)]
    internal double4_mt(double3_mt xyz)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = default;
    }

    [MethodImpl(256 | 512)]
    public double4_mt(double3_mt xyz, double_mt w)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public double4_mt(double_mt x, double3_mt yzw)
    {
        this.x = x;
        this.y = yzw.x;
        this.z = yzw.y;
        this.w = yzw.z;
    }

    [MethodImpl(256 | 512)]
    internal double4_mt(double3_mt xzw, double_mt y, insert_y _)
    {
        this.x = xzw.x;
        this.y = y;
        this.z = xzw.y;
        this.w = xzw.z;
    }

    [MethodImpl(256 | 512)]
    internal double4_mt(double3_mt xyw, double_mt z, insert_z _)
    {
        this.x = xyw.x;
        this.y = xyw.y;
        this.z = z;
        this.w = xyw.z;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static double4_mt double4_mt(double3_mt xyz, double_mt w) => new(xyz, w);

    [MethodImpl(256 | 512)]
    public static double4_mt double4_mt(double_mt x, double3_mt yzw) => new(x, yzw);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z, w) => (X, y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double4_mt Ix(this double3_mt yzw, double_mt x) => new(x, yzw);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z, w) => (x, Y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double4_mt Iy(this double3_mt xzw, double_mt y) => new(xzw, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y, w) => (x, y, Z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double4_mt Iz(this double3_mt xyw, double_mt z) => new(xyw, z, new insert_z());

    /// <summary>
    /// Insert W component
    /// <code>W -> (x, y, z) => (x, y, z, W)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double4_mt Iw(this double3_mt xyz, double_mt w) => new(xyz, w);
}

#endregion // double4_mt

#region int4_mt

[Ex]
public static partial class math_mt
{
    /// <summary>
    /// Unchecked convert (reinterpret if simd) to int3_mt, must ensure that the w component is 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int3_mt as3([This] int4_mt xyzw)
    {
        return xyzw.xyz;
    }

    /// <summary>
    /// Unchecked convert (reinterpret if simd) to int4_mt, the w component will be 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int4_mt as4([This] int3_mt xyz) => new(xyz);
}

public partial struct int4_mt 
{
    [MethodImpl(256 | 512)]
    internal int4_mt(int3_mt xyz)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = default;
    }

    [MethodImpl(256 | 512)]
    public int4_mt(int3_mt xyz, int_mt w)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public int4_mt(int_mt x, int3_mt yzw)
    {
        this.x = x;
        this.y = yzw.x;
        this.z = yzw.y;
        this.w = yzw.z;
    }

    [MethodImpl(256 | 512)]
    internal int4_mt(int3_mt xzw, int_mt y, insert_y _)
    {
        this.x = xzw.x;
        this.y = y;
        this.z = xzw.y;
        this.w = xzw.z;
    }

    [MethodImpl(256 | 512)]
    internal int4_mt(int3_mt xyw, int_mt z, insert_z _)
    {
        this.x = xyw.x;
        this.y = xyw.y;
        this.z = z;
        this.w = xyw.z;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static int4_mt int4_mt(int3_mt xyz, int_mt w) => new(xyz, w);

    [MethodImpl(256 | 512)]
    public static int4_mt int4_mt(int_mt x, int3_mt yzw) => new(x, yzw);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z, w) => (X, y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int4_mt Ix(this int3_mt yzw, int_mt x) => new(x, yzw);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z, w) => (x, Y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int4_mt Iy(this int3_mt xzw, int_mt y) => new(xzw, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y, w) => (x, y, Z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int4_mt Iz(this int3_mt xyw, int_mt z) => new(xyw, z, new insert_z());

    /// <summary>
    /// Insert W component
    /// <code>W -> (x, y, z) => (x, y, z, W)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int4_mt Iw(this int3_mt xyz, int_mt w) => new(xyz, w);
}

#endregion // int4_mt

#region uint4_mt

[Ex]
public static partial class math_mt
{
    /// <summary>
    /// Unchecked convert (reinterpret if simd) to uint3_mt, must ensure that the w component is 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint3_mt as3([This] uint4_mt xyzw)
    {
        return xyzw.xyz;
    }

    /// <summary>
    /// Unchecked convert (reinterpret if simd) to uint4_mt, the w component will be 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint4_mt as4([This] uint3_mt xyz) => new(xyz);
}

public partial struct uint4_mt 
{
    [MethodImpl(256 | 512)]
    internal uint4_mt(uint3_mt xyz)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = default;
    }

    [MethodImpl(256 | 512)]
    public uint4_mt(uint3_mt xyz, uint_mt w)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public uint4_mt(uint_mt x, uint3_mt yzw)
    {
        this.x = x;
        this.y = yzw.x;
        this.z = yzw.y;
        this.w = yzw.z;
    }

    [MethodImpl(256 | 512)]
    internal uint4_mt(uint3_mt xzw, uint_mt y, insert_y _)
    {
        this.x = xzw.x;
        this.y = y;
        this.z = xzw.y;
        this.w = xzw.z;
    }

    [MethodImpl(256 | 512)]
    internal uint4_mt(uint3_mt xyw, uint_mt z, insert_z _)
    {
        this.x = xyw.x;
        this.y = xyw.y;
        this.z = z;
        this.w = xyw.z;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static uint4_mt uint4_mt(uint3_mt xyz, uint_mt w) => new(xyz, w);

    [MethodImpl(256 | 512)]
    public static uint4_mt uint4_mt(uint_mt x, uint3_mt yzw) => new(x, yzw);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z, w) => (X, y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint4_mt Ix(this uint3_mt yzw, uint_mt x) => new(x, yzw);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z, w) => (x, Y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint4_mt Iy(this uint3_mt xzw, uint_mt y) => new(xzw, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y, w) => (x, y, Z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint4_mt Iz(this uint3_mt xyw, uint_mt z) => new(xyw, z, new insert_z());

    /// <summary>
    /// Insert W component
    /// <code>W -> (x, y, z) => (x, y, z, W)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint4_mt Iw(this uint3_mt xyz, uint_mt w) => new(xyz, w);
}

#endregion // uint4_mt

#region long4_mt

[Ex]
public static partial class math_mt
{
    /// <summary>
    /// Unchecked convert (reinterpret if simd) to long3_mt, must ensure that the w component is 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long3_mt as3([This] long4_mt xyzw)
    {
        return xyzw.xyz;
    }

    /// <summary>
    /// Unchecked convert (reinterpret if simd) to long4_mt, the w component will be 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long4_mt as4([This] long3_mt xyz) => new(xyz);
}

public partial struct long4_mt 
{
    [MethodImpl(256 | 512)]
    internal long4_mt(long3_mt xyz)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = default;
    }

    [MethodImpl(256 | 512)]
    public long4_mt(long3_mt xyz, long_mt w)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public long4_mt(long_mt x, long3_mt yzw)
    {
        this.x = x;
        this.y = yzw.x;
        this.z = yzw.y;
        this.w = yzw.z;
    }

    [MethodImpl(256 | 512)]
    internal long4_mt(long3_mt xzw, long_mt y, insert_y _)
    {
        this.x = xzw.x;
        this.y = y;
        this.z = xzw.y;
        this.w = xzw.z;
    }

    [MethodImpl(256 | 512)]
    internal long4_mt(long3_mt xyw, long_mt z, insert_z _)
    {
        this.x = xyw.x;
        this.y = xyw.y;
        this.z = z;
        this.w = xyw.z;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static long4_mt long4_mt(long3_mt xyz, long_mt w) => new(xyz, w);

    [MethodImpl(256 | 512)]
    public static long4_mt long4_mt(long_mt x, long3_mt yzw) => new(x, yzw);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z, w) => (X, y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long4_mt Ix(this long3_mt yzw, long_mt x) => new(x, yzw);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z, w) => (x, Y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long4_mt Iy(this long3_mt xzw, long_mt y) => new(xzw, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y, w) => (x, y, Z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long4_mt Iz(this long3_mt xyw, long_mt z) => new(xyw, z, new insert_z());

    /// <summary>
    /// Insert W component
    /// <code>W -> (x, y, z) => (x, y, z, W)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long4_mt Iw(this long3_mt xyz, long_mt w) => new(xyz, w);
}

#endregion // long4_mt

#region ulong4_mt

[Ex]
public static partial class math_mt
{
    /// <summary>
    /// Unchecked convert (reinterpret if simd) to ulong3_mt, must ensure that the w component is 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong3_mt as3([This] ulong4_mt xyzw)
    {
        return xyzw.xyz;
    }

    /// <summary>
    /// Unchecked convert (reinterpret if simd) to ulong4_mt, the w component will be 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong4_mt as4([This] ulong3_mt xyz) => new(xyz);
}

public partial struct ulong4_mt 
{
    [MethodImpl(256 | 512)]
    internal ulong4_mt(ulong3_mt xyz)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = default;
    }

    [MethodImpl(256 | 512)]
    public ulong4_mt(ulong3_mt xyz, ulong_mt w)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public ulong4_mt(ulong_mt x, ulong3_mt yzw)
    {
        this.x = x;
        this.y = yzw.x;
        this.z = yzw.y;
        this.w = yzw.z;
    }

    [MethodImpl(256 | 512)]
    internal ulong4_mt(ulong3_mt xzw, ulong_mt y, insert_y _)
    {
        this.x = xzw.x;
        this.y = y;
        this.z = xzw.y;
        this.w = xzw.z;
    }

    [MethodImpl(256 | 512)]
    internal ulong4_mt(ulong3_mt xyw, ulong_mt z, insert_z _)
    {
        this.x = xyw.x;
        this.y = xyw.y;
        this.z = z;
        this.w = xyw.z;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static ulong4_mt ulong4_mt(ulong3_mt xyz, ulong_mt w) => new(xyz, w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt ulong4_mt(ulong_mt x, ulong3_mt yzw) => new(x, yzw);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z, w) => (X, y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong4_mt Ix(this ulong3_mt yzw, ulong_mt x) => new(x, yzw);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z, w) => (x, Y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong4_mt Iy(this ulong3_mt xzw, ulong_mt y) => new(xzw, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y, w) => (x, y, Z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong4_mt Iz(this ulong3_mt xyw, ulong_mt z) => new(xyw, z, new insert_z());

    /// <summary>
    /// Insert W component
    /// <code>W -> (x, y, z) => (x, y, z, W)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong4_mt Iw(this ulong3_mt xyz, ulong_mt w) => new(xyz, w);
}

#endregion // ulong4_mt

#region b32v4_mt

[Ex]
public static partial class math_mt
{
    /// <summary>
    /// Unchecked convert (reinterpret if simd) to b32v3_mt, must ensure that the w component is 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v3_mt as3([This] b32v4_mt xyzw)
    {
        return xyzw.xyz;
    }

    /// <summary>
    /// Unchecked convert (reinterpret if simd) to b32v4_mt, the w component will be 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v4_mt as4([This] b32v3_mt xyz) => new(xyz);
}

public partial struct b32v4_mt 
{
    [MethodImpl(256 | 512)]
    internal b32v4_mt(b32v3_mt xyz)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = default;
    }

    [MethodImpl(256 | 512)]
    public b32v4_mt(b32v3_mt xyz, b32_mt w)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public b32v4_mt(b32_mt x, b32v3_mt yzw)
    {
        this.x = x;
        this.y = yzw.x;
        this.z = yzw.y;
        this.w = yzw.z;
    }

    [MethodImpl(256 | 512)]
    internal b32v4_mt(b32v3_mt xzw, b32_mt y, insert_y _)
    {
        this.x = xzw.x;
        this.y = y;
        this.z = xzw.y;
        this.w = xzw.z;
    }

    [MethodImpl(256 | 512)]
    internal b32v4_mt(b32v3_mt xyw, b32_mt z, insert_z _)
    {
        this.x = xyw.x;
        this.y = xyw.y;
        this.z = z;
        this.w = xyw.z;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static b32v4_mt b32v4_mt(b32v3_mt xyz, b32_mt w) => new(xyz, w);

    [MethodImpl(256 | 512)]
    public static b32v4_mt b32v4_mt(b32_mt x, b32v3_mt yzw) => new(x, yzw);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z, w) => (X, y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v4_mt Ix(this b32v3_mt yzw, b32_mt x) => new(x, yzw);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z, w) => (x, Y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v4_mt Iy(this b32v3_mt xzw, b32_mt y) => new(xzw, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y, w) => (x, y, Z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v4_mt Iz(this b32v3_mt xyw, b32_mt z) => new(xyw, z, new insert_z());

    /// <summary>
    /// Insert W component
    /// <code>W -> (x, y, z) => (x, y, z, W)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v4_mt Iw(this b32v3_mt xyz, b32_mt w) => new(xyz, w);
}

#endregion // b32v4_mt

#region b64v4_mt

[Ex]
public static partial class math_mt
{
    /// <summary>
    /// Unchecked convert (reinterpret if simd) to b64v3_mt, must ensure that the w component is 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v3_mt as3([This] b64v4_mt xyzw)
    {
        return xyzw.xyz;
    }

    /// <summary>
    /// Unchecked convert (reinterpret if simd) to b64v4_mt, the w component will be 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v4_mt as4([This] b64v3_mt xyz) => new(xyz);
}

public partial struct b64v4_mt 
{
    [MethodImpl(256 | 512)]
    internal b64v4_mt(b64v3_mt xyz)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = default;
    }

    [MethodImpl(256 | 512)]
    public b64v4_mt(b64v3_mt xyz, b64_mt w)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public b64v4_mt(b64_mt x, b64v3_mt yzw)
    {
        this.x = x;
        this.y = yzw.x;
        this.z = yzw.y;
        this.w = yzw.z;
    }

    [MethodImpl(256 | 512)]
    internal b64v4_mt(b64v3_mt xzw, b64_mt y, insert_y _)
    {
        this.x = xzw.x;
        this.y = y;
        this.z = xzw.y;
        this.w = xzw.z;
    }

    [MethodImpl(256 | 512)]
    internal b64v4_mt(b64v3_mt xyw, b64_mt z, insert_z _)
    {
        this.x = xyw.x;
        this.y = xyw.y;
        this.z = z;
        this.w = xyw.z;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static b64v4_mt b64v4_mt(b64v3_mt xyz, b64_mt w) => new(xyz, w);

    [MethodImpl(256 | 512)]
    public static b64v4_mt b64v4_mt(b64_mt x, b64v3_mt yzw) => new(x, yzw);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z, w) => (X, y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v4_mt Ix(this b64v3_mt yzw, b64_mt x) => new(x, yzw);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z, w) => (x, Y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v4_mt Iy(this b64v3_mt xzw, b64_mt y) => new(xzw, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y, w) => (x, y, Z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v4_mt Iz(this b64v3_mt xyw, b64_mt z) => new(xyw, z, new insert_z());

    /// <summary>
    /// Insert W component
    /// <code>W -> (x, y, z) => (x, y, z, W)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v4_mt Iw(this b64v3_mt xyz, b64_mt w) => new(xyz, w);
}

#endregion // b64v4_mt
