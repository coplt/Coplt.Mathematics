// generated by template, do not modify manually

namespace Coplt.Mathematics.Simt;

#region float3_mt4

public partial struct float3_mt4 
{
    [MethodImpl(256 | 512)]
    public float3_mt4(float2_mt4 xy, float_mt4 z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public float3_mt4(float_mt4 x, float2_mt4 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal float3_mt4(float2_mt4 xz, float_mt4 y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static float3_mt4 float3_mt4(float2_mt4 xy, float_mt4 z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static float3_mt4 float3_mt4(float_mt4 x, float2_mt4 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float3_mt4 Ix(this float2_mt4 yz, float_mt4 x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float3_mt4 Iy(this float2_mt4 xz, float_mt4 y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float3_mt4 Iz(this float2_mt4 xy, float_mt4 z) => new(xy, z);
}

#endregion // float3_mt4

#region float3_mt8

public partial struct float3_mt8 
{
    [MethodImpl(256 | 512)]
    public float3_mt8(float2_mt8 xy, float_mt8 z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public float3_mt8(float_mt8 x, float2_mt8 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal float3_mt8(float2_mt8 xz, float_mt8 y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static float3_mt8 float3_mt8(float2_mt8 xy, float_mt8 z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static float3_mt8 float3_mt8(float_mt8 x, float2_mt8 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float3_mt8 Ix(this float2_mt8 yz, float_mt8 x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float3_mt8 Iy(this float2_mt8 xz, float_mt8 y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float3_mt8 Iz(this float2_mt8 xy, float_mt8 z) => new(xy, z);
}

#endregion // float3_mt8

#region float3_mt16

public partial struct float3_mt16 
{
    [MethodImpl(256 | 512)]
    public float3_mt16(float2_mt16 xy, float_mt16 z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public float3_mt16(float_mt16 x, float2_mt16 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal float3_mt16(float2_mt16 xz, float_mt16 y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static float3_mt16 float3_mt16(float2_mt16 xy, float_mt16 z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static float3_mt16 float3_mt16(float_mt16 x, float2_mt16 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float3_mt16 Ix(this float2_mt16 yz, float_mt16 x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float3_mt16 Iy(this float2_mt16 xz, float_mt16 y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float3_mt16 Iz(this float2_mt16 xy, float_mt16 z) => new(xy, z);
}

#endregion // float3_mt16

#region float3_mt32

public partial struct float3_mt32 
{
    [MethodImpl(256 | 512)]
    public float3_mt32(float2_mt32 xy, float_mt32 z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public float3_mt32(float_mt32 x, float2_mt32 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal float3_mt32(float2_mt32 xz, float_mt32 y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static float3_mt32 float3_mt32(float2_mt32 xy, float_mt32 z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static float3_mt32 float3_mt32(float_mt32 x, float2_mt32 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float3_mt32 Ix(this float2_mt32 yz, float_mt32 x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float3_mt32 Iy(this float2_mt32 xz, float_mt32 y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float3_mt32 Iz(this float2_mt32 xy, float_mt32 z) => new(xy, z);
}

#endregion // float3_mt32

#region double3_mt4

public partial struct double3_mt4 
{
    [MethodImpl(256 | 512)]
    public double3_mt4(double2_mt4 xy, double_mt4 z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public double3_mt4(double_mt4 x, double2_mt4 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal double3_mt4(double2_mt4 xz, double_mt4 y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static double3_mt4 double3_mt4(double2_mt4 xy, double_mt4 z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static double3_mt4 double3_mt4(double_mt4 x, double2_mt4 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double3_mt4 Ix(this double2_mt4 yz, double_mt4 x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double3_mt4 Iy(this double2_mt4 xz, double_mt4 y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double3_mt4 Iz(this double2_mt4 xy, double_mt4 z) => new(xy, z);
}

#endregion // double3_mt4

#region double3_mt8

public partial struct double3_mt8 
{
    [MethodImpl(256 | 512)]
    public double3_mt8(double2_mt8 xy, double_mt8 z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public double3_mt8(double_mt8 x, double2_mt8 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal double3_mt8(double2_mt8 xz, double_mt8 y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static double3_mt8 double3_mt8(double2_mt8 xy, double_mt8 z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static double3_mt8 double3_mt8(double_mt8 x, double2_mt8 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double3_mt8 Ix(this double2_mt8 yz, double_mt8 x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double3_mt8 Iy(this double2_mt8 xz, double_mt8 y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double3_mt8 Iz(this double2_mt8 xy, double_mt8 z) => new(xy, z);
}

#endregion // double3_mt8

#region double3_mt16

public partial struct double3_mt16 
{
    [MethodImpl(256 | 512)]
    public double3_mt16(double2_mt16 xy, double_mt16 z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public double3_mt16(double_mt16 x, double2_mt16 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal double3_mt16(double2_mt16 xz, double_mt16 y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static double3_mt16 double3_mt16(double2_mt16 xy, double_mt16 z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static double3_mt16 double3_mt16(double_mt16 x, double2_mt16 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double3_mt16 Ix(this double2_mt16 yz, double_mt16 x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double3_mt16 Iy(this double2_mt16 xz, double_mt16 y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double3_mt16 Iz(this double2_mt16 xy, double_mt16 z) => new(xy, z);
}

#endregion // double3_mt16

#region double3_mt32

public partial struct double3_mt32 
{
    [MethodImpl(256 | 512)]
    public double3_mt32(double2_mt32 xy, double_mt32 z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public double3_mt32(double_mt32 x, double2_mt32 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal double3_mt32(double2_mt32 xz, double_mt32 y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static double3_mt32 double3_mt32(double2_mt32 xy, double_mt32 z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static double3_mt32 double3_mt32(double_mt32 x, double2_mt32 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double3_mt32 Ix(this double2_mt32 yz, double_mt32 x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double3_mt32 Iy(this double2_mt32 xz, double_mt32 y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double3_mt32 Iz(this double2_mt32 xy, double_mt32 z) => new(xy, z);
}

#endregion // double3_mt32

#region int3_mt4

public partial struct int3_mt4 
{
    [MethodImpl(256 | 512)]
    public int3_mt4(int2_mt4 xy, int_mt4 z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public int3_mt4(int_mt4 x, int2_mt4 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal int3_mt4(int2_mt4 xz, int_mt4 y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static int3_mt4 int3_mt4(int2_mt4 xy, int_mt4 z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static int3_mt4 int3_mt4(int_mt4 x, int2_mt4 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int3_mt4 Ix(this int2_mt4 yz, int_mt4 x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int3_mt4 Iy(this int2_mt4 xz, int_mt4 y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int3_mt4 Iz(this int2_mt4 xy, int_mt4 z) => new(xy, z);
}

#endregion // int3_mt4

#region int3_mt8

public partial struct int3_mt8 
{
    [MethodImpl(256 | 512)]
    public int3_mt8(int2_mt8 xy, int_mt8 z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public int3_mt8(int_mt8 x, int2_mt8 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal int3_mt8(int2_mt8 xz, int_mt8 y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static int3_mt8 int3_mt8(int2_mt8 xy, int_mt8 z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static int3_mt8 int3_mt8(int_mt8 x, int2_mt8 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int3_mt8 Ix(this int2_mt8 yz, int_mt8 x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int3_mt8 Iy(this int2_mt8 xz, int_mt8 y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int3_mt8 Iz(this int2_mt8 xy, int_mt8 z) => new(xy, z);
}

#endregion // int3_mt8

#region int3_mt16

public partial struct int3_mt16 
{
    [MethodImpl(256 | 512)]
    public int3_mt16(int2_mt16 xy, int_mt16 z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public int3_mt16(int_mt16 x, int2_mt16 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal int3_mt16(int2_mt16 xz, int_mt16 y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static int3_mt16 int3_mt16(int2_mt16 xy, int_mt16 z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static int3_mt16 int3_mt16(int_mt16 x, int2_mt16 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int3_mt16 Ix(this int2_mt16 yz, int_mt16 x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int3_mt16 Iy(this int2_mt16 xz, int_mt16 y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int3_mt16 Iz(this int2_mt16 xy, int_mt16 z) => new(xy, z);
}

#endregion // int3_mt16

#region int3_mt32

public partial struct int3_mt32 
{
    [MethodImpl(256 | 512)]
    public int3_mt32(int2_mt32 xy, int_mt32 z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public int3_mt32(int_mt32 x, int2_mt32 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal int3_mt32(int2_mt32 xz, int_mt32 y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static int3_mt32 int3_mt32(int2_mt32 xy, int_mt32 z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static int3_mt32 int3_mt32(int_mt32 x, int2_mt32 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int3_mt32 Ix(this int2_mt32 yz, int_mt32 x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int3_mt32 Iy(this int2_mt32 xz, int_mt32 y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int3_mt32 Iz(this int2_mt32 xy, int_mt32 z) => new(xy, z);
}

#endregion // int3_mt32

#region uint3_mt4

public partial struct uint3_mt4 
{
    [MethodImpl(256 | 512)]
    public uint3_mt4(uint2_mt4 xy, uint_mt4 z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public uint3_mt4(uint_mt4 x, uint2_mt4 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal uint3_mt4(uint2_mt4 xz, uint_mt4 y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static uint3_mt4 uint3_mt4(uint2_mt4 xy, uint_mt4 z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static uint3_mt4 uint3_mt4(uint_mt4 x, uint2_mt4 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint3_mt4 Ix(this uint2_mt4 yz, uint_mt4 x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint3_mt4 Iy(this uint2_mt4 xz, uint_mt4 y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint3_mt4 Iz(this uint2_mt4 xy, uint_mt4 z) => new(xy, z);
}

#endregion // uint3_mt4

#region uint3_mt8

public partial struct uint3_mt8 
{
    [MethodImpl(256 | 512)]
    public uint3_mt8(uint2_mt8 xy, uint_mt8 z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public uint3_mt8(uint_mt8 x, uint2_mt8 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal uint3_mt8(uint2_mt8 xz, uint_mt8 y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static uint3_mt8 uint3_mt8(uint2_mt8 xy, uint_mt8 z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static uint3_mt8 uint3_mt8(uint_mt8 x, uint2_mt8 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint3_mt8 Ix(this uint2_mt8 yz, uint_mt8 x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint3_mt8 Iy(this uint2_mt8 xz, uint_mt8 y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint3_mt8 Iz(this uint2_mt8 xy, uint_mt8 z) => new(xy, z);
}

#endregion // uint3_mt8

#region uint3_mt16

public partial struct uint3_mt16 
{
    [MethodImpl(256 | 512)]
    public uint3_mt16(uint2_mt16 xy, uint_mt16 z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public uint3_mt16(uint_mt16 x, uint2_mt16 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal uint3_mt16(uint2_mt16 xz, uint_mt16 y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static uint3_mt16 uint3_mt16(uint2_mt16 xy, uint_mt16 z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static uint3_mt16 uint3_mt16(uint_mt16 x, uint2_mt16 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint3_mt16 Ix(this uint2_mt16 yz, uint_mt16 x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint3_mt16 Iy(this uint2_mt16 xz, uint_mt16 y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint3_mt16 Iz(this uint2_mt16 xy, uint_mt16 z) => new(xy, z);
}

#endregion // uint3_mt16

#region uint3_mt32

public partial struct uint3_mt32 
{
    [MethodImpl(256 | 512)]
    public uint3_mt32(uint2_mt32 xy, uint_mt32 z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public uint3_mt32(uint_mt32 x, uint2_mt32 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal uint3_mt32(uint2_mt32 xz, uint_mt32 y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static uint3_mt32 uint3_mt32(uint2_mt32 xy, uint_mt32 z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static uint3_mt32 uint3_mt32(uint_mt32 x, uint2_mt32 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint3_mt32 Ix(this uint2_mt32 yz, uint_mt32 x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint3_mt32 Iy(this uint2_mt32 xz, uint_mt32 y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint3_mt32 Iz(this uint2_mt32 xy, uint_mt32 z) => new(xy, z);
}

#endregion // uint3_mt32

#region long3_mt4

public partial struct long3_mt4 
{
    [MethodImpl(256 | 512)]
    public long3_mt4(long2_mt4 xy, long_mt4 z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public long3_mt4(long_mt4 x, long2_mt4 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal long3_mt4(long2_mt4 xz, long_mt4 y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static long3_mt4 long3_mt4(long2_mt4 xy, long_mt4 z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static long3_mt4 long3_mt4(long_mt4 x, long2_mt4 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long3_mt4 Ix(this long2_mt4 yz, long_mt4 x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long3_mt4 Iy(this long2_mt4 xz, long_mt4 y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long3_mt4 Iz(this long2_mt4 xy, long_mt4 z) => new(xy, z);
}

#endregion // long3_mt4

#region long3_mt8

public partial struct long3_mt8 
{
    [MethodImpl(256 | 512)]
    public long3_mt8(long2_mt8 xy, long_mt8 z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public long3_mt8(long_mt8 x, long2_mt8 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal long3_mt8(long2_mt8 xz, long_mt8 y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static long3_mt8 long3_mt8(long2_mt8 xy, long_mt8 z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static long3_mt8 long3_mt8(long_mt8 x, long2_mt8 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long3_mt8 Ix(this long2_mt8 yz, long_mt8 x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long3_mt8 Iy(this long2_mt8 xz, long_mt8 y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long3_mt8 Iz(this long2_mt8 xy, long_mt8 z) => new(xy, z);
}

#endregion // long3_mt8

#region long3_mt16

public partial struct long3_mt16 
{
    [MethodImpl(256 | 512)]
    public long3_mt16(long2_mt16 xy, long_mt16 z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public long3_mt16(long_mt16 x, long2_mt16 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal long3_mt16(long2_mt16 xz, long_mt16 y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static long3_mt16 long3_mt16(long2_mt16 xy, long_mt16 z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static long3_mt16 long3_mt16(long_mt16 x, long2_mt16 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long3_mt16 Ix(this long2_mt16 yz, long_mt16 x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long3_mt16 Iy(this long2_mt16 xz, long_mt16 y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long3_mt16 Iz(this long2_mt16 xy, long_mt16 z) => new(xy, z);
}

#endregion // long3_mt16

#region long3_mt32

public partial struct long3_mt32 
{
    [MethodImpl(256 | 512)]
    public long3_mt32(long2_mt32 xy, long_mt32 z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public long3_mt32(long_mt32 x, long2_mt32 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal long3_mt32(long2_mt32 xz, long_mt32 y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static long3_mt32 long3_mt32(long2_mt32 xy, long_mt32 z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static long3_mt32 long3_mt32(long_mt32 x, long2_mt32 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long3_mt32 Ix(this long2_mt32 yz, long_mt32 x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long3_mt32 Iy(this long2_mt32 xz, long_mt32 y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long3_mt32 Iz(this long2_mt32 xy, long_mt32 z) => new(xy, z);
}

#endregion // long3_mt32

#region ulong3_mt4

public partial struct ulong3_mt4 
{
    [MethodImpl(256 | 512)]
    public ulong3_mt4(ulong2_mt4 xy, ulong_mt4 z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public ulong3_mt4(ulong_mt4 x, ulong2_mt4 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal ulong3_mt4(ulong2_mt4 xz, ulong_mt4 y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static ulong3_mt4 ulong3_mt4(ulong2_mt4 xy, ulong_mt4 z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt4 ulong3_mt4(ulong_mt4 x, ulong2_mt4 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong3_mt4 Ix(this ulong2_mt4 yz, ulong_mt4 x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong3_mt4 Iy(this ulong2_mt4 xz, ulong_mt4 y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong3_mt4 Iz(this ulong2_mt4 xy, ulong_mt4 z) => new(xy, z);
}

#endregion // ulong3_mt4

#region ulong3_mt8

public partial struct ulong3_mt8 
{
    [MethodImpl(256 | 512)]
    public ulong3_mt8(ulong2_mt8 xy, ulong_mt8 z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public ulong3_mt8(ulong_mt8 x, ulong2_mt8 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal ulong3_mt8(ulong2_mt8 xz, ulong_mt8 y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static ulong3_mt8 ulong3_mt8(ulong2_mt8 xy, ulong_mt8 z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt8 ulong3_mt8(ulong_mt8 x, ulong2_mt8 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong3_mt8 Ix(this ulong2_mt8 yz, ulong_mt8 x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong3_mt8 Iy(this ulong2_mt8 xz, ulong_mt8 y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong3_mt8 Iz(this ulong2_mt8 xy, ulong_mt8 z) => new(xy, z);
}

#endregion // ulong3_mt8

#region ulong3_mt16

public partial struct ulong3_mt16 
{
    [MethodImpl(256 | 512)]
    public ulong3_mt16(ulong2_mt16 xy, ulong_mt16 z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public ulong3_mt16(ulong_mt16 x, ulong2_mt16 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal ulong3_mt16(ulong2_mt16 xz, ulong_mt16 y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static ulong3_mt16 ulong3_mt16(ulong2_mt16 xy, ulong_mt16 z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt16 ulong3_mt16(ulong_mt16 x, ulong2_mt16 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong3_mt16 Ix(this ulong2_mt16 yz, ulong_mt16 x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong3_mt16 Iy(this ulong2_mt16 xz, ulong_mt16 y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong3_mt16 Iz(this ulong2_mt16 xy, ulong_mt16 z) => new(xy, z);
}

#endregion // ulong3_mt16

#region ulong3_mt32

public partial struct ulong3_mt32 
{
    [MethodImpl(256 | 512)]
    public ulong3_mt32(ulong2_mt32 xy, ulong_mt32 z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public ulong3_mt32(ulong_mt32 x, ulong2_mt32 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal ulong3_mt32(ulong2_mt32 xz, ulong_mt32 y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static ulong3_mt32 ulong3_mt32(ulong2_mt32 xy, ulong_mt32 z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt32 ulong3_mt32(ulong_mt32 x, ulong2_mt32 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong3_mt32 Ix(this ulong2_mt32 yz, ulong_mt32 x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong3_mt32 Iy(this ulong2_mt32 xz, ulong_mt32 y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong3_mt32 Iz(this ulong2_mt32 xy, ulong_mt32 z) => new(xy, z);
}

#endregion // ulong3_mt32

#region b32v3_mt4

public partial struct b32v3_mt4 
{
    [MethodImpl(256 | 512)]
    public b32v3_mt4(b32v2_mt4 xy, b32_mt4 z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public b32v3_mt4(b32_mt4 x, b32v2_mt4 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal b32v3_mt4(b32v2_mt4 xz, b32_mt4 y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static b32v3_mt4 b32v3_mt4(b32v2_mt4 xy, b32_mt4 z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static b32v3_mt4 b32v3_mt4(b32_mt4 x, b32v2_mt4 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v3_mt4 Ix(this b32v2_mt4 yz, b32_mt4 x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v3_mt4 Iy(this b32v2_mt4 xz, b32_mt4 y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v3_mt4 Iz(this b32v2_mt4 xy, b32_mt4 z) => new(xy, z);
}

#endregion // b32v3_mt4

#region b32v3_mt8

public partial struct b32v3_mt8 
{
    [MethodImpl(256 | 512)]
    public b32v3_mt8(b32v2_mt8 xy, b32_mt8 z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public b32v3_mt8(b32_mt8 x, b32v2_mt8 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal b32v3_mt8(b32v2_mt8 xz, b32_mt8 y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static b32v3_mt8 b32v3_mt8(b32v2_mt8 xy, b32_mt8 z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static b32v3_mt8 b32v3_mt8(b32_mt8 x, b32v2_mt8 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v3_mt8 Ix(this b32v2_mt8 yz, b32_mt8 x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v3_mt8 Iy(this b32v2_mt8 xz, b32_mt8 y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v3_mt8 Iz(this b32v2_mt8 xy, b32_mt8 z) => new(xy, z);
}

#endregion // b32v3_mt8

#region b32v3_mt16

public partial struct b32v3_mt16 
{
    [MethodImpl(256 | 512)]
    public b32v3_mt16(b32v2_mt16 xy, b32_mt16 z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public b32v3_mt16(b32_mt16 x, b32v2_mt16 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal b32v3_mt16(b32v2_mt16 xz, b32_mt16 y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static b32v3_mt16 b32v3_mt16(b32v2_mt16 xy, b32_mt16 z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static b32v3_mt16 b32v3_mt16(b32_mt16 x, b32v2_mt16 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v3_mt16 Ix(this b32v2_mt16 yz, b32_mt16 x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v3_mt16 Iy(this b32v2_mt16 xz, b32_mt16 y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v3_mt16 Iz(this b32v2_mt16 xy, b32_mt16 z) => new(xy, z);
}

#endregion // b32v3_mt16

#region b32v3_mt32

public partial struct b32v3_mt32 
{
    [MethodImpl(256 | 512)]
    public b32v3_mt32(b32v2_mt32 xy, b32_mt32 z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public b32v3_mt32(b32_mt32 x, b32v2_mt32 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal b32v3_mt32(b32v2_mt32 xz, b32_mt32 y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static b32v3_mt32 b32v3_mt32(b32v2_mt32 xy, b32_mt32 z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static b32v3_mt32 b32v3_mt32(b32_mt32 x, b32v2_mt32 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v3_mt32 Ix(this b32v2_mt32 yz, b32_mt32 x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v3_mt32 Iy(this b32v2_mt32 xz, b32_mt32 y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v3_mt32 Iz(this b32v2_mt32 xy, b32_mt32 z) => new(xy, z);
}

#endregion // b32v3_mt32

#region b64v3_mt4

public partial struct b64v3_mt4 
{
    [MethodImpl(256 | 512)]
    public b64v3_mt4(b64v2_mt4 xy, b64_mt4 z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public b64v3_mt4(b64_mt4 x, b64v2_mt4 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal b64v3_mt4(b64v2_mt4 xz, b64_mt4 y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static b64v3_mt4 b64v3_mt4(b64v2_mt4 xy, b64_mt4 z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static b64v3_mt4 b64v3_mt4(b64_mt4 x, b64v2_mt4 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v3_mt4 Ix(this b64v2_mt4 yz, b64_mt4 x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v3_mt4 Iy(this b64v2_mt4 xz, b64_mt4 y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v3_mt4 Iz(this b64v2_mt4 xy, b64_mt4 z) => new(xy, z);
}

#endregion // b64v3_mt4

#region b64v3_mt8

public partial struct b64v3_mt8 
{
    [MethodImpl(256 | 512)]
    public b64v3_mt8(b64v2_mt8 xy, b64_mt8 z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public b64v3_mt8(b64_mt8 x, b64v2_mt8 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal b64v3_mt8(b64v2_mt8 xz, b64_mt8 y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static b64v3_mt8 b64v3_mt8(b64v2_mt8 xy, b64_mt8 z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static b64v3_mt8 b64v3_mt8(b64_mt8 x, b64v2_mt8 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v3_mt8 Ix(this b64v2_mt8 yz, b64_mt8 x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v3_mt8 Iy(this b64v2_mt8 xz, b64_mt8 y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v3_mt8 Iz(this b64v2_mt8 xy, b64_mt8 z) => new(xy, z);
}

#endregion // b64v3_mt8

#region b64v3_mt16

public partial struct b64v3_mt16 
{
    [MethodImpl(256 | 512)]
    public b64v3_mt16(b64v2_mt16 xy, b64_mt16 z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public b64v3_mt16(b64_mt16 x, b64v2_mt16 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal b64v3_mt16(b64v2_mt16 xz, b64_mt16 y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static b64v3_mt16 b64v3_mt16(b64v2_mt16 xy, b64_mt16 z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static b64v3_mt16 b64v3_mt16(b64_mt16 x, b64v2_mt16 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v3_mt16 Ix(this b64v2_mt16 yz, b64_mt16 x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v3_mt16 Iy(this b64v2_mt16 xz, b64_mt16 y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v3_mt16 Iz(this b64v2_mt16 xy, b64_mt16 z) => new(xy, z);
}

#endregion // b64v3_mt16

#region b64v3_mt32

public partial struct b64v3_mt32 
{
    [MethodImpl(256 | 512)]
    public b64v3_mt32(b64v2_mt32 xy, b64_mt32 z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public b64v3_mt32(b64_mt32 x, b64v2_mt32 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal b64v3_mt32(b64v2_mt32 xz, b64_mt32 y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static b64v3_mt32 b64v3_mt32(b64v2_mt32 xy, b64_mt32 z) => new(xy, z);

    [MethodImpl(256 | 512)]
    public static b64v3_mt32 b64v3_mt32(b64_mt32 x, b64v2_mt32 yz) => new(x, yz);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v3_mt32 Ix(this b64v2_mt32 yz, b64_mt32 x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v3_mt32 Iy(this b64v2_mt32 xz, b64_mt32 y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v3_mt32 Iz(this b64v2_mt32 xy, b64_mt32 z) => new(xy, z);
}

#endregion // b64v3_mt32
