<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="../../../Coplt.Mathematics/types.ttinclude" #><#@ import namespace="System.Linq" #>// generated by template, do not modify manually

namespace Coplt.Mathematics.Simt;
<#
    var sizes = new[] { 4, 8, 16, 32 };
    foreach (var typ in Typ.Typs)
    {
        if (!typ.simd) continue;
        if (typ.size < 4) continue;
        foreach (var size in sizes)
        {
            var typeName = $"{typ.name}4_mt{size}";
            var typeName3 = $"{typ.name}3_mt{size}";
            var type = $"{typ.compType}_mt{size}";
#>

#region <#= typeName #>

[Ex]
public static partial class math
{
    /// <summary>
    /// Unchecked convert (reinterpret if simd) to <#= typeName3 #>, must ensure that the w component is 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static <#= typeName3 #> as3([This] <#= typeName #> xyzw)
    {
        return xyzw.xyz;
    }

    /// <summary>
    /// Unchecked convert (reinterpret if simd) to <#= typeName #>, the w component will be 0.
    /// </summary>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> as4([This] <#= typeName3 #> xyz) => new(xyz);
}

public partial struct <#= typeName #> 
{
    [MethodImpl(256 | 512)]
    internal <#= typeName #>(<#= typeName3 #> xyz)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = default;
    }

    [MethodImpl(256 | 512)]
    public <#= typeName #>(<#= typeName3 #> xyz, <#= type #> w)
    {
        this.x = xyz.x;
        this.y = xyz.y;
        this.z = xyz.z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public <#= typeName #>(<#= type #> x, <#= typeName3 #> yzw)
    {
        this.x = x;
        this.y = yzw.x;
        this.z = yzw.y;
        this.w = yzw.z;
    }

    [MethodImpl(256 | 512)]
    internal <#= typeName #>(<#= typeName3 #> xzw, <#= type #> y, insert_y _)
    {
        this.x = xzw.x;
        this.y = y;
        this.z = xzw.y;
        this.w = xzw.z;
    }

    [MethodImpl(256 | 512)]
    internal <#= typeName #>(<#= typeName3 #> xyw, <#= type #> z, insert_z _)
    {
        this.x = xyw.x;
        this.y = xyw.y;
        this.z = z;
        this.w = xyw.z;
    }
}

public static partial class ctor_mt
{
    [MethodImpl(256 | 512)]
    public static <#= typeName #> <#= typeName #>(<#= typeName3 #> xyz, <#= type #> w) => new(xyz, w);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> <#= typeName #>(<#= type #> x, <#= typeName3 #> yzw) => new(x, yzw);
}

public static partial class math_mt_ex
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z, w) => (X, y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> Ix(this <#= typeName3 #> yzw, <#= type #> x) => new(x, yzw);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z, w) => (x, Y, z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> Iy(this <#= typeName3 #> xzw, <#= type #> y) => new(xzw, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y, w) => (x, y, Z, w)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> Iz(this <#= typeName3 #> xyw, <#= type #> z) => new(xyw, z, new insert_z());

    /// <summary>
    /// Insert W component
    /// <code>W -> (x, y, z) => (x, y, z, W)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> Iw(this <#= typeName3 #> xyz, <#= type #> w) => new(xyz, w);
}

#endregion // <#= typeName #>
<#
        }
    }
#>
