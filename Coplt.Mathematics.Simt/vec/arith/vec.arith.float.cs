// generated by template, do not modify manually

namespace Coplt.Mathematics.Simt;

#region float2_mt

public partial struct float2_mt
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static float2_mt E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277f); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static float2_mt Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094f); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static float2_mt Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009f);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static float2_mt PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923f);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static float2_mt Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846f);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static float2_mt RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861f);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static float2_mt DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144f);
    }
}

[Ex]
public static partial class math_mt
{
    #pragma warning disable CS1718
    // ReSharper disable once EqualExpressionComparison
    [MethodImpl(256 | 512)]
    public static b32v2_mt isNaN([This] float2_mt a) => a != a;
    #pragma warning restore CS1718

    [MethodImpl(256 | 512)]
    public static b32v2_mt isFinite([This] float2_mt a) => abs(a) < float.PositiveInfinity;

    [MethodImpl(256 | 512)]
    public static b32v2_mt isInf([This] float2_mt a) => new(a.x.isInf(), a.y.isInf());

    [MethodImpl(256 | 512)]
    public static b32v2_mt isPosInf([This] float2_mt a) => a == float.PositiveInfinity;

    [MethodImpl(256 | 512)]
    public static b32v2_mt isNegInf([This] float2_mt a) => a == float.NegativeInfinity;

    [MethodImpl(256 | 512)]
    public static float2_mt ceil([This] float2_mt a) => new(a.x.floor(), a.y.floor());

    [MethodImpl(256 | 512)]
    public static float2_mt floor([This] float2_mt a) => new(a.x.floor(), a.y.floor());

    [MethodImpl(256 | 512)]
    public static float2_mt round([This] float2_mt a) => new(a.x.round(), a.y.round());

    [MethodImpl(256 | 512)]
    public static float2_mt trunc([This] float2_mt a) => new(a.x.trunc(), a.y.trunc());

    [MethodImpl(256 | 512)]
    public static float2_mt mod([This] float2_mt a, float2_mt b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt mod([This] float_mt a, float2_mt b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt mod([This] float2_mt a, float_mt b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt mod([This] float a, float2_mt b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt mod([This] float2_mt a, float b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt rem([This] float2_mt a, float2_mt b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt rem([This] float_mt a, float2_mt b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt rem([This] float2_mt a, float_mt b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt rem([This] float a, float2_mt b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt rem([This] float2_mt a, float b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt frac([This] float2_mt a) => a - floor(a);

    [MethodImpl(256 | 512)]
    public static float2_mt modf([This] float2_mt d, out float2_mt i)
    {
        i = trunc(d);
        return d - i;
    }

    [MethodImpl(256 | 512)]
    public static float2_mt rcp([This] float2_mt a) => new(rcp(a.x), rcp(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt saturate([This] float2_mt a) => a.clamp(default, float2_mt.One);

    [MethodImpl(256 | 512)]
    public static float2_mt smoothstep(float2_mt min, float2_mt max, [This] float2_mt a)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * fnma(2.0f, t, 3.0f); // (3.0f - (2.0f * t))
    }

    [MethodImpl(256 | 512)]
    public static float2_mt reflect([This] float2_mt i, float2_mt n)
    {
        // i - 2f * n * dot(i, n);
        return fnma(2f * n, dot(i, n), i);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt project([This] float2_mt a, float2_mt onto) =>
        dot(a, onto) / dot(onto, onto) * onto;

    [MethodImpl(256 | 512)]
    public static float2_mt projectOnPlane([This] float2_mt a, float2_mt plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static float2_mt projectNormalized([This] float2_mt a, float2_mt onto) =>
        dot(a, onto) * onto;

    [MethodImpl(256 | 512)]
    public static float2_mt projectOnPlaneNormalized([This] float2_mt a, float2_mt plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static float2_mt radians([This] float2_mt a) => a * 0.0174532925199432957692369076848861271344287188854172545609719144f;

    [MethodImpl(256 | 512)]
    public static float2_mt degrees([This] float2_mt a) => a * 57.295779513082320876798154814105170332405472466564321549160243861f;

    [MethodImpl(256 | 512)]
    public static float2_mt wrap([This] float2_mt x, float2_mt min, float2_mt max)
    {
        var add = select(x >= float2_mt.Zero, min, max);
        var off = x % (max - min);
        return add + off;
    }

    [MethodImpl(256 | 512)]
    public static float2_mt wrap([This] float2_mt x, float_mt min, float_mt max)
    {
        var add = select(x >= float2_mt.Zero, min, max);
        var off = x % (max - min);
        return add + off;
    }

    [MethodImpl(256 | 512)]
    public static float2_mt wrap([This] float2_mt x, float min, float max)
    {
        var add = select(x >= float2_mt.Zero, min, max);
        var off = x % (max - min);
        return add + off;
    }

    [MethodImpl(256 | 512)]
    public static float2_mt log([This] float2_mt a) => new(log(a.x), log(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt log2([This] float2_mt a) => new(log2(a.x), log2(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt log([This] float2_mt a, float2_mt b) => new(log(a.x, b.x), log(a.y, b.y));

    [MethodImpl(256 | 512)]
    public static float2_mt log([This] float2_mt a, float_mt b) => new(log(a.x, b), log(a.y, b));

    [MethodImpl(256 | 512)]
    public static float2_mt log([This] float_mt a, float2_mt b) => new(log(a, b.x), log(a, b.y));

    [MethodImpl(256 | 512)]
    public static float2_mt log10([This] float2_mt a) => new(log10(a.x), log10(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt exp([This] float2_mt a) => new(exp(a.x), exp(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt exp2([This] float2_mt a) => new(exp2(a.x), exp2(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt exp10([This] float2_mt a) => new(exp10(a.x), exp10(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt pow([This] float2_mt a, float2_mt b) => new(pow(a.x, b.x), pow(a.y, b.y));

    [MethodImpl(256 | 512)]
    public static float2_mt pow([This] float2_mt a, float_mt b) => new(pow(a.x, b), pow(a.y, b));

    [MethodImpl(256 | 512)]
    public static float2_mt pow([This] float2_mt a, float b) => new(pow(a.x, b), pow(a.y, b));

    [MethodImpl(256 | 512)]
    public static float2_mt sqrt([This] float2_mt a) => new(sqrt(a.x), sqrt(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt rsqrt([This] float2_mt a) => new(rsqrt(a.x), rsqrt(a.y));

    [MethodImpl(256 | 512)]
    public static float_mt length([This] float2_mt a) => dot(a, a).sqrt();

    [MethodImpl(256 | 512)]
    public static float_mt distance([This] float2_mt a, float2_mt b) => length(b - a);

    [MethodImpl(256 | 512)]
    public static float2_mt normalize([This] float2_mt a) => a * dot(a, a).rsqrt();

    [MethodImpl(256 | 512)]
    public static float2_mt normalizeSafe([This] float2_mt a, float2_mt defaultValue = default)
    {
        var len = dot(a, a);
        return select(len > 1.175494351e-38f, a * rsqrt(len), defaultValue);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt step(float2_mt threshold, [This] float2_mt a) =>
        select(a >= threshold, float2_mt.One, default);

    [MethodImpl(256 | 512)]
    public static float2_mt refract(float2_mt i, float2_mt n, [This] float indexOfRefraction)
    {
        var ni = dot(n, i);
        var k = (float_mt)(1.0f - indexOfRefraction * indexOfRefraction * (1.0f - ni * ni));
        return select(k >= 0.0f, indexOfRefraction * i - (float_mt)((float_mt)(indexOfRefraction * ni) + sqrt(k)) * n, default);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt projectSafe([This] float2_mt a, float2_mt onto, float2_mt defaultValue = default) 
    {
        var proj = project(a, onto);
        return select(all(isFinite(proj)), proj, defaultValue);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt faceForward([This] float2_mt n, float2_mt i, float2_mt ng) =>
        select(dot(ng, i) >= 0.0f, -n, n);

    [MethodImpl(256 | 512)]
    public static float2_mt sin([This] float2_mt a) => new(sin(a.x), sin(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt cos([This] float2_mt a) => new(cos(a.x), cos(a.y));

    [MethodImpl(256 | 512)]
    public static (float2_mt sin, float2_mt cos) sincos([This] float2_mt a)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        return (
            new(sin_x, sin_y),
            new(cos_x, cos_y)
        );
    }

    [MethodImpl(256 | 512)]
    public static void sincos([This] float2_mt a, out float2_mt sin, out float2_mt cos)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        sin = new(sin_x, sin_y);
        cos = new(cos_x, cos_y);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt tan([This] float2_mt a) => new(tan(a.x), tan(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt asin([This] float2_mt a) => new(asin(a.x), asin(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt acos([This] float2_mt a) => new(acos(a.x), acos(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt atan([This] float2_mt a) => new(atan(a.x), atan(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt atan2([This] float2_mt a, float2_mt b) => new(atan2(a.x, b.x), atan2(a.y, b.y));

    [MethodImpl(256 | 512)]
    public static float2_mt sinh([This] float2_mt a) => new(sinh(a.x), sinh(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt cosh([This] float2_mt a) => new(cosh(a.x), cosh(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt tanh([This] float2_mt a) => new(tanh(a.x), tanh(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt asinh([This] float2_mt a) => new(asinh(a.x), asinh(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt acosh([This] float2_mt a) => new(acosh(a.x), acosh(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt atanh([This] float2_mt a) => new(atanh(a.x), atanh(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt chgsign([This] float2_mt a, float2_mt b) => new(chgsign(a.x, b.x), chgsign(a.y, b.y));
}

#endregion // float2_mt
#region float3_mt

public partial struct float3_mt
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static float3_mt E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277f); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static float3_mt Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094f); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static float3_mt Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009f);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static float3_mt PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923f);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static float3_mt Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846f);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static float3_mt RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861f);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static float3_mt DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144f);
    }
}

[Ex]
public static partial class math_mt
{
    #pragma warning disable CS1718
    // ReSharper disable once EqualExpressionComparison
    [MethodImpl(256 | 512)]
    public static b32v3_mt isNaN([This] float3_mt a) => a != a;
    #pragma warning restore CS1718

    [MethodImpl(256 | 512)]
    public static b32v3_mt isFinite([This] float3_mt a) => abs(a) < float.PositiveInfinity;

    [MethodImpl(256 | 512)]
    public static b32v3_mt isInf([This] float3_mt a) => new(a.x.isInf(), a.y.isInf(), a.z.isInf());

    [MethodImpl(256 | 512)]
    public static b32v3_mt isPosInf([This] float3_mt a) => a == float.PositiveInfinity;

    [MethodImpl(256 | 512)]
    public static b32v3_mt isNegInf([This] float3_mt a) => a == float.NegativeInfinity;

    [MethodImpl(256 | 512)]
    public static float3_mt ceil([This] float3_mt a) => new(a.x.floor(), a.y.floor(), a.z.floor());

    [MethodImpl(256 | 512)]
    public static float3_mt floor([This] float3_mt a) => new(a.x.floor(), a.y.floor(), a.z.floor());

    [MethodImpl(256 | 512)]
    public static float3_mt round([This] float3_mt a) => new(a.x.round(), a.y.round(), a.z.round());

    [MethodImpl(256 | 512)]
    public static float3_mt trunc([This] float3_mt a) => new(a.x.trunc(), a.y.trunc(), a.z.trunc());

    [MethodImpl(256 | 512)]
    public static float3_mt mod([This] float3_mt a, float3_mt b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt mod([This] float_mt a, float3_mt b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt mod([This] float3_mt a, float_mt b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt mod([This] float a, float3_mt b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt mod([This] float3_mt a, float b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt rem([This] float3_mt a, float3_mt b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt rem([This] float_mt a, float3_mt b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt rem([This] float3_mt a, float_mt b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt rem([This] float a, float3_mt b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt rem([This] float3_mt a, float b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt frac([This] float3_mt a) => a - floor(a);

    [MethodImpl(256 | 512)]
    public static float3_mt modf([This] float3_mt d, out float3_mt i)
    {
        i = trunc(d);
        return d - i;
    }

    [MethodImpl(256 | 512)]
    public static float3_mt rcp([This] float3_mt a) => new(rcp(a.x), rcp(a.y), rcp(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt saturate([This] float3_mt a) => a.clamp(default, float3_mt.One);

    [MethodImpl(256 | 512)]
    public static float3_mt smoothstep(float3_mt min, float3_mt max, [This] float3_mt a)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * fnma(2.0f, t, 3.0f); // (3.0f - (2.0f * t))
    }

    [MethodImpl(256 | 512)]
    public static float3_mt reflect([This] float3_mt i, float3_mt n)
    {
        // i - 2f * n * dot(i, n);
        return fnma(2f * n, dot(i, n), i);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt project([This] float3_mt a, float3_mt onto) =>
        dot(a, onto) / dot(onto, onto) * onto;

    [MethodImpl(256 | 512)]
    public static float3_mt projectOnPlane([This] float3_mt a, float3_mt plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static float3_mt projectNormalized([This] float3_mt a, float3_mt onto) =>
        dot(a, onto) * onto;

    [MethodImpl(256 | 512)]
    public static float3_mt projectOnPlaneNormalized([This] float3_mt a, float3_mt plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static float3_mt radians([This] float3_mt a) => a * 0.0174532925199432957692369076848861271344287188854172545609719144f;

    [MethodImpl(256 | 512)]
    public static float3_mt degrees([This] float3_mt a) => a * 57.295779513082320876798154814105170332405472466564321549160243861f;

    [MethodImpl(256 | 512)]
    public static float3_mt wrap([This] float3_mt x, float3_mt min, float3_mt max)
    {
        var add = select(x >= float3_mt.Zero, min, max);
        var off = x % (max - min);
        return add + off;
    }

    [MethodImpl(256 | 512)]
    public static float3_mt wrap([This] float3_mt x, float_mt min, float_mt max)
    {
        var add = select(x >= float3_mt.Zero, min, max);
        var off = x % (max - min);
        return add + off;
    }

    [MethodImpl(256 | 512)]
    public static float3_mt wrap([This] float3_mt x, float min, float max)
    {
        var add = select(x >= float3_mt.Zero, min, max);
        var off = x % (max - min);
        return add + off;
    }

    [MethodImpl(256 | 512)]
    public static float3_mt log([This] float3_mt a) => new(log(a.x), log(a.y), log(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt log2([This] float3_mt a) => new(log2(a.x), log2(a.y), log2(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt log([This] float3_mt a, float3_mt b) => new(log(a.x, b.x), log(a.y, b.y), log(a.z, b.z));

    [MethodImpl(256 | 512)]
    public static float3_mt log([This] float3_mt a, float_mt b) => new(log(a.x, b), log(a.y, b), log(a.z, b));

    [MethodImpl(256 | 512)]
    public static float3_mt log([This] float_mt a, float3_mt b) => new(log(a, b.x), log(a, b.y), log(a, b.z));

    [MethodImpl(256 | 512)]
    public static float3_mt log10([This] float3_mt a) => new(log10(a.x), log10(a.y), log10(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt exp([This] float3_mt a) => new(exp(a.x), exp(a.y), exp(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt exp2([This] float3_mt a) => new(exp2(a.x), exp2(a.y), exp2(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt exp10([This] float3_mt a) => new(exp10(a.x), exp10(a.y), exp10(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt pow([This] float3_mt a, float3_mt b) => new(pow(a.x, b.x), pow(a.y, b.y), pow(a.z, b.z));

    [MethodImpl(256 | 512)]
    public static float3_mt pow([This] float3_mt a, float_mt b) => new(pow(a.x, b), pow(a.y, b), pow(a.z, b));

    [MethodImpl(256 | 512)]
    public static float3_mt pow([This] float3_mt a, float b) => new(pow(a.x, b), pow(a.y, b), pow(a.z, b));

    [MethodImpl(256 | 512)]
    public static float3_mt sqrt([This] float3_mt a) => new(sqrt(a.x), sqrt(a.y), sqrt(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt rsqrt([This] float3_mt a) => new(rsqrt(a.x), rsqrt(a.y), rsqrt(a.z));

    [MethodImpl(256 | 512)]
    public static float_mt length([This] float3_mt a) => dot(a, a).sqrt();

    [MethodImpl(256 | 512)]
    public static float_mt distance([This] float3_mt a, float3_mt b) => length(b - a);

    [MethodImpl(256 | 512)]
    public static float3_mt normalize([This] float3_mt a) => a * dot(a, a).rsqrt();

    [MethodImpl(256 | 512)]
    public static float3_mt normalizeSafe([This] float3_mt a, float3_mt defaultValue = default)
    {
        var len = dot(a, a);
        return select(len > 1.175494351e-38f, a * rsqrt(len), defaultValue);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt step(float3_mt threshold, [This] float3_mt a) =>
        select(a >= threshold, float3_mt.One, default);

    [MethodImpl(256 | 512)]
    public static float3_mt refract(float3_mt i, float3_mt n, [This] float indexOfRefraction)
    {
        var ni = dot(n, i);
        var k = (float_mt)(1.0f - indexOfRefraction * indexOfRefraction * (1.0f - ni * ni));
        return select(k >= 0.0f, indexOfRefraction * i - (float_mt)((float_mt)(indexOfRefraction * ni) + sqrt(k)) * n, default);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt projectSafe([This] float3_mt a, float3_mt onto, float3_mt defaultValue = default) 
    {
        var proj = project(a, onto);
        return select(all(isFinite(proj)), proj, defaultValue);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt faceForward([This] float3_mt n, float3_mt i, float3_mt ng) =>
        select(dot(ng, i) >= 0.0f, -n, n);

    [MethodImpl(256 | 512)]
    public static float3_mt sin([This] float3_mt a) => new(sin(a.x), sin(a.y), sin(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt cos([This] float3_mt a) => new(cos(a.x), cos(a.y), cos(a.z));

    [MethodImpl(256 | 512)]
    public static (float3_mt sin, float3_mt cos) sincos([This] float3_mt a)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        var (sin_z, cos_z) = sincos(a.z);
        return (
            new(sin_x, sin_y, sin_z),
            new(cos_x, cos_y, cos_z)
        );
    }

    [MethodImpl(256 | 512)]
    public static void sincos([This] float3_mt a, out float3_mt sin, out float3_mt cos)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        var (sin_z, cos_z) = sincos(a.z);
        sin = new(sin_x, sin_y, sin_z);
        cos = new(cos_x, cos_y, cos_z);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt tan([This] float3_mt a) => new(tan(a.x), tan(a.y), tan(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt asin([This] float3_mt a) => new(asin(a.x), asin(a.y), asin(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt acos([This] float3_mt a) => new(acos(a.x), acos(a.y), acos(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt atan([This] float3_mt a) => new(atan(a.x), atan(a.y), atan(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt atan2([This] float3_mt a, float3_mt b) => new(atan2(a.x, b.x), atan2(a.y, b.y), atan2(a.z, b.z));

    [MethodImpl(256 | 512)]
    public static float3_mt sinh([This] float3_mt a) => new(sinh(a.x), sinh(a.y), sinh(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt cosh([This] float3_mt a) => new(cosh(a.x), cosh(a.y), cosh(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt tanh([This] float3_mt a) => new(tanh(a.x), tanh(a.y), tanh(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt asinh([This] float3_mt a) => new(asinh(a.x), asinh(a.y), asinh(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt acosh([This] float3_mt a) => new(acosh(a.x), acosh(a.y), acosh(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt atanh([This] float3_mt a) => new(atanh(a.x), atanh(a.y), atanh(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt chgsign([This] float3_mt a, float3_mt b) => new(chgsign(a.x, b.x), chgsign(a.y, b.y), chgsign(a.z, b.z));
}

#endregion // float3_mt
#region float4_mt

public partial struct float4_mt
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static float4_mt E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277f); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static float4_mt Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094f); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static float4_mt Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009f);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static float4_mt PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923f);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static float4_mt Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846f);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static float4_mt RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861f);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static float4_mt DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144f);
    }
}

[Ex]
public static partial class math_mt
{
    #pragma warning disable CS1718
    // ReSharper disable once EqualExpressionComparison
    [MethodImpl(256 | 512)]
    public static b32v4_mt isNaN([This] float4_mt a) => a != a;
    #pragma warning restore CS1718

    [MethodImpl(256 | 512)]
    public static b32v4_mt isFinite([This] float4_mt a) => abs(a) < float.PositiveInfinity;

    [MethodImpl(256 | 512)]
    public static b32v4_mt isInf([This] float4_mt a) => new(a.x.isInf(), a.y.isInf(), a.z.isInf(), a.w.isInf());

    [MethodImpl(256 | 512)]
    public static b32v4_mt isPosInf([This] float4_mt a) => a == float.PositiveInfinity;

    [MethodImpl(256 | 512)]
    public static b32v4_mt isNegInf([This] float4_mt a) => a == float.NegativeInfinity;

    [MethodImpl(256 | 512)]
    public static float4_mt ceil([This] float4_mt a) => new(a.x.floor(), a.y.floor(), a.z.floor(), a.w.floor());

    [MethodImpl(256 | 512)]
    public static float4_mt floor([This] float4_mt a) => new(a.x.floor(), a.y.floor(), a.z.floor(), a.w.floor());

    [MethodImpl(256 | 512)]
    public static float4_mt round([This] float4_mt a) => new(a.x.round(), a.y.round(), a.z.round(), a.w.round());

    [MethodImpl(256 | 512)]
    public static float4_mt trunc([This] float4_mt a) => new(a.x.trunc(), a.y.trunc(), a.z.trunc(), a.w.trunc());

    [MethodImpl(256 | 512)]
    public static float4_mt mod([This] float4_mt a, float4_mt b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt mod([This] float_mt a, float4_mt b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt mod([This] float4_mt a, float_mt b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt mod([This] float a, float4_mt b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt mod([This] float4_mt a, float b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt rem([This] float4_mt a, float4_mt b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt rem([This] float_mt a, float4_mt b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt rem([This] float4_mt a, float_mt b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt rem([This] float a, float4_mt b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt rem([This] float4_mt a, float b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt frac([This] float4_mt a) => a - floor(a);

    [MethodImpl(256 | 512)]
    public static float4_mt modf([This] float4_mt d, out float4_mt i)
    {
        i = trunc(d);
        return d - i;
    }

    [MethodImpl(256 | 512)]
    public static float4_mt rcp([This] float4_mt a) => new(rcp(a.x), rcp(a.y), rcp(a.z), rcp(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt saturate([This] float4_mt a) => a.clamp(default, float4_mt.One);

    [MethodImpl(256 | 512)]
    public static float4_mt smoothstep(float4_mt min, float4_mt max, [This] float4_mt a)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * fnma(2.0f, t, 3.0f); // (3.0f - (2.0f * t))
    }

    [MethodImpl(256 | 512)]
    public static float4_mt reflect([This] float4_mt i, float4_mt n)
    {
        // i - 2f * n * dot(i, n);
        return fnma(2f * n, dot(i, n), i);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt project([This] float4_mt a, float4_mt onto) =>
        dot(a, onto) / dot(onto, onto) * onto;

    [MethodImpl(256 | 512)]
    public static float4_mt projectOnPlane([This] float4_mt a, float4_mt plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static float4_mt projectNormalized([This] float4_mt a, float4_mt onto) =>
        dot(a, onto) * onto;

    [MethodImpl(256 | 512)]
    public static float4_mt projectOnPlaneNormalized([This] float4_mt a, float4_mt plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static float4_mt radians([This] float4_mt a) => a * 0.0174532925199432957692369076848861271344287188854172545609719144f;

    [MethodImpl(256 | 512)]
    public static float4_mt degrees([This] float4_mt a) => a * 57.295779513082320876798154814105170332405472466564321549160243861f;

    [MethodImpl(256 | 512)]
    public static float4_mt wrap([This] float4_mt x, float4_mt min, float4_mt max)
    {
        var add = select(x >= float4_mt.Zero, min, max);
        var off = x % (max - min);
        return add + off;
    }

    [MethodImpl(256 | 512)]
    public static float4_mt wrap([This] float4_mt x, float_mt min, float_mt max)
    {
        var add = select(x >= float4_mt.Zero, min, max);
        var off = x % (max - min);
        return add + off;
    }

    [MethodImpl(256 | 512)]
    public static float4_mt wrap([This] float4_mt x, float min, float max)
    {
        var add = select(x >= float4_mt.Zero, min, max);
        var off = x % (max - min);
        return add + off;
    }

    [MethodImpl(256 | 512)]
    public static float4_mt log([This] float4_mt a) => new(log(a.x), log(a.y), log(a.z), log(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt log2([This] float4_mt a) => new(log2(a.x), log2(a.y), log2(a.z), log2(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt log([This] float4_mt a, float4_mt b) => new(log(a.x, b.x), log(a.y, b.y), log(a.z, b.z), log(a.w, b.w));

    [MethodImpl(256 | 512)]
    public static float4_mt log([This] float4_mt a, float_mt b) => new(log(a.x, b), log(a.y, b), log(a.z, b), log(a.w, b));

    [MethodImpl(256 | 512)]
    public static float4_mt log([This] float_mt a, float4_mt b) => new(log(a, b.x), log(a, b.y), log(a, b.z), log(a, b.w));

    [MethodImpl(256 | 512)]
    public static float4_mt log10([This] float4_mt a) => new(log10(a.x), log10(a.y), log10(a.z), log10(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt exp([This] float4_mt a) => new(exp(a.x), exp(a.y), exp(a.z), exp(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt exp2([This] float4_mt a) => new(exp2(a.x), exp2(a.y), exp2(a.z), exp2(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt exp10([This] float4_mt a) => new(exp10(a.x), exp10(a.y), exp10(a.z), exp10(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt pow([This] float4_mt a, float4_mt b) => new(pow(a.x, b.x), pow(a.y, b.y), pow(a.z, b.z), pow(a.w, b.w));

    [MethodImpl(256 | 512)]
    public static float4_mt pow([This] float4_mt a, float_mt b) => new(pow(a.x, b), pow(a.y, b), pow(a.z, b), pow(a.w, b));

    [MethodImpl(256 | 512)]
    public static float4_mt pow([This] float4_mt a, float b) => new(pow(a.x, b), pow(a.y, b), pow(a.z, b), pow(a.w, b));

    [MethodImpl(256 | 512)]
    public static float4_mt sqrt([This] float4_mt a) => new(sqrt(a.x), sqrt(a.y), sqrt(a.z), sqrt(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt rsqrt([This] float4_mt a) => new(rsqrt(a.x), rsqrt(a.y), rsqrt(a.z), rsqrt(a.w));

    [MethodImpl(256 | 512)]
    public static float_mt length([This] float4_mt a) => dot(a, a).sqrt();

    [MethodImpl(256 | 512)]
    public static float_mt distance([This] float4_mt a, float4_mt b) => length(b - a);

    [MethodImpl(256 | 512)]
    public static float4_mt normalize([This] float4_mt a) => a * dot(a, a).rsqrt();

    [MethodImpl(256 | 512)]
    public static float4_mt normalizeSafe([This] float4_mt a, float4_mt defaultValue = default)
    {
        var len = dot(a, a);
        return select(len > 1.175494351e-38f, a * rsqrt(len), defaultValue);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt step(float4_mt threshold, [This] float4_mt a) =>
        select(a >= threshold, float4_mt.One, default);

    [MethodImpl(256 | 512)]
    public static float4_mt refract(float4_mt i, float4_mt n, [This] float indexOfRefraction)
    {
        var ni = dot(n, i);
        var k = (float_mt)(1.0f - indexOfRefraction * indexOfRefraction * (1.0f - ni * ni));
        return select(k >= 0.0f, indexOfRefraction * i - (float_mt)((float_mt)(indexOfRefraction * ni) + sqrt(k)) * n, default);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt projectSafe([This] float4_mt a, float4_mt onto, float4_mt defaultValue = default) 
    {
        var proj = project(a, onto);
        return select(all(isFinite(proj)), proj, defaultValue);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt faceForward([This] float4_mt n, float4_mt i, float4_mt ng) =>
        select(dot(ng, i) >= 0.0f, -n, n);

    [MethodImpl(256 | 512)]
    public static float4_mt sin([This] float4_mt a) => new(sin(a.x), sin(a.y), sin(a.z), sin(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt cos([This] float4_mt a) => new(cos(a.x), cos(a.y), cos(a.z), cos(a.w));

    [MethodImpl(256 | 512)]
    public static (float4_mt sin, float4_mt cos) sincos([This] float4_mt a)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        var (sin_z, cos_z) = sincos(a.z);
        var (sin_w, cos_w) = sincos(a.w);
        return (
            new(sin_x, sin_y, sin_z, sin_w),
            new(cos_x, cos_y, cos_z, cos_w)
        );
    }

    [MethodImpl(256 | 512)]
    public static void sincos([This] float4_mt a, out float4_mt sin, out float4_mt cos)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        var (sin_z, cos_z) = sincos(a.z);
        var (sin_w, cos_w) = sincos(a.w);
        sin = new(sin_x, sin_y, sin_z, sin_w);
        cos = new(cos_x, cos_y, cos_z, cos_w);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt tan([This] float4_mt a) => new(tan(a.x), tan(a.y), tan(a.z), tan(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt asin([This] float4_mt a) => new(asin(a.x), asin(a.y), asin(a.z), asin(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt acos([This] float4_mt a) => new(acos(a.x), acos(a.y), acos(a.z), acos(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt atan([This] float4_mt a) => new(atan(a.x), atan(a.y), atan(a.z), atan(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt atan2([This] float4_mt a, float4_mt b) => new(atan2(a.x, b.x), atan2(a.y, b.y), atan2(a.z, b.z), atan2(a.w, b.w));

    [MethodImpl(256 | 512)]
    public static float4_mt sinh([This] float4_mt a) => new(sinh(a.x), sinh(a.y), sinh(a.z), sinh(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt cosh([This] float4_mt a) => new(cosh(a.x), cosh(a.y), cosh(a.z), cosh(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt tanh([This] float4_mt a) => new(tanh(a.x), tanh(a.y), tanh(a.z), tanh(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt asinh([This] float4_mt a) => new(asinh(a.x), asinh(a.y), asinh(a.z), asinh(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt acosh([This] float4_mt a) => new(acosh(a.x), acosh(a.y), acosh(a.z), acosh(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt atanh([This] float4_mt a) => new(atanh(a.x), atanh(a.y), atanh(a.z), atanh(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt chgsign([This] float4_mt a, float4_mt b) => new(chgsign(a.x, b.x), chgsign(a.y, b.y), chgsign(a.z, b.z), chgsign(a.w, b.w));
}

#endregion // float4_mt
#region double2_mt

public partial struct double2_mt
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static double2_mt E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static double2_mt Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static double2_mt Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static double2_mt PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static double2_mt Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static double2_mt RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static double2_mt DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144);
    }
}

[Ex]
public static partial class math_mt
{
    #pragma warning disable CS1718
    // ReSharper disable once EqualExpressionComparison
    [MethodImpl(256 | 512)]
    public static b64v2_mt isNaN([This] double2_mt a) => a != a;
    #pragma warning restore CS1718

    [MethodImpl(256 | 512)]
    public static b64v2_mt isFinite([This] double2_mt a) => abs(a) < double.PositiveInfinity;

    [MethodImpl(256 | 512)]
    public static b64v2_mt isInf([This] double2_mt a) => new(a.x.isInf(), a.y.isInf());

    [MethodImpl(256 | 512)]
    public static b64v2_mt isPosInf([This] double2_mt a) => a == double.PositiveInfinity;

    [MethodImpl(256 | 512)]
    public static b64v2_mt isNegInf([This] double2_mt a) => a == double.NegativeInfinity;

    [MethodImpl(256 | 512)]
    public static double2_mt ceil([This] double2_mt a) => new(a.x.floor(), a.y.floor());

    [MethodImpl(256 | 512)]
    public static double2_mt floor([This] double2_mt a) => new(a.x.floor(), a.y.floor());

    [MethodImpl(256 | 512)]
    public static double2_mt round([This] double2_mt a) => new(a.x.round(), a.y.round());

    [MethodImpl(256 | 512)]
    public static double2_mt trunc([This] double2_mt a) => new(a.x.trunc(), a.y.trunc());

    [MethodImpl(256 | 512)]
    public static double2_mt mod([This] double2_mt a, double2_mt b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt mod([This] double_mt a, double2_mt b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt mod([This] double2_mt a, double_mt b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt mod([This] double a, double2_mt b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt mod([This] double2_mt a, double b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt rem([This] double2_mt a, double2_mt b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt rem([This] double_mt a, double2_mt b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt rem([This] double2_mt a, double_mt b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt rem([This] double a, double2_mt b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt rem([This] double2_mt a, double b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt frac([This] double2_mt a) => a - floor(a);

    [MethodImpl(256 | 512)]
    public static double2_mt modf([This] double2_mt d, out double2_mt i)
    {
        i = trunc(d);
        return d - i;
    }

    [MethodImpl(256 | 512)]
    public static double2_mt rcp([This] double2_mt a) => new(rcp(a.x), rcp(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt saturate([This] double2_mt a) => a.clamp(default, double2_mt.One);

    [MethodImpl(256 | 512)]
    public static double2_mt smoothstep(double2_mt min, double2_mt max, [This] double2_mt a)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * fnma(2.0, t, 3.0); // (3.0 - (2.0 * t))
    }

    [MethodImpl(256 | 512)]
    public static double2_mt reflect([This] double2_mt i, double2_mt n)
    {
        // i - 2 * n * dot(i, n);
        return fnma(2 * n, dot(i, n), i);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt project([This] double2_mt a, double2_mt onto) =>
        dot(a, onto) / dot(onto, onto) * onto;

    [MethodImpl(256 | 512)]
    public static double2_mt projectOnPlane([This] double2_mt a, double2_mt plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static double2_mt projectNormalized([This] double2_mt a, double2_mt onto) =>
        dot(a, onto) * onto;

    [MethodImpl(256 | 512)]
    public static double2_mt projectOnPlaneNormalized([This] double2_mt a, double2_mt plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static double2_mt radians([This] double2_mt a) => a * 0.0174532925199432957692369076848861271344287188854172545609719144;

    [MethodImpl(256 | 512)]
    public static double2_mt degrees([This] double2_mt a) => a * 57.295779513082320876798154814105170332405472466564321549160243861;

    [MethodImpl(256 | 512)]
    public static double2_mt wrap([This] double2_mt x, double2_mt min, double2_mt max)
    {
        var add = select(x >= double2_mt.Zero, min, max);
        var off = x % (max - min);
        return add + off;
    }

    [MethodImpl(256 | 512)]
    public static double2_mt wrap([This] double2_mt x, double_mt min, double_mt max)
    {
        var add = select(x >= double2_mt.Zero, min, max);
        var off = x % (max - min);
        return add + off;
    }

    [MethodImpl(256 | 512)]
    public static double2_mt wrap([This] double2_mt x, double min, double max)
    {
        var add = select(x >= double2_mt.Zero, min, max);
        var off = x % (max - min);
        return add + off;
    }

    [MethodImpl(256 | 512)]
    public static double2_mt log([This] double2_mt a) => new(log(a.x), log(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt log2([This] double2_mt a) => new(log2(a.x), log2(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt log([This] double2_mt a, double2_mt b) => new(log(a.x, b.x), log(a.y, b.y));

    [MethodImpl(256 | 512)]
    public static double2_mt log([This] double2_mt a, double_mt b) => new(log(a.x, b), log(a.y, b));

    [MethodImpl(256 | 512)]
    public static double2_mt log([This] double_mt a, double2_mt b) => new(log(a, b.x), log(a, b.y));

    [MethodImpl(256 | 512)]
    public static double2_mt log10([This] double2_mt a) => new(log10(a.x), log10(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt exp([This] double2_mt a) => new(exp(a.x), exp(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt exp2([This] double2_mt a) => new(exp2(a.x), exp2(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt exp10([This] double2_mt a) => new(exp10(a.x), exp10(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt pow([This] double2_mt a, double2_mt b) => new(pow(a.x, b.x), pow(a.y, b.y));

    [MethodImpl(256 | 512)]
    public static double2_mt pow([This] double2_mt a, double_mt b) => new(pow(a.x, b), pow(a.y, b));

    [MethodImpl(256 | 512)]
    public static double2_mt pow([This] double2_mt a, double b) => new(pow(a.x, b), pow(a.y, b));

    [MethodImpl(256 | 512)]
    public static double2_mt sqrt([This] double2_mt a) => new(sqrt(a.x), sqrt(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt rsqrt([This] double2_mt a) => new(rsqrt(a.x), rsqrt(a.y));

    [MethodImpl(256 | 512)]
    public static double_mt length([This] double2_mt a) => dot(a, a).sqrt();

    [MethodImpl(256 | 512)]
    public static double_mt distance([This] double2_mt a, double2_mt b) => length(b - a);

    [MethodImpl(256 | 512)]
    public static double2_mt normalize([This] double2_mt a) => a * dot(a, a).rsqrt();

    [MethodImpl(256 | 512)]
    public static double2_mt normalizeSafe([This] double2_mt a, double2_mt defaultValue = default)
    {
        var len = dot(a, a);
        return select(len > 1.175494351e-38, a * rsqrt(len), defaultValue);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt step(double2_mt threshold, [This] double2_mt a) =>
        select(a >= threshold, double2_mt.One, default);

    [MethodImpl(256 | 512)]
    public static double2_mt refract(double2_mt i, double2_mt n, [This] double indexOfRefraction)
    {
        var ni = dot(n, i);
        var k = (double_mt)(1.0 - indexOfRefraction * indexOfRefraction * (1.0 - ni * ni));
        return select(k >= 0.0, indexOfRefraction * i - (double_mt)((double_mt)(indexOfRefraction * ni) + sqrt(k)) * n, default);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt projectSafe([This] double2_mt a, double2_mt onto, double2_mt defaultValue = default) 
    {
        var proj = project(a, onto);
        return select(all(isFinite(proj)), proj, defaultValue);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt faceForward([This] double2_mt n, double2_mt i, double2_mt ng) =>
        select(dot(ng, i) >= 0.0, -n, n);

    [MethodImpl(256 | 512)]
    public static double2_mt sin([This] double2_mt a) => new(sin(a.x), sin(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt cos([This] double2_mt a) => new(cos(a.x), cos(a.y));

    [MethodImpl(256 | 512)]
    public static (double2_mt sin, double2_mt cos) sincos([This] double2_mt a)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        return (
            new(sin_x, sin_y),
            new(cos_x, cos_y)
        );
    }

    [MethodImpl(256 | 512)]
    public static void sincos([This] double2_mt a, out double2_mt sin, out double2_mt cos)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        sin = new(sin_x, sin_y);
        cos = new(cos_x, cos_y);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt tan([This] double2_mt a) => new(tan(a.x), tan(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt asin([This] double2_mt a) => new(asin(a.x), asin(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt acos([This] double2_mt a) => new(acos(a.x), acos(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt atan([This] double2_mt a) => new(atan(a.x), atan(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt atan2([This] double2_mt a, double2_mt b) => new(atan2(a.x, b.x), atan2(a.y, b.y));

    [MethodImpl(256 | 512)]
    public static double2_mt sinh([This] double2_mt a) => new(sinh(a.x), sinh(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt cosh([This] double2_mt a) => new(cosh(a.x), cosh(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt tanh([This] double2_mt a) => new(tanh(a.x), tanh(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt asinh([This] double2_mt a) => new(asinh(a.x), asinh(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt acosh([This] double2_mt a) => new(acosh(a.x), acosh(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt atanh([This] double2_mt a) => new(atanh(a.x), atanh(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt chgsign([This] double2_mt a, double2_mt b) => new(chgsign(a.x, b.x), chgsign(a.y, b.y));
}

#endregion // double2_mt
#region double3_mt

public partial struct double3_mt
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static double3_mt E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static double3_mt Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static double3_mt Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static double3_mt PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static double3_mt Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static double3_mt RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static double3_mt DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144);
    }
}

[Ex]
public static partial class math_mt
{
    #pragma warning disable CS1718
    // ReSharper disable once EqualExpressionComparison
    [MethodImpl(256 | 512)]
    public static b64v3_mt isNaN([This] double3_mt a) => a != a;
    #pragma warning restore CS1718

    [MethodImpl(256 | 512)]
    public static b64v3_mt isFinite([This] double3_mt a) => abs(a) < double.PositiveInfinity;

    [MethodImpl(256 | 512)]
    public static b64v3_mt isInf([This] double3_mt a) => new(a.x.isInf(), a.y.isInf(), a.z.isInf());

    [MethodImpl(256 | 512)]
    public static b64v3_mt isPosInf([This] double3_mt a) => a == double.PositiveInfinity;

    [MethodImpl(256 | 512)]
    public static b64v3_mt isNegInf([This] double3_mt a) => a == double.NegativeInfinity;

    [MethodImpl(256 | 512)]
    public static double3_mt ceil([This] double3_mt a) => new(a.x.floor(), a.y.floor(), a.z.floor());

    [MethodImpl(256 | 512)]
    public static double3_mt floor([This] double3_mt a) => new(a.x.floor(), a.y.floor(), a.z.floor());

    [MethodImpl(256 | 512)]
    public static double3_mt round([This] double3_mt a) => new(a.x.round(), a.y.round(), a.z.round());

    [MethodImpl(256 | 512)]
    public static double3_mt trunc([This] double3_mt a) => new(a.x.trunc(), a.y.trunc(), a.z.trunc());

    [MethodImpl(256 | 512)]
    public static double3_mt mod([This] double3_mt a, double3_mt b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt mod([This] double_mt a, double3_mt b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt mod([This] double3_mt a, double_mt b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt mod([This] double a, double3_mt b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt mod([This] double3_mt a, double b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt rem([This] double3_mt a, double3_mt b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt rem([This] double_mt a, double3_mt b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt rem([This] double3_mt a, double_mt b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt rem([This] double a, double3_mt b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt rem([This] double3_mt a, double b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt frac([This] double3_mt a) => a - floor(a);

    [MethodImpl(256 | 512)]
    public static double3_mt modf([This] double3_mt d, out double3_mt i)
    {
        i = trunc(d);
        return d - i;
    }

    [MethodImpl(256 | 512)]
    public static double3_mt rcp([This] double3_mt a) => new(rcp(a.x), rcp(a.y), rcp(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt saturate([This] double3_mt a) => a.clamp(default, double3_mt.One);

    [MethodImpl(256 | 512)]
    public static double3_mt smoothstep(double3_mt min, double3_mt max, [This] double3_mt a)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * fnma(2.0, t, 3.0); // (3.0 - (2.0 * t))
    }

    [MethodImpl(256 | 512)]
    public static double3_mt reflect([This] double3_mt i, double3_mt n)
    {
        // i - 2 * n * dot(i, n);
        return fnma(2 * n, dot(i, n), i);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt project([This] double3_mt a, double3_mt onto) =>
        dot(a, onto) / dot(onto, onto) * onto;

    [MethodImpl(256 | 512)]
    public static double3_mt projectOnPlane([This] double3_mt a, double3_mt plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static double3_mt projectNormalized([This] double3_mt a, double3_mt onto) =>
        dot(a, onto) * onto;

    [MethodImpl(256 | 512)]
    public static double3_mt projectOnPlaneNormalized([This] double3_mt a, double3_mt plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static double3_mt radians([This] double3_mt a) => a * 0.0174532925199432957692369076848861271344287188854172545609719144;

    [MethodImpl(256 | 512)]
    public static double3_mt degrees([This] double3_mt a) => a * 57.295779513082320876798154814105170332405472466564321549160243861;

    [MethodImpl(256 | 512)]
    public static double3_mt wrap([This] double3_mt x, double3_mt min, double3_mt max)
    {
        var add = select(x >= double3_mt.Zero, min, max);
        var off = x % (max - min);
        return add + off;
    }

    [MethodImpl(256 | 512)]
    public static double3_mt wrap([This] double3_mt x, double_mt min, double_mt max)
    {
        var add = select(x >= double3_mt.Zero, min, max);
        var off = x % (max - min);
        return add + off;
    }

    [MethodImpl(256 | 512)]
    public static double3_mt wrap([This] double3_mt x, double min, double max)
    {
        var add = select(x >= double3_mt.Zero, min, max);
        var off = x % (max - min);
        return add + off;
    }

    [MethodImpl(256 | 512)]
    public static double3_mt log([This] double3_mt a) => new(log(a.x), log(a.y), log(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt log2([This] double3_mt a) => new(log2(a.x), log2(a.y), log2(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt log([This] double3_mt a, double3_mt b) => new(log(a.x, b.x), log(a.y, b.y), log(a.z, b.z));

    [MethodImpl(256 | 512)]
    public static double3_mt log([This] double3_mt a, double_mt b) => new(log(a.x, b), log(a.y, b), log(a.z, b));

    [MethodImpl(256 | 512)]
    public static double3_mt log([This] double_mt a, double3_mt b) => new(log(a, b.x), log(a, b.y), log(a, b.z));

    [MethodImpl(256 | 512)]
    public static double3_mt log10([This] double3_mt a) => new(log10(a.x), log10(a.y), log10(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt exp([This] double3_mt a) => new(exp(a.x), exp(a.y), exp(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt exp2([This] double3_mt a) => new(exp2(a.x), exp2(a.y), exp2(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt exp10([This] double3_mt a) => new(exp10(a.x), exp10(a.y), exp10(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt pow([This] double3_mt a, double3_mt b) => new(pow(a.x, b.x), pow(a.y, b.y), pow(a.z, b.z));

    [MethodImpl(256 | 512)]
    public static double3_mt pow([This] double3_mt a, double_mt b) => new(pow(a.x, b), pow(a.y, b), pow(a.z, b));

    [MethodImpl(256 | 512)]
    public static double3_mt pow([This] double3_mt a, double b) => new(pow(a.x, b), pow(a.y, b), pow(a.z, b));

    [MethodImpl(256 | 512)]
    public static double3_mt sqrt([This] double3_mt a) => new(sqrt(a.x), sqrt(a.y), sqrt(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt rsqrt([This] double3_mt a) => new(rsqrt(a.x), rsqrt(a.y), rsqrt(a.z));

    [MethodImpl(256 | 512)]
    public static double_mt length([This] double3_mt a) => dot(a, a).sqrt();

    [MethodImpl(256 | 512)]
    public static double_mt distance([This] double3_mt a, double3_mt b) => length(b - a);

    [MethodImpl(256 | 512)]
    public static double3_mt normalize([This] double3_mt a) => a * dot(a, a).rsqrt();

    [MethodImpl(256 | 512)]
    public static double3_mt normalizeSafe([This] double3_mt a, double3_mt defaultValue = default)
    {
        var len = dot(a, a);
        return select(len > 1.175494351e-38, a * rsqrt(len), defaultValue);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt step(double3_mt threshold, [This] double3_mt a) =>
        select(a >= threshold, double3_mt.One, default);

    [MethodImpl(256 | 512)]
    public static double3_mt refract(double3_mt i, double3_mt n, [This] double indexOfRefraction)
    {
        var ni = dot(n, i);
        var k = (double_mt)(1.0 - indexOfRefraction * indexOfRefraction * (1.0 - ni * ni));
        return select(k >= 0.0, indexOfRefraction * i - (double_mt)((double_mt)(indexOfRefraction * ni) + sqrt(k)) * n, default);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt projectSafe([This] double3_mt a, double3_mt onto, double3_mt defaultValue = default) 
    {
        var proj = project(a, onto);
        return select(all(isFinite(proj)), proj, defaultValue);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt faceForward([This] double3_mt n, double3_mt i, double3_mt ng) =>
        select(dot(ng, i) >= 0.0, -n, n);

    [MethodImpl(256 | 512)]
    public static double3_mt sin([This] double3_mt a) => new(sin(a.x), sin(a.y), sin(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt cos([This] double3_mt a) => new(cos(a.x), cos(a.y), cos(a.z));

    [MethodImpl(256 | 512)]
    public static (double3_mt sin, double3_mt cos) sincos([This] double3_mt a)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        var (sin_z, cos_z) = sincos(a.z);
        return (
            new(sin_x, sin_y, sin_z),
            new(cos_x, cos_y, cos_z)
        );
    }

    [MethodImpl(256 | 512)]
    public static void sincos([This] double3_mt a, out double3_mt sin, out double3_mt cos)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        var (sin_z, cos_z) = sincos(a.z);
        sin = new(sin_x, sin_y, sin_z);
        cos = new(cos_x, cos_y, cos_z);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt tan([This] double3_mt a) => new(tan(a.x), tan(a.y), tan(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt asin([This] double3_mt a) => new(asin(a.x), asin(a.y), asin(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt acos([This] double3_mt a) => new(acos(a.x), acos(a.y), acos(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt atan([This] double3_mt a) => new(atan(a.x), atan(a.y), atan(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt atan2([This] double3_mt a, double3_mt b) => new(atan2(a.x, b.x), atan2(a.y, b.y), atan2(a.z, b.z));

    [MethodImpl(256 | 512)]
    public static double3_mt sinh([This] double3_mt a) => new(sinh(a.x), sinh(a.y), sinh(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt cosh([This] double3_mt a) => new(cosh(a.x), cosh(a.y), cosh(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt tanh([This] double3_mt a) => new(tanh(a.x), tanh(a.y), tanh(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt asinh([This] double3_mt a) => new(asinh(a.x), asinh(a.y), asinh(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt acosh([This] double3_mt a) => new(acosh(a.x), acosh(a.y), acosh(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt atanh([This] double3_mt a) => new(atanh(a.x), atanh(a.y), atanh(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt chgsign([This] double3_mt a, double3_mt b) => new(chgsign(a.x, b.x), chgsign(a.y, b.y), chgsign(a.z, b.z));
}

#endregion // double3_mt
#region double4_mt

public partial struct double4_mt
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static double4_mt E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static double4_mt Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static double4_mt Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static double4_mt PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static double4_mt Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static double4_mt RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static double4_mt DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144);
    }
}

[Ex]
public static partial class math_mt
{
    #pragma warning disable CS1718
    // ReSharper disable once EqualExpressionComparison
    [MethodImpl(256 | 512)]
    public static b64v4_mt isNaN([This] double4_mt a) => a != a;
    #pragma warning restore CS1718

    [MethodImpl(256 | 512)]
    public static b64v4_mt isFinite([This] double4_mt a) => abs(a) < double.PositiveInfinity;

    [MethodImpl(256 | 512)]
    public static b64v4_mt isInf([This] double4_mt a) => new(a.x.isInf(), a.y.isInf(), a.z.isInf(), a.w.isInf());

    [MethodImpl(256 | 512)]
    public static b64v4_mt isPosInf([This] double4_mt a) => a == double.PositiveInfinity;

    [MethodImpl(256 | 512)]
    public static b64v4_mt isNegInf([This] double4_mt a) => a == double.NegativeInfinity;

    [MethodImpl(256 | 512)]
    public static double4_mt ceil([This] double4_mt a) => new(a.x.floor(), a.y.floor(), a.z.floor(), a.w.floor());

    [MethodImpl(256 | 512)]
    public static double4_mt floor([This] double4_mt a) => new(a.x.floor(), a.y.floor(), a.z.floor(), a.w.floor());

    [MethodImpl(256 | 512)]
    public static double4_mt round([This] double4_mt a) => new(a.x.round(), a.y.round(), a.z.round(), a.w.round());

    [MethodImpl(256 | 512)]
    public static double4_mt trunc([This] double4_mt a) => new(a.x.trunc(), a.y.trunc(), a.z.trunc(), a.w.trunc());

    [MethodImpl(256 | 512)]
    public static double4_mt mod([This] double4_mt a, double4_mt b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt mod([This] double_mt a, double4_mt b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt mod([This] double4_mt a, double_mt b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt mod([This] double a, double4_mt b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt mod([This] double4_mt a, double b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = floor(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt rem([This] double4_mt a, double4_mt b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt rem([This] double_mt a, double4_mt b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt rem([This] double4_mt a, double_mt b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt rem([This] double a, double4_mt b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt rem([This] double4_mt a, double b)
    {
        var x = a;
        var y = b;
        var div = x / y;
        var flr = trunc(div);
        return fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt frac([This] double4_mt a) => a - floor(a);

    [MethodImpl(256 | 512)]
    public static double4_mt modf([This] double4_mt d, out double4_mt i)
    {
        i = trunc(d);
        return d - i;
    }

    [MethodImpl(256 | 512)]
    public static double4_mt rcp([This] double4_mt a) => new(rcp(a.x), rcp(a.y), rcp(a.z), rcp(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt saturate([This] double4_mt a) => a.clamp(default, double4_mt.One);

    [MethodImpl(256 | 512)]
    public static double4_mt smoothstep(double4_mt min, double4_mt max, [This] double4_mt a)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * fnma(2.0, t, 3.0); // (3.0 - (2.0 * t))
    }

    [MethodImpl(256 | 512)]
    public static double4_mt reflect([This] double4_mt i, double4_mt n)
    {
        // i - 2 * n * dot(i, n);
        return fnma(2 * n, dot(i, n), i);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt project([This] double4_mt a, double4_mt onto) =>
        dot(a, onto) / dot(onto, onto) * onto;

    [MethodImpl(256 | 512)]
    public static double4_mt projectOnPlane([This] double4_mt a, double4_mt plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static double4_mt projectNormalized([This] double4_mt a, double4_mt onto) =>
        dot(a, onto) * onto;

    [MethodImpl(256 | 512)]
    public static double4_mt projectOnPlaneNormalized([This] double4_mt a, double4_mt plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static double4_mt radians([This] double4_mt a) => a * 0.0174532925199432957692369076848861271344287188854172545609719144;

    [MethodImpl(256 | 512)]
    public static double4_mt degrees([This] double4_mt a) => a * 57.295779513082320876798154814105170332405472466564321549160243861;

    [MethodImpl(256 | 512)]
    public static double4_mt wrap([This] double4_mt x, double4_mt min, double4_mt max)
    {
        var add = select(x >= double4_mt.Zero, min, max);
        var off = x % (max - min);
        return add + off;
    }

    [MethodImpl(256 | 512)]
    public static double4_mt wrap([This] double4_mt x, double_mt min, double_mt max)
    {
        var add = select(x >= double4_mt.Zero, min, max);
        var off = x % (max - min);
        return add + off;
    }

    [MethodImpl(256 | 512)]
    public static double4_mt wrap([This] double4_mt x, double min, double max)
    {
        var add = select(x >= double4_mt.Zero, min, max);
        var off = x % (max - min);
        return add + off;
    }

    [MethodImpl(256 | 512)]
    public static double4_mt log([This] double4_mt a) => new(log(a.x), log(a.y), log(a.z), log(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt log2([This] double4_mt a) => new(log2(a.x), log2(a.y), log2(a.z), log2(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt log([This] double4_mt a, double4_mt b) => new(log(a.x, b.x), log(a.y, b.y), log(a.z, b.z), log(a.w, b.w));

    [MethodImpl(256 | 512)]
    public static double4_mt log([This] double4_mt a, double_mt b) => new(log(a.x, b), log(a.y, b), log(a.z, b), log(a.w, b));

    [MethodImpl(256 | 512)]
    public static double4_mt log([This] double_mt a, double4_mt b) => new(log(a, b.x), log(a, b.y), log(a, b.z), log(a, b.w));

    [MethodImpl(256 | 512)]
    public static double4_mt log10([This] double4_mt a) => new(log10(a.x), log10(a.y), log10(a.z), log10(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt exp([This] double4_mt a) => new(exp(a.x), exp(a.y), exp(a.z), exp(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt exp2([This] double4_mt a) => new(exp2(a.x), exp2(a.y), exp2(a.z), exp2(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt exp10([This] double4_mt a) => new(exp10(a.x), exp10(a.y), exp10(a.z), exp10(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt pow([This] double4_mt a, double4_mt b) => new(pow(a.x, b.x), pow(a.y, b.y), pow(a.z, b.z), pow(a.w, b.w));

    [MethodImpl(256 | 512)]
    public static double4_mt pow([This] double4_mt a, double_mt b) => new(pow(a.x, b), pow(a.y, b), pow(a.z, b), pow(a.w, b));

    [MethodImpl(256 | 512)]
    public static double4_mt pow([This] double4_mt a, double b) => new(pow(a.x, b), pow(a.y, b), pow(a.z, b), pow(a.w, b));

    [MethodImpl(256 | 512)]
    public static double4_mt sqrt([This] double4_mt a) => new(sqrt(a.x), sqrt(a.y), sqrt(a.z), sqrt(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt rsqrt([This] double4_mt a) => new(rsqrt(a.x), rsqrt(a.y), rsqrt(a.z), rsqrt(a.w));

    [MethodImpl(256 | 512)]
    public static double_mt length([This] double4_mt a) => dot(a, a).sqrt();

    [MethodImpl(256 | 512)]
    public static double_mt distance([This] double4_mt a, double4_mt b) => length(b - a);

    [MethodImpl(256 | 512)]
    public static double4_mt normalize([This] double4_mt a) => a * dot(a, a).rsqrt();

    [MethodImpl(256 | 512)]
    public static double4_mt normalizeSafe([This] double4_mt a, double4_mt defaultValue = default)
    {
        var len = dot(a, a);
        return select(len > 1.175494351e-38, a * rsqrt(len), defaultValue);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt step(double4_mt threshold, [This] double4_mt a) =>
        select(a >= threshold, double4_mt.One, default);

    [MethodImpl(256 | 512)]
    public static double4_mt refract(double4_mt i, double4_mt n, [This] double indexOfRefraction)
    {
        var ni = dot(n, i);
        var k = (double_mt)(1.0 - indexOfRefraction * indexOfRefraction * (1.0 - ni * ni));
        return select(k >= 0.0, indexOfRefraction * i - (double_mt)((double_mt)(indexOfRefraction * ni) + sqrt(k)) * n, default);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt projectSafe([This] double4_mt a, double4_mt onto, double4_mt defaultValue = default) 
    {
        var proj = project(a, onto);
        return select(all(isFinite(proj)), proj, defaultValue);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt faceForward([This] double4_mt n, double4_mt i, double4_mt ng) =>
        select(dot(ng, i) >= 0.0, -n, n);

    [MethodImpl(256 | 512)]
    public static double4_mt sin([This] double4_mt a) => new(sin(a.x), sin(a.y), sin(a.z), sin(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt cos([This] double4_mt a) => new(cos(a.x), cos(a.y), cos(a.z), cos(a.w));

    [MethodImpl(256 | 512)]
    public static (double4_mt sin, double4_mt cos) sincos([This] double4_mt a)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        var (sin_z, cos_z) = sincos(a.z);
        var (sin_w, cos_w) = sincos(a.w);
        return (
            new(sin_x, sin_y, sin_z, sin_w),
            new(cos_x, cos_y, cos_z, cos_w)
        );
    }

    [MethodImpl(256 | 512)]
    public static void sincos([This] double4_mt a, out double4_mt sin, out double4_mt cos)
    {
        var (sin_x, cos_x) = sincos(a.x);
        var (sin_y, cos_y) = sincos(a.y);
        var (sin_z, cos_z) = sincos(a.z);
        var (sin_w, cos_w) = sincos(a.w);
        sin = new(sin_x, sin_y, sin_z, sin_w);
        cos = new(cos_x, cos_y, cos_z, cos_w);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt tan([This] double4_mt a) => new(tan(a.x), tan(a.y), tan(a.z), tan(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt asin([This] double4_mt a) => new(asin(a.x), asin(a.y), asin(a.z), asin(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt acos([This] double4_mt a) => new(acos(a.x), acos(a.y), acos(a.z), acos(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt atan([This] double4_mt a) => new(atan(a.x), atan(a.y), atan(a.z), atan(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt atan2([This] double4_mt a, double4_mt b) => new(atan2(a.x, b.x), atan2(a.y, b.y), atan2(a.z, b.z), atan2(a.w, b.w));

    [MethodImpl(256 | 512)]
    public static double4_mt sinh([This] double4_mt a) => new(sinh(a.x), sinh(a.y), sinh(a.z), sinh(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt cosh([This] double4_mt a) => new(cosh(a.x), cosh(a.y), cosh(a.z), cosh(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt tanh([This] double4_mt a) => new(tanh(a.x), tanh(a.y), tanh(a.z), tanh(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt asinh([This] double4_mt a) => new(asinh(a.x), asinh(a.y), asinh(a.z), asinh(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt acosh([This] double4_mt a) => new(acosh(a.x), acosh(a.y), acosh(a.z), acosh(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt atanh([This] double4_mt a) => new(atanh(a.x), atanh(a.y), atanh(a.z), atanh(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt chgsign([This] double4_mt a, double4_mt b) => new(chgsign(a.x, b.x), chgsign(a.y, b.y), chgsign(a.z, b.z), chgsign(a.w, b.w));
}

#endregion // double4_mt
