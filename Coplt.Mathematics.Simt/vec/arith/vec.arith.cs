// generated by template, do not modify manually

namespace Coplt.Mathematics.Simt;

#region float2_mt

public partial struct float2_mt
{
    #region Constants

    public static float2_mt Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static float2_mt One
    {
        [MethodImpl(256 | 512)]
        get => new(1.0f);
    }

    public static float2_mt Two
    {
        [MethodImpl(256 | 512)]
        get => new(2.0f);
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static float2_mt operator-(float2_mt a) => new(-a.x, -a.y);

    [MethodImpl(256 | 512)]
    public static float2_mt operator+(float2_mt a, float2_mt b) => new(a.x + b.x, a.y + b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt operator+(float2_mt a, float_mt b) => new(a.x + b, a.y + b);

    [MethodImpl(256 | 512)]
    public static float2_mt operator+(float_mt a, float2_mt b) => new(a + b.x, a + b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt operator-(float2_mt a, float2_mt b) => new(a.x - b.x, a.y - b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt operator-(float2_mt a, float_mt b) => new(a.x - b, a.y - b);

    [MethodImpl(256 | 512)]
    public static float2_mt operator-(float_mt a, float2_mt b) => new(a - b.x, a - b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt operator*(float2_mt a, float2_mt b) => new(a.x * b.x, a.y * b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt operator*(float2_mt a, float_mt b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static float2_mt operator*(float_mt a, float2_mt b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt operator*(float2_mt a, float b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static float2_mt operator*(float a, float2_mt b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt operator/(float2_mt a, float2_mt b) => new(a.x / b.x, a.y / b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt operator/(float_mt a, float2_mt b) => new(a / b.x, a / b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt operator/(float2_mt a, float_mt b) => new(a.x / b, a.y / b);

    [MethodImpl(256 | 512)]
    public static float2_mt operator/(float a, float2_mt b) => new(a / b.x, a / b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt operator/(float2_mt a, float b) => new(a.x / b, a.y / b);

    [MethodImpl(256 | 512)]
    public static float2_mt operator%(float2_mt a, float2_mt b) => math_mt.rem(a, b);

    [MethodImpl(256 | 512)]
    public static float2_mt operator%(float_mt a, float2_mt b) => math_mt.rem(a, b);

    [MethodImpl(256 | 512)]
    public static float2_mt operator%(float2_mt a, float_mt b) => math_mt.rem(a, b);

    [MethodImpl(256 | 512)]
    public static float2_mt operator%(float a, float2_mt b) => math_mt.rem(a, b);

    [MethodImpl(256 | 512)]
    public static float2_mt operator%(float2_mt a, float b) => math_mt.rem(a, b);

    [MethodImpl(256 | 512)]
    public static float2_mt operator++(float2_mt a) => a + float_mt.One;

    [MethodImpl(256 | 512)]
    public static float2_mt operator--(float2_mt a) => a - float_mt.One;

    #endregion // Operators
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static float2_mt abs([This] float2_mt a) => new(abs(a.x), abs(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt sign([This] float2_mt a) => new(sign(a.x), sign(a.y));

    [MethodImpl(256 | 512)]
    public static float2_mt min([This] float2_mt a, float2_mt b) => new(min(a.x, b.x), min(a.y, b.y));

    [MethodImpl(256 | 512)]
    public static float2_mt max([This] float2_mt a, float2_mt b) => new(max(a.x, b.x), max(a.y, b.y));

    [MethodImpl(256 | 512)]
    public static float2_mt clamp([This] float2_mt v, float2_mt min, float2_mt max) => math_mt.max(min, math_mt.min(max, v));

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float2_mt fma([This] float2_mt a, float2_mt b, float2_mt c) => new(fma(a.x, b.x, c.x), fma(a.y, b.y, c.y));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static float2_mt fms([This] float2_mt a, float2_mt b, float2_mt c) => new(fms(a.x, b.x, c.x), fms(a.y, b.y, c.y));

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static float2_mt fnma([This] float2_mt a, float2_mt b, float2_mt c) => new(fnma(a.x, b.x, c.x), fnma(a.y, b.y, c.y));

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static float2_mt fsm([This] float2_mt c, float2_mt a, float2_mt b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float2_mt fam([This] float2_mt c, float2_mt a, float2_mt b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float2_mt mad([This] float2_mt a, float2_mt b, float2_mt c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static float2_mt lerp(float2_mt start, float2_mt end, [This] float2_mt t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt lerp(float2_mt start, float2_mt end, [This] float t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt lerp(float start, float end, [This] float2_mt t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static float2_mt unlerp([This] float2_mt a, float2_mt start, float2_mt end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static float2_mt unlerp([This] float a, float2_mt start, float2_mt end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static float2_mt unlerp([This] float2_mt a, float start, float end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static float2_mt remap([This] float2_mt a, float2_mt srcStart, float2_mt srcEnd, float2_mt dstStart, float2_mt dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static float2_mt remap([This] float2_mt a, float srcStart, float srcEnd, float dstStart, float dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static float2_mt square([This] float2_mt a) => a * a;

    [MethodImpl(256 | 512)]
    public static float_mt dot([This] float2_mt a, float2_mt b)
    {
        // a.x * b.x + a.y * b.y
        return fma(a.y, b.y, a.x * b.x);
    }

    [MethodImpl(256 | 512)]
    public static float_mt lengthsq([This] float2_mt a) => dot(a, a);

    [MethodImpl(256 | 512)]
    public static float_mt distancesq([This] float2_mt a, float2_mt b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static float_mt csum([This] float2_mt a) => a.x + a.y;

    [MethodImpl(256 | 512)]
    public static float_mt cmin([This] float2_mt a) => a.x.min(a.y);

    [MethodImpl(256 | 512)]
    public static float_mt cmax([This] float2_mt a) => a.x.max(a.y);

}

#endregion // float2_mt
#region float3_mt

public partial struct float3_mt
{
    #region Constants

    public static float3_mt Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static float3_mt One
    {
        [MethodImpl(256 | 512)]
        get => new(1.0f);
    }

    public static float3_mt Two
    {
        [MethodImpl(256 | 512)]
        get => new(2.0f);
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static float3_mt operator-(float3_mt a) => new(-a.x, -a.y, -a.z);

    [MethodImpl(256 | 512)]
    public static float3_mt operator+(float3_mt a, float3_mt b) => new(a.x + b.x, a.y + b.y, a.z + b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt operator+(float3_mt a, float_mt b) => new(a.x + b, a.y + b, a.z + b);

    [MethodImpl(256 | 512)]
    public static float3_mt operator+(float_mt a, float3_mt b) => new(a + b.x, a + b.y, a + b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt operator-(float3_mt a, float3_mt b) => new(a.x - b.x, a.y - b.y, a.z - b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt operator-(float3_mt a, float_mt b) => new(a.x - b, a.y - b, a.z - b);

    [MethodImpl(256 | 512)]
    public static float3_mt operator-(float_mt a, float3_mt b) => new(a - b.x, a - b.y, a - b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt operator*(float3_mt a, float3_mt b) => new(a.x * b.x, a.y * b.y, a.z * b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt operator*(float3_mt a, float_mt b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static float3_mt operator*(float_mt a, float3_mt b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt operator*(float3_mt a, float b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static float3_mt operator*(float a, float3_mt b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt operator/(float3_mt a, float3_mt b) => new(a.x / b.x, a.y / b.y, a.z / b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt operator/(float_mt a, float3_mt b) => new(a / b.x, a / b.y, a / b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt operator/(float3_mt a, float_mt b) => new(a.x / b, a.y / b, a.z / b);

    [MethodImpl(256 | 512)]
    public static float3_mt operator/(float a, float3_mt b) => new(a / b.x, a / b.y, a / b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt operator/(float3_mt a, float b) => new(a.x / b, a.y / b, a.z / b);

    [MethodImpl(256 | 512)]
    public static float3_mt operator%(float3_mt a, float3_mt b) => math_mt.rem(a, b);

    [MethodImpl(256 | 512)]
    public static float3_mt operator%(float_mt a, float3_mt b) => math_mt.rem(a, b);

    [MethodImpl(256 | 512)]
    public static float3_mt operator%(float3_mt a, float_mt b) => math_mt.rem(a, b);

    [MethodImpl(256 | 512)]
    public static float3_mt operator%(float a, float3_mt b) => math_mt.rem(a, b);

    [MethodImpl(256 | 512)]
    public static float3_mt operator%(float3_mt a, float b) => math_mt.rem(a, b);

    [MethodImpl(256 | 512)]
    public static float3_mt operator++(float3_mt a) => a + float_mt.One;

    [MethodImpl(256 | 512)]
    public static float3_mt operator--(float3_mt a) => a - float_mt.One;

    #endregion // Operators
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static float3_mt abs([This] float3_mt a) => new(abs(a.x), abs(a.y), abs(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt sign([This] float3_mt a) => new(sign(a.x), sign(a.y), sign(a.z));

    [MethodImpl(256 | 512)]
    public static float3_mt min([This] float3_mt a, float3_mt b) => new(min(a.x, b.x), min(a.y, b.y), min(a.z, b.z));

    [MethodImpl(256 | 512)]
    public static float3_mt max([This] float3_mt a, float3_mt b) => new(max(a.x, b.x), max(a.y, b.y), max(a.z, b.z));

    [MethodImpl(256 | 512)]
    public static float3_mt clamp([This] float3_mt v, float3_mt min, float3_mt max) => math_mt.max(min, math_mt.min(max, v));

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float3_mt fma([This] float3_mt a, float3_mt b, float3_mt c) => new(fma(a.x, b.x, c.x), fma(a.y, b.y, c.y), fma(a.z, b.z, c.z));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static float3_mt fms([This] float3_mt a, float3_mt b, float3_mt c) => new(fms(a.x, b.x, c.x), fms(a.y, b.y, c.y), fms(a.z, b.z, c.z));

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static float3_mt fnma([This] float3_mt a, float3_mt b, float3_mt c) => new(fnma(a.x, b.x, c.x), fnma(a.y, b.y, c.y), fnma(a.z, b.z, c.z));

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static float3_mt fsm([This] float3_mt c, float3_mt a, float3_mt b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float3_mt fam([This] float3_mt c, float3_mt a, float3_mt b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float3_mt mad([This] float3_mt a, float3_mt b, float3_mt c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static float3_mt lerp(float3_mt start, float3_mt end, [This] float3_mt t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt lerp(float3_mt start, float3_mt end, [This] float t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt lerp(float start, float end, [This] float3_mt t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static float3_mt unlerp([This] float3_mt a, float3_mt start, float3_mt end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static float3_mt unlerp([This] float a, float3_mt start, float3_mt end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static float3_mt unlerp([This] float3_mt a, float start, float end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static float3_mt remap([This] float3_mt a, float3_mt srcStart, float3_mt srcEnd, float3_mt dstStart, float3_mt dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static float3_mt remap([This] float3_mt a, float srcStart, float srcEnd, float dstStart, float dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static float3_mt square([This] float3_mt a) => a * a;

    [MethodImpl(256 | 512)]
    public static float_mt dot([This] float3_mt a, float3_mt b)
    {
        // a.x * b.x + a.y * b.y + a.z * b.z
        return fma(a.z, b.z, fma(a.y, b.y, a.x * b.x));
    }

    [MethodImpl(256 | 512)]
    public static float3_mt cross([This] float3_mt a, float3_mt b)
    {
        // (a * b.yzx - a.yzx * b).yzx;
        return fnma(a.yzx, b, a * b.yzx).yzx;
    }

    [MethodImpl(256 | 512)]
    public static float_mt lengthsq([This] float3_mt a) => dot(a, a);

    [MethodImpl(256 | 512)]
    public static float_mt distancesq([This] float3_mt a, float3_mt b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static float_mt csum([This] float3_mt a) => a.x + a.y + a.z;

    [MethodImpl(256 | 512)]
    public static float_mt cmin([This] float3_mt a) => a.x.min(a.y).min(a.z);

    [MethodImpl(256 | 512)]
    public static float_mt cmax([This] float3_mt a) => a.x.max(a.y).max(a.z);

}

#endregion // float3_mt
#region float4_mt

public partial struct float4_mt
{
    #region Constants

    public static float4_mt Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static float4_mt One
    {
        [MethodImpl(256 | 512)]
        get => new(1.0f);
    }

    public static float4_mt Two
    {
        [MethodImpl(256 | 512)]
        get => new(2.0f);
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static float4_mt operator-(float4_mt a) => new(-a.x, -a.y, -a.z, -a.w);

    [MethodImpl(256 | 512)]
    public static float4_mt operator+(float4_mt a, float4_mt b) => new(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt operator+(float4_mt a, float_mt b) => new(a.x + b, a.y + b, a.z + b, a.w + b);

    [MethodImpl(256 | 512)]
    public static float4_mt operator+(float_mt a, float4_mt b) => new(a + b.x, a + b.y, a + b.z, a + b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt operator-(float4_mt a, float4_mt b) => new(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt operator-(float4_mt a, float_mt b) => new(a.x - b, a.y - b, a.z - b, a.w - b);

    [MethodImpl(256 | 512)]
    public static float4_mt operator-(float_mt a, float4_mt b) => new(a - b.x, a - b.y, a - b.z, a - b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt operator*(float4_mt a, float4_mt b) => new(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt operator*(float4_mt a, float_mt b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static float4_mt operator*(float_mt a, float4_mt b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt operator*(float4_mt a, float b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static float4_mt operator*(float a, float4_mt b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt operator/(float4_mt a, float4_mt b) => new(a.x / b.x, a.y / b.y, a.z / b.z, a.w / b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt operator/(float_mt a, float4_mt b) => new(a / b.x, a / b.y, a / b.z, a / b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt operator/(float4_mt a, float_mt b) => new(a.x / b, a.y / b, a.z / b, a.w / b);

    [MethodImpl(256 | 512)]
    public static float4_mt operator/(float a, float4_mt b) => new(a / b.x, a / b.y, a / b.z, a / b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt operator/(float4_mt a, float b) => new(a.x / b, a.y / b, a.z / b, a.w / b);

    [MethodImpl(256 | 512)]
    public static float4_mt operator%(float4_mt a, float4_mt b) => math_mt.rem(a, b);

    [MethodImpl(256 | 512)]
    public static float4_mt operator%(float_mt a, float4_mt b) => math_mt.rem(a, b);

    [MethodImpl(256 | 512)]
    public static float4_mt operator%(float4_mt a, float_mt b) => math_mt.rem(a, b);

    [MethodImpl(256 | 512)]
    public static float4_mt operator%(float a, float4_mt b) => math_mt.rem(a, b);

    [MethodImpl(256 | 512)]
    public static float4_mt operator%(float4_mt a, float b) => math_mt.rem(a, b);

    [MethodImpl(256 | 512)]
    public static float4_mt operator++(float4_mt a) => a + float_mt.One;

    [MethodImpl(256 | 512)]
    public static float4_mt operator--(float4_mt a) => a - float_mt.One;

    #endregion // Operators
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static float4_mt abs([This] float4_mt a) => new(abs(a.x), abs(a.y), abs(a.z), abs(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt sign([This] float4_mt a) => new(sign(a.x), sign(a.y), sign(a.z), sign(a.w));

    [MethodImpl(256 | 512)]
    public static float4_mt min([This] float4_mt a, float4_mt b) => new(min(a.x, b.x), min(a.y, b.y), min(a.z, b.z), min(a.w, b.w));

    [MethodImpl(256 | 512)]
    public static float4_mt max([This] float4_mt a, float4_mt b) => new(max(a.x, b.x), max(a.y, b.y), max(a.z, b.z), max(a.w, b.w));

    [MethodImpl(256 | 512)]
    public static float4_mt clamp([This] float4_mt v, float4_mt min, float4_mt max) => math_mt.max(min, math_mt.min(max, v));

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float4_mt fma([This] float4_mt a, float4_mt b, float4_mt c) => new(fma(a.x, b.x, c.x), fma(a.y, b.y, c.y), fma(a.z, b.z, c.z), fma(a.w, b.w, c.w));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static float4_mt fms([This] float4_mt a, float4_mt b, float4_mt c) => new(fms(a.x, b.x, c.x), fms(a.y, b.y, c.y), fms(a.z, b.z, c.z), fms(a.w, b.w, c.w));

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static float4_mt fnma([This] float4_mt a, float4_mt b, float4_mt c) => new(fnma(a.x, b.x, c.x), fnma(a.y, b.y, c.y), fnma(a.z, b.z, c.z), fnma(a.w, b.w, c.w));

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static float4_mt fsm([This] float4_mt c, float4_mt a, float4_mt b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float4_mt fam([This] float4_mt c, float4_mt a, float4_mt b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float4_mt mad([This] float4_mt a, float4_mt b, float4_mt c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static float4_mt lerp(float4_mt start, float4_mt end, [This] float4_mt t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt lerp(float4_mt start, float4_mt end, [This] float t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt lerp(float start, float end, [This] float4_mt t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static float4_mt unlerp([This] float4_mt a, float4_mt start, float4_mt end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static float4_mt unlerp([This] float a, float4_mt start, float4_mt end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static float4_mt unlerp([This] float4_mt a, float start, float end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static float4_mt remap([This] float4_mt a, float4_mt srcStart, float4_mt srcEnd, float4_mt dstStart, float4_mt dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static float4_mt remap([This] float4_mt a, float srcStart, float srcEnd, float dstStart, float dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static float4_mt square([This] float4_mt a) => a * a;

    [MethodImpl(256 | 512)]
    public static float_mt dot([This] float4_mt a, float4_mt b)
    {
        // a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w
        return fma(a.w, b.w, fma(a.z, b.z, fma(a.y, b.y, a.x * b.x)));
    }

    [MethodImpl(256 | 512)]
    public static float_mt lengthsq([This] float4_mt a) => dot(a, a);

    [MethodImpl(256 | 512)]
    public static float_mt distancesq([This] float4_mt a, float4_mt b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static float_mt csum([This] float4_mt a) => a.x + a.y + a.z + a.w;

    [MethodImpl(256 | 512)]
    public static float_mt cmin([This] float4_mt a) => a.x.min(a.y).min(a.z).min(a.w);

    [MethodImpl(256 | 512)]
    public static float_mt cmax([This] float4_mt a) => a.x.max(a.y).max(a.z).max(a.w);

}

#endregion // float4_mt
#region double2_mt

public partial struct double2_mt
{
    #region Constants

    public static double2_mt Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static double2_mt One
    {
        [MethodImpl(256 | 512)]
        get => new(1.0);
    }

    public static double2_mt Two
    {
        [MethodImpl(256 | 512)]
        get => new(2.0);
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static double2_mt operator-(double2_mt a) => new(-a.x, -a.y);

    [MethodImpl(256 | 512)]
    public static double2_mt operator+(double2_mt a, double2_mt b) => new(a.x + b.x, a.y + b.y);

    [MethodImpl(256 | 512)]
    public static double2_mt operator+(double2_mt a, double_mt b) => new(a.x + b, a.y + b);

    [MethodImpl(256 | 512)]
    public static double2_mt operator+(double_mt a, double2_mt b) => new(a + b.x, a + b.y);

    [MethodImpl(256 | 512)]
    public static double2_mt operator-(double2_mt a, double2_mt b) => new(a.x - b.x, a.y - b.y);

    [MethodImpl(256 | 512)]
    public static double2_mt operator-(double2_mt a, double_mt b) => new(a.x - b, a.y - b);

    [MethodImpl(256 | 512)]
    public static double2_mt operator-(double_mt a, double2_mt b) => new(a - b.x, a - b.y);

    [MethodImpl(256 | 512)]
    public static double2_mt operator*(double2_mt a, double2_mt b) => new(a.x * b.x, a.y * b.y);

    [MethodImpl(256 | 512)]
    public static double2_mt operator*(double2_mt a, double_mt b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static double2_mt operator*(double_mt a, double2_mt b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static double2_mt operator*(double2_mt a, double b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static double2_mt operator*(double a, double2_mt b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static double2_mt operator/(double2_mt a, double2_mt b) => new(a.x / b.x, a.y / b.y);

    [MethodImpl(256 | 512)]
    public static double2_mt operator/(double_mt a, double2_mt b) => new(a / b.x, a / b.y);

    [MethodImpl(256 | 512)]
    public static double2_mt operator/(double2_mt a, double_mt b) => new(a.x / b, a.y / b);

    [MethodImpl(256 | 512)]
    public static double2_mt operator/(double a, double2_mt b) => new(a / b.x, a / b.y);

    [MethodImpl(256 | 512)]
    public static double2_mt operator/(double2_mt a, double b) => new(a.x / b, a.y / b);

    [MethodImpl(256 | 512)]
    public static double2_mt operator%(double2_mt a, double2_mt b) => math_mt.rem(a, b);

    [MethodImpl(256 | 512)]
    public static double2_mt operator%(double_mt a, double2_mt b) => math_mt.rem(a, b);

    [MethodImpl(256 | 512)]
    public static double2_mt operator%(double2_mt a, double_mt b) => math_mt.rem(a, b);

    [MethodImpl(256 | 512)]
    public static double2_mt operator%(double a, double2_mt b) => math_mt.rem(a, b);

    [MethodImpl(256 | 512)]
    public static double2_mt operator%(double2_mt a, double b) => math_mt.rem(a, b);

    [MethodImpl(256 | 512)]
    public static double2_mt operator++(double2_mt a) => a + double_mt.One;

    [MethodImpl(256 | 512)]
    public static double2_mt operator--(double2_mt a) => a - double_mt.One;

    #endregion // Operators
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static double2_mt abs([This] double2_mt a) => new(abs(a.x), abs(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt sign([This] double2_mt a) => new(sign(a.x), sign(a.y));

    [MethodImpl(256 | 512)]
    public static double2_mt min([This] double2_mt a, double2_mt b) => new(min(a.x, b.x), min(a.y, b.y));

    [MethodImpl(256 | 512)]
    public static double2_mt max([This] double2_mt a, double2_mt b) => new(max(a.x, b.x), max(a.y, b.y));

    [MethodImpl(256 | 512)]
    public static double2_mt clamp([This] double2_mt v, double2_mt min, double2_mt max) => math_mt.max(min, math_mt.min(max, v));

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double2_mt fma([This] double2_mt a, double2_mt b, double2_mt c) => new(fma(a.x, b.x, c.x), fma(a.y, b.y, c.y));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static double2_mt fms([This] double2_mt a, double2_mt b, double2_mt c) => new(fms(a.x, b.x, c.x), fms(a.y, b.y, c.y));

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static double2_mt fnma([This] double2_mt a, double2_mt b, double2_mt c) => new(fnma(a.x, b.x, c.x), fnma(a.y, b.y, c.y));

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static double2_mt fsm([This] double2_mt c, double2_mt a, double2_mt b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double2_mt fam([This] double2_mt c, double2_mt a, double2_mt b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double2_mt mad([This] double2_mt a, double2_mt b, double2_mt c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static double2_mt lerp(double2_mt start, double2_mt end, [This] double2_mt t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt lerp(double2_mt start, double2_mt end, [This] double t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt lerp(double start, double end, [This] double2_mt t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static double2_mt unlerp([This] double2_mt a, double2_mt start, double2_mt end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static double2_mt unlerp([This] double a, double2_mt start, double2_mt end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static double2_mt unlerp([This] double2_mt a, double start, double end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static double2_mt remap([This] double2_mt a, double2_mt srcStart, double2_mt srcEnd, double2_mt dstStart, double2_mt dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static double2_mt remap([This] double2_mt a, double srcStart, double srcEnd, double dstStart, double dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static double2_mt square([This] double2_mt a) => a * a;

    [MethodImpl(256 | 512)]
    public static double_mt dot([This] double2_mt a, double2_mt b)
    {
        // a.x * b.x + a.y * b.y
        return fma(a.y, b.y, a.x * b.x);
    }

    [MethodImpl(256 | 512)]
    public static double_mt lengthsq([This] double2_mt a) => dot(a, a);

    [MethodImpl(256 | 512)]
    public static double_mt distancesq([This] double2_mt a, double2_mt b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static double_mt csum([This] double2_mt a) => a.x + a.y;

    [MethodImpl(256 | 512)]
    public static double_mt cmin([This] double2_mt a) => a.x.min(a.y);

    [MethodImpl(256 | 512)]
    public static double_mt cmax([This] double2_mt a) => a.x.max(a.y);

}

#endregion // double2_mt
#region double3_mt

public partial struct double3_mt
{
    #region Constants

    public static double3_mt Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static double3_mt One
    {
        [MethodImpl(256 | 512)]
        get => new(1.0);
    }

    public static double3_mt Two
    {
        [MethodImpl(256 | 512)]
        get => new(2.0);
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static double3_mt operator-(double3_mt a) => new(-a.x, -a.y, -a.z);

    [MethodImpl(256 | 512)]
    public static double3_mt operator+(double3_mt a, double3_mt b) => new(a.x + b.x, a.y + b.y, a.z + b.z);

    [MethodImpl(256 | 512)]
    public static double3_mt operator+(double3_mt a, double_mt b) => new(a.x + b, a.y + b, a.z + b);

    [MethodImpl(256 | 512)]
    public static double3_mt operator+(double_mt a, double3_mt b) => new(a + b.x, a + b.y, a + b.z);

    [MethodImpl(256 | 512)]
    public static double3_mt operator-(double3_mt a, double3_mt b) => new(a.x - b.x, a.y - b.y, a.z - b.z);

    [MethodImpl(256 | 512)]
    public static double3_mt operator-(double3_mt a, double_mt b) => new(a.x - b, a.y - b, a.z - b);

    [MethodImpl(256 | 512)]
    public static double3_mt operator-(double_mt a, double3_mt b) => new(a - b.x, a - b.y, a - b.z);

    [MethodImpl(256 | 512)]
    public static double3_mt operator*(double3_mt a, double3_mt b) => new(a.x * b.x, a.y * b.y, a.z * b.z);

    [MethodImpl(256 | 512)]
    public static double3_mt operator*(double3_mt a, double_mt b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static double3_mt operator*(double_mt a, double3_mt b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static double3_mt operator*(double3_mt a, double b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static double3_mt operator*(double a, double3_mt b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static double3_mt operator/(double3_mt a, double3_mt b) => new(a.x / b.x, a.y / b.y, a.z / b.z);

    [MethodImpl(256 | 512)]
    public static double3_mt operator/(double_mt a, double3_mt b) => new(a / b.x, a / b.y, a / b.z);

    [MethodImpl(256 | 512)]
    public static double3_mt operator/(double3_mt a, double_mt b) => new(a.x / b, a.y / b, a.z / b);

    [MethodImpl(256 | 512)]
    public static double3_mt operator/(double a, double3_mt b) => new(a / b.x, a / b.y, a / b.z);

    [MethodImpl(256 | 512)]
    public static double3_mt operator/(double3_mt a, double b) => new(a.x / b, a.y / b, a.z / b);

    [MethodImpl(256 | 512)]
    public static double3_mt operator%(double3_mt a, double3_mt b) => math_mt.rem(a, b);

    [MethodImpl(256 | 512)]
    public static double3_mt operator%(double_mt a, double3_mt b) => math_mt.rem(a, b);

    [MethodImpl(256 | 512)]
    public static double3_mt operator%(double3_mt a, double_mt b) => math_mt.rem(a, b);

    [MethodImpl(256 | 512)]
    public static double3_mt operator%(double a, double3_mt b) => math_mt.rem(a, b);

    [MethodImpl(256 | 512)]
    public static double3_mt operator%(double3_mt a, double b) => math_mt.rem(a, b);

    [MethodImpl(256 | 512)]
    public static double3_mt operator++(double3_mt a) => a + double_mt.One;

    [MethodImpl(256 | 512)]
    public static double3_mt operator--(double3_mt a) => a - double_mt.One;

    #endregion // Operators
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static double3_mt abs([This] double3_mt a) => new(abs(a.x), abs(a.y), abs(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt sign([This] double3_mt a) => new(sign(a.x), sign(a.y), sign(a.z));

    [MethodImpl(256 | 512)]
    public static double3_mt min([This] double3_mt a, double3_mt b) => new(min(a.x, b.x), min(a.y, b.y), min(a.z, b.z));

    [MethodImpl(256 | 512)]
    public static double3_mt max([This] double3_mt a, double3_mt b) => new(max(a.x, b.x), max(a.y, b.y), max(a.z, b.z));

    [MethodImpl(256 | 512)]
    public static double3_mt clamp([This] double3_mt v, double3_mt min, double3_mt max) => math_mt.max(min, math_mt.min(max, v));

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double3_mt fma([This] double3_mt a, double3_mt b, double3_mt c) => new(fma(a.x, b.x, c.x), fma(a.y, b.y, c.y), fma(a.z, b.z, c.z));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static double3_mt fms([This] double3_mt a, double3_mt b, double3_mt c) => new(fms(a.x, b.x, c.x), fms(a.y, b.y, c.y), fms(a.z, b.z, c.z));

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static double3_mt fnma([This] double3_mt a, double3_mt b, double3_mt c) => new(fnma(a.x, b.x, c.x), fnma(a.y, b.y, c.y), fnma(a.z, b.z, c.z));

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static double3_mt fsm([This] double3_mt c, double3_mt a, double3_mt b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double3_mt fam([This] double3_mt c, double3_mt a, double3_mt b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double3_mt mad([This] double3_mt a, double3_mt b, double3_mt c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static double3_mt lerp(double3_mt start, double3_mt end, [This] double3_mt t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt lerp(double3_mt start, double3_mt end, [This] double t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt lerp(double start, double end, [This] double3_mt t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static double3_mt unlerp([This] double3_mt a, double3_mt start, double3_mt end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static double3_mt unlerp([This] double a, double3_mt start, double3_mt end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static double3_mt unlerp([This] double3_mt a, double start, double end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static double3_mt remap([This] double3_mt a, double3_mt srcStart, double3_mt srcEnd, double3_mt dstStart, double3_mt dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static double3_mt remap([This] double3_mt a, double srcStart, double srcEnd, double dstStart, double dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static double3_mt square([This] double3_mt a) => a * a;

    [MethodImpl(256 | 512)]
    public static double_mt dot([This] double3_mt a, double3_mt b)
    {
        // a.x * b.x + a.y * b.y + a.z * b.z
        return fma(a.z, b.z, fma(a.y, b.y, a.x * b.x));
    }

    [MethodImpl(256 | 512)]
    public static double3_mt cross([This] double3_mt a, double3_mt b)
    {
        // (a * b.yzx - a.yzx * b).yzx;
        return fnma(a.yzx, b, a * b.yzx).yzx;
    }

    [MethodImpl(256 | 512)]
    public static double_mt lengthsq([This] double3_mt a) => dot(a, a);

    [MethodImpl(256 | 512)]
    public static double_mt distancesq([This] double3_mt a, double3_mt b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static double_mt csum([This] double3_mt a) => a.x + a.y + a.z;

    [MethodImpl(256 | 512)]
    public static double_mt cmin([This] double3_mt a) => a.x.min(a.y).min(a.z);

    [MethodImpl(256 | 512)]
    public static double_mt cmax([This] double3_mt a) => a.x.max(a.y).max(a.z);

}

#endregion // double3_mt
#region double4_mt

public partial struct double4_mt
{
    #region Constants

    public static double4_mt Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static double4_mt One
    {
        [MethodImpl(256 | 512)]
        get => new(1.0);
    }

    public static double4_mt Two
    {
        [MethodImpl(256 | 512)]
        get => new(2.0);
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static double4_mt operator-(double4_mt a) => new(-a.x, -a.y, -a.z, -a.w);

    [MethodImpl(256 | 512)]
    public static double4_mt operator+(double4_mt a, double4_mt b) => new(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);

    [MethodImpl(256 | 512)]
    public static double4_mt operator+(double4_mt a, double_mt b) => new(a.x + b, a.y + b, a.z + b, a.w + b);

    [MethodImpl(256 | 512)]
    public static double4_mt operator+(double_mt a, double4_mt b) => new(a + b.x, a + b.y, a + b.z, a + b.w);

    [MethodImpl(256 | 512)]
    public static double4_mt operator-(double4_mt a, double4_mt b) => new(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);

    [MethodImpl(256 | 512)]
    public static double4_mt operator-(double4_mt a, double_mt b) => new(a.x - b, a.y - b, a.z - b, a.w - b);

    [MethodImpl(256 | 512)]
    public static double4_mt operator-(double_mt a, double4_mt b) => new(a - b.x, a - b.y, a - b.z, a - b.w);

    [MethodImpl(256 | 512)]
    public static double4_mt operator*(double4_mt a, double4_mt b) => new(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);

    [MethodImpl(256 | 512)]
    public static double4_mt operator*(double4_mt a, double_mt b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static double4_mt operator*(double_mt a, double4_mt b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static double4_mt operator*(double4_mt a, double b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static double4_mt operator*(double a, double4_mt b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static double4_mt operator/(double4_mt a, double4_mt b) => new(a.x / b.x, a.y / b.y, a.z / b.z, a.w / b.w);

    [MethodImpl(256 | 512)]
    public static double4_mt operator/(double_mt a, double4_mt b) => new(a / b.x, a / b.y, a / b.z, a / b.w);

    [MethodImpl(256 | 512)]
    public static double4_mt operator/(double4_mt a, double_mt b) => new(a.x / b, a.y / b, a.z / b, a.w / b);

    [MethodImpl(256 | 512)]
    public static double4_mt operator/(double a, double4_mt b) => new(a / b.x, a / b.y, a / b.z, a / b.w);

    [MethodImpl(256 | 512)]
    public static double4_mt operator/(double4_mt a, double b) => new(a.x / b, a.y / b, a.z / b, a.w / b);

    [MethodImpl(256 | 512)]
    public static double4_mt operator%(double4_mt a, double4_mt b) => math_mt.rem(a, b);

    [MethodImpl(256 | 512)]
    public static double4_mt operator%(double_mt a, double4_mt b) => math_mt.rem(a, b);

    [MethodImpl(256 | 512)]
    public static double4_mt operator%(double4_mt a, double_mt b) => math_mt.rem(a, b);

    [MethodImpl(256 | 512)]
    public static double4_mt operator%(double a, double4_mt b) => math_mt.rem(a, b);

    [MethodImpl(256 | 512)]
    public static double4_mt operator%(double4_mt a, double b) => math_mt.rem(a, b);

    [MethodImpl(256 | 512)]
    public static double4_mt operator++(double4_mt a) => a + double_mt.One;

    [MethodImpl(256 | 512)]
    public static double4_mt operator--(double4_mt a) => a - double_mt.One;

    #endregion // Operators
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static double4_mt abs([This] double4_mt a) => new(abs(a.x), abs(a.y), abs(a.z), abs(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt sign([This] double4_mt a) => new(sign(a.x), sign(a.y), sign(a.z), sign(a.w));

    [MethodImpl(256 | 512)]
    public static double4_mt min([This] double4_mt a, double4_mt b) => new(min(a.x, b.x), min(a.y, b.y), min(a.z, b.z), min(a.w, b.w));

    [MethodImpl(256 | 512)]
    public static double4_mt max([This] double4_mt a, double4_mt b) => new(max(a.x, b.x), max(a.y, b.y), max(a.z, b.z), max(a.w, b.w));

    [MethodImpl(256 | 512)]
    public static double4_mt clamp([This] double4_mt v, double4_mt min, double4_mt max) => math_mt.max(min, math_mt.min(max, v));

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double4_mt fma([This] double4_mt a, double4_mt b, double4_mt c) => new(fma(a.x, b.x, c.x), fma(a.y, b.y, c.y), fma(a.z, b.z, c.z), fma(a.w, b.w, c.w));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static double4_mt fms([This] double4_mt a, double4_mt b, double4_mt c) => new(fms(a.x, b.x, c.x), fms(a.y, b.y, c.y), fms(a.z, b.z, c.z), fms(a.w, b.w, c.w));

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static double4_mt fnma([This] double4_mt a, double4_mt b, double4_mt c) => new(fnma(a.x, b.x, c.x), fnma(a.y, b.y, c.y), fnma(a.z, b.z, c.z), fnma(a.w, b.w, c.w));

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static double4_mt fsm([This] double4_mt c, double4_mt a, double4_mt b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double4_mt fam([This] double4_mt c, double4_mt a, double4_mt b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double4_mt mad([This] double4_mt a, double4_mt b, double4_mt c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static double4_mt lerp(double4_mt start, double4_mt end, [This] double4_mt t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt lerp(double4_mt start, double4_mt end, [This] double t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt lerp(double start, double end, [This] double4_mt t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static double4_mt unlerp([This] double4_mt a, double4_mt start, double4_mt end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static double4_mt unlerp([This] double a, double4_mt start, double4_mt end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static double4_mt unlerp([This] double4_mt a, double start, double end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static double4_mt remap([This] double4_mt a, double4_mt srcStart, double4_mt srcEnd, double4_mt dstStart, double4_mt dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static double4_mt remap([This] double4_mt a, double srcStart, double srcEnd, double dstStart, double dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static double4_mt square([This] double4_mt a) => a * a;

    [MethodImpl(256 | 512)]
    public static double_mt dot([This] double4_mt a, double4_mt b)
    {
        // a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w
        return fma(a.w, b.w, fma(a.z, b.z, fma(a.y, b.y, a.x * b.x)));
    }

    [MethodImpl(256 | 512)]
    public static double_mt lengthsq([This] double4_mt a) => dot(a, a);

    [MethodImpl(256 | 512)]
    public static double_mt distancesq([This] double4_mt a, double4_mt b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static double_mt csum([This] double4_mt a) => a.x + a.y + a.z + a.w;

    [MethodImpl(256 | 512)]
    public static double_mt cmin([This] double4_mt a) => a.x.min(a.y).min(a.z).min(a.w);

    [MethodImpl(256 | 512)]
    public static double_mt cmax([This] double4_mt a) => a.x.max(a.y).max(a.z).max(a.w);

}

#endregion // double4_mt
#region int2_mt

public partial struct int2_mt
{
    #region Constants

    public static int2_mt Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static int2_mt One
    {
        [MethodImpl(256 | 512)]
        get => new(1);
    }

    public static int2_mt Two
    {
        [MethodImpl(256 | 512)]
        get => new((1 + 1));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static int2_mt operator-(int2_mt a) => new(-a.x, -a.y);

    [MethodImpl(256 | 512)]
    public static int2_mt operator+(int2_mt a, int2_mt b) => new(a.x + b.x, a.y + b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt operator+(int2_mt a, int_mt b) => new(a.x + b, a.y + b);

    [MethodImpl(256 | 512)]
    public static int2_mt operator+(int_mt a, int2_mt b) => new(a + b.x, a + b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt operator-(int2_mt a, int2_mt b) => new(a.x - b.x, a.y - b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt operator-(int2_mt a, int_mt b) => new(a.x - b, a.y - b);

    [MethodImpl(256 | 512)]
    public static int2_mt operator-(int_mt a, int2_mt b) => new(a - b.x, a - b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt operator*(int2_mt a, int2_mt b) => new(a.x * b.x, a.y * b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt operator*(int2_mt a, int_mt b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static int2_mt operator*(int_mt a, int2_mt b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt operator*(int2_mt a, int b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static int2_mt operator*(int a, int2_mt b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt operator/(int2_mt a, int2_mt b) => new(a.x / b.x, a.y / b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt operator/(int_mt a, int2_mt b) => new(a / b.x, a / b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt operator/(int2_mt a, int_mt b) => new(a.x / b, a.y / b);

    [MethodImpl(256 | 512)]
    public static int2_mt operator/(int a, int2_mt b) => new(a / b.x, a / b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt operator/(int2_mt a, int b) => new(a.x / b, a.y / b);

    [MethodImpl(256 | 512)]
    public static int2_mt operator%(int2_mt a, int2_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static int2_mt operator%(int_mt a, int2_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static int2_mt operator%(int2_mt a, int_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static int2_mt operator%(int a, int2_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static int2_mt operator%(int2_mt a, int b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static int2_mt operator++(int2_mt a) => a + int_mt.One;

    [MethodImpl(256 | 512)]
    public static int2_mt operator--(int2_mt a) => a - int_mt.One;

    #endregion // Operators
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static int2_mt abs([This] int2_mt a) => new(abs(a.x), abs(a.y));

    [MethodImpl(256 | 512)]
    public static int2_mt sign([This] int2_mt a) => new(sign(a.x), sign(a.y));

    [MethodImpl(256 | 512)]
    public static int2_mt min([This] int2_mt a, int2_mt b) => new(min(a.x, b.x), min(a.y, b.y));

    [MethodImpl(256 | 512)]
    public static int2_mt max([This] int2_mt a, int2_mt b) => new(max(a.x, b.x), max(a.y, b.y));

    [MethodImpl(256 | 512)]
    public static int2_mt clamp([This] int2_mt v, int2_mt min, int2_mt max) => math_mt.max(min, math_mt.min(max, v));

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static int2_mt fma([This] int2_mt a, int2_mt b, int2_mt c) => new(fma(a.x, b.x, c.x), fma(a.y, b.y, c.y));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static int2_mt fms([This] int2_mt a, int2_mt b, int2_mt c) => new(fms(a.x, b.x, c.x), fms(a.y, b.y, c.y));

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static int2_mt fnma([This] int2_mt a, int2_mt b, int2_mt c) => new(fnma(a.x, b.x, c.x), fnma(a.y, b.y, c.y));

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static int2_mt fsm([This] int2_mt c, int2_mt a, int2_mt b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static int2_mt fam([This] int2_mt c, int2_mt a, int2_mt b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static int2_mt mad([This] int2_mt a, int2_mt b, int2_mt c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static int2_mt lerp(int2_mt start, int2_mt end, [This] int2_mt t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static int2_mt lerp(int2_mt start, int2_mt end, [This] int t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static int2_mt lerp(int start, int end, [This] int2_mt t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static int2_mt unlerp([This] int2_mt a, int2_mt start, int2_mt end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static int2_mt unlerp([This] int a, int2_mt start, int2_mt end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static int2_mt unlerp([This] int2_mt a, int start, int end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static int2_mt remap([This] int2_mt a, int2_mt srcStart, int2_mt srcEnd, int2_mt dstStart, int2_mt dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static int2_mt remap([This] int2_mt a, int srcStart, int srcEnd, int dstStart, int dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static int2_mt square([This] int2_mt a) => a * a;

    [MethodImpl(256 | 512)]
    public static int_mt dot([This] int2_mt a, int2_mt b)
    {
        // a.x * b.x + a.y * b.y
        return fma(a.y, b.y, a.x * b.x);
    }

    [MethodImpl(256 | 512)]
    public static int_mt lengthsq([This] int2_mt a) => dot(a, a);

    [MethodImpl(256 | 512)]
    public static int_mt distancesq([This] int2_mt a, int2_mt b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static int_mt csum([This] int2_mt a) => a.x + a.y;

    [MethodImpl(256 | 512)]
    public static int_mt cmin([This] int2_mt a) => a.x.min(a.y);

    [MethodImpl(256 | 512)]
    public static int_mt cmax([This] int2_mt a) => a.x.max(a.y);

}

#endregion // int2_mt
#region int3_mt

public partial struct int3_mt
{
    #region Constants

    public static int3_mt Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static int3_mt One
    {
        [MethodImpl(256 | 512)]
        get => new(1);
    }

    public static int3_mt Two
    {
        [MethodImpl(256 | 512)]
        get => new((1 + 1));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static int3_mt operator-(int3_mt a) => new(-a.x, -a.y, -a.z);

    [MethodImpl(256 | 512)]
    public static int3_mt operator+(int3_mt a, int3_mt b) => new(a.x + b.x, a.y + b.y, a.z + b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt operator+(int3_mt a, int_mt b) => new(a.x + b, a.y + b, a.z + b);

    [MethodImpl(256 | 512)]
    public static int3_mt operator+(int_mt a, int3_mt b) => new(a + b.x, a + b.y, a + b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt operator-(int3_mt a, int3_mt b) => new(a.x - b.x, a.y - b.y, a.z - b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt operator-(int3_mt a, int_mt b) => new(a.x - b, a.y - b, a.z - b);

    [MethodImpl(256 | 512)]
    public static int3_mt operator-(int_mt a, int3_mt b) => new(a - b.x, a - b.y, a - b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt operator*(int3_mt a, int3_mt b) => new(a.x * b.x, a.y * b.y, a.z * b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt operator*(int3_mt a, int_mt b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static int3_mt operator*(int_mt a, int3_mt b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt operator*(int3_mt a, int b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static int3_mt operator*(int a, int3_mt b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt operator/(int3_mt a, int3_mt b) => new(a.x / b.x, a.y / b.y, a.z / b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt operator/(int_mt a, int3_mt b) => new(a / b.x, a / b.y, a / b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt operator/(int3_mt a, int_mt b) => new(a.x / b, a.y / b, a.z / b);

    [MethodImpl(256 | 512)]
    public static int3_mt operator/(int a, int3_mt b) => new(a / b.x, a / b.y, a / b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt operator/(int3_mt a, int b) => new(a.x / b, a.y / b, a.z / b);

    [MethodImpl(256 | 512)]
    public static int3_mt operator%(int3_mt a, int3_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static int3_mt operator%(int_mt a, int3_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static int3_mt operator%(int3_mt a, int_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static int3_mt operator%(int a, int3_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static int3_mt operator%(int3_mt a, int b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static int3_mt operator++(int3_mt a) => a + int_mt.One;

    [MethodImpl(256 | 512)]
    public static int3_mt operator--(int3_mt a) => a - int_mt.One;

    #endregion // Operators
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static int3_mt abs([This] int3_mt a) => new(abs(a.x), abs(a.y), abs(a.z));

    [MethodImpl(256 | 512)]
    public static int3_mt sign([This] int3_mt a) => new(sign(a.x), sign(a.y), sign(a.z));

    [MethodImpl(256 | 512)]
    public static int3_mt min([This] int3_mt a, int3_mt b) => new(min(a.x, b.x), min(a.y, b.y), min(a.z, b.z));

    [MethodImpl(256 | 512)]
    public static int3_mt max([This] int3_mt a, int3_mt b) => new(max(a.x, b.x), max(a.y, b.y), max(a.z, b.z));

    [MethodImpl(256 | 512)]
    public static int3_mt clamp([This] int3_mt v, int3_mt min, int3_mt max) => math_mt.max(min, math_mt.min(max, v));

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static int3_mt fma([This] int3_mt a, int3_mt b, int3_mt c) => new(fma(a.x, b.x, c.x), fma(a.y, b.y, c.y), fma(a.z, b.z, c.z));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static int3_mt fms([This] int3_mt a, int3_mt b, int3_mt c) => new(fms(a.x, b.x, c.x), fms(a.y, b.y, c.y), fms(a.z, b.z, c.z));

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static int3_mt fnma([This] int3_mt a, int3_mt b, int3_mt c) => new(fnma(a.x, b.x, c.x), fnma(a.y, b.y, c.y), fnma(a.z, b.z, c.z));

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static int3_mt fsm([This] int3_mt c, int3_mt a, int3_mt b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static int3_mt fam([This] int3_mt c, int3_mt a, int3_mt b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static int3_mt mad([This] int3_mt a, int3_mt b, int3_mt c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static int3_mt lerp(int3_mt start, int3_mt end, [This] int3_mt t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static int3_mt lerp(int3_mt start, int3_mt end, [This] int t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static int3_mt lerp(int start, int end, [This] int3_mt t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static int3_mt unlerp([This] int3_mt a, int3_mt start, int3_mt end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static int3_mt unlerp([This] int a, int3_mt start, int3_mt end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static int3_mt unlerp([This] int3_mt a, int start, int end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static int3_mt remap([This] int3_mt a, int3_mt srcStart, int3_mt srcEnd, int3_mt dstStart, int3_mt dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static int3_mt remap([This] int3_mt a, int srcStart, int srcEnd, int dstStart, int dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static int3_mt square([This] int3_mt a) => a * a;

    [MethodImpl(256 | 512)]
    public static int_mt dot([This] int3_mt a, int3_mt b)
    {
        // a.x * b.x + a.y * b.y + a.z * b.z
        return fma(a.z, b.z, fma(a.y, b.y, a.x * b.x));
    }

    [MethodImpl(256 | 512)]
    public static int3_mt cross([This] int3_mt a, int3_mt b)
    {
        // (a * b.yzx - a.yzx * b).yzx;
        return fnma(a.yzx, b, a * b.yzx).yzx;
    }

    [MethodImpl(256 | 512)]
    public static int_mt lengthsq([This] int3_mt a) => dot(a, a);

    [MethodImpl(256 | 512)]
    public static int_mt distancesq([This] int3_mt a, int3_mt b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static int_mt csum([This] int3_mt a) => a.x + a.y + a.z;

    [MethodImpl(256 | 512)]
    public static int_mt cmin([This] int3_mt a) => a.x.min(a.y).min(a.z);

    [MethodImpl(256 | 512)]
    public static int_mt cmax([This] int3_mt a) => a.x.max(a.y).max(a.z);

}

#endregion // int3_mt
#region int4_mt

public partial struct int4_mt
{
    #region Constants

    public static int4_mt Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static int4_mt One
    {
        [MethodImpl(256 | 512)]
        get => new(1);
    }

    public static int4_mt Two
    {
        [MethodImpl(256 | 512)]
        get => new((1 + 1));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static int4_mt operator-(int4_mt a) => new(-a.x, -a.y, -a.z, -a.w);

    [MethodImpl(256 | 512)]
    public static int4_mt operator+(int4_mt a, int4_mt b) => new(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt operator+(int4_mt a, int_mt b) => new(a.x + b, a.y + b, a.z + b, a.w + b);

    [MethodImpl(256 | 512)]
    public static int4_mt operator+(int_mt a, int4_mt b) => new(a + b.x, a + b.y, a + b.z, a + b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt operator-(int4_mt a, int4_mt b) => new(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt operator-(int4_mt a, int_mt b) => new(a.x - b, a.y - b, a.z - b, a.w - b);

    [MethodImpl(256 | 512)]
    public static int4_mt operator-(int_mt a, int4_mt b) => new(a - b.x, a - b.y, a - b.z, a - b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt operator*(int4_mt a, int4_mt b) => new(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt operator*(int4_mt a, int_mt b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static int4_mt operator*(int_mt a, int4_mt b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt operator*(int4_mt a, int b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static int4_mt operator*(int a, int4_mt b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt operator/(int4_mt a, int4_mt b) => new(a.x / b.x, a.y / b.y, a.z / b.z, a.w / b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt operator/(int_mt a, int4_mt b) => new(a / b.x, a / b.y, a / b.z, a / b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt operator/(int4_mt a, int_mt b) => new(a.x / b, a.y / b, a.z / b, a.w / b);

    [MethodImpl(256 | 512)]
    public static int4_mt operator/(int a, int4_mt b) => new(a / b.x, a / b.y, a / b.z, a / b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt operator/(int4_mt a, int b) => new(a.x / b, a.y / b, a.z / b, a.w / b);

    [MethodImpl(256 | 512)]
    public static int4_mt operator%(int4_mt a, int4_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static int4_mt operator%(int_mt a, int4_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static int4_mt operator%(int4_mt a, int_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static int4_mt operator%(int a, int4_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static int4_mt operator%(int4_mt a, int b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static int4_mt operator++(int4_mt a) => a + int_mt.One;

    [MethodImpl(256 | 512)]
    public static int4_mt operator--(int4_mt a) => a - int_mt.One;

    #endregion // Operators
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static int4_mt abs([This] int4_mt a) => new(abs(a.x), abs(a.y), abs(a.z), abs(a.w));

    [MethodImpl(256 | 512)]
    public static int4_mt sign([This] int4_mt a) => new(sign(a.x), sign(a.y), sign(a.z), sign(a.w));

    [MethodImpl(256 | 512)]
    public static int4_mt min([This] int4_mt a, int4_mt b) => new(min(a.x, b.x), min(a.y, b.y), min(a.z, b.z), min(a.w, b.w));

    [MethodImpl(256 | 512)]
    public static int4_mt max([This] int4_mt a, int4_mt b) => new(max(a.x, b.x), max(a.y, b.y), max(a.z, b.z), max(a.w, b.w));

    [MethodImpl(256 | 512)]
    public static int4_mt clamp([This] int4_mt v, int4_mt min, int4_mt max) => math_mt.max(min, math_mt.min(max, v));

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static int4_mt fma([This] int4_mt a, int4_mt b, int4_mt c) => new(fma(a.x, b.x, c.x), fma(a.y, b.y, c.y), fma(a.z, b.z, c.z), fma(a.w, b.w, c.w));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static int4_mt fms([This] int4_mt a, int4_mt b, int4_mt c) => new(fms(a.x, b.x, c.x), fms(a.y, b.y, c.y), fms(a.z, b.z, c.z), fms(a.w, b.w, c.w));

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static int4_mt fnma([This] int4_mt a, int4_mt b, int4_mt c) => new(fnma(a.x, b.x, c.x), fnma(a.y, b.y, c.y), fnma(a.z, b.z, c.z), fnma(a.w, b.w, c.w));

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static int4_mt fsm([This] int4_mt c, int4_mt a, int4_mt b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static int4_mt fam([This] int4_mt c, int4_mt a, int4_mt b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static int4_mt mad([This] int4_mt a, int4_mt b, int4_mt c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static int4_mt lerp(int4_mt start, int4_mt end, [This] int4_mt t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static int4_mt lerp(int4_mt start, int4_mt end, [This] int t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static int4_mt lerp(int start, int end, [This] int4_mt t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static int4_mt unlerp([This] int4_mt a, int4_mt start, int4_mt end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static int4_mt unlerp([This] int a, int4_mt start, int4_mt end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static int4_mt unlerp([This] int4_mt a, int start, int end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static int4_mt remap([This] int4_mt a, int4_mt srcStart, int4_mt srcEnd, int4_mt dstStart, int4_mt dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static int4_mt remap([This] int4_mt a, int srcStart, int srcEnd, int dstStart, int dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static int4_mt square([This] int4_mt a) => a * a;

    [MethodImpl(256 | 512)]
    public static int_mt dot([This] int4_mt a, int4_mt b)
    {
        // a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w
        return fma(a.w, b.w, fma(a.z, b.z, fma(a.y, b.y, a.x * b.x)));
    }

    [MethodImpl(256 | 512)]
    public static int_mt lengthsq([This] int4_mt a) => dot(a, a);

    [MethodImpl(256 | 512)]
    public static int_mt distancesq([This] int4_mt a, int4_mt b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static int_mt csum([This] int4_mt a) => a.x + a.y + a.z + a.w;

    [MethodImpl(256 | 512)]
    public static int_mt cmin([This] int4_mt a) => a.x.min(a.y).min(a.z).min(a.w);

    [MethodImpl(256 | 512)]
    public static int_mt cmax([This] int4_mt a) => a.x.max(a.y).max(a.z).max(a.w);

}

#endregion // int4_mt
#region uint2_mt

public partial struct uint2_mt
{
    #region Constants

    public static uint2_mt Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static uint2_mt One
    {
        [MethodImpl(256 | 512)]
        get => new(1u);
    }

    public static uint2_mt Two
    {
        [MethodImpl(256 | 512)]
        get => new((1u + 1u));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static uint2_mt operator-(uint2_mt a) => new(-a.x, -a.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt operator+(uint2_mt a, uint2_mt b) => new(a.x + b.x, a.y + b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt operator+(uint2_mt a, uint_mt b) => new(a.x + b, a.y + b);

    [MethodImpl(256 | 512)]
    public static uint2_mt operator+(uint_mt a, uint2_mt b) => new(a + b.x, a + b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt operator-(uint2_mt a, uint2_mt b) => new(a.x - b.x, a.y - b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt operator-(uint2_mt a, uint_mt b) => new(a.x - b, a.y - b);

    [MethodImpl(256 | 512)]
    public static uint2_mt operator-(uint_mt a, uint2_mt b) => new(a - b.x, a - b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt operator*(uint2_mt a, uint2_mt b) => new(a.x * b.x, a.y * b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt operator*(uint2_mt a, uint_mt b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static uint2_mt operator*(uint_mt a, uint2_mt b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt operator*(uint2_mt a, uint b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static uint2_mt operator*(uint a, uint2_mt b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt operator/(uint2_mt a, uint2_mt b) => new(a.x / b.x, a.y / b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt operator/(uint_mt a, uint2_mt b) => new(a / b.x, a / b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt operator/(uint2_mt a, uint_mt b) => new(a.x / b, a.y / b);

    [MethodImpl(256 | 512)]
    public static uint2_mt operator/(uint a, uint2_mt b) => new(a / b.x, a / b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt operator/(uint2_mt a, uint b) => new(a.x / b, a.y / b);

    [MethodImpl(256 | 512)]
    public static uint2_mt operator%(uint2_mt a, uint2_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static uint2_mt operator%(uint_mt a, uint2_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static uint2_mt operator%(uint2_mt a, uint_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static uint2_mt operator%(uint a, uint2_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static uint2_mt operator%(uint2_mt a, uint b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static uint2_mt operator++(uint2_mt a) => a + uint_mt.One;

    [MethodImpl(256 | 512)]
    public static uint2_mt operator--(uint2_mt a) => a - uint_mt.One;

    #endregion // Operators
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static uint2_mt abs([This] uint2_mt a) => new(abs(a.x), abs(a.y));

    [MethodImpl(256 | 512)]
    public static uint2_mt sign([This] uint2_mt a) => new(sign(a.x), sign(a.y));

    [MethodImpl(256 | 512)]
    public static uint2_mt min([This] uint2_mt a, uint2_mt b) => new(min(a.x, b.x), min(a.y, b.y));

    [MethodImpl(256 | 512)]
    public static uint2_mt max([This] uint2_mt a, uint2_mt b) => new(max(a.x, b.x), max(a.y, b.y));

    [MethodImpl(256 | 512)]
    public static uint2_mt clamp([This] uint2_mt v, uint2_mt min, uint2_mt max) => math_mt.max(min, math_mt.min(max, v));

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static uint2_mt fma([This] uint2_mt a, uint2_mt b, uint2_mt c) => new(fma(a.x, b.x, c.x), fma(a.y, b.y, c.y));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static uint2_mt fms([This] uint2_mt a, uint2_mt b, uint2_mt c) => new(fms(a.x, b.x, c.x), fms(a.y, b.y, c.y));

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static uint2_mt fnma([This] uint2_mt a, uint2_mt b, uint2_mt c) => new(fnma(a.x, b.x, c.x), fnma(a.y, b.y, c.y));

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static uint2_mt fsm([This] uint2_mt c, uint2_mt a, uint2_mt b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static uint2_mt fam([This] uint2_mt c, uint2_mt a, uint2_mt b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static uint2_mt mad([This] uint2_mt a, uint2_mt b, uint2_mt c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static uint2_mt lerp(uint2_mt start, uint2_mt end, [This] uint2_mt t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static uint2_mt lerp(uint2_mt start, uint2_mt end, [This] uint t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static uint2_mt lerp(uint start, uint end, [This] uint2_mt t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static uint2_mt unlerp([This] uint2_mt a, uint2_mt start, uint2_mt end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static uint2_mt unlerp([This] uint a, uint2_mt start, uint2_mt end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static uint2_mt unlerp([This] uint2_mt a, uint start, uint end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static uint2_mt remap([This] uint2_mt a, uint2_mt srcStart, uint2_mt srcEnd, uint2_mt dstStart, uint2_mt dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static uint2_mt remap([This] uint2_mt a, uint srcStart, uint srcEnd, uint dstStart, uint dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static uint2_mt square([This] uint2_mt a) => a * a;

    [MethodImpl(256 | 512)]
    public static uint_mt dot([This] uint2_mt a, uint2_mt b)
    {
        // a.x * b.x + a.y * b.y
        return fma(a.y, b.y, a.x * b.x);
    }

    [MethodImpl(256 | 512)]
    public static uint_mt lengthsq([This] uint2_mt a) => dot(a, a);

    [MethodImpl(256 | 512)]
    public static uint_mt distancesq([This] uint2_mt a, uint2_mt b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static uint_mt csum([This] uint2_mt a) => a.x + a.y;

    [MethodImpl(256 | 512)]
    public static uint_mt cmin([This] uint2_mt a) => a.x.min(a.y);

    [MethodImpl(256 | 512)]
    public static uint_mt cmax([This] uint2_mt a) => a.x.max(a.y);

}

#endregion // uint2_mt
#region uint3_mt

public partial struct uint3_mt
{
    #region Constants

    public static uint3_mt Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static uint3_mt One
    {
        [MethodImpl(256 | 512)]
        get => new(1u);
    }

    public static uint3_mt Two
    {
        [MethodImpl(256 | 512)]
        get => new((1u + 1u));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static uint3_mt operator-(uint3_mt a) => new(-a.x, -a.y, -a.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt operator+(uint3_mt a, uint3_mt b) => new(a.x + b.x, a.y + b.y, a.z + b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt operator+(uint3_mt a, uint_mt b) => new(a.x + b, a.y + b, a.z + b);

    [MethodImpl(256 | 512)]
    public static uint3_mt operator+(uint_mt a, uint3_mt b) => new(a + b.x, a + b.y, a + b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt operator-(uint3_mt a, uint3_mt b) => new(a.x - b.x, a.y - b.y, a.z - b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt operator-(uint3_mt a, uint_mt b) => new(a.x - b, a.y - b, a.z - b);

    [MethodImpl(256 | 512)]
    public static uint3_mt operator-(uint_mt a, uint3_mt b) => new(a - b.x, a - b.y, a - b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt operator*(uint3_mt a, uint3_mt b) => new(a.x * b.x, a.y * b.y, a.z * b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt operator*(uint3_mt a, uint_mt b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static uint3_mt operator*(uint_mt a, uint3_mt b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt operator*(uint3_mt a, uint b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static uint3_mt operator*(uint a, uint3_mt b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt operator/(uint3_mt a, uint3_mt b) => new(a.x / b.x, a.y / b.y, a.z / b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt operator/(uint_mt a, uint3_mt b) => new(a / b.x, a / b.y, a / b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt operator/(uint3_mt a, uint_mt b) => new(a.x / b, a.y / b, a.z / b);

    [MethodImpl(256 | 512)]
    public static uint3_mt operator/(uint a, uint3_mt b) => new(a / b.x, a / b.y, a / b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt operator/(uint3_mt a, uint b) => new(a.x / b, a.y / b, a.z / b);

    [MethodImpl(256 | 512)]
    public static uint3_mt operator%(uint3_mt a, uint3_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static uint3_mt operator%(uint_mt a, uint3_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static uint3_mt operator%(uint3_mt a, uint_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static uint3_mt operator%(uint a, uint3_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static uint3_mt operator%(uint3_mt a, uint b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static uint3_mt operator++(uint3_mt a) => a + uint_mt.One;

    [MethodImpl(256 | 512)]
    public static uint3_mt operator--(uint3_mt a) => a - uint_mt.One;

    #endregion // Operators
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static uint3_mt abs([This] uint3_mt a) => new(abs(a.x), abs(a.y), abs(a.z));

    [MethodImpl(256 | 512)]
    public static uint3_mt sign([This] uint3_mt a) => new(sign(a.x), sign(a.y), sign(a.z));

    [MethodImpl(256 | 512)]
    public static uint3_mt min([This] uint3_mt a, uint3_mt b) => new(min(a.x, b.x), min(a.y, b.y), min(a.z, b.z));

    [MethodImpl(256 | 512)]
    public static uint3_mt max([This] uint3_mt a, uint3_mt b) => new(max(a.x, b.x), max(a.y, b.y), max(a.z, b.z));

    [MethodImpl(256 | 512)]
    public static uint3_mt clamp([This] uint3_mt v, uint3_mt min, uint3_mt max) => math_mt.max(min, math_mt.min(max, v));

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static uint3_mt fma([This] uint3_mt a, uint3_mt b, uint3_mt c) => new(fma(a.x, b.x, c.x), fma(a.y, b.y, c.y), fma(a.z, b.z, c.z));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static uint3_mt fms([This] uint3_mt a, uint3_mt b, uint3_mt c) => new(fms(a.x, b.x, c.x), fms(a.y, b.y, c.y), fms(a.z, b.z, c.z));

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static uint3_mt fnma([This] uint3_mt a, uint3_mt b, uint3_mt c) => new(fnma(a.x, b.x, c.x), fnma(a.y, b.y, c.y), fnma(a.z, b.z, c.z));

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static uint3_mt fsm([This] uint3_mt c, uint3_mt a, uint3_mt b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static uint3_mt fam([This] uint3_mt c, uint3_mt a, uint3_mt b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static uint3_mt mad([This] uint3_mt a, uint3_mt b, uint3_mt c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static uint3_mt lerp(uint3_mt start, uint3_mt end, [This] uint3_mt t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static uint3_mt lerp(uint3_mt start, uint3_mt end, [This] uint t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static uint3_mt lerp(uint start, uint end, [This] uint3_mt t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static uint3_mt unlerp([This] uint3_mt a, uint3_mt start, uint3_mt end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static uint3_mt unlerp([This] uint a, uint3_mt start, uint3_mt end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static uint3_mt unlerp([This] uint3_mt a, uint start, uint end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static uint3_mt remap([This] uint3_mt a, uint3_mt srcStart, uint3_mt srcEnd, uint3_mt dstStart, uint3_mt dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static uint3_mt remap([This] uint3_mt a, uint srcStart, uint srcEnd, uint dstStart, uint dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static uint3_mt square([This] uint3_mt a) => a * a;

    [MethodImpl(256 | 512)]
    public static uint_mt dot([This] uint3_mt a, uint3_mt b)
    {
        // a.x * b.x + a.y * b.y + a.z * b.z
        return fma(a.z, b.z, fma(a.y, b.y, a.x * b.x));
    }

    [MethodImpl(256 | 512)]
    public static uint3_mt cross([This] uint3_mt a, uint3_mt b)
    {
        // (a * b.yzx - a.yzx * b).yzx;
        return fnma(a.yzx, b, a * b.yzx).yzx;
    }

    [MethodImpl(256 | 512)]
    public static uint_mt lengthsq([This] uint3_mt a) => dot(a, a);

    [MethodImpl(256 | 512)]
    public static uint_mt distancesq([This] uint3_mt a, uint3_mt b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static uint_mt csum([This] uint3_mt a) => a.x + a.y + a.z;

    [MethodImpl(256 | 512)]
    public static uint_mt cmin([This] uint3_mt a) => a.x.min(a.y).min(a.z);

    [MethodImpl(256 | 512)]
    public static uint_mt cmax([This] uint3_mt a) => a.x.max(a.y).max(a.z);

}

#endregion // uint3_mt
#region uint4_mt

public partial struct uint4_mt
{
    #region Constants

    public static uint4_mt Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static uint4_mt One
    {
        [MethodImpl(256 | 512)]
        get => new(1u);
    }

    public static uint4_mt Two
    {
        [MethodImpl(256 | 512)]
        get => new((1u + 1u));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static uint4_mt operator-(uint4_mt a) => new(-a.x, -a.y, -a.z, -a.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt operator+(uint4_mt a, uint4_mt b) => new(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt operator+(uint4_mt a, uint_mt b) => new(a.x + b, a.y + b, a.z + b, a.w + b);

    [MethodImpl(256 | 512)]
    public static uint4_mt operator+(uint_mt a, uint4_mt b) => new(a + b.x, a + b.y, a + b.z, a + b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt operator-(uint4_mt a, uint4_mt b) => new(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt operator-(uint4_mt a, uint_mt b) => new(a.x - b, a.y - b, a.z - b, a.w - b);

    [MethodImpl(256 | 512)]
    public static uint4_mt operator-(uint_mt a, uint4_mt b) => new(a - b.x, a - b.y, a - b.z, a - b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt operator*(uint4_mt a, uint4_mt b) => new(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt operator*(uint4_mt a, uint_mt b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static uint4_mt operator*(uint_mt a, uint4_mt b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt operator*(uint4_mt a, uint b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static uint4_mt operator*(uint a, uint4_mt b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt operator/(uint4_mt a, uint4_mt b) => new(a.x / b.x, a.y / b.y, a.z / b.z, a.w / b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt operator/(uint_mt a, uint4_mt b) => new(a / b.x, a / b.y, a / b.z, a / b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt operator/(uint4_mt a, uint_mt b) => new(a.x / b, a.y / b, a.z / b, a.w / b);

    [MethodImpl(256 | 512)]
    public static uint4_mt operator/(uint a, uint4_mt b) => new(a / b.x, a / b.y, a / b.z, a / b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt operator/(uint4_mt a, uint b) => new(a.x / b, a.y / b, a.z / b, a.w / b);

    [MethodImpl(256 | 512)]
    public static uint4_mt operator%(uint4_mt a, uint4_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static uint4_mt operator%(uint_mt a, uint4_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static uint4_mt operator%(uint4_mt a, uint_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static uint4_mt operator%(uint a, uint4_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static uint4_mt operator%(uint4_mt a, uint b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static uint4_mt operator++(uint4_mt a) => a + uint_mt.One;

    [MethodImpl(256 | 512)]
    public static uint4_mt operator--(uint4_mt a) => a - uint_mt.One;

    #endregion // Operators
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static uint4_mt abs([This] uint4_mt a) => new(abs(a.x), abs(a.y), abs(a.z), abs(a.w));

    [MethodImpl(256 | 512)]
    public static uint4_mt sign([This] uint4_mt a) => new(sign(a.x), sign(a.y), sign(a.z), sign(a.w));

    [MethodImpl(256 | 512)]
    public static uint4_mt min([This] uint4_mt a, uint4_mt b) => new(min(a.x, b.x), min(a.y, b.y), min(a.z, b.z), min(a.w, b.w));

    [MethodImpl(256 | 512)]
    public static uint4_mt max([This] uint4_mt a, uint4_mt b) => new(max(a.x, b.x), max(a.y, b.y), max(a.z, b.z), max(a.w, b.w));

    [MethodImpl(256 | 512)]
    public static uint4_mt clamp([This] uint4_mt v, uint4_mt min, uint4_mt max) => math_mt.max(min, math_mt.min(max, v));

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static uint4_mt fma([This] uint4_mt a, uint4_mt b, uint4_mt c) => new(fma(a.x, b.x, c.x), fma(a.y, b.y, c.y), fma(a.z, b.z, c.z), fma(a.w, b.w, c.w));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static uint4_mt fms([This] uint4_mt a, uint4_mt b, uint4_mt c) => new(fms(a.x, b.x, c.x), fms(a.y, b.y, c.y), fms(a.z, b.z, c.z), fms(a.w, b.w, c.w));

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static uint4_mt fnma([This] uint4_mt a, uint4_mt b, uint4_mt c) => new(fnma(a.x, b.x, c.x), fnma(a.y, b.y, c.y), fnma(a.z, b.z, c.z), fnma(a.w, b.w, c.w));

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static uint4_mt fsm([This] uint4_mt c, uint4_mt a, uint4_mt b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static uint4_mt fam([This] uint4_mt c, uint4_mt a, uint4_mt b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static uint4_mt mad([This] uint4_mt a, uint4_mt b, uint4_mt c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static uint4_mt lerp(uint4_mt start, uint4_mt end, [This] uint4_mt t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static uint4_mt lerp(uint4_mt start, uint4_mt end, [This] uint t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static uint4_mt lerp(uint start, uint end, [This] uint4_mt t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static uint4_mt unlerp([This] uint4_mt a, uint4_mt start, uint4_mt end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static uint4_mt unlerp([This] uint a, uint4_mt start, uint4_mt end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static uint4_mt unlerp([This] uint4_mt a, uint start, uint end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static uint4_mt remap([This] uint4_mt a, uint4_mt srcStart, uint4_mt srcEnd, uint4_mt dstStart, uint4_mt dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static uint4_mt remap([This] uint4_mt a, uint srcStart, uint srcEnd, uint dstStart, uint dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static uint4_mt square([This] uint4_mt a) => a * a;

    [MethodImpl(256 | 512)]
    public static uint_mt dot([This] uint4_mt a, uint4_mt b)
    {
        // a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w
        return fma(a.w, b.w, fma(a.z, b.z, fma(a.y, b.y, a.x * b.x)));
    }

    [MethodImpl(256 | 512)]
    public static uint_mt lengthsq([This] uint4_mt a) => dot(a, a);

    [MethodImpl(256 | 512)]
    public static uint_mt distancesq([This] uint4_mt a, uint4_mt b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static uint_mt csum([This] uint4_mt a) => a.x + a.y + a.z + a.w;

    [MethodImpl(256 | 512)]
    public static uint_mt cmin([This] uint4_mt a) => a.x.min(a.y).min(a.z).min(a.w);

    [MethodImpl(256 | 512)]
    public static uint_mt cmax([This] uint4_mt a) => a.x.max(a.y).max(a.z).max(a.w);

}

#endregion // uint4_mt
#region long2_mt

public partial struct long2_mt
{
    #region Constants

    public static long2_mt Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static long2_mt One
    {
        [MethodImpl(256 | 512)]
        get => new(1L);
    }

    public static long2_mt Two
    {
        [MethodImpl(256 | 512)]
        get => new((1L + 1L));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static long2_mt operator-(long2_mt a) => new(-a.x, -a.y);

    [MethodImpl(256 | 512)]
    public static long2_mt operator+(long2_mt a, long2_mt b) => new(a.x + b.x, a.y + b.y);

    [MethodImpl(256 | 512)]
    public static long2_mt operator+(long2_mt a, long_mt b) => new(a.x + b, a.y + b);

    [MethodImpl(256 | 512)]
    public static long2_mt operator+(long_mt a, long2_mt b) => new(a + b.x, a + b.y);

    [MethodImpl(256 | 512)]
    public static long2_mt operator-(long2_mt a, long2_mt b) => new(a.x - b.x, a.y - b.y);

    [MethodImpl(256 | 512)]
    public static long2_mt operator-(long2_mt a, long_mt b) => new(a.x - b, a.y - b);

    [MethodImpl(256 | 512)]
    public static long2_mt operator-(long_mt a, long2_mt b) => new(a - b.x, a - b.y);

    [MethodImpl(256 | 512)]
    public static long2_mt operator*(long2_mt a, long2_mt b) => new(a.x * b.x, a.y * b.y);

    [MethodImpl(256 | 512)]
    public static long2_mt operator*(long2_mt a, long_mt b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static long2_mt operator*(long_mt a, long2_mt b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static long2_mt operator*(long2_mt a, long b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static long2_mt operator*(long a, long2_mt b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static long2_mt operator/(long2_mt a, long2_mt b) => new(a.x / b.x, a.y / b.y);

    [MethodImpl(256 | 512)]
    public static long2_mt operator/(long_mt a, long2_mt b) => new(a / b.x, a / b.y);

    [MethodImpl(256 | 512)]
    public static long2_mt operator/(long2_mt a, long_mt b) => new(a.x / b, a.y / b);

    [MethodImpl(256 | 512)]
    public static long2_mt operator/(long a, long2_mt b) => new(a / b.x, a / b.y);

    [MethodImpl(256 | 512)]
    public static long2_mt operator/(long2_mt a, long b) => new(a.x / b, a.y / b);

    [MethodImpl(256 | 512)]
    public static long2_mt operator%(long2_mt a, long2_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static long2_mt operator%(long_mt a, long2_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static long2_mt operator%(long2_mt a, long_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static long2_mt operator%(long a, long2_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static long2_mt operator%(long2_mt a, long b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static long2_mt operator++(long2_mt a) => a + long_mt.One;

    [MethodImpl(256 | 512)]
    public static long2_mt operator--(long2_mt a) => a - long_mt.One;

    #endregion // Operators
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static long2_mt abs([This] long2_mt a) => new(abs(a.x), abs(a.y));

    [MethodImpl(256 | 512)]
    public static long2_mt sign([This] long2_mt a) => new(sign(a.x), sign(a.y));

    [MethodImpl(256 | 512)]
    public static long2_mt min([This] long2_mt a, long2_mt b) => new(min(a.x, b.x), min(a.y, b.y));

    [MethodImpl(256 | 512)]
    public static long2_mt max([This] long2_mt a, long2_mt b) => new(max(a.x, b.x), max(a.y, b.y));

    [MethodImpl(256 | 512)]
    public static long2_mt clamp([This] long2_mt v, long2_mt min, long2_mt max) => math_mt.max(min, math_mt.min(max, v));

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static long2_mt fma([This] long2_mt a, long2_mt b, long2_mt c) => new(fma(a.x, b.x, c.x), fma(a.y, b.y, c.y));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static long2_mt fms([This] long2_mt a, long2_mt b, long2_mt c) => new(fms(a.x, b.x, c.x), fms(a.y, b.y, c.y));

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static long2_mt fnma([This] long2_mt a, long2_mt b, long2_mt c) => new(fnma(a.x, b.x, c.x), fnma(a.y, b.y, c.y));

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static long2_mt fsm([This] long2_mt c, long2_mt a, long2_mt b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static long2_mt fam([This] long2_mt c, long2_mt a, long2_mt b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static long2_mt mad([This] long2_mt a, long2_mt b, long2_mt c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static long2_mt lerp(long2_mt start, long2_mt end, [This] long2_mt t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static long2_mt lerp(long2_mt start, long2_mt end, [This] long t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static long2_mt lerp(long start, long end, [This] long2_mt t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static long2_mt unlerp([This] long2_mt a, long2_mt start, long2_mt end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static long2_mt unlerp([This] long a, long2_mt start, long2_mt end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static long2_mt unlerp([This] long2_mt a, long start, long end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static long2_mt remap([This] long2_mt a, long2_mt srcStart, long2_mt srcEnd, long2_mt dstStart, long2_mt dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static long2_mt remap([This] long2_mt a, long srcStart, long srcEnd, long dstStart, long dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static long2_mt square([This] long2_mt a) => a * a;

    [MethodImpl(256 | 512)]
    public static long_mt dot([This] long2_mt a, long2_mt b)
    {
        // a.x * b.x + a.y * b.y
        return fma(a.y, b.y, a.x * b.x);
    }

    [MethodImpl(256 | 512)]
    public static long_mt lengthsq([This] long2_mt a) => dot(a, a);

    [MethodImpl(256 | 512)]
    public static long_mt distancesq([This] long2_mt a, long2_mt b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static long_mt csum([This] long2_mt a) => a.x + a.y;

    [MethodImpl(256 | 512)]
    public static long_mt cmin([This] long2_mt a) => a.x.min(a.y);

    [MethodImpl(256 | 512)]
    public static long_mt cmax([This] long2_mt a) => a.x.max(a.y);

}

#endregion // long2_mt
#region long3_mt

public partial struct long3_mt
{
    #region Constants

    public static long3_mt Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static long3_mt One
    {
        [MethodImpl(256 | 512)]
        get => new(1L);
    }

    public static long3_mt Two
    {
        [MethodImpl(256 | 512)]
        get => new((1L + 1L));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static long3_mt operator-(long3_mt a) => new(-a.x, -a.y, -a.z);

    [MethodImpl(256 | 512)]
    public static long3_mt operator+(long3_mt a, long3_mt b) => new(a.x + b.x, a.y + b.y, a.z + b.z);

    [MethodImpl(256 | 512)]
    public static long3_mt operator+(long3_mt a, long_mt b) => new(a.x + b, a.y + b, a.z + b);

    [MethodImpl(256 | 512)]
    public static long3_mt operator+(long_mt a, long3_mt b) => new(a + b.x, a + b.y, a + b.z);

    [MethodImpl(256 | 512)]
    public static long3_mt operator-(long3_mt a, long3_mt b) => new(a.x - b.x, a.y - b.y, a.z - b.z);

    [MethodImpl(256 | 512)]
    public static long3_mt operator-(long3_mt a, long_mt b) => new(a.x - b, a.y - b, a.z - b);

    [MethodImpl(256 | 512)]
    public static long3_mt operator-(long_mt a, long3_mt b) => new(a - b.x, a - b.y, a - b.z);

    [MethodImpl(256 | 512)]
    public static long3_mt operator*(long3_mt a, long3_mt b) => new(a.x * b.x, a.y * b.y, a.z * b.z);

    [MethodImpl(256 | 512)]
    public static long3_mt operator*(long3_mt a, long_mt b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static long3_mt operator*(long_mt a, long3_mt b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static long3_mt operator*(long3_mt a, long b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static long3_mt operator*(long a, long3_mt b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static long3_mt operator/(long3_mt a, long3_mt b) => new(a.x / b.x, a.y / b.y, a.z / b.z);

    [MethodImpl(256 | 512)]
    public static long3_mt operator/(long_mt a, long3_mt b) => new(a / b.x, a / b.y, a / b.z);

    [MethodImpl(256 | 512)]
    public static long3_mt operator/(long3_mt a, long_mt b) => new(a.x / b, a.y / b, a.z / b);

    [MethodImpl(256 | 512)]
    public static long3_mt operator/(long a, long3_mt b) => new(a / b.x, a / b.y, a / b.z);

    [MethodImpl(256 | 512)]
    public static long3_mt operator/(long3_mt a, long b) => new(a.x / b, a.y / b, a.z / b);

    [MethodImpl(256 | 512)]
    public static long3_mt operator%(long3_mt a, long3_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static long3_mt operator%(long_mt a, long3_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static long3_mt operator%(long3_mt a, long_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static long3_mt operator%(long a, long3_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static long3_mt operator%(long3_mt a, long b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static long3_mt operator++(long3_mt a) => a + long_mt.One;

    [MethodImpl(256 | 512)]
    public static long3_mt operator--(long3_mt a) => a - long_mt.One;

    #endregion // Operators
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static long3_mt abs([This] long3_mt a) => new(abs(a.x), abs(a.y), abs(a.z));

    [MethodImpl(256 | 512)]
    public static long3_mt sign([This] long3_mt a) => new(sign(a.x), sign(a.y), sign(a.z));

    [MethodImpl(256 | 512)]
    public static long3_mt min([This] long3_mt a, long3_mt b) => new(min(a.x, b.x), min(a.y, b.y), min(a.z, b.z));

    [MethodImpl(256 | 512)]
    public static long3_mt max([This] long3_mt a, long3_mt b) => new(max(a.x, b.x), max(a.y, b.y), max(a.z, b.z));

    [MethodImpl(256 | 512)]
    public static long3_mt clamp([This] long3_mt v, long3_mt min, long3_mt max) => math_mt.max(min, math_mt.min(max, v));

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static long3_mt fma([This] long3_mt a, long3_mt b, long3_mt c) => new(fma(a.x, b.x, c.x), fma(a.y, b.y, c.y), fma(a.z, b.z, c.z));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static long3_mt fms([This] long3_mt a, long3_mt b, long3_mt c) => new(fms(a.x, b.x, c.x), fms(a.y, b.y, c.y), fms(a.z, b.z, c.z));

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static long3_mt fnma([This] long3_mt a, long3_mt b, long3_mt c) => new(fnma(a.x, b.x, c.x), fnma(a.y, b.y, c.y), fnma(a.z, b.z, c.z));

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static long3_mt fsm([This] long3_mt c, long3_mt a, long3_mt b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static long3_mt fam([This] long3_mt c, long3_mt a, long3_mt b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static long3_mt mad([This] long3_mt a, long3_mt b, long3_mt c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static long3_mt lerp(long3_mt start, long3_mt end, [This] long3_mt t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static long3_mt lerp(long3_mt start, long3_mt end, [This] long t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static long3_mt lerp(long start, long end, [This] long3_mt t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static long3_mt unlerp([This] long3_mt a, long3_mt start, long3_mt end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static long3_mt unlerp([This] long a, long3_mt start, long3_mt end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static long3_mt unlerp([This] long3_mt a, long start, long end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static long3_mt remap([This] long3_mt a, long3_mt srcStart, long3_mt srcEnd, long3_mt dstStart, long3_mt dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static long3_mt remap([This] long3_mt a, long srcStart, long srcEnd, long dstStart, long dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static long3_mt square([This] long3_mt a) => a * a;

    [MethodImpl(256 | 512)]
    public static long_mt dot([This] long3_mt a, long3_mt b)
    {
        // a.x * b.x + a.y * b.y + a.z * b.z
        return fma(a.z, b.z, fma(a.y, b.y, a.x * b.x));
    }

    [MethodImpl(256 | 512)]
    public static long3_mt cross([This] long3_mt a, long3_mt b)
    {
        // (a * b.yzx - a.yzx * b).yzx;
        return fnma(a.yzx, b, a * b.yzx).yzx;
    }

    [MethodImpl(256 | 512)]
    public static long_mt lengthsq([This] long3_mt a) => dot(a, a);

    [MethodImpl(256 | 512)]
    public static long_mt distancesq([This] long3_mt a, long3_mt b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static long_mt csum([This] long3_mt a) => a.x + a.y + a.z;

    [MethodImpl(256 | 512)]
    public static long_mt cmin([This] long3_mt a) => a.x.min(a.y).min(a.z);

    [MethodImpl(256 | 512)]
    public static long_mt cmax([This] long3_mt a) => a.x.max(a.y).max(a.z);

}

#endregion // long3_mt
#region long4_mt

public partial struct long4_mt
{
    #region Constants

    public static long4_mt Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static long4_mt One
    {
        [MethodImpl(256 | 512)]
        get => new(1L);
    }

    public static long4_mt Two
    {
        [MethodImpl(256 | 512)]
        get => new((1L + 1L));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static long4_mt operator-(long4_mt a) => new(-a.x, -a.y, -a.z, -a.w);

    [MethodImpl(256 | 512)]
    public static long4_mt operator+(long4_mt a, long4_mt b) => new(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);

    [MethodImpl(256 | 512)]
    public static long4_mt operator+(long4_mt a, long_mt b) => new(a.x + b, a.y + b, a.z + b, a.w + b);

    [MethodImpl(256 | 512)]
    public static long4_mt operator+(long_mt a, long4_mt b) => new(a + b.x, a + b.y, a + b.z, a + b.w);

    [MethodImpl(256 | 512)]
    public static long4_mt operator-(long4_mt a, long4_mt b) => new(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);

    [MethodImpl(256 | 512)]
    public static long4_mt operator-(long4_mt a, long_mt b) => new(a.x - b, a.y - b, a.z - b, a.w - b);

    [MethodImpl(256 | 512)]
    public static long4_mt operator-(long_mt a, long4_mt b) => new(a - b.x, a - b.y, a - b.z, a - b.w);

    [MethodImpl(256 | 512)]
    public static long4_mt operator*(long4_mt a, long4_mt b) => new(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);

    [MethodImpl(256 | 512)]
    public static long4_mt operator*(long4_mt a, long_mt b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static long4_mt operator*(long_mt a, long4_mt b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static long4_mt operator*(long4_mt a, long b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static long4_mt operator*(long a, long4_mt b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static long4_mt operator/(long4_mt a, long4_mt b) => new(a.x / b.x, a.y / b.y, a.z / b.z, a.w / b.w);

    [MethodImpl(256 | 512)]
    public static long4_mt operator/(long_mt a, long4_mt b) => new(a / b.x, a / b.y, a / b.z, a / b.w);

    [MethodImpl(256 | 512)]
    public static long4_mt operator/(long4_mt a, long_mt b) => new(a.x / b, a.y / b, a.z / b, a.w / b);

    [MethodImpl(256 | 512)]
    public static long4_mt operator/(long a, long4_mt b) => new(a / b.x, a / b.y, a / b.z, a / b.w);

    [MethodImpl(256 | 512)]
    public static long4_mt operator/(long4_mt a, long b) => new(a.x / b, a.y / b, a.z / b, a.w / b);

    [MethodImpl(256 | 512)]
    public static long4_mt operator%(long4_mt a, long4_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static long4_mt operator%(long_mt a, long4_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static long4_mt operator%(long4_mt a, long_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static long4_mt operator%(long a, long4_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static long4_mt operator%(long4_mt a, long b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static long4_mt operator++(long4_mt a) => a + long_mt.One;

    [MethodImpl(256 | 512)]
    public static long4_mt operator--(long4_mt a) => a - long_mt.One;

    #endregion // Operators
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static long4_mt abs([This] long4_mt a) => new(abs(a.x), abs(a.y), abs(a.z), abs(a.w));

    [MethodImpl(256 | 512)]
    public static long4_mt sign([This] long4_mt a) => new(sign(a.x), sign(a.y), sign(a.z), sign(a.w));

    [MethodImpl(256 | 512)]
    public static long4_mt min([This] long4_mt a, long4_mt b) => new(min(a.x, b.x), min(a.y, b.y), min(a.z, b.z), min(a.w, b.w));

    [MethodImpl(256 | 512)]
    public static long4_mt max([This] long4_mt a, long4_mt b) => new(max(a.x, b.x), max(a.y, b.y), max(a.z, b.z), max(a.w, b.w));

    [MethodImpl(256 | 512)]
    public static long4_mt clamp([This] long4_mt v, long4_mt min, long4_mt max) => math_mt.max(min, math_mt.min(max, v));

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static long4_mt fma([This] long4_mt a, long4_mt b, long4_mt c) => new(fma(a.x, b.x, c.x), fma(a.y, b.y, c.y), fma(a.z, b.z, c.z), fma(a.w, b.w, c.w));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static long4_mt fms([This] long4_mt a, long4_mt b, long4_mt c) => new(fms(a.x, b.x, c.x), fms(a.y, b.y, c.y), fms(a.z, b.z, c.z), fms(a.w, b.w, c.w));

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static long4_mt fnma([This] long4_mt a, long4_mt b, long4_mt c) => new(fnma(a.x, b.x, c.x), fnma(a.y, b.y, c.y), fnma(a.z, b.z, c.z), fnma(a.w, b.w, c.w));

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static long4_mt fsm([This] long4_mt c, long4_mt a, long4_mt b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static long4_mt fam([This] long4_mt c, long4_mt a, long4_mt b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static long4_mt mad([This] long4_mt a, long4_mt b, long4_mt c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static long4_mt lerp(long4_mt start, long4_mt end, [This] long4_mt t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static long4_mt lerp(long4_mt start, long4_mt end, [This] long t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static long4_mt lerp(long start, long end, [This] long4_mt t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static long4_mt unlerp([This] long4_mt a, long4_mt start, long4_mt end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static long4_mt unlerp([This] long a, long4_mt start, long4_mt end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static long4_mt unlerp([This] long4_mt a, long start, long end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static long4_mt remap([This] long4_mt a, long4_mt srcStart, long4_mt srcEnd, long4_mt dstStart, long4_mt dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static long4_mt remap([This] long4_mt a, long srcStart, long srcEnd, long dstStart, long dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static long4_mt square([This] long4_mt a) => a * a;

    [MethodImpl(256 | 512)]
    public static long_mt dot([This] long4_mt a, long4_mt b)
    {
        // a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w
        return fma(a.w, b.w, fma(a.z, b.z, fma(a.y, b.y, a.x * b.x)));
    }

    [MethodImpl(256 | 512)]
    public static long_mt lengthsq([This] long4_mt a) => dot(a, a);

    [MethodImpl(256 | 512)]
    public static long_mt distancesq([This] long4_mt a, long4_mt b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static long_mt csum([This] long4_mt a) => a.x + a.y + a.z + a.w;

    [MethodImpl(256 | 512)]
    public static long_mt cmin([This] long4_mt a) => a.x.min(a.y).min(a.z).min(a.w);

    [MethodImpl(256 | 512)]
    public static long_mt cmax([This] long4_mt a) => a.x.max(a.y).max(a.z).max(a.w);

}

#endregion // long4_mt
#region ulong2_mt

public partial struct ulong2_mt
{
    #region Constants

    public static ulong2_mt Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static ulong2_mt One
    {
        [MethodImpl(256 | 512)]
        get => new(1UL);
    }

    public static ulong2_mt Two
    {
        [MethodImpl(256 | 512)]
        get => new((1UL + 1UL));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static ulong2_mt operator-(ulong2_mt a) => new(-a.x, -a.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt operator+(ulong2_mt a, ulong2_mt b) => new(a.x + b.x, a.y + b.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt operator+(ulong2_mt a, ulong_mt b) => new(a.x + b, a.y + b);

    [MethodImpl(256 | 512)]
    public static ulong2_mt operator+(ulong_mt a, ulong2_mt b) => new(a + b.x, a + b.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt operator-(ulong2_mt a, ulong2_mt b) => new(a.x - b.x, a.y - b.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt operator-(ulong2_mt a, ulong_mt b) => new(a.x - b, a.y - b);

    [MethodImpl(256 | 512)]
    public static ulong2_mt operator-(ulong_mt a, ulong2_mt b) => new(a - b.x, a - b.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt operator*(ulong2_mt a, ulong2_mt b) => new(a.x * b.x, a.y * b.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt operator*(ulong2_mt a, ulong_mt b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static ulong2_mt operator*(ulong_mt a, ulong2_mt b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt operator*(ulong2_mt a, ulong b) => new(a.x * b, a.y * b);

    [MethodImpl(256 | 512)]
    public static ulong2_mt operator*(ulong a, ulong2_mt b) => new(a * b.x, a * b.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt operator/(ulong2_mt a, ulong2_mt b) => new(a.x / b.x, a.y / b.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt operator/(ulong_mt a, ulong2_mt b) => new(a / b.x, a / b.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt operator/(ulong2_mt a, ulong_mt b) => new(a.x / b, a.y / b);

    [MethodImpl(256 | 512)]
    public static ulong2_mt operator/(ulong a, ulong2_mt b) => new(a / b.x, a / b.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt operator/(ulong2_mt a, ulong b) => new(a.x / b, a.y / b);

    [MethodImpl(256 | 512)]
    public static ulong2_mt operator%(ulong2_mt a, ulong2_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static ulong2_mt operator%(ulong_mt a, ulong2_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static ulong2_mt operator%(ulong2_mt a, ulong_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static ulong2_mt operator%(ulong a, ulong2_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static ulong2_mt operator%(ulong2_mt a, ulong b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static ulong2_mt operator++(ulong2_mt a) => a + ulong_mt.One;

    [MethodImpl(256 | 512)]
    public static ulong2_mt operator--(ulong2_mt a) => a - ulong_mt.One;

    #endregion // Operators
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static ulong2_mt abs([This] ulong2_mt a) => new(abs(a.x), abs(a.y));

    [MethodImpl(256 | 512)]
    public static ulong2_mt sign([This] ulong2_mt a) => new(sign(a.x), sign(a.y));

    [MethodImpl(256 | 512)]
    public static ulong2_mt min([This] ulong2_mt a, ulong2_mt b) => new(min(a.x, b.x), min(a.y, b.y));

    [MethodImpl(256 | 512)]
    public static ulong2_mt max([This] ulong2_mt a, ulong2_mt b) => new(max(a.x, b.x), max(a.y, b.y));

    [MethodImpl(256 | 512)]
    public static ulong2_mt clamp([This] ulong2_mt v, ulong2_mt min, ulong2_mt max) => math_mt.max(min, math_mt.min(max, v));

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ulong2_mt fma([This] ulong2_mt a, ulong2_mt b, ulong2_mt c) => new(fma(a.x, b.x, c.x), fma(a.y, b.y, c.y));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static ulong2_mt fms([This] ulong2_mt a, ulong2_mt b, ulong2_mt c) => new(fms(a.x, b.x, c.x), fms(a.y, b.y, c.y));

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static ulong2_mt fnma([This] ulong2_mt a, ulong2_mt b, ulong2_mt c) => new(fnma(a.x, b.x, c.x), fnma(a.y, b.y, c.y));

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static ulong2_mt fsm([This] ulong2_mt c, ulong2_mt a, ulong2_mt b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ulong2_mt fam([This] ulong2_mt c, ulong2_mt a, ulong2_mt b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ulong2_mt mad([This] ulong2_mt a, ulong2_mt b, ulong2_mt c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static ulong2_mt lerp(ulong2_mt start, ulong2_mt end, [This] ulong2_mt t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static ulong2_mt lerp(ulong2_mt start, ulong2_mt end, [This] ulong t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static ulong2_mt lerp(ulong start, ulong end, [This] ulong2_mt t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static ulong2_mt unlerp([This] ulong2_mt a, ulong2_mt start, ulong2_mt end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ulong2_mt unlerp([This] ulong a, ulong2_mt start, ulong2_mt end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ulong2_mt unlerp([This] ulong2_mt a, ulong start, ulong end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ulong2_mt remap([This] ulong2_mt a, ulong2_mt srcStart, ulong2_mt srcEnd, ulong2_mt dstStart, ulong2_mt dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static ulong2_mt remap([This] ulong2_mt a, ulong srcStart, ulong srcEnd, ulong dstStart, ulong dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static ulong2_mt square([This] ulong2_mt a) => a * a;

    [MethodImpl(256 | 512)]
    public static ulong_mt dot([This] ulong2_mt a, ulong2_mt b)
    {
        // a.x * b.x + a.y * b.y
        return fma(a.y, b.y, a.x * b.x);
    }

    [MethodImpl(256 | 512)]
    public static ulong_mt lengthsq([This] ulong2_mt a) => dot(a, a);

    [MethodImpl(256 | 512)]
    public static ulong_mt distancesq([This] ulong2_mt a, ulong2_mt b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static ulong_mt csum([This] ulong2_mt a) => a.x + a.y;

    [MethodImpl(256 | 512)]
    public static ulong_mt cmin([This] ulong2_mt a) => a.x.min(a.y);

    [MethodImpl(256 | 512)]
    public static ulong_mt cmax([This] ulong2_mt a) => a.x.max(a.y);

}

#endregion // ulong2_mt
#region ulong3_mt

public partial struct ulong3_mt
{
    #region Constants

    public static ulong3_mt Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static ulong3_mt One
    {
        [MethodImpl(256 | 512)]
        get => new(1UL);
    }

    public static ulong3_mt Two
    {
        [MethodImpl(256 | 512)]
        get => new((1UL + 1UL));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static ulong3_mt operator-(ulong3_mt a) => new(-a.x, -a.y, -a.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt operator+(ulong3_mt a, ulong3_mt b) => new(a.x + b.x, a.y + b.y, a.z + b.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt operator+(ulong3_mt a, ulong_mt b) => new(a.x + b, a.y + b, a.z + b);

    [MethodImpl(256 | 512)]
    public static ulong3_mt operator+(ulong_mt a, ulong3_mt b) => new(a + b.x, a + b.y, a + b.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt operator-(ulong3_mt a, ulong3_mt b) => new(a.x - b.x, a.y - b.y, a.z - b.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt operator-(ulong3_mt a, ulong_mt b) => new(a.x - b, a.y - b, a.z - b);

    [MethodImpl(256 | 512)]
    public static ulong3_mt operator-(ulong_mt a, ulong3_mt b) => new(a - b.x, a - b.y, a - b.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt operator*(ulong3_mt a, ulong3_mt b) => new(a.x * b.x, a.y * b.y, a.z * b.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt operator*(ulong3_mt a, ulong_mt b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static ulong3_mt operator*(ulong_mt a, ulong3_mt b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt operator*(ulong3_mt a, ulong b) => new(a.x * b, a.y * b, a.z * b);

    [MethodImpl(256 | 512)]
    public static ulong3_mt operator*(ulong a, ulong3_mt b) => new(a * b.x, a * b.y, a * b.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt operator/(ulong3_mt a, ulong3_mt b) => new(a.x / b.x, a.y / b.y, a.z / b.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt operator/(ulong_mt a, ulong3_mt b) => new(a / b.x, a / b.y, a / b.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt operator/(ulong3_mt a, ulong_mt b) => new(a.x / b, a.y / b, a.z / b);

    [MethodImpl(256 | 512)]
    public static ulong3_mt operator/(ulong a, ulong3_mt b) => new(a / b.x, a / b.y, a / b.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt operator/(ulong3_mt a, ulong b) => new(a.x / b, a.y / b, a.z / b);

    [MethodImpl(256 | 512)]
    public static ulong3_mt operator%(ulong3_mt a, ulong3_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static ulong3_mt operator%(ulong_mt a, ulong3_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static ulong3_mt operator%(ulong3_mt a, ulong_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static ulong3_mt operator%(ulong a, ulong3_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static ulong3_mt operator%(ulong3_mt a, ulong b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static ulong3_mt operator++(ulong3_mt a) => a + ulong_mt.One;

    [MethodImpl(256 | 512)]
    public static ulong3_mt operator--(ulong3_mt a) => a - ulong_mt.One;

    #endregion // Operators
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static ulong3_mt abs([This] ulong3_mt a) => new(abs(a.x), abs(a.y), abs(a.z));

    [MethodImpl(256 | 512)]
    public static ulong3_mt sign([This] ulong3_mt a) => new(sign(a.x), sign(a.y), sign(a.z));

    [MethodImpl(256 | 512)]
    public static ulong3_mt min([This] ulong3_mt a, ulong3_mt b) => new(min(a.x, b.x), min(a.y, b.y), min(a.z, b.z));

    [MethodImpl(256 | 512)]
    public static ulong3_mt max([This] ulong3_mt a, ulong3_mt b) => new(max(a.x, b.x), max(a.y, b.y), max(a.z, b.z));

    [MethodImpl(256 | 512)]
    public static ulong3_mt clamp([This] ulong3_mt v, ulong3_mt min, ulong3_mt max) => math_mt.max(min, math_mt.min(max, v));

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ulong3_mt fma([This] ulong3_mt a, ulong3_mt b, ulong3_mt c) => new(fma(a.x, b.x, c.x), fma(a.y, b.y, c.y), fma(a.z, b.z, c.z));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static ulong3_mt fms([This] ulong3_mt a, ulong3_mt b, ulong3_mt c) => new(fms(a.x, b.x, c.x), fms(a.y, b.y, c.y), fms(a.z, b.z, c.z));

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static ulong3_mt fnma([This] ulong3_mt a, ulong3_mt b, ulong3_mt c) => new(fnma(a.x, b.x, c.x), fnma(a.y, b.y, c.y), fnma(a.z, b.z, c.z));

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static ulong3_mt fsm([This] ulong3_mt c, ulong3_mt a, ulong3_mt b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ulong3_mt fam([This] ulong3_mt c, ulong3_mt a, ulong3_mt b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ulong3_mt mad([This] ulong3_mt a, ulong3_mt b, ulong3_mt c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static ulong3_mt lerp(ulong3_mt start, ulong3_mt end, [This] ulong3_mt t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static ulong3_mt lerp(ulong3_mt start, ulong3_mt end, [This] ulong t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static ulong3_mt lerp(ulong start, ulong end, [This] ulong3_mt t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static ulong3_mt unlerp([This] ulong3_mt a, ulong3_mt start, ulong3_mt end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ulong3_mt unlerp([This] ulong a, ulong3_mt start, ulong3_mt end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ulong3_mt unlerp([This] ulong3_mt a, ulong start, ulong end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ulong3_mt remap([This] ulong3_mt a, ulong3_mt srcStart, ulong3_mt srcEnd, ulong3_mt dstStart, ulong3_mt dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static ulong3_mt remap([This] ulong3_mt a, ulong srcStart, ulong srcEnd, ulong dstStart, ulong dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static ulong3_mt square([This] ulong3_mt a) => a * a;

    [MethodImpl(256 | 512)]
    public static ulong_mt dot([This] ulong3_mt a, ulong3_mt b)
    {
        // a.x * b.x + a.y * b.y + a.z * b.z
        return fma(a.z, b.z, fma(a.y, b.y, a.x * b.x));
    }

    [MethodImpl(256 | 512)]
    public static ulong3_mt cross([This] ulong3_mt a, ulong3_mt b)
    {
        // (a * b.yzx - a.yzx * b).yzx;
        return fnma(a.yzx, b, a * b.yzx).yzx;
    }

    [MethodImpl(256 | 512)]
    public static ulong_mt lengthsq([This] ulong3_mt a) => dot(a, a);

    [MethodImpl(256 | 512)]
    public static ulong_mt distancesq([This] ulong3_mt a, ulong3_mt b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static ulong_mt csum([This] ulong3_mt a) => a.x + a.y + a.z;

    [MethodImpl(256 | 512)]
    public static ulong_mt cmin([This] ulong3_mt a) => a.x.min(a.y).min(a.z);

    [MethodImpl(256 | 512)]
    public static ulong_mt cmax([This] ulong3_mt a) => a.x.max(a.y).max(a.z);

}

#endregion // ulong3_mt
#region ulong4_mt

public partial struct ulong4_mt
{
    #region Constants

    public static ulong4_mt Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static ulong4_mt One
    {
        [MethodImpl(256 | 512)]
        get => new(1UL);
    }

    public static ulong4_mt Two
    {
        [MethodImpl(256 | 512)]
        get => new((1UL + 1UL));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static ulong4_mt operator-(ulong4_mt a) => new(-a.x, -a.y, -a.z, -a.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt operator+(ulong4_mt a, ulong4_mt b) => new(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt operator+(ulong4_mt a, ulong_mt b) => new(a.x + b, a.y + b, a.z + b, a.w + b);

    [MethodImpl(256 | 512)]
    public static ulong4_mt operator+(ulong_mt a, ulong4_mt b) => new(a + b.x, a + b.y, a + b.z, a + b.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt operator-(ulong4_mt a, ulong4_mt b) => new(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt operator-(ulong4_mt a, ulong_mt b) => new(a.x - b, a.y - b, a.z - b, a.w - b);

    [MethodImpl(256 | 512)]
    public static ulong4_mt operator-(ulong_mt a, ulong4_mt b) => new(a - b.x, a - b.y, a - b.z, a - b.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt operator*(ulong4_mt a, ulong4_mt b) => new(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt operator*(ulong4_mt a, ulong_mt b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static ulong4_mt operator*(ulong_mt a, ulong4_mt b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt operator*(ulong4_mt a, ulong b) => new(a.x * b, a.y * b, a.z * b, a.w * b);

    [MethodImpl(256 | 512)]
    public static ulong4_mt operator*(ulong a, ulong4_mt b) => new(a * b.x, a * b.y, a * b.z, a * b.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt operator/(ulong4_mt a, ulong4_mt b) => new(a.x / b.x, a.y / b.y, a.z / b.z, a.w / b.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt operator/(ulong_mt a, ulong4_mt b) => new(a / b.x, a / b.y, a / b.z, a / b.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt operator/(ulong4_mt a, ulong_mt b) => new(a.x / b, a.y / b, a.z / b, a.w / b);

    [MethodImpl(256 | 512)]
    public static ulong4_mt operator/(ulong a, ulong4_mt b) => new(a / b.x, a / b.y, a / b.z, a / b.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt operator/(ulong4_mt a, ulong b) => new(a.x / b, a.y / b, a.z / b, a.w / b);

    [MethodImpl(256 | 512)]
    public static ulong4_mt operator%(ulong4_mt a, ulong4_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static ulong4_mt operator%(ulong_mt a, ulong4_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static ulong4_mt operator%(ulong4_mt a, ulong_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static ulong4_mt operator%(ulong a, ulong4_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static ulong4_mt operator%(ulong4_mt a, ulong b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static ulong4_mt operator++(ulong4_mt a) => a + ulong_mt.One;

    [MethodImpl(256 | 512)]
    public static ulong4_mt operator--(ulong4_mt a) => a - ulong_mt.One;

    #endregion // Operators
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static ulong4_mt abs([This] ulong4_mt a) => new(abs(a.x), abs(a.y), abs(a.z), abs(a.w));

    [MethodImpl(256 | 512)]
    public static ulong4_mt sign([This] ulong4_mt a) => new(sign(a.x), sign(a.y), sign(a.z), sign(a.w));

    [MethodImpl(256 | 512)]
    public static ulong4_mt min([This] ulong4_mt a, ulong4_mt b) => new(min(a.x, b.x), min(a.y, b.y), min(a.z, b.z), min(a.w, b.w));

    [MethodImpl(256 | 512)]
    public static ulong4_mt max([This] ulong4_mt a, ulong4_mt b) => new(max(a.x, b.x), max(a.y, b.y), max(a.z, b.z), max(a.w, b.w));

    [MethodImpl(256 | 512)]
    public static ulong4_mt clamp([This] ulong4_mt v, ulong4_mt min, ulong4_mt max) => math_mt.max(min, math_mt.min(max, v));

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ulong4_mt fma([This] ulong4_mt a, ulong4_mt b, ulong4_mt c) => new(fma(a.x, b.x, c.x), fma(a.y, b.y, c.y), fma(a.z, b.z, c.z), fma(a.w, b.w, c.w));

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static ulong4_mt fms([This] ulong4_mt a, ulong4_mt b, ulong4_mt c) => new(fms(a.x, b.x, c.x), fms(a.y, b.y, c.y), fms(a.z, b.z, c.z), fms(a.w, b.w, c.w));

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static ulong4_mt fnma([This] ulong4_mt a, ulong4_mt b, ulong4_mt c) => new(fnma(a.x, b.x, c.x), fnma(a.y, b.y, c.y), fnma(a.z, b.z, c.z), fnma(a.w, b.w, c.w));

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static ulong4_mt fsm([This] ulong4_mt c, ulong4_mt a, ulong4_mt b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ulong4_mt fam([This] ulong4_mt c, ulong4_mt a, ulong4_mt b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ulong4_mt mad([This] ulong4_mt a, ulong4_mt b, ulong4_mt c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static ulong4_mt lerp(ulong4_mt start, ulong4_mt end, [This] ulong4_mt t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static ulong4_mt lerp(ulong4_mt start, ulong4_mt end, [This] ulong t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static ulong4_mt lerp(ulong start, ulong end, [This] ulong4_mt t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static ulong4_mt unlerp([This] ulong4_mt a, ulong4_mt start, ulong4_mt end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ulong4_mt unlerp([This] ulong a, ulong4_mt start, ulong4_mt end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ulong4_mt unlerp([This] ulong4_mt a, ulong start, ulong end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ulong4_mt remap([This] ulong4_mt a, ulong4_mt srcStart, ulong4_mt srcEnd, ulong4_mt dstStart, ulong4_mt dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static ulong4_mt remap([This] ulong4_mt a, ulong srcStart, ulong srcEnd, ulong dstStart, ulong dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static ulong4_mt square([This] ulong4_mt a) => a * a;

    [MethodImpl(256 | 512)]
    public static ulong_mt dot([This] ulong4_mt a, ulong4_mt b)
    {
        // a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w
        return fma(a.w, b.w, fma(a.z, b.z, fma(a.y, b.y, a.x * b.x)));
    }

    [MethodImpl(256 | 512)]
    public static ulong_mt lengthsq([This] ulong4_mt a) => dot(a, a);

    [MethodImpl(256 | 512)]
    public static ulong_mt distancesq([This] ulong4_mt a, ulong4_mt b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static ulong_mt csum([This] ulong4_mt a) => a.x + a.y + a.z + a.w;

    [MethodImpl(256 | 512)]
    public static ulong_mt cmin([This] ulong4_mt a) => a.x.min(a.y).min(a.z).min(a.w);

    [MethodImpl(256 | 512)]
    public static ulong_mt cmax([This] ulong4_mt a) => a.x.max(a.y).max(a.z).max(a.w);

}

#endregion // ulong4_mt
