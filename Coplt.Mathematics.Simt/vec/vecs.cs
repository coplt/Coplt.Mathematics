// generated by template, do not modify manually

namespace Coplt.Mathematics.Simt;

#region float2_mt

[CpuOnly]
public partial struct float2_mt
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => float_mt.LineCount;
    }

    #endregion

    #region Fields

    public float_mt x;
    public float_mt y;

    #endregion // Fields

    #region Properties

    public float_mt r
    {
        [MethodImpl(256 | 512)]
        readonly get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public float_mt g
    {
        [MethodImpl(256 | 512)]
        readonly get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly float2 LaneGet(int index) => new(x[index], y[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, float2 value)
    {
        x[index] = value.x;
        y[index] = value.y;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public float2_mt(float_mt x, float_mt y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public float2_mt(float value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public float2_mt(float_mt value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public float2_mt(float2 value)
    {
        x = new(value.x);
        y = new(value.y);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator float2_mt(float value) => new float_mt(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float2_mt(float_mt value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float2_mt(float2 value) => new(value);

    [MethodImpl(256 | 512)]
    public static float2_mt operator~(float2_mt a) => new(~a.x, ~a.y);

    [MethodImpl(256 | 512)]
    public static float2_mt operator|(float2_mt a, float2_mt b) => new(a.x | b.x, a.y | b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt operator&(float2_mt a, float2_mt b) => new(a.x & b.x, a.y & b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt operator^(float2_mt a, float2_mt b) => new(a.x ^ b.x, a.y ^ b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt operator<<(float2_mt a, int b) => new(a.x << b, a.y << b);

    [MethodImpl(256 | 512)]
    public static float2_mt operator>>(float2_mt a, int b) => new(a.x >> b, a.y >> b);

    [MethodImpl(256 | 512)]
    public static float2_mt operator>>>(float2_mt a, int b) => new(a.x >>> b, a.y >>> b);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out float_mt x, out float_mt y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // Deconstruct

    #region Index

    public float_mt this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"float2_mt {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // float2_mt
#region float3_mt

[CpuOnly]
public partial struct float3_mt
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => float_mt.LineCount;
    }

    #endregion

    #region Fields

    public float_mt x;
    public float_mt y;
    public float_mt z;

    #endregion // Fields

    #region Properties

    public float_mt r
    {
        [MethodImpl(256 | 512)]
        readonly get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public float_mt g
    {
        [MethodImpl(256 | 512)]
        readonly get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public float_mt b
    {
        [MethodImpl(256 | 512)]
        readonly get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly float3 LaneGet(int index) => new(x[index], y[index], z[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, float3 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public float3_mt(float_mt x, float_mt y, float_mt z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public float3_mt(float value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public float3_mt(float_mt value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public float3_mt(float3 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator float3_mt(float value) => new float_mt(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float3_mt(float_mt value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float3_mt(float3 value) => new(value);

    [MethodImpl(256 | 512)]
    public static float3_mt operator~(float3_mt a) => new(~a.x, ~a.y, ~a.z);

    [MethodImpl(256 | 512)]
    public static float3_mt operator|(float3_mt a, float3_mt b) => new(a.x | b.x, a.y | b.y, a.z | b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt operator&(float3_mt a, float3_mt b) => new(a.x & b.x, a.y & b.y, a.z & b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt operator^(float3_mt a, float3_mt b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt operator<<(float3_mt a, int b) => new(a.x << b, a.y << b, a.z << b);

    [MethodImpl(256 | 512)]
    public static float3_mt operator>>(float3_mt a, int b) => new(a.x >> b, a.y >> b, a.z >> b);

    [MethodImpl(256 | 512)]
    public static float3_mt operator>>>(float3_mt a, int b) => new(a.x >>> b, a.y >>> b, a.z >>> b);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out float_mt x, out float_mt y, out float_mt z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // Deconstruct

    #region Index

    public float_mt this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"float3_mt {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // float3_mt
#region float4_mt

[CpuOnly]
public partial struct float4_mt
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => float_mt.LineCount;
    }

    #endregion

    #region Fields

    public float_mt x;
    public float_mt y;
    public float_mt z;
    public float_mt w;

    #endregion // Fields

    #region Properties

    public float_mt r
    {
        [MethodImpl(256 | 512)]
        readonly get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public float_mt g
    {
        [MethodImpl(256 | 512)]
        readonly get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public float_mt b
    {
        [MethodImpl(256 | 512)]
        readonly get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }
    public float_mt a
    {
        [MethodImpl(256 | 512)]
        readonly get => w;
        [MethodImpl(256 | 512)]
        set => w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly float4 LaneGet(int index) => new(x[index], y[index], z[index], w[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, float4 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
        w[index] = value.w;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public float4_mt(float_mt x, float_mt y, float_mt z, float_mt w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public float4_mt(float value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public float4_mt(float_mt value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public float4_mt(float4 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
        w = new(value.w);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator float4_mt(float value) => new float_mt(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float4_mt(float_mt value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float4_mt(float4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static float4_mt operator~(float4_mt a) => new(~a.x, ~a.y, ~a.z, ~a.w);

    [MethodImpl(256 | 512)]
    public static float4_mt operator|(float4_mt a, float4_mt b) => new(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt operator&(float4_mt a, float4_mt b) => new(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt operator^(float4_mt a, float4_mt b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt operator<<(float4_mt a, int b) => new(a.x << b, a.y << b, a.z << b, a.w << b);

    [MethodImpl(256 | 512)]
    public static float4_mt operator>>(float4_mt a, int b) => new(a.x >> b, a.y >> b, a.z >> b, a.w >> b);

    [MethodImpl(256 | 512)]
    public static float4_mt operator>>>(float4_mt a, int b) => new(a.x >>> b, a.y >>> b, a.z >>> b, a.w >>> b);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out float_mt x, out float_mt y, out float_mt z, out float_mt w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // Deconstruct

    #region Index

    public float_mt this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"float4_mt {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // float4_mt
#region double2_mt

[CpuOnly]
public partial struct double2_mt
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => double_mt.LineCount;
    }

    #endregion

    #region Fields

    public double_mt x;
    public double_mt y;

    #endregion // Fields

    #region Properties

    public double_mt r
    {
        [MethodImpl(256 | 512)]
        readonly get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public double_mt g
    {
        [MethodImpl(256 | 512)]
        readonly get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly double2 LaneGet(int index) => new(x[index], y[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, double2 value)
    {
        x[index] = value.x;
        y[index] = value.y;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public double2_mt(double_mt x, double_mt y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public double2_mt(double value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public double2_mt(double_mt value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public double2_mt(double2 value)
    {
        x = new(value.x);
        y = new(value.y);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator double2_mt(double value) => new double_mt(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double2_mt(double_mt value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double2_mt(double2 value) => new(value);

    [MethodImpl(256 | 512)]
    public static double2_mt operator~(double2_mt a) => new(~a.x, ~a.y);

    [MethodImpl(256 | 512)]
    public static double2_mt operator|(double2_mt a, double2_mt b) => new(a.x | b.x, a.y | b.y);

    [MethodImpl(256 | 512)]
    public static double2_mt operator&(double2_mt a, double2_mt b) => new(a.x & b.x, a.y & b.y);

    [MethodImpl(256 | 512)]
    public static double2_mt operator^(double2_mt a, double2_mt b) => new(a.x ^ b.x, a.y ^ b.y);

    [MethodImpl(256 | 512)]
    public static double2_mt operator<<(double2_mt a, int b) => new(a.x << b, a.y << b);

    [MethodImpl(256 | 512)]
    public static double2_mt operator>>(double2_mt a, int b) => new(a.x >> b, a.y >> b);

    [MethodImpl(256 | 512)]
    public static double2_mt operator>>>(double2_mt a, int b) => new(a.x >>> b, a.y >>> b);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out double_mt x, out double_mt y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // Deconstruct

    #region Index

    public double_mt this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"double2_mt {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // double2_mt
#region double3_mt

[CpuOnly]
public partial struct double3_mt
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => double_mt.LineCount;
    }

    #endregion

    #region Fields

    public double_mt x;
    public double_mt y;
    public double_mt z;

    #endregion // Fields

    #region Properties

    public double_mt r
    {
        [MethodImpl(256 | 512)]
        readonly get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public double_mt g
    {
        [MethodImpl(256 | 512)]
        readonly get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public double_mt b
    {
        [MethodImpl(256 | 512)]
        readonly get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly double3 LaneGet(int index) => new(x[index], y[index], z[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, double3 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public double3_mt(double_mt x, double_mt y, double_mt z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public double3_mt(double value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public double3_mt(double_mt value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public double3_mt(double3 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator double3_mt(double value) => new double_mt(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double3_mt(double_mt value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double3_mt(double3 value) => new(value);

    [MethodImpl(256 | 512)]
    public static double3_mt operator~(double3_mt a) => new(~a.x, ~a.y, ~a.z);

    [MethodImpl(256 | 512)]
    public static double3_mt operator|(double3_mt a, double3_mt b) => new(a.x | b.x, a.y | b.y, a.z | b.z);

    [MethodImpl(256 | 512)]
    public static double3_mt operator&(double3_mt a, double3_mt b) => new(a.x & b.x, a.y & b.y, a.z & b.z);

    [MethodImpl(256 | 512)]
    public static double3_mt operator^(double3_mt a, double3_mt b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z);

    [MethodImpl(256 | 512)]
    public static double3_mt operator<<(double3_mt a, int b) => new(a.x << b, a.y << b, a.z << b);

    [MethodImpl(256 | 512)]
    public static double3_mt operator>>(double3_mt a, int b) => new(a.x >> b, a.y >> b, a.z >> b);

    [MethodImpl(256 | 512)]
    public static double3_mt operator>>>(double3_mt a, int b) => new(a.x >>> b, a.y >>> b, a.z >>> b);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out double_mt x, out double_mt y, out double_mt z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // Deconstruct

    #region Index

    public double_mt this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"double3_mt {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // double3_mt
#region double4_mt

[CpuOnly]
public partial struct double4_mt
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => double_mt.LineCount;
    }

    #endregion

    #region Fields

    public double_mt x;
    public double_mt y;
    public double_mt z;
    public double_mt w;

    #endregion // Fields

    #region Properties

    public double_mt r
    {
        [MethodImpl(256 | 512)]
        readonly get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public double_mt g
    {
        [MethodImpl(256 | 512)]
        readonly get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public double_mt b
    {
        [MethodImpl(256 | 512)]
        readonly get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }
    public double_mt a
    {
        [MethodImpl(256 | 512)]
        readonly get => w;
        [MethodImpl(256 | 512)]
        set => w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly double4 LaneGet(int index) => new(x[index], y[index], z[index], w[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, double4 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
        w[index] = value.w;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public double4_mt(double_mt x, double_mt y, double_mt z, double_mt w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public double4_mt(double value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public double4_mt(double_mt value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public double4_mt(double4 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
        w = new(value.w);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator double4_mt(double value) => new double_mt(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double4_mt(double_mt value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double4_mt(double4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static double4_mt operator~(double4_mt a) => new(~a.x, ~a.y, ~a.z, ~a.w);

    [MethodImpl(256 | 512)]
    public static double4_mt operator|(double4_mt a, double4_mt b) => new(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);

    [MethodImpl(256 | 512)]
    public static double4_mt operator&(double4_mt a, double4_mt b) => new(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);

    [MethodImpl(256 | 512)]
    public static double4_mt operator^(double4_mt a, double4_mt b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);

    [MethodImpl(256 | 512)]
    public static double4_mt operator<<(double4_mt a, int b) => new(a.x << b, a.y << b, a.z << b, a.w << b);

    [MethodImpl(256 | 512)]
    public static double4_mt operator>>(double4_mt a, int b) => new(a.x >> b, a.y >> b, a.z >> b, a.w >> b);

    [MethodImpl(256 | 512)]
    public static double4_mt operator>>>(double4_mt a, int b) => new(a.x >>> b, a.y >>> b, a.z >>> b, a.w >>> b);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out double_mt x, out double_mt y, out double_mt z, out double_mt w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // Deconstruct

    #region Index

    public double_mt this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"double4_mt {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // double4_mt
#region int2_mt

[CpuOnly]
public partial struct int2_mt
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => int_mt.LineCount;
    }

    #endregion

    #region Fields

    public int_mt x;
    public int_mt y;

    #endregion // Fields

    #region Properties

    public int_mt r
    {
        [MethodImpl(256 | 512)]
        readonly get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public int_mt g
    {
        [MethodImpl(256 | 512)]
        readonly get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly int2 LaneGet(int index) => new(x[index], y[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, int2 value)
    {
        x[index] = value.x;
        y[index] = value.y;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public int2_mt(int_mt x, int_mt y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public int2_mt(int value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public int2_mt(int_mt value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public int2_mt(int2 value)
    {
        x = new(value.x);
        y = new(value.y);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator int2_mt(int value) => new int_mt(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int2_mt(int_mt value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int2_mt(int2 value) => new(value);

    [MethodImpl(256 | 512)]
    public static int2_mt operator~(int2_mt a) => new(~a.x, ~a.y);

    [MethodImpl(256 | 512)]
    public static int2_mt operator|(int2_mt a, int2_mt b) => new(a.x | b.x, a.y | b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt operator&(int2_mt a, int2_mt b) => new(a.x & b.x, a.y & b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt operator^(int2_mt a, int2_mt b) => new(a.x ^ b.x, a.y ^ b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt operator<<(int2_mt a, int b) => new(a.x << b, a.y << b);

    [MethodImpl(256 | 512)]
    public static int2_mt operator>>(int2_mt a, int b) => new(a.x >> b, a.y >> b);

    [MethodImpl(256 | 512)]
    public static int2_mt operator>>>(int2_mt a, int b) => new(a.x >>> b, a.y >>> b);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out int_mt x, out int_mt y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // Deconstruct

    #region Index

    public int_mt this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"int2_mt {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // int2_mt
#region int3_mt

[CpuOnly]
public partial struct int3_mt
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => int_mt.LineCount;
    }

    #endregion

    #region Fields

    public int_mt x;
    public int_mt y;
    public int_mt z;

    #endregion // Fields

    #region Properties

    public int_mt r
    {
        [MethodImpl(256 | 512)]
        readonly get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public int_mt g
    {
        [MethodImpl(256 | 512)]
        readonly get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public int_mt b
    {
        [MethodImpl(256 | 512)]
        readonly get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly int3 LaneGet(int index) => new(x[index], y[index], z[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, int3 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public int3_mt(int_mt x, int_mt y, int_mt z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public int3_mt(int value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public int3_mt(int_mt value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public int3_mt(int3 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator int3_mt(int value) => new int_mt(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int3_mt(int_mt value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int3_mt(int3 value) => new(value);

    [MethodImpl(256 | 512)]
    public static int3_mt operator~(int3_mt a) => new(~a.x, ~a.y, ~a.z);

    [MethodImpl(256 | 512)]
    public static int3_mt operator|(int3_mt a, int3_mt b) => new(a.x | b.x, a.y | b.y, a.z | b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt operator&(int3_mt a, int3_mt b) => new(a.x & b.x, a.y & b.y, a.z & b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt operator^(int3_mt a, int3_mt b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt operator<<(int3_mt a, int b) => new(a.x << b, a.y << b, a.z << b);

    [MethodImpl(256 | 512)]
    public static int3_mt operator>>(int3_mt a, int b) => new(a.x >> b, a.y >> b, a.z >> b);

    [MethodImpl(256 | 512)]
    public static int3_mt operator>>>(int3_mt a, int b) => new(a.x >>> b, a.y >>> b, a.z >>> b);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out int_mt x, out int_mt y, out int_mt z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // Deconstruct

    #region Index

    public int_mt this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"int3_mt {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // int3_mt
#region int4_mt

[CpuOnly]
public partial struct int4_mt
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => int_mt.LineCount;
    }

    #endregion

    #region Fields

    public int_mt x;
    public int_mt y;
    public int_mt z;
    public int_mt w;

    #endregion // Fields

    #region Properties

    public int_mt r
    {
        [MethodImpl(256 | 512)]
        readonly get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public int_mt g
    {
        [MethodImpl(256 | 512)]
        readonly get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public int_mt b
    {
        [MethodImpl(256 | 512)]
        readonly get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }
    public int_mt a
    {
        [MethodImpl(256 | 512)]
        readonly get => w;
        [MethodImpl(256 | 512)]
        set => w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly int4 LaneGet(int index) => new(x[index], y[index], z[index], w[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, int4 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
        w[index] = value.w;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public int4_mt(int_mt x, int_mt y, int_mt z, int_mt w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public int4_mt(int value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public int4_mt(int_mt value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public int4_mt(int4 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
        w = new(value.w);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator int4_mt(int value) => new int_mt(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int4_mt(int_mt value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int4_mt(int4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static int4_mt operator~(int4_mt a) => new(~a.x, ~a.y, ~a.z, ~a.w);

    [MethodImpl(256 | 512)]
    public static int4_mt operator|(int4_mt a, int4_mt b) => new(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt operator&(int4_mt a, int4_mt b) => new(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt operator^(int4_mt a, int4_mt b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt operator<<(int4_mt a, int b) => new(a.x << b, a.y << b, a.z << b, a.w << b);

    [MethodImpl(256 | 512)]
    public static int4_mt operator>>(int4_mt a, int b) => new(a.x >> b, a.y >> b, a.z >> b, a.w >> b);

    [MethodImpl(256 | 512)]
    public static int4_mt operator>>>(int4_mt a, int b) => new(a.x >>> b, a.y >>> b, a.z >>> b, a.w >>> b);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out int_mt x, out int_mt y, out int_mt z, out int_mt w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // Deconstruct

    #region Index

    public int_mt this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"int4_mt {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // int4_mt
#region uint2_mt

[CpuOnly]
public partial struct uint2_mt
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => uint_mt.LineCount;
    }

    #endregion

    #region Fields

    public uint_mt x;
    public uint_mt y;

    #endregion // Fields

    #region Properties

    public uint_mt r
    {
        [MethodImpl(256 | 512)]
        readonly get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public uint_mt g
    {
        [MethodImpl(256 | 512)]
        readonly get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly uint2 LaneGet(int index) => new(x[index], y[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, uint2 value)
    {
        x[index] = value.x;
        y[index] = value.y;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public uint2_mt(uint_mt x, uint_mt y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public uint2_mt(uint value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public uint2_mt(uint_mt value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public uint2_mt(uint2 value)
    {
        x = new(value.x);
        y = new(value.y);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator uint2_mt(uint value) => new uint_mt(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint2_mt(uint_mt value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint2_mt(uint2 value) => new(value);

    [MethodImpl(256 | 512)]
    public static uint2_mt operator~(uint2_mt a) => new(~a.x, ~a.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt operator|(uint2_mt a, uint2_mt b) => new(a.x | b.x, a.y | b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt operator&(uint2_mt a, uint2_mt b) => new(a.x & b.x, a.y & b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt operator^(uint2_mt a, uint2_mt b) => new(a.x ^ b.x, a.y ^ b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt operator<<(uint2_mt a, int b) => new(a.x << b, a.y << b);

    [MethodImpl(256 | 512)]
    public static uint2_mt operator>>(uint2_mt a, int b) => new(a.x >> b, a.y >> b);

    [MethodImpl(256 | 512)]
    public static uint2_mt operator>>>(uint2_mt a, int b) => new(a.x >>> b, a.y >>> b);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out uint_mt x, out uint_mt y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // Deconstruct

    #region Index

    public uint_mt this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"uint2_mt {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // uint2_mt
#region uint3_mt

[CpuOnly]
public partial struct uint3_mt
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => uint_mt.LineCount;
    }

    #endregion

    #region Fields

    public uint_mt x;
    public uint_mt y;
    public uint_mt z;

    #endregion // Fields

    #region Properties

    public uint_mt r
    {
        [MethodImpl(256 | 512)]
        readonly get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public uint_mt g
    {
        [MethodImpl(256 | 512)]
        readonly get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public uint_mt b
    {
        [MethodImpl(256 | 512)]
        readonly get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly uint3 LaneGet(int index) => new(x[index], y[index], z[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, uint3 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public uint3_mt(uint_mt x, uint_mt y, uint_mt z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public uint3_mt(uint value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public uint3_mt(uint_mt value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public uint3_mt(uint3 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator uint3_mt(uint value) => new uint_mt(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint3_mt(uint_mt value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint3_mt(uint3 value) => new(value);

    [MethodImpl(256 | 512)]
    public static uint3_mt operator~(uint3_mt a) => new(~a.x, ~a.y, ~a.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt operator|(uint3_mt a, uint3_mt b) => new(a.x | b.x, a.y | b.y, a.z | b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt operator&(uint3_mt a, uint3_mt b) => new(a.x & b.x, a.y & b.y, a.z & b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt operator^(uint3_mt a, uint3_mt b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt operator<<(uint3_mt a, int b) => new(a.x << b, a.y << b, a.z << b);

    [MethodImpl(256 | 512)]
    public static uint3_mt operator>>(uint3_mt a, int b) => new(a.x >> b, a.y >> b, a.z >> b);

    [MethodImpl(256 | 512)]
    public static uint3_mt operator>>>(uint3_mt a, int b) => new(a.x >>> b, a.y >>> b, a.z >>> b);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out uint_mt x, out uint_mt y, out uint_mt z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // Deconstruct

    #region Index

    public uint_mt this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"uint3_mt {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // uint3_mt
#region uint4_mt

[CpuOnly]
public partial struct uint4_mt
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => uint_mt.LineCount;
    }

    #endregion

    #region Fields

    public uint_mt x;
    public uint_mt y;
    public uint_mt z;
    public uint_mt w;

    #endregion // Fields

    #region Properties

    public uint_mt r
    {
        [MethodImpl(256 | 512)]
        readonly get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public uint_mt g
    {
        [MethodImpl(256 | 512)]
        readonly get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public uint_mt b
    {
        [MethodImpl(256 | 512)]
        readonly get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }
    public uint_mt a
    {
        [MethodImpl(256 | 512)]
        readonly get => w;
        [MethodImpl(256 | 512)]
        set => w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly uint4 LaneGet(int index) => new(x[index], y[index], z[index], w[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, uint4 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
        w[index] = value.w;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public uint4_mt(uint_mt x, uint_mt y, uint_mt z, uint_mt w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public uint4_mt(uint value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public uint4_mt(uint_mt value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public uint4_mt(uint4 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
        w = new(value.w);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator uint4_mt(uint value) => new uint_mt(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint4_mt(uint_mt value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint4_mt(uint4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static uint4_mt operator~(uint4_mt a) => new(~a.x, ~a.y, ~a.z, ~a.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt operator|(uint4_mt a, uint4_mt b) => new(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt operator&(uint4_mt a, uint4_mt b) => new(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt operator^(uint4_mt a, uint4_mt b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt operator<<(uint4_mt a, int b) => new(a.x << b, a.y << b, a.z << b, a.w << b);

    [MethodImpl(256 | 512)]
    public static uint4_mt operator>>(uint4_mt a, int b) => new(a.x >> b, a.y >> b, a.z >> b, a.w >> b);

    [MethodImpl(256 | 512)]
    public static uint4_mt operator>>>(uint4_mt a, int b) => new(a.x >>> b, a.y >>> b, a.z >>> b, a.w >>> b);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out uint_mt x, out uint_mt y, out uint_mt z, out uint_mt w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // Deconstruct

    #region Index

    public uint_mt this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"uint4_mt {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // uint4_mt
#region long2_mt

[CpuOnly]
public partial struct long2_mt
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => long_mt.LineCount;
    }

    #endregion

    #region Fields

    public long_mt x;
    public long_mt y;

    #endregion // Fields

    #region Properties

    public long_mt r
    {
        [MethodImpl(256 | 512)]
        readonly get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public long_mt g
    {
        [MethodImpl(256 | 512)]
        readonly get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly long2 LaneGet(int index) => new(x[index], y[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, long2 value)
    {
        x[index] = value.x;
        y[index] = value.y;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public long2_mt(long_mt x, long_mt y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public long2_mt(long value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public long2_mt(long_mt value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public long2_mt(long2 value)
    {
        x = new(value.x);
        y = new(value.y);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator long2_mt(long value) => new long_mt(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long2_mt(long_mt value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long2_mt(long2 value) => new(value);

    [MethodImpl(256 | 512)]
    public static long2_mt operator~(long2_mt a) => new(~a.x, ~a.y);

    [MethodImpl(256 | 512)]
    public static long2_mt operator|(long2_mt a, long2_mt b) => new(a.x | b.x, a.y | b.y);

    [MethodImpl(256 | 512)]
    public static long2_mt operator&(long2_mt a, long2_mt b) => new(a.x & b.x, a.y & b.y);

    [MethodImpl(256 | 512)]
    public static long2_mt operator^(long2_mt a, long2_mt b) => new(a.x ^ b.x, a.y ^ b.y);

    [MethodImpl(256 | 512)]
    public static long2_mt operator<<(long2_mt a, int b) => new(a.x << b, a.y << b);

    [MethodImpl(256 | 512)]
    public static long2_mt operator>>(long2_mt a, int b) => new(a.x >> b, a.y >> b);

    [MethodImpl(256 | 512)]
    public static long2_mt operator>>>(long2_mt a, int b) => new(a.x >>> b, a.y >>> b);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out long_mt x, out long_mt y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // Deconstruct

    #region Index

    public long_mt this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"long2_mt {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // long2_mt
#region long3_mt

[CpuOnly]
public partial struct long3_mt
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => long_mt.LineCount;
    }

    #endregion

    #region Fields

    public long_mt x;
    public long_mt y;
    public long_mt z;

    #endregion // Fields

    #region Properties

    public long_mt r
    {
        [MethodImpl(256 | 512)]
        readonly get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public long_mt g
    {
        [MethodImpl(256 | 512)]
        readonly get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public long_mt b
    {
        [MethodImpl(256 | 512)]
        readonly get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly long3 LaneGet(int index) => new(x[index], y[index], z[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, long3 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public long3_mt(long_mt x, long_mt y, long_mt z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public long3_mt(long value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public long3_mt(long_mt value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public long3_mt(long3 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator long3_mt(long value) => new long_mt(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long3_mt(long_mt value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long3_mt(long3 value) => new(value);

    [MethodImpl(256 | 512)]
    public static long3_mt operator~(long3_mt a) => new(~a.x, ~a.y, ~a.z);

    [MethodImpl(256 | 512)]
    public static long3_mt operator|(long3_mt a, long3_mt b) => new(a.x | b.x, a.y | b.y, a.z | b.z);

    [MethodImpl(256 | 512)]
    public static long3_mt operator&(long3_mt a, long3_mt b) => new(a.x & b.x, a.y & b.y, a.z & b.z);

    [MethodImpl(256 | 512)]
    public static long3_mt operator^(long3_mt a, long3_mt b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z);

    [MethodImpl(256 | 512)]
    public static long3_mt operator<<(long3_mt a, int b) => new(a.x << b, a.y << b, a.z << b);

    [MethodImpl(256 | 512)]
    public static long3_mt operator>>(long3_mt a, int b) => new(a.x >> b, a.y >> b, a.z >> b);

    [MethodImpl(256 | 512)]
    public static long3_mt operator>>>(long3_mt a, int b) => new(a.x >>> b, a.y >>> b, a.z >>> b);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out long_mt x, out long_mt y, out long_mt z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // Deconstruct

    #region Index

    public long_mt this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"long3_mt {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // long3_mt
#region long4_mt

[CpuOnly]
public partial struct long4_mt
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => long_mt.LineCount;
    }

    #endregion

    #region Fields

    public long_mt x;
    public long_mt y;
    public long_mt z;
    public long_mt w;

    #endregion // Fields

    #region Properties

    public long_mt r
    {
        [MethodImpl(256 | 512)]
        readonly get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public long_mt g
    {
        [MethodImpl(256 | 512)]
        readonly get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public long_mt b
    {
        [MethodImpl(256 | 512)]
        readonly get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }
    public long_mt a
    {
        [MethodImpl(256 | 512)]
        readonly get => w;
        [MethodImpl(256 | 512)]
        set => w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly long4 LaneGet(int index) => new(x[index], y[index], z[index], w[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, long4 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
        w[index] = value.w;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public long4_mt(long_mt x, long_mt y, long_mt z, long_mt w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public long4_mt(long value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public long4_mt(long_mt value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public long4_mt(long4 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
        w = new(value.w);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator long4_mt(long value) => new long_mt(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long4_mt(long_mt value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long4_mt(long4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static long4_mt operator~(long4_mt a) => new(~a.x, ~a.y, ~a.z, ~a.w);

    [MethodImpl(256 | 512)]
    public static long4_mt operator|(long4_mt a, long4_mt b) => new(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);

    [MethodImpl(256 | 512)]
    public static long4_mt operator&(long4_mt a, long4_mt b) => new(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);

    [MethodImpl(256 | 512)]
    public static long4_mt operator^(long4_mt a, long4_mt b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);

    [MethodImpl(256 | 512)]
    public static long4_mt operator<<(long4_mt a, int b) => new(a.x << b, a.y << b, a.z << b, a.w << b);

    [MethodImpl(256 | 512)]
    public static long4_mt operator>>(long4_mt a, int b) => new(a.x >> b, a.y >> b, a.z >> b, a.w >> b);

    [MethodImpl(256 | 512)]
    public static long4_mt operator>>>(long4_mt a, int b) => new(a.x >>> b, a.y >>> b, a.z >>> b, a.w >>> b);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out long_mt x, out long_mt y, out long_mt z, out long_mt w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // Deconstruct

    #region Index

    public long_mt this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"long4_mt {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // long4_mt
#region ulong2_mt

[CpuOnly]
public partial struct ulong2_mt
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => ulong_mt.LineCount;
    }

    #endregion

    #region Fields

    public ulong_mt x;
    public ulong_mt y;

    #endregion // Fields

    #region Properties

    public ulong_mt r
    {
        [MethodImpl(256 | 512)]
        readonly get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public ulong_mt g
    {
        [MethodImpl(256 | 512)]
        readonly get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly ulong2 LaneGet(int index) => new(x[index], y[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, ulong2 value)
    {
        x[index] = value.x;
        y[index] = value.y;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public ulong2_mt(ulong_mt x, ulong_mt y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public ulong2_mt(ulong value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public ulong2_mt(ulong_mt value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public ulong2_mt(ulong2 value)
    {
        x = new(value.x);
        y = new(value.y);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2_mt(ulong value) => new ulong_mt(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2_mt(ulong_mt value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2_mt(ulong2 value) => new(value);

    [MethodImpl(256 | 512)]
    public static ulong2_mt operator~(ulong2_mt a) => new(~a.x, ~a.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt operator|(ulong2_mt a, ulong2_mt b) => new(a.x | b.x, a.y | b.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt operator&(ulong2_mt a, ulong2_mt b) => new(a.x & b.x, a.y & b.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt operator^(ulong2_mt a, ulong2_mt b) => new(a.x ^ b.x, a.y ^ b.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt operator<<(ulong2_mt a, int b) => new(a.x << b, a.y << b);

    [MethodImpl(256 | 512)]
    public static ulong2_mt operator>>(ulong2_mt a, int b) => new(a.x >> b, a.y >> b);

    [MethodImpl(256 | 512)]
    public static ulong2_mt operator>>>(ulong2_mt a, int b) => new(a.x >>> b, a.y >>> b);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out ulong_mt x, out ulong_mt y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // Deconstruct

    #region Index

    public ulong_mt this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"ulong2_mt {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // ulong2_mt
#region ulong3_mt

[CpuOnly]
public partial struct ulong3_mt
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => ulong_mt.LineCount;
    }

    #endregion

    #region Fields

    public ulong_mt x;
    public ulong_mt y;
    public ulong_mt z;

    #endregion // Fields

    #region Properties

    public ulong_mt r
    {
        [MethodImpl(256 | 512)]
        readonly get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public ulong_mt g
    {
        [MethodImpl(256 | 512)]
        readonly get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public ulong_mt b
    {
        [MethodImpl(256 | 512)]
        readonly get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly ulong3 LaneGet(int index) => new(x[index], y[index], z[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, ulong3 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public ulong3_mt(ulong_mt x, ulong_mt y, ulong_mt z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public ulong3_mt(ulong value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public ulong3_mt(ulong_mt value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public ulong3_mt(ulong3 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3_mt(ulong value) => new ulong_mt(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3_mt(ulong_mt value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3_mt(ulong3 value) => new(value);

    [MethodImpl(256 | 512)]
    public static ulong3_mt operator~(ulong3_mt a) => new(~a.x, ~a.y, ~a.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt operator|(ulong3_mt a, ulong3_mt b) => new(a.x | b.x, a.y | b.y, a.z | b.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt operator&(ulong3_mt a, ulong3_mt b) => new(a.x & b.x, a.y & b.y, a.z & b.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt operator^(ulong3_mt a, ulong3_mt b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt operator<<(ulong3_mt a, int b) => new(a.x << b, a.y << b, a.z << b);

    [MethodImpl(256 | 512)]
    public static ulong3_mt operator>>(ulong3_mt a, int b) => new(a.x >> b, a.y >> b, a.z >> b);

    [MethodImpl(256 | 512)]
    public static ulong3_mt operator>>>(ulong3_mt a, int b) => new(a.x >>> b, a.y >>> b, a.z >>> b);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out ulong_mt x, out ulong_mt y, out ulong_mt z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // Deconstruct

    #region Index

    public ulong_mt this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"ulong3_mt {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // ulong3_mt
#region ulong4_mt

[CpuOnly]
public partial struct ulong4_mt
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => ulong_mt.LineCount;
    }

    #endregion

    #region Fields

    public ulong_mt x;
    public ulong_mt y;
    public ulong_mt z;
    public ulong_mt w;

    #endregion // Fields

    #region Properties

    public ulong_mt r
    {
        [MethodImpl(256 | 512)]
        readonly get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public ulong_mt g
    {
        [MethodImpl(256 | 512)]
        readonly get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public ulong_mt b
    {
        [MethodImpl(256 | 512)]
        readonly get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }
    public ulong_mt a
    {
        [MethodImpl(256 | 512)]
        readonly get => w;
        [MethodImpl(256 | 512)]
        set => w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly ulong4 LaneGet(int index) => new(x[index], y[index], z[index], w[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, ulong4 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
        w[index] = value.w;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public ulong4_mt(ulong_mt x, ulong_mt y, ulong_mt z, ulong_mt w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public ulong4_mt(ulong value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public ulong4_mt(ulong_mt value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public ulong4_mt(ulong4 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
        w = new(value.w);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4_mt(ulong value) => new ulong_mt(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4_mt(ulong_mt value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4_mt(ulong4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static ulong4_mt operator~(ulong4_mt a) => new(~a.x, ~a.y, ~a.z, ~a.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt operator|(ulong4_mt a, ulong4_mt b) => new(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt operator&(ulong4_mt a, ulong4_mt b) => new(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt operator^(ulong4_mt a, ulong4_mt b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt operator<<(ulong4_mt a, int b) => new(a.x << b, a.y << b, a.z << b, a.w << b);

    [MethodImpl(256 | 512)]
    public static ulong4_mt operator>>(ulong4_mt a, int b) => new(a.x >> b, a.y >> b, a.z >> b, a.w >> b);

    [MethodImpl(256 | 512)]
    public static ulong4_mt operator>>>(ulong4_mt a, int b) => new(a.x >>> b, a.y >>> b, a.z >>> b, a.w >>> b);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out ulong_mt x, out ulong_mt y, out ulong_mt z, out ulong_mt w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // Deconstruct

    #region Index

    public ulong_mt this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"ulong4_mt {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // ulong4_mt
#region b32v2_mt

[CpuOnly]
public partial struct b32v2_mt
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b32_mt.LineCount;
    }

    #endregion

    #region Fields

    public b32_mt x;
    public b32_mt y;

    #endregion // Fields

    #region Properties

    public b32_mt r
    {
        [MethodImpl(256 | 512)]
        readonly get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public b32_mt g
    {
        [MethodImpl(256 | 512)]
        readonly get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b32v2 LaneGet(int index) => new(x[index], y[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b32v2 value)
    {
        x[index] = value.x;
        y[index] = value.y;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public b32v2_mt(b32_mt x, b32_mt y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public b32v2_mt(b32 value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b32v2_mt(b32_mt value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b32v2_mt(b32v2 value)
    {
        x = new(value.x);
        y = new(value.y);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator b32v2_mt(b32 value) => new b32_mt(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v2_mt(bool value) => (b32)(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v2_mt(b32_mt value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v2_mt(b32v2 value) => new(value);

    [MethodImpl(256 | 512)]
    public static b32v2_mt operator~(b32v2_mt a) => new(~a.x, ~a.y);

    [MethodImpl(256 | 512)]
    public static b32v2_mt operator|(b32v2_mt a, b32v2_mt b) => new(a.x | b.x, a.y | b.y);

    [MethodImpl(256 | 512)]
    public static b32v2_mt operator&(b32v2_mt a, b32v2_mt b) => new(a.x & b.x, a.y & b.y);

    [MethodImpl(256 | 512)]
    public static b32v2_mt operator^(b32v2_mt a, b32v2_mt b) => new(a.x ^ b.x, a.y ^ b.y);

    [MethodImpl(256 | 512)]
    public static b32v2_mt operator<<(b32v2_mt a, int b) => new(a.x << b, a.y << b);

    [MethodImpl(256 | 512)]
    public static b32v2_mt operator>>(b32v2_mt a, int b) => new(a.x >> b, a.y >> b);

    [MethodImpl(256 | 512)]
    public static b32v2_mt operator>>>(b32v2_mt a, int b) => new(a.x >>> b, a.y >>> b);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b32_mt x, out b32_mt y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // Deconstruct

    #region Index

    public b32_mt this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"b32v2_mt {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // b32v2_mt
#region b32v3_mt

[CpuOnly]
public partial struct b32v3_mt
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b32_mt.LineCount;
    }

    #endregion

    #region Fields

    public b32_mt x;
    public b32_mt y;
    public b32_mt z;

    #endregion // Fields

    #region Properties

    public b32_mt r
    {
        [MethodImpl(256 | 512)]
        readonly get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public b32_mt g
    {
        [MethodImpl(256 | 512)]
        readonly get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public b32_mt b
    {
        [MethodImpl(256 | 512)]
        readonly get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b32v3 LaneGet(int index) => new(x[index], y[index], z[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b32v3 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public b32v3_mt(b32_mt x, b32_mt y, b32_mt z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public b32v3_mt(b32 value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b32v3_mt(b32_mt value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b32v3_mt(b32v3 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator b32v3_mt(b32 value) => new b32_mt(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v3_mt(bool value) => (b32)(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v3_mt(b32_mt value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v3_mt(b32v3 value) => new(value);

    [MethodImpl(256 | 512)]
    public static b32v3_mt operator~(b32v3_mt a) => new(~a.x, ~a.y, ~a.z);

    [MethodImpl(256 | 512)]
    public static b32v3_mt operator|(b32v3_mt a, b32v3_mt b) => new(a.x | b.x, a.y | b.y, a.z | b.z);

    [MethodImpl(256 | 512)]
    public static b32v3_mt operator&(b32v3_mt a, b32v3_mt b) => new(a.x & b.x, a.y & b.y, a.z & b.z);

    [MethodImpl(256 | 512)]
    public static b32v3_mt operator^(b32v3_mt a, b32v3_mt b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z);

    [MethodImpl(256 | 512)]
    public static b32v3_mt operator<<(b32v3_mt a, int b) => new(a.x << b, a.y << b, a.z << b);

    [MethodImpl(256 | 512)]
    public static b32v3_mt operator>>(b32v3_mt a, int b) => new(a.x >> b, a.y >> b, a.z >> b);

    [MethodImpl(256 | 512)]
    public static b32v3_mt operator>>>(b32v3_mt a, int b) => new(a.x >>> b, a.y >>> b, a.z >>> b);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b32_mt x, out b32_mt y, out b32_mt z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // Deconstruct

    #region Index

    public b32_mt this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"b32v3_mt {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // b32v3_mt
#region b32v4_mt

[CpuOnly]
public partial struct b32v4_mt
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b32_mt.LineCount;
    }

    #endregion

    #region Fields

    public b32_mt x;
    public b32_mt y;
    public b32_mt z;
    public b32_mt w;

    #endregion // Fields

    #region Properties

    public b32_mt r
    {
        [MethodImpl(256 | 512)]
        readonly get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public b32_mt g
    {
        [MethodImpl(256 | 512)]
        readonly get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public b32_mt b
    {
        [MethodImpl(256 | 512)]
        readonly get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }
    public b32_mt a
    {
        [MethodImpl(256 | 512)]
        readonly get => w;
        [MethodImpl(256 | 512)]
        set => w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b32v4 LaneGet(int index) => new(x[index], y[index], z[index], w[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b32v4 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
        w[index] = value.w;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public b32v4_mt(b32_mt x, b32_mt y, b32_mt z, b32_mt w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public b32v4_mt(b32 value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b32v4_mt(b32_mt value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b32v4_mt(b32v4 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
        w = new(value.w);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator b32v4_mt(b32 value) => new b32_mt(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v4_mt(bool value) => (b32)(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v4_mt(b32_mt value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v4_mt(b32v4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static b32v4_mt operator~(b32v4_mt a) => new(~a.x, ~a.y, ~a.z, ~a.w);

    [MethodImpl(256 | 512)]
    public static b32v4_mt operator|(b32v4_mt a, b32v4_mt b) => new(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);

    [MethodImpl(256 | 512)]
    public static b32v4_mt operator&(b32v4_mt a, b32v4_mt b) => new(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);

    [MethodImpl(256 | 512)]
    public static b32v4_mt operator^(b32v4_mt a, b32v4_mt b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);

    [MethodImpl(256 | 512)]
    public static b32v4_mt operator<<(b32v4_mt a, int b) => new(a.x << b, a.y << b, a.z << b, a.w << b);

    [MethodImpl(256 | 512)]
    public static b32v4_mt operator>>(b32v4_mt a, int b) => new(a.x >> b, a.y >> b, a.z >> b, a.w >> b);

    [MethodImpl(256 | 512)]
    public static b32v4_mt operator>>>(b32v4_mt a, int b) => new(a.x >>> b, a.y >>> b, a.z >>> b, a.w >>> b);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b32_mt x, out b32_mt y, out b32_mt z, out b32_mt w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // Deconstruct

    #region Index

    public b32_mt this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"b32v4_mt {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // b32v4_mt
#region b64v2_mt

[CpuOnly]
public partial struct b64v2_mt
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b64_mt.LineCount;
    }

    #endregion

    #region Fields

    public b64_mt x;
    public b64_mt y;

    #endregion // Fields

    #region Properties

    public b64_mt r
    {
        [MethodImpl(256 | 512)]
        readonly get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public b64_mt g
    {
        [MethodImpl(256 | 512)]
        readonly get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b64v2 LaneGet(int index) => new(x[index], y[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b64v2 value)
    {
        x[index] = value.x;
        y[index] = value.y;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public b64v2_mt(b64_mt x, b64_mt y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public b64v2_mt(b64 value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b64v2_mt(b64_mt value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b64v2_mt(b64v2 value)
    {
        x = new(value.x);
        y = new(value.y);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator b64v2_mt(b64 value) => new b64_mt(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64v2_mt(bool value) => (b64)(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64v2_mt(b64_mt value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64v2_mt(b64v2 value) => new(value);

    [MethodImpl(256 | 512)]
    public static b64v2_mt operator~(b64v2_mt a) => new(~a.x, ~a.y);

    [MethodImpl(256 | 512)]
    public static b64v2_mt operator|(b64v2_mt a, b64v2_mt b) => new(a.x | b.x, a.y | b.y);

    [MethodImpl(256 | 512)]
    public static b64v2_mt operator&(b64v2_mt a, b64v2_mt b) => new(a.x & b.x, a.y & b.y);

    [MethodImpl(256 | 512)]
    public static b64v2_mt operator^(b64v2_mt a, b64v2_mt b) => new(a.x ^ b.x, a.y ^ b.y);

    [MethodImpl(256 | 512)]
    public static b64v2_mt operator<<(b64v2_mt a, int b) => new(a.x << b, a.y << b);

    [MethodImpl(256 | 512)]
    public static b64v2_mt operator>>(b64v2_mt a, int b) => new(a.x >> b, a.y >> b);

    [MethodImpl(256 | 512)]
    public static b64v2_mt operator>>>(b64v2_mt a, int b) => new(a.x >>> b, a.y >>> b);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b64_mt x, out b64_mt y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // Deconstruct

    #region Index

    public b64_mt this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"b64v2_mt {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // b64v2_mt
#region b64v3_mt

[CpuOnly]
public partial struct b64v3_mt
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b64_mt.LineCount;
    }

    #endregion

    #region Fields

    public b64_mt x;
    public b64_mt y;
    public b64_mt z;

    #endregion // Fields

    #region Properties

    public b64_mt r
    {
        [MethodImpl(256 | 512)]
        readonly get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public b64_mt g
    {
        [MethodImpl(256 | 512)]
        readonly get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public b64_mt b
    {
        [MethodImpl(256 | 512)]
        readonly get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b64v3 LaneGet(int index) => new(x[index], y[index], z[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b64v3 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public b64v3_mt(b64_mt x, b64_mt y, b64_mt z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public b64v3_mt(b64 value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b64v3_mt(b64_mt value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b64v3_mt(b64v3 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator b64v3_mt(b64 value) => new b64_mt(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64v3_mt(bool value) => (b64)(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64v3_mt(b64_mt value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64v3_mt(b64v3 value) => new(value);

    [MethodImpl(256 | 512)]
    public static b64v3_mt operator~(b64v3_mt a) => new(~a.x, ~a.y, ~a.z);

    [MethodImpl(256 | 512)]
    public static b64v3_mt operator|(b64v3_mt a, b64v3_mt b) => new(a.x | b.x, a.y | b.y, a.z | b.z);

    [MethodImpl(256 | 512)]
    public static b64v3_mt operator&(b64v3_mt a, b64v3_mt b) => new(a.x & b.x, a.y & b.y, a.z & b.z);

    [MethodImpl(256 | 512)]
    public static b64v3_mt operator^(b64v3_mt a, b64v3_mt b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z);

    [MethodImpl(256 | 512)]
    public static b64v3_mt operator<<(b64v3_mt a, int b) => new(a.x << b, a.y << b, a.z << b);

    [MethodImpl(256 | 512)]
    public static b64v3_mt operator>>(b64v3_mt a, int b) => new(a.x >> b, a.y >> b, a.z >> b);

    [MethodImpl(256 | 512)]
    public static b64v3_mt operator>>>(b64v3_mt a, int b) => new(a.x >>> b, a.y >>> b, a.z >>> b);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b64_mt x, out b64_mt y, out b64_mt z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // Deconstruct

    #region Index

    public b64_mt this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"b64v3_mt {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // b64v3_mt
#region b64v4_mt

[CpuOnly]
public partial struct b64v4_mt
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b64_mt.LineCount;
    }

    #endregion

    #region Fields

    public b64_mt x;
    public b64_mt y;
    public b64_mt z;
    public b64_mt w;

    #endregion // Fields

    #region Properties

    public b64_mt r
    {
        [MethodImpl(256 | 512)]
        readonly get => x;
        [MethodImpl(256 | 512)]
        set => x = value;
    }
    public b64_mt g
    {
        [MethodImpl(256 | 512)]
        readonly get => y;
        [MethodImpl(256 | 512)]
        set => y = value;
    }
    public b64_mt b
    {
        [MethodImpl(256 | 512)]
        readonly get => z;
        [MethodImpl(256 | 512)]
        set => z = value;
    }
    public b64_mt a
    {
        [MethodImpl(256 | 512)]
        readonly get => w;
        [MethodImpl(256 | 512)]
        set => w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b64v4 LaneGet(int index) => new(x[index], y[index], z[index], w[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b64v4 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
        w[index] = value.w;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public b64v4_mt(b64_mt x, b64_mt y, b64_mt z, b64_mt w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public b64v4_mt(b64 value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b64v4_mt(b64_mt value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b64v4_mt(b64v4 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
        w = new(value.w);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator b64v4_mt(b64 value) => new b64_mt(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64v4_mt(bool value) => (b64)(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64v4_mt(b64_mt value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64v4_mt(b64v4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static b64v4_mt operator~(b64v4_mt a) => new(~a.x, ~a.y, ~a.z, ~a.w);

    [MethodImpl(256 | 512)]
    public static b64v4_mt operator|(b64v4_mt a, b64v4_mt b) => new(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);

    [MethodImpl(256 | 512)]
    public static b64v4_mt operator&(b64v4_mt a, b64v4_mt b) => new(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);

    [MethodImpl(256 | 512)]
    public static b64v4_mt operator^(b64v4_mt a, b64v4_mt b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);

    [MethodImpl(256 | 512)]
    public static b64v4_mt operator<<(b64v4_mt a, int b) => new(a.x << b, a.y << b, a.z << b, a.w << b);

    [MethodImpl(256 | 512)]
    public static b64v4_mt operator>>(b64v4_mt a, int b) => new(a.x >> b, a.y >> b, a.z >> b, a.w >> b);

    [MethodImpl(256 | 512)]
    public static b64v4_mt operator>>>(b64v4_mt a, int b) => new(a.x >>> b, a.y >>> b, a.z >>> b, a.w >>> b);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b64_mt x, out b64_mt y, out b64_mt z, out b64_mt w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // Deconstruct

    #region Index

    public b64_mt this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"b64v4_mt {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // b64v4_mt
