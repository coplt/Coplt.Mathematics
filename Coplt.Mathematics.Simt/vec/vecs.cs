// generated by template, do not modify manually

namespace Coplt.Mathematics.Simt;

#region float2_mt4

[CpuOnly]
public partial struct float2_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => float_mt4.LineCount;
    }

    #endregion

    #region Fields

    public float_mt4 x;
    public float_mt4 y;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly float2 LaneGet(int index) => new(x[index], y[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, float2 value)
    {
        x[index] = value.x;
        y[index] = value.y;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public float2_mt4(float_mt4 x, float_mt4 y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public float2_mt4(float value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public float2_mt4(float_mt4 value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public float2_mt4(float2 value)
    {
        x = new(value.x);
        y = new(value.y);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator float2_mt4(float value) => new float_mt4(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float2_mt4(float_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float2_mt4(float2 value) => new(value);

    [MethodImpl(256 | 512)]
    public static float2_mt4 operator~(float2_mt4 a) => new(~a.x, ~a.y);

    [MethodImpl(256 | 512)]
    public static float2_mt4 operator|(float2_mt4 a, float2_mt4 b) => new(a.x | b.x, a.y | b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt4 operator&(float2_mt4 a, float2_mt4 b) => new(a.x & b.x, a.y & b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt4 operator^(float2_mt4 a, float2_mt4 b) => new(a.x ^ b.x, a.y ^ b.y);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out float_mt4 x, out float_mt4 y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // Deconstruct

    #region Index

    public float_mt4 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"float2_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // float2_mt4
#region float2_mt8

[CpuOnly]
public partial struct float2_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => float_mt8.LineCount;
    }

    #endregion

    #region Fields

    public float_mt8 x;
    public float_mt8 y;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly float2 LaneGet(int index) => new(x[index], y[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, float2 value)
    {
        x[index] = value.x;
        y[index] = value.y;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public float2_mt8(float_mt8 x, float_mt8 y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public float2_mt8(float value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public float2_mt8(float_mt8 value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public float2_mt8(float2 value)
    {
        x = new(value.x);
        y = new(value.y);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator float2_mt8(float value) => new float_mt8(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float2_mt8(float_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float2_mt8(float2 value) => new(value);

    [MethodImpl(256 | 512)]
    public static float2_mt8 operator~(float2_mt8 a) => new(~a.x, ~a.y);

    [MethodImpl(256 | 512)]
    public static float2_mt8 operator|(float2_mt8 a, float2_mt8 b) => new(a.x | b.x, a.y | b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt8 operator&(float2_mt8 a, float2_mt8 b) => new(a.x & b.x, a.y & b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt8 operator^(float2_mt8 a, float2_mt8 b) => new(a.x ^ b.x, a.y ^ b.y);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out float_mt8 x, out float_mt8 y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // Deconstruct

    #region Index

    public float_mt8 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"float2_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // float2_mt8
#region float2_mt16

[CpuOnly]
public partial struct float2_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => float_mt16.LineCount;
    }

    #endregion

    #region Fields

    public float_mt16 x;
    public float_mt16 y;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly float2 LaneGet(int index) => new(x[index], y[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, float2 value)
    {
        x[index] = value.x;
        y[index] = value.y;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public float2_mt16(float_mt16 x, float_mt16 y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public float2_mt16(float value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public float2_mt16(float_mt16 value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public float2_mt16(float2 value)
    {
        x = new(value.x);
        y = new(value.y);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator float2_mt16(float value) => new float_mt16(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float2_mt16(float_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float2_mt16(float2 value) => new(value);

    [MethodImpl(256 | 512)]
    public static float2_mt16 operator~(float2_mt16 a) => new(~a.x, ~a.y);

    [MethodImpl(256 | 512)]
    public static float2_mt16 operator|(float2_mt16 a, float2_mt16 b) => new(a.x | b.x, a.y | b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt16 operator&(float2_mt16 a, float2_mt16 b) => new(a.x & b.x, a.y & b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt16 operator^(float2_mt16 a, float2_mt16 b) => new(a.x ^ b.x, a.y ^ b.y);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out float_mt16 x, out float_mt16 y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // Deconstruct

    #region Index

    public float_mt16 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"float2_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // float2_mt16
#region float2_mt32

[CpuOnly]
public partial struct float2_mt32
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => float_mt32.LineCount;
    }

    #endregion

    #region Fields

    public float_mt32 x;
    public float_mt32 y;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly float2 LaneGet(int index) => new(x[index], y[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, float2 value)
    {
        x[index] = value.x;
        y[index] = value.y;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public float2_mt32(float_mt32 x, float_mt32 y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public float2_mt32(float value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public float2_mt32(float_mt32 value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public float2_mt32(float2 value)
    {
        x = new(value.x);
        y = new(value.y);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator float2_mt32(float value) => new float_mt32(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float2_mt32(float_mt32 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float2_mt32(float2 value) => new(value);

    [MethodImpl(256 | 512)]
    public static float2_mt32 operator~(float2_mt32 a) => new(~a.x, ~a.y);

    [MethodImpl(256 | 512)]
    public static float2_mt32 operator|(float2_mt32 a, float2_mt32 b) => new(a.x | b.x, a.y | b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt32 operator&(float2_mt32 a, float2_mt32 b) => new(a.x & b.x, a.y & b.y);

    [MethodImpl(256 | 512)]
    public static float2_mt32 operator^(float2_mt32 a, float2_mt32 b) => new(a.x ^ b.x, a.y ^ b.y);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out float_mt32 x, out float_mt32 y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // Deconstruct

    #region Index

    public float_mt32 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"float2_mt32 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)}, t16 = {this.LaneGet(16)}, t17 = {this.LaneGet(17)}, t18 = {this.LaneGet(18)}, t19 = {this.LaneGet(19)}, t20 = {this.LaneGet(20)}, t21 = {this.LaneGet(21)}, t22 = {this.LaneGet(22)}, t23 = {this.LaneGet(23)}, t24 = {this.LaneGet(24)}, t25 = {this.LaneGet(25)}, t26 = {this.LaneGet(26)}, t27 = {this.LaneGet(27)}, t28 = {this.LaneGet(28)}, t29 = {this.LaneGet(29)}, t30 = {this.LaneGet(30)}, t31 = {this.LaneGet(31)} }}";
    
    #endregion // ToString
}

#endregion // float2_mt32
#region float3_mt4

[CpuOnly]
public partial struct float3_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => float_mt4.LineCount;
    }

    #endregion

    #region Fields

    public float_mt4 x;
    public float_mt4 y;
    public float_mt4 z;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly float3 LaneGet(int index) => new(x[index], y[index], z[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, float3 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public float3_mt4(float_mt4 x, float_mt4 y, float_mt4 z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public float3_mt4(float value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public float3_mt4(float_mt4 value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public float3_mt4(float3 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator float3_mt4(float value) => new float_mt4(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float3_mt4(float_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float3_mt4(float3 value) => new(value);

    [MethodImpl(256 | 512)]
    public static float3_mt4 operator~(float3_mt4 a) => new(~a.x, ~a.y, ~a.z);

    [MethodImpl(256 | 512)]
    public static float3_mt4 operator|(float3_mt4 a, float3_mt4 b) => new(a.x | b.x, a.y | b.y, a.z | b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt4 operator&(float3_mt4 a, float3_mt4 b) => new(a.x & b.x, a.y & b.y, a.z & b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt4 operator^(float3_mt4 a, float3_mt4 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out float_mt4 x, out float_mt4 y, out float_mt4 z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // Deconstruct

    #region Index

    public float_mt4 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"float3_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // float3_mt4
#region float3_mt8

[CpuOnly]
public partial struct float3_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => float_mt8.LineCount;
    }

    #endregion

    #region Fields

    public float_mt8 x;
    public float_mt8 y;
    public float_mt8 z;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly float3 LaneGet(int index) => new(x[index], y[index], z[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, float3 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public float3_mt8(float_mt8 x, float_mt8 y, float_mt8 z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public float3_mt8(float value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public float3_mt8(float_mt8 value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public float3_mt8(float3 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator float3_mt8(float value) => new float_mt8(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float3_mt8(float_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float3_mt8(float3 value) => new(value);

    [MethodImpl(256 | 512)]
    public static float3_mt8 operator~(float3_mt8 a) => new(~a.x, ~a.y, ~a.z);

    [MethodImpl(256 | 512)]
    public static float3_mt8 operator|(float3_mt8 a, float3_mt8 b) => new(a.x | b.x, a.y | b.y, a.z | b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt8 operator&(float3_mt8 a, float3_mt8 b) => new(a.x & b.x, a.y & b.y, a.z & b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt8 operator^(float3_mt8 a, float3_mt8 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out float_mt8 x, out float_mt8 y, out float_mt8 z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // Deconstruct

    #region Index

    public float_mt8 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"float3_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // float3_mt8
#region float3_mt16

[CpuOnly]
public partial struct float3_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => float_mt16.LineCount;
    }

    #endregion

    #region Fields

    public float_mt16 x;
    public float_mt16 y;
    public float_mt16 z;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly float3 LaneGet(int index) => new(x[index], y[index], z[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, float3 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public float3_mt16(float_mt16 x, float_mt16 y, float_mt16 z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public float3_mt16(float value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public float3_mt16(float_mt16 value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public float3_mt16(float3 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator float3_mt16(float value) => new float_mt16(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float3_mt16(float_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float3_mt16(float3 value) => new(value);

    [MethodImpl(256 | 512)]
    public static float3_mt16 operator~(float3_mt16 a) => new(~a.x, ~a.y, ~a.z);

    [MethodImpl(256 | 512)]
    public static float3_mt16 operator|(float3_mt16 a, float3_mt16 b) => new(a.x | b.x, a.y | b.y, a.z | b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt16 operator&(float3_mt16 a, float3_mt16 b) => new(a.x & b.x, a.y & b.y, a.z & b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt16 operator^(float3_mt16 a, float3_mt16 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out float_mt16 x, out float_mt16 y, out float_mt16 z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // Deconstruct

    #region Index

    public float_mt16 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"float3_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // float3_mt16
#region float3_mt32

[CpuOnly]
public partial struct float3_mt32
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => float_mt32.LineCount;
    }

    #endregion

    #region Fields

    public float_mt32 x;
    public float_mt32 y;
    public float_mt32 z;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly float3 LaneGet(int index) => new(x[index], y[index], z[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, float3 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public float3_mt32(float_mt32 x, float_mt32 y, float_mt32 z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public float3_mt32(float value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public float3_mt32(float_mt32 value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public float3_mt32(float3 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator float3_mt32(float value) => new float_mt32(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float3_mt32(float_mt32 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float3_mt32(float3 value) => new(value);

    [MethodImpl(256 | 512)]
    public static float3_mt32 operator~(float3_mt32 a) => new(~a.x, ~a.y, ~a.z);

    [MethodImpl(256 | 512)]
    public static float3_mt32 operator|(float3_mt32 a, float3_mt32 b) => new(a.x | b.x, a.y | b.y, a.z | b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt32 operator&(float3_mt32 a, float3_mt32 b) => new(a.x & b.x, a.y & b.y, a.z & b.z);

    [MethodImpl(256 | 512)]
    public static float3_mt32 operator^(float3_mt32 a, float3_mt32 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out float_mt32 x, out float_mt32 y, out float_mt32 z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // Deconstruct

    #region Index

    public float_mt32 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"float3_mt32 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)}, t16 = {this.LaneGet(16)}, t17 = {this.LaneGet(17)}, t18 = {this.LaneGet(18)}, t19 = {this.LaneGet(19)}, t20 = {this.LaneGet(20)}, t21 = {this.LaneGet(21)}, t22 = {this.LaneGet(22)}, t23 = {this.LaneGet(23)}, t24 = {this.LaneGet(24)}, t25 = {this.LaneGet(25)}, t26 = {this.LaneGet(26)}, t27 = {this.LaneGet(27)}, t28 = {this.LaneGet(28)}, t29 = {this.LaneGet(29)}, t30 = {this.LaneGet(30)}, t31 = {this.LaneGet(31)} }}";
    
    #endregion // ToString
}

#endregion // float3_mt32
#region float4_mt4

[CpuOnly]
public partial struct float4_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => float_mt4.LineCount;
    }

    #endregion

    #region Fields

    public float_mt4 x;
    public float_mt4 y;
    public float_mt4 z;
    public float_mt4 w;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly float4 LaneGet(int index) => new(x[index], y[index], z[index], w[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, float4 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
        w[index] = value.w;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public float4_mt4(float_mt4 x, float_mt4 y, float_mt4 z, float_mt4 w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public float4_mt4(float value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public float4_mt4(float_mt4 value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public float4_mt4(float4 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
        w = new(value.w);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator float4_mt4(float value) => new float_mt4(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float4_mt4(float_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float4_mt4(float4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static float4_mt4 operator~(float4_mt4 a) => new(~a.x, ~a.y, ~a.z, ~a.w);

    [MethodImpl(256 | 512)]
    public static float4_mt4 operator|(float4_mt4 a, float4_mt4 b) => new(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt4 operator&(float4_mt4 a, float4_mt4 b) => new(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt4 operator^(float4_mt4 a, float4_mt4 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out float_mt4 x, out float_mt4 y, out float_mt4 z, out float_mt4 w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // Deconstruct

    #region Index

    public float_mt4 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"float4_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // float4_mt4
#region float4_mt8

[CpuOnly]
public partial struct float4_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => float_mt8.LineCount;
    }

    #endregion

    #region Fields

    public float_mt8 x;
    public float_mt8 y;
    public float_mt8 z;
    public float_mt8 w;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly float4 LaneGet(int index) => new(x[index], y[index], z[index], w[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, float4 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
        w[index] = value.w;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public float4_mt8(float_mt8 x, float_mt8 y, float_mt8 z, float_mt8 w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public float4_mt8(float value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public float4_mt8(float_mt8 value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public float4_mt8(float4 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
        w = new(value.w);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator float4_mt8(float value) => new float_mt8(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float4_mt8(float_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float4_mt8(float4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static float4_mt8 operator~(float4_mt8 a) => new(~a.x, ~a.y, ~a.z, ~a.w);

    [MethodImpl(256 | 512)]
    public static float4_mt8 operator|(float4_mt8 a, float4_mt8 b) => new(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt8 operator&(float4_mt8 a, float4_mt8 b) => new(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt8 operator^(float4_mt8 a, float4_mt8 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out float_mt8 x, out float_mt8 y, out float_mt8 z, out float_mt8 w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // Deconstruct

    #region Index

    public float_mt8 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"float4_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // float4_mt8
#region float4_mt16

[CpuOnly]
public partial struct float4_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => float_mt16.LineCount;
    }

    #endregion

    #region Fields

    public float_mt16 x;
    public float_mt16 y;
    public float_mt16 z;
    public float_mt16 w;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly float4 LaneGet(int index) => new(x[index], y[index], z[index], w[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, float4 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
        w[index] = value.w;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public float4_mt16(float_mt16 x, float_mt16 y, float_mt16 z, float_mt16 w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public float4_mt16(float value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public float4_mt16(float_mt16 value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public float4_mt16(float4 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
        w = new(value.w);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator float4_mt16(float value) => new float_mt16(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float4_mt16(float_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float4_mt16(float4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static float4_mt16 operator~(float4_mt16 a) => new(~a.x, ~a.y, ~a.z, ~a.w);

    [MethodImpl(256 | 512)]
    public static float4_mt16 operator|(float4_mt16 a, float4_mt16 b) => new(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt16 operator&(float4_mt16 a, float4_mt16 b) => new(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt16 operator^(float4_mt16 a, float4_mt16 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out float_mt16 x, out float_mt16 y, out float_mt16 z, out float_mt16 w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // Deconstruct

    #region Index

    public float_mt16 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"float4_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // float4_mt16
#region float4_mt32

[CpuOnly]
public partial struct float4_mt32
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => float_mt32.LineCount;
    }

    #endregion

    #region Fields

    public float_mt32 x;
    public float_mt32 y;
    public float_mt32 z;
    public float_mt32 w;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly float4 LaneGet(int index) => new(x[index], y[index], z[index], w[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, float4 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
        w[index] = value.w;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public float4_mt32(float_mt32 x, float_mt32 y, float_mt32 z, float_mt32 w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public float4_mt32(float value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public float4_mt32(float_mt32 value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public float4_mt32(float4 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
        w = new(value.w);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator float4_mt32(float value) => new float_mt32(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float4_mt32(float_mt32 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float4_mt32(float4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static float4_mt32 operator~(float4_mt32 a) => new(~a.x, ~a.y, ~a.z, ~a.w);

    [MethodImpl(256 | 512)]
    public static float4_mt32 operator|(float4_mt32 a, float4_mt32 b) => new(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt32 operator&(float4_mt32 a, float4_mt32 b) => new(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);

    [MethodImpl(256 | 512)]
    public static float4_mt32 operator^(float4_mt32 a, float4_mt32 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out float_mt32 x, out float_mt32 y, out float_mt32 z, out float_mt32 w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // Deconstruct

    #region Index

    public float_mt32 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"float4_mt32 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)}, t16 = {this.LaneGet(16)}, t17 = {this.LaneGet(17)}, t18 = {this.LaneGet(18)}, t19 = {this.LaneGet(19)}, t20 = {this.LaneGet(20)}, t21 = {this.LaneGet(21)}, t22 = {this.LaneGet(22)}, t23 = {this.LaneGet(23)}, t24 = {this.LaneGet(24)}, t25 = {this.LaneGet(25)}, t26 = {this.LaneGet(26)}, t27 = {this.LaneGet(27)}, t28 = {this.LaneGet(28)}, t29 = {this.LaneGet(29)}, t30 = {this.LaneGet(30)}, t31 = {this.LaneGet(31)} }}";
    
    #endregion // ToString
}

#endregion // float4_mt32
#region double2_mt4

[CpuOnly]
public partial struct double2_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => double_mt4.LineCount;
    }

    #endregion

    #region Fields

    public double_mt4 x;
    public double_mt4 y;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly double2 LaneGet(int index) => new(x[index], y[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, double2 value)
    {
        x[index] = value.x;
        y[index] = value.y;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public double2_mt4(double_mt4 x, double_mt4 y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public double2_mt4(double value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public double2_mt4(double_mt4 value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public double2_mt4(double2 value)
    {
        x = new(value.x);
        y = new(value.y);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator double2_mt4(double value) => new double_mt4(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double2_mt4(double_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double2_mt4(double2 value) => new(value);

    [MethodImpl(256 | 512)]
    public static double2_mt4 operator~(double2_mt4 a) => new(~a.x, ~a.y);

    [MethodImpl(256 | 512)]
    public static double2_mt4 operator|(double2_mt4 a, double2_mt4 b) => new(a.x | b.x, a.y | b.y);

    [MethodImpl(256 | 512)]
    public static double2_mt4 operator&(double2_mt4 a, double2_mt4 b) => new(a.x & b.x, a.y & b.y);

    [MethodImpl(256 | 512)]
    public static double2_mt4 operator^(double2_mt4 a, double2_mt4 b) => new(a.x ^ b.x, a.y ^ b.y);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out double_mt4 x, out double_mt4 y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // Deconstruct

    #region Index

    public double_mt4 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"double2_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // double2_mt4
#region double2_mt8

[CpuOnly]
public partial struct double2_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => double_mt8.LineCount;
    }

    #endregion

    #region Fields

    public double_mt8 x;
    public double_mt8 y;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly double2 LaneGet(int index) => new(x[index], y[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, double2 value)
    {
        x[index] = value.x;
        y[index] = value.y;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public double2_mt8(double_mt8 x, double_mt8 y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public double2_mt8(double value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public double2_mt8(double_mt8 value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public double2_mt8(double2 value)
    {
        x = new(value.x);
        y = new(value.y);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator double2_mt8(double value) => new double_mt8(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double2_mt8(double_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double2_mt8(double2 value) => new(value);

    [MethodImpl(256 | 512)]
    public static double2_mt8 operator~(double2_mt8 a) => new(~a.x, ~a.y);

    [MethodImpl(256 | 512)]
    public static double2_mt8 operator|(double2_mt8 a, double2_mt8 b) => new(a.x | b.x, a.y | b.y);

    [MethodImpl(256 | 512)]
    public static double2_mt8 operator&(double2_mt8 a, double2_mt8 b) => new(a.x & b.x, a.y & b.y);

    [MethodImpl(256 | 512)]
    public static double2_mt8 operator^(double2_mt8 a, double2_mt8 b) => new(a.x ^ b.x, a.y ^ b.y);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out double_mt8 x, out double_mt8 y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // Deconstruct

    #region Index

    public double_mt8 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"double2_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // double2_mt8
#region double2_mt16

[CpuOnly]
public partial struct double2_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => double_mt16.LineCount;
    }

    #endregion

    #region Fields

    public double_mt16 x;
    public double_mt16 y;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly double2 LaneGet(int index) => new(x[index], y[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, double2 value)
    {
        x[index] = value.x;
        y[index] = value.y;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public double2_mt16(double_mt16 x, double_mt16 y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public double2_mt16(double value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public double2_mt16(double_mt16 value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public double2_mt16(double2 value)
    {
        x = new(value.x);
        y = new(value.y);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator double2_mt16(double value) => new double_mt16(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double2_mt16(double_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double2_mt16(double2 value) => new(value);

    [MethodImpl(256 | 512)]
    public static double2_mt16 operator~(double2_mt16 a) => new(~a.x, ~a.y);

    [MethodImpl(256 | 512)]
    public static double2_mt16 operator|(double2_mt16 a, double2_mt16 b) => new(a.x | b.x, a.y | b.y);

    [MethodImpl(256 | 512)]
    public static double2_mt16 operator&(double2_mt16 a, double2_mt16 b) => new(a.x & b.x, a.y & b.y);

    [MethodImpl(256 | 512)]
    public static double2_mt16 operator^(double2_mt16 a, double2_mt16 b) => new(a.x ^ b.x, a.y ^ b.y);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out double_mt16 x, out double_mt16 y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // Deconstruct

    #region Index

    public double_mt16 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"double2_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // double2_mt16
#region double2_mt32

[CpuOnly]
public partial struct double2_mt32
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => double_mt32.LineCount;
    }

    #endregion

    #region Fields

    public double_mt32 x;
    public double_mt32 y;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly double2 LaneGet(int index) => new(x[index], y[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, double2 value)
    {
        x[index] = value.x;
        y[index] = value.y;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public double2_mt32(double_mt32 x, double_mt32 y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public double2_mt32(double value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public double2_mt32(double_mt32 value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public double2_mt32(double2 value)
    {
        x = new(value.x);
        y = new(value.y);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator double2_mt32(double value) => new double_mt32(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double2_mt32(double_mt32 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double2_mt32(double2 value) => new(value);

    [MethodImpl(256 | 512)]
    public static double2_mt32 operator~(double2_mt32 a) => new(~a.x, ~a.y);

    [MethodImpl(256 | 512)]
    public static double2_mt32 operator|(double2_mt32 a, double2_mt32 b) => new(a.x | b.x, a.y | b.y);

    [MethodImpl(256 | 512)]
    public static double2_mt32 operator&(double2_mt32 a, double2_mt32 b) => new(a.x & b.x, a.y & b.y);

    [MethodImpl(256 | 512)]
    public static double2_mt32 operator^(double2_mt32 a, double2_mt32 b) => new(a.x ^ b.x, a.y ^ b.y);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out double_mt32 x, out double_mt32 y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // Deconstruct

    #region Index

    public double_mt32 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"double2_mt32 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)}, t16 = {this.LaneGet(16)}, t17 = {this.LaneGet(17)}, t18 = {this.LaneGet(18)}, t19 = {this.LaneGet(19)}, t20 = {this.LaneGet(20)}, t21 = {this.LaneGet(21)}, t22 = {this.LaneGet(22)}, t23 = {this.LaneGet(23)}, t24 = {this.LaneGet(24)}, t25 = {this.LaneGet(25)}, t26 = {this.LaneGet(26)}, t27 = {this.LaneGet(27)}, t28 = {this.LaneGet(28)}, t29 = {this.LaneGet(29)}, t30 = {this.LaneGet(30)}, t31 = {this.LaneGet(31)} }}";
    
    #endregion // ToString
}

#endregion // double2_mt32
#region double3_mt4

[CpuOnly]
public partial struct double3_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => double_mt4.LineCount;
    }

    #endregion

    #region Fields

    public double_mt4 x;
    public double_mt4 y;
    public double_mt4 z;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly double3 LaneGet(int index) => new(x[index], y[index], z[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, double3 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public double3_mt4(double_mt4 x, double_mt4 y, double_mt4 z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public double3_mt4(double value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public double3_mt4(double_mt4 value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public double3_mt4(double3 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator double3_mt4(double value) => new double_mt4(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double3_mt4(double_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double3_mt4(double3 value) => new(value);

    [MethodImpl(256 | 512)]
    public static double3_mt4 operator~(double3_mt4 a) => new(~a.x, ~a.y, ~a.z);

    [MethodImpl(256 | 512)]
    public static double3_mt4 operator|(double3_mt4 a, double3_mt4 b) => new(a.x | b.x, a.y | b.y, a.z | b.z);

    [MethodImpl(256 | 512)]
    public static double3_mt4 operator&(double3_mt4 a, double3_mt4 b) => new(a.x & b.x, a.y & b.y, a.z & b.z);

    [MethodImpl(256 | 512)]
    public static double3_mt4 operator^(double3_mt4 a, double3_mt4 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out double_mt4 x, out double_mt4 y, out double_mt4 z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // Deconstruct

    #region Index

    public double_mt4 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"double3_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // double3_mt4
#region double3_mt8

[CpuOnly]
public partial struct double3_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => double_mt8.LineCount;
    }

    #endregion

    #region Fields

    public double_mt8 x;
    public double_mt8 y;
    public double_mt8 z;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly double3 LaneGet(int index) => new(x[index], y[index], z[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, double3 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public double3_mt8(double_mt8 x, double_mt8 y, double_mt8 z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public double3_mt8(double value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public double3_mt8(double_mt8 value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public double3_mt8(double3 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator double3_mt8(double value) => new double_mt8(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double3_mt8(double_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double3_mt8(double3 value) => new(value);

    [MethodImpl(256 | 512)]
    public static double3_mt8 operator~(double3_mt8 a) => new(~a.x, ~a.y, ~a.z);

    [MethodImpl(256 | 512)]
    public static double3_mt8 operator|(double3_mt8 a, double3_mt8 b) => new(a.x | b.x, a.y | b.y, a.z | b.z);

    [MethodImpl(256 | 512)]
    public static double3_mt8 operator&(double3_mt8 a, double3_mt8 b) => new(a.x & b.x, a.y & b.y, a.z & b.z);

    [MethodImpl(256 | 512)]
    public static double3_mt8 operator^(double3_mt8 a, double3_mt8 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out double_mt8 x, out double_mt8 y, out double_mt8 z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // Deconstruct

    #region Index

    public double_mt8 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"double3_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // double3_mt8
#region double3_mt16

[CpuOnly]
public partial struct double3_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => double_mt16.LineCount;
    }

    #endregion

    #region Fields

    public double_mt16 x;
    public double_mt16 y;
    public double_mt16 z;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly double3 LaneGet(int index) => new(x[index], y[index], z[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, double3 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public double3_mt16(double_mt16 x, double_mt16 y, double_mt16 z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public double3_mt16(double value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public double3_mt16(double_mt16 value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public double3_mt16(double3 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator double3_mt16(double value) => new double_mt16(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double3_mt16(double_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double3_mt16(double3 value) => new(value);

    [MethodImpl(256 | 512)]
    public static double3_mt16 operator~(double3_mt16 a) => new(~a.x, ~a.y, ~a.z);

    [MethodImpl(256 | 512)]
    public static double3_mt16 operator|(double3_mt16 a, double3_mt16 b) => new(a.x | b.x, a.y | b.y, a.z | b.z);

    [MethodImpl(256 | 512)]
    public static double3_mt16 operator&(double3_mt16 a, double3_mt16 b) => new(a.x & b.x, a.y & b.y, a.z & b.z);

    [MethodImpl(256 | 512)]
    public static double3_mt16 operator^(double3_mt16 a, double3_mt16 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out double_mt16 x, out double_mt16 y, out double_mt16 z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // Deconstruct

    #region Index

    public double_mt16 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"double3_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // double3_mt16
#region double3_mt32

[CpuOnly]
public partial struct double3_mt32
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => double_mt32.LineCount;
    }

    #endregion

    #region Fields

    public double_mt32 x;
    public double_mt32 y;
    public double_mt32 z;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly double3 LaneGet(int index) => new(x[index], y[index], z[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, double3 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public double3_mt32(double_mt32 x, double_mt32 y, double_mt32 z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public double3_mt32(double value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public double3_mt32(double_mt32 value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public double3_mt32(double3 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator double3_mt32(double value) => new double_mt32(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double3_mt32(double_mt32 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double3_mt32(double3 value) => new(value);

    [MethodImpl(256 | 512)]
    public static double3_mt32 operator~(double3_mt32 a) => new(~a.x, ~a.y, ~a.z);

    [MethodImpl(256 | 512)]
    public static double3_mt32 operator|(double3_mt32 a, double3_mt32 b) => new(a.x | b.x, a.y | b.y, a.z | b.z);

    [MethodImpl(256 | 512)]
    public static double3_mt32 operator&(double3_mt32 a, double3_mt32 b) => new(a.x & b.x, a.y & b.y, a.z & b.z);

    [MethodImpl(256 | 512)]
    public static double3_mt32 operator^(double3_mt32 a, double3_mt32 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out double_mt32 x, out double_mt32 y, out double_mt32 z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // Deconstruct

    #region Index

    public double_mt32 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"double3_mt32 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)}, t16 = {this.LaneGet(16)}, t17 = {this.LaneGet(17)}, t18 = {this.LaneGet(18)}, t19 = {this.LaneGet(19)}, t20 = {this.LaneGet(20)}, t21 = {this.LaneGet(21)}, t22 = {this.LaneGet(22)}, t23 = {this.LaneGet(23)}, t24 = {this.LaneGet(24)}, t25 = {this.LaneGet(25)}, t26 = {this.LaneGet(26)}, t27 = {this.LaneGet(27)}, t28 = {this.LaneGet(28)}, t29 = {this.LaneGet(29)}, t30 = {this.LaneGet(30)}, t31 = {this.LaneGet(31)} }}";
    
    #endregion // ToString
}

#endregion // double3_mt32
#region double4_mt4

[CpuOnly]
public partial struct double4_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => double_mt4.LineCount;
    }

    #endregion

    #region Fields

    public double_mt4 x;
    public double_mt4 y;
    public double_mt4 z;
    public double_mt4 w;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly double4 LaneGet(int index) => new(x[index], y[index], z[index], w[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, double4 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
        w[index] = value.w;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public double4_mt4(double_mt4 x, double_mt4 y, double_mt4 z, double_mt4 w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public double4_mt4(double value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public double4_mt4(double_mt4 value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public double4_mt4(double4 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
        w = new(value.w);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator double4_mt4(double value) => new double_mt4(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double4_mt4(double_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double4_mt4(double4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static double4_mt4 operator~(double4_mt4 a) => new(~a.x, ~a.y, ~a.z, ~a.w);

    [MethodImpl(256 | 512)]
    public static double4_mt4 operator|(double4_mt4 a, double4_mt4 b) => new(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);

    [MethodImpl(256 | 512)]
    public static double4_mt4 operator&(double4_mt4 a, double4_mt4 b) => new(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);

    [MethodImpl(256 | 512)]
    public static double4_mt4 operator^(double4_mt4 a, double4_mt4 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out double_mt4 x, out double_mt4 y, out double_mt4 z, out double_mt4 w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // Deconstruct

    #region Index

    public double_mt4 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"double4_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // double4_mt4
#region double4_mt8

[CpuOnly]
public partial struct double4_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => double_mt8.LineCount;
    }

    #endregion

    #region Fields

    public double_mt8 x;
    public double_mt8 y;
    public double_mt8 z;
    public double_mt8 w;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly double4 LaneGet(int index) => new(x[index], y[index], z[index], w[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, double4 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
        w[index] = value.w;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public double4_mt8(double_mt8 x, double_mt8 y, double_mt8 z, double_mt8 w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public double4_mt8(double value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public double4_mt8(double_mt8 value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public double4_mt8(double4 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
        w = new(value.w);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator double4_mt8(double value) => new double_mt8(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double4_mt8(double_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double4_mt8(double4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static double4_mt8 operator~(double4_mt8 a) => new(~a.x, ~a.y, ~a.z, ~a.w);

    [MethodImpl(256 | 512)]
    public static double4_mt8 operator|(double4_mt8 a, double4_mt8 b) => new(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);

    [MethodImpl(256 | 512)]
    public static double4_mt8 operator&(double4_mt8 a, double4_mt8 b) => new(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);

    [MethodImpl(256 | 512)]
    public static double4_mt8 operator^(double4_mt8 a, double4_mt8 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out double_mt8 x, out double_mt8 y, out double_mt8 z, out double_mt8 w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // Deconstruct

    #region Index

    public double_mt8 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"double4_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // double4_mt8
#region double4_mt16

[CpuOnly]
public partial struct double4_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => double_mt16.LineCount;
    }

    #endregion

    #region Fields

    public double_mt16 x;
    public double_mt16 y;
    public double_mt16 z;
    public double_mt16 w;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly double4 LaneGet(int index) => new(x[index], y[index], z[index], w[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, double4 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
        w[index] = value.w;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public double4_mt16(double_mt16 x, double_mt16 y, double_mt16 z, double_mt16 w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public double4_mt16(double value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public double4_mt16(double_mt16 value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public double4_mt16(double4 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
        w = new(value.w);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator double4_mt16(double value) => new double_mt16(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double4_mt16(double_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double4_mt16(double4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static double4_mt16 operator~(double4_mt16 a) => new(~a.x, ~a.y, ~a.z, ~a.w);

    [MethodImpl(256 | 512)]
    public static double4_mt16 operator|(double4_mt16 a, double4_mt16 b) => new(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);

    [MethodImpl(256 | 512)]
    public static double4_mt16 operator&(double4_mt16 a, double4_mt16 b) => new(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);

    [MethodImpl(256 | 512)]
    public static double4_mt16 operator^(double4_mt16 a, double4_mt16 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out double_mt16 x, out double_mt16 y, out double_mt16 z, out double_mt16 w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // Deconstruct

    #region Index

    public double_mt16 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"double4_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // double4_mt16
#region double4_mt32

[CpuOnly]
public partial struct double4_mt32
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => double_mt32.LineCount;
    }

    #endregion

    #region Fields

    public double_mt32 x;
    public double_mt32 y;
    public double_mt32 z;
    public double_mt32 w;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly double4 LaneGet(int index) => new(x[index], y[index], z[index], w[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, double4 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
        w[index] = value.w;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public double4_mt32(double_mt32 x, double_mt32 y, double_mt32 z, double_mt32 w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public double4_mt32(double value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public double4_mt32(double_mt32 value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public double4_mt32(double4 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
        w = new(value.w);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator double4_mt32(double value) => new double_mt32(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double4_mt32(double_mt32 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double4_mt32(double4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static double4_mt32 operator~(double4_mt32 a) => new(~a.x, ~a.y, ~a.z, ~a.w);

    [MethodImpl(256 | 512)]
    public static double4_mt32 operator|(double4_mt32 a, double4_mt32 b) => new(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);

    [MethodImpl(256 | 512)]
    public static double4_mt32 operator&(double4_mt32 a, double4_mt32 b) => new(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);

    [MethodImpl(256 | 512)]
    public static double4_mt32 operator^(double4_mt32 a, double4_mt32 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out double_mt32 x, out double_mt32 y, out double_mt32 z, out double_mt32 w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // Deconstruct

    #region Index

    public double_mt32 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"double4_mt32 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)}, t16 = {this.LaneGet(16)}, t17 = {this.LaneGet(17)}, t18 = {this.LaneGet(18)}, t19 = {this.LaneGet(19)}, t20 = {this.LaneGet(20)}, t21 = {this.LaneGet(21)}, t22 = {this.LaneGet(22)}, t23 = {this.LaneGet(23)}, t24 = {this.LaneGet(24)}, t25 = {this.LaneGet(25)}, t26 = {this.LaneGet(26)}, t27 = {this.LaneGet(27)}, t28 = {this.LaneGet(28)}, t29 = {this.LaneGet(29)}, t30 = {this.LaneGet(30)}, t31 = {this.LaneGet(31)} }}";
    
    #endregion // ToString
}

#endregion // double4_mt32
#region int2_mt4

[CpuOnly]
public partial struct int2_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => int_mt4.LineCount;
    }

    #endregion

    #region Fields

    public int_mt4 x;
    public int_mt4 y;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly int2 LaneGet(int index) => new(x[index], y[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, int2 value)
    {
        x[index] = value.x;
        y[index] = value.y;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public int2_mt4(int_mt4 x, int_mt4 y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public int2_mt4(int value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public int2_mt4(int_mt4 value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public int2_mt4(int2 value)
    {
        x = new(value.x);
        y = new(value.y);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator int2_mt4(int value) => new int_mt4(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int2_mt4(int_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int2_mt4(int2 value) => new(value);

    [MethodImpl(256 | 512)]
    public static int2_mt4 operator~(int2_mt4 a) => new(~a.x, ~a.y);

    [MethodImpl(256 | 512)]
    public static int2_mt4 operator|(int2_mt4 a, int2_mt4 b) => new(a.x | b.x, a.y | b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt4 operator&(int2_mt4 a, int2_mt4 b) => new(a.x & b.x, a.y & b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt4 operator^(int2_mt4 a, int2_mt4 b) => new(a.x ^ b.x, a.y ^ b.y);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out int_mt4 x, out int_mt4 y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // Deconstruct

    #region Index

    public int_mt4 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"int2_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // int2_mt4
#region int2_mt8

[CpuOnly]
public partial struct int2_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => int_mt8.LineCount;
    }

    #endregion

    #region Fields

    public int_mt8 x;
    public int_mt8 y;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly int2 LaneGet(int index) => new(x[index], y[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, int2 value)
    {
        x[index] = value.x;
        y[index] = value.y;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public int2_mt8(int_mt8 x, int_mt8 y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public int2_mt8(int value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public int2_mt8(int_mt8 value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public int2_mt8(int2 value)
    {
        x = new(value.x);
        y = new(value.y);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator int2_mt8(int value) => new int_mt8(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int2_mt8(int_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int2_mt8(int2 value) => new(value);

    [MethodImpl(256 | 512)]
    public static int2_mt8 operator~(int2_mt8 a) => new(~a.x, ~a.y);

    [MethodImpl(256 | 512)]
    public static int2_mt8 operator|(int2_mt8 a, int2_mt8 b) => new(a.x | b.x, a.y | b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt8 operator&(int2_mt8 a, int2_mt8 b) => new(a.x & b.x, a.y & b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt8 operator^(int2_mt8 a, int2_mt8 b) => new(a.x ^ b.x, a.y ^ b.y);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out int_mt8 x, out int_mt8 y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // Deconstruct

    #region Index

    public int_mt8 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"int2_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // int2_mt8
#region int2_mt16

[CpuOnly]
public partial struct int2_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => int_mt16.LineCount;
    }

    #endregion

    #region Fields

    public int_mt16 x;
    public int_mt16 y;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly int2 LaneGet(int index) => new(x[index], y[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, int2 value)
    {
        x[index] = value.x;
        y[index] = value.y;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public int2_mt16(int_mt16 x, int_mt16 y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public int2_mt16(int value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public int2_mt16(int_mt16 value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public int2_mt16(int2 value)
    {
        x = new(value.x);
        y = new(value.y);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator int2_mt16(int value) => new int_mt16(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int2_mt16(int_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int2_mt16(int2 value) => new(value);

    [MethodImpl(256 | 512)]
    public static int2_mt16 operator~(int2_mt16 a) => new(~a.x, ~a.y);

    [MethodImpl(256 | 512)]
    public static int2_mt16 operator|(int2_mt16 a, int2_mt16 b) => new(a.x | b.x, a.y | b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt16 operator&(int2_mt16 a, int2_mt16 b) => new(a.x & b.x, a.y & b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt16 operator^(int2_mt16 a, int2_mt16 b) => new(a.x ^ b.x, a.y ^ b.y);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out int_mt16 x, out int_mt16 y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // Deconstruct

    #region Index

    public int_mt16 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"int2_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // int2_mt16
#region int2_mt32

[CpuOnly]
public partial struct int2_mt32
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => int_mt32.LineCount;
    }

    #endregion

    #region Fields

    public int_mt32 x;
    public int_mt32 y;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly int2 LaneGet(int index) => new(x[index], y[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, int2 value)
    {
        x[index] = value.x;
        y[index] = value.y;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public int2_mt32(int_mt32 x, int_mt32 y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public int2_mt32(int value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public int2_mt32(int_mt32 value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public int2_mt32(int2 value)
    {
        x = new(value.x);
        y = new(value.y);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator int2_mt32(int value) => new int_mt32(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int2_mt32(int_mt32 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int2_mt32(int2 value) => new(value);

    [MethodImpl(256 | 512)]
    public static int2_mt32 operator~(int2_mt32 a) => new(~a.x, ~a.y);

    [MethodImpl(256 | 512)]
    public static int2_mt32 operator|(int2_mt32 a, int2_mt32 b) => new(a.x | b.x, a.y | b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt32 operator&(int2_mt32 a, int2_mt32 b) => new(a.x & b.x, a.y & b.y);

    [MethodImpl(256 | 512)]
    public static int2_mt32 operator^(int2_mt32 a, int2_mt32 b) => new(a.x ^ b.x, a.y ^ b.y);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out int_mt32 x, out int_mt32 y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // Deconstruct

    #region Index

    public int_mt32 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"int2_mt32 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)}, t16 = {this.LaneGet(16)}, t17 = {this.LaneGet(17)}, t18 = {this.LaneGet(18)}, t19 = {this.LaneGet(19)}, t20 = {this.LaneGet(20)}, t21 = {this.LaneGet(21)}, t22 = {this.LaneGet(22)}, t23 = {this.LaneGet(23)}, t24 = {this.LaneGet(24)}, t25 = {this.LaneGet(25)}, t26 = {this.LaneGet(26)}, t27 = {this.LaneGet(27)}, t28 = {this.LaneGet(28)}, t29 = {this.LaneGet(29)}, t30 = {this.LaneGet(30)}, t31 = {this.LaneGet(31)} }}";
    
    #endregion // ToString
}

#endregion // int2_mt32
#region int3_mt4

[CpuOnly]
public partial struct int3_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => int_mt4.LineCount;
    }

    #endregion

    #region Fields

    public int_mt4 x;
    public int_mt4 y;
    public int_mt4 z;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly int3 LaneGet(int index) => new(x[index], y[index], z[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, int3 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public int3_mt4(int_mt4 x, int_mt4 y, int_mt4 z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public int3_mt4(int value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public int3_mt4(int_mt4 value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public int3_mt4(int3 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator int3_mt4(int value) => new int_mt4(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int3_mt4(int_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int3_mt4(int3 value) => new(value);

    [MethodImpl(256 | 512)]
    public static int3_mt4 operator~(int3_mt4 a) => new(~a.x, ~a.y, ~a.z);

    [MethodImpl(256 | 512)]
    public static int3_mt4 operator|(int3_mt4 a, int3_mt4 b) => new(a.x | b.x, a.y | b.y, a.z | b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt4 operator&(int3_mt4 a, int3_mt4 b) => new(a.x & b.x, a.y & b.y, a.z & b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt4 operator^(int3_mt4 a, int3_mt4 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out int_mt4 x, out int_mt4 y, out int_mt4 z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // Deconstruct

    #region Index

    public int_mt4 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"int3_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // int3_mt4
#region int3_mt8

[CpuOnly]
public partial struct int3_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => int_mt8.LineCount;
    }

    #endregion

    #region Fields

    public int_mt8 x;
    public int_mt8 y;
    public int_mt8 z;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly int3 LaneGet(int index) => new(x[index], y[index], z[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, int3 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public int3_mt8(int_mt8 x, int_mt8 y, int_mt8 z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public int3_mt8(int value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public int3_mt8(int_mt8 value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public int3_mt8(int3 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator int3_mt8(int value) => new int_mt8(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int3_mt8(int_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int3_mt8(int3 value) => new(value);

    [MethodImpl(256 | 512)]
    public static int3_mt8 operator~(int3_mt8 a) => new(~a.x, ~a.y, ~a.z);

    [MethodImpl(256 | 512)]
    public static int3_mt8 operator|(int3_mt8 a, int3_mt8 b) => new(a.x | b.x, a.y | b.y, a.z | b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt8 operator&(int3_mt8 a, int3_mt8 b) => new(a.x & b.x, a.y & b.y, a.z & b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt8 operator^(int3_mt8 a, int3_mt8 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out int_mt8 x, out int_mt8 y, out int_mt8 z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // Deconstruct

    #region Index

    public int_mt8 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"int3_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // int3_mt8
#region int3_mt16

[CpuOnly]
public partial struct int3_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => int_mt16.LineCount;
    }

    #endregion

    #region Fields

    public int_mt16 x;
    public int_mt16 y;
    public int_mt16 z;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly int3 LaneGet(int index) => new(x[index], y[index], z[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, int3 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public int3_mt16(int_mt16 x, int_mt16 y, int_mt16 z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public int3_mt16(int value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public int3_mt16(int_mt16 value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public int3_mt16(int3 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator int3_mt16(int value) => new int_mt16(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int3_mt16(int_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int3_mt16(int3 value) => new(value);

    [MethodImpl(256 | 512)]
    public static int3_mt16 operator~(int3_mt16 a) => new(~a.x, ~a.y, ~a.z);

    [MethodImpl(256 | 512)]
    public static int3_mt16 operator|(int3_mt16 a, int3_mt16 b) => new(a.x | b.x, a.y | b.y, a.z | b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt16 operator&(int3_mt16 a, int3_mt16 b) => new(a.x & b.x, a.y & b.y, a.z & b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt16 operator^(int3_mt16 a, int3_mt16 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out int_mt16 x, out int_mt16 y, out int_mt16 z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // Deconstruct

    #region Index

    public int_mt16 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"int3_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // int3_mt16
#region int3_mt32

[CpuOnly]
public partial struct int3_mt32
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => int_mt32.LineCount;
    }

    #endregion

    #region Fields

    public int_mt32 x;
    public int_mt32 y;
    public int_mt32 z;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly int3 LaneGet(int index) => new(x[index], y[index], z[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, int3 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public int3_mt32(int_mt32 x, int_mt32 y, int_mt32 z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public int3_mt32(int value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public int3_mt32(int_mt32 value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public int3_mt32(int3 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator int3_mt32(int value) => new int_mt32(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int3_mt32(int_mt32 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int3_mt32(int3 value) => new(value);

    [MethodImpl(256 | 512)]
    public static int3_mt32 operator~(int3_mt32 a) => new(~a.x, ~a.y, ~a.z);

    [MethodImpl(256 | 512)]
    public static int3_mt32 operator|(int3_mt32 a, int3_mt32 b) => new(a.x | b.x, a.y | b.y, a.z | b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt32 operator&(int3_mt32 a, int3_mt32 b) => new(a.x & b.x, a.y & b.y, a.z & b.z);

    [MethodImpl(256 | 512)]
    public static int3_mt32 operator^(int3_mt32 a, int3_mt32 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out int_mt32 x, out int_mt32 y, out int_mt32 z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // Deconstruct

    #region Index

    public int_mt32 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"int3_mt32 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)}, t16 = {this.LaneGet(16)}, t17 = {this.LaneGet(17)}, t18 = {this.LaneGet(18)}, t19 = {this.LaneGet(19)}, t20 = {this.LaneGet(20)}, t21 = {this.LaneGet(21)}, t22 = {this.LaneGet(22)}, t23 = {this.LaneGet(23)}, t24 = {this.LaneGet(24)}, t25 = {this.LaneGet(25)}, t26 = {this.LaneGet(26)}, t27 = {this.LaneGet(27)}, t28 = {this.LaneGet(28)}, t29 = {this.LaneGet(29)}, t30 = {this.LaneGet(30)}, t31 = {this.LaneGet(31)} }}";
    
    #endregion // ToString
}

#endregion // int3_mt32
#region int4_mt4

[CpuOnly]
public partial struct int4_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => int_mt4.LineCount;
    }

    #endregion

    #region Fields

    public int_mt4 x;
    public int_mt4 y;
    public int_mt4 z;
    public int_mt4 w;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly int4 LaneGet(int index) => new(x[index], y[index], z[index], w[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, int4 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
        w[index] = value.w;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public int4_mt4(int_mt4 x, int_mt4 y, int_mt4 z, int_mt4 w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public int4_mt4(int value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public int4_mt4(int_mt4 value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public int4_mt4(int4 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
        w = new(value.w);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator int4_mt4(int value) => new int_mt4(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int4_mt4(int_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int4_mt4(int4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static int4_mt4 operator~(int4_mt4 a) => new(~a.x, ~a.y, ~a.z, ~a.w);

    [MethodImpl(256 | 512)]
    public static int4_mt4 operator|(int4_mt4 a, int4_mt4 b) => new(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt4 operator&(int4_mt4 a, int4_mt4 b) => new(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt4 operator^(int4_mt4 a, int4_mt4 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out int_mt4 x, out int_mt4 y, out int_mt4 z, out int_mt4 w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // Deconstruct

    #region Index

    public int_mt4 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"int4_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // int4_mt4
#region int4_mt8

[CpuOnly]
public partial struct int4_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => int_mt8.LineCount;
    }

    #endregion

    #region Fields

    public int_mt8 x;
    public int_mt8 y;
    public int_mt8 z;
    public int_mt8 w;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly int4 LaneGet(int index) => new(x[index], y[index], z[index], w[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, int4 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
        w[index] = value.w;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public int4_mt8(int_mt8 x, int_mt8 y, int_mt8 z, int_mt8 w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public int4_mt8(int value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public int4_mt8(int_mt8 value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public int4_mt8(int4 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
        w = new(value.w);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator int4_mt8(int value) => new int_mt8(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int4_mt8(int_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int4_mt8(int4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static int4_mt8 operator~(int4_mt8 a) => new(~a.x, ~a.y, ~a.z, ~a.w);

    [MethodImpl(256 | 512)]
    public static int4_mt8 operator|(int4_mt8 a, int4_mt8 b) => new(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt8 operator&(int4_mt8 a, int4_mt8 b) => new(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt8 operator^(int4_mt8 a, int4_mt8 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out int_mt8 x, out int_mt8 y, out int_mt8 z, out int_mt8 w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // Deconstruct

    #region Index

    public int_mt8 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"int4_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // int4_mt8
#region int4_mt16

[CpuOnly]
public partial struct int4_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => int_mt16.LineCount;
    }

    #endregion

    #region Fields

    public int_mt16 x;
    public int_mt16 y;
    public int_mt16 z;
    public int_mt16 w;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly int4 LaneGet(int index) => new(x[index], y[index], z[index], w[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, int4 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
        w[index] = value.w;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public int4_mt16(int_mt16 x, int_mt16 y, int_mt16 z, int_mt16 w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public int4_mt16(int value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public int4_mt16(int_mt16 value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public int4_mt16(int4 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
        w = new(value.w);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator int4_mt16(int value) => new int_mt16(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int4_mt16(int_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int4_mt16(int4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static int4_mt16 operator~(int4_mt16 a) => new(~a.x, ~a.y, ~a.z, ~a.w);

    [MethodImpl(256 | 512)]
    public static int4_mt16 operator|(int4_mt16 a, int4_mt16 b) => new(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt16 operator&(int4_mt16 a, int4_mt16 b) => new(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt16 operator^(int4_mt16 a, int4_mt16 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out int_mt16 x, out int_mt16 y, out int_mt16 z, out int_mt16 w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // Deconstruct

    #region Index

    public int_mt16 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"int4_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // int4_mt16
#region int4_mt32

[CpuOnly]
public partial struct int4_mt32
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => int_mt32.LineCount;
    }

    #endregion

    #region Fields

    public int_mt32 x;
    public int_mt32 y;
    public int_mt32 z;
    public int_mt32 w;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly int4 LaneGet(int index) => new(x[index], y[index], z[index], w[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, int4 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
        w[index] = value.w;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public int4_mt32(int_mt32 x, int_mt32 y, int_mt32 z, int_mt32 w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public int4_mt32(int value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public int4_mt32(int_mt32 value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public int4_mt32(int4 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
        w = new(value.w);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator int4_mt32(int value) => new int_mt32(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int4_mt32(int_mt32 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int4_mt32(int4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static int4_mt32 operator~(int4_mt32 a) => new(~a.x, ~a.y, ~a.z, ~a.w);

    [MethodImpl(256 | 512)]
    public static int4_mt32 operator|(int4_mt32 a, int4_mt32 b) => new(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt32 operator&(int4_mt32 a, int4_mt32 b) => new(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);

    [MethodImpl(256 | 512)]
    public static int4_mt32 operator^(int4_mt32 a, int4_mt32 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out int_mt32 x, out int_mt32 y, out int_mt32 z, out int_mt32 w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // Deconstruct

    #region Index

    public int_mt32 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"int4_mt32 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)}, t16 = {this.LaneGet(16)}, t17 = {this.LaneGet(17)}, t18 = {this.LaneGet(18)}, t19 = {this.LaneGet(19)}, t20 = {this.LaneGet(20)}, t21 = {this.LaneGet(21)}, t22 = {this.LaneGet(22)}, t23 = {this.LaneGet(23)}, t24 = {this.LaneGet(24)}, t25 = {this.LaneGet(25)}, t26 = {this.LaneGet(26)}, t27 = {this.LaneGet(27)}, t28 = {this.LaneGet(28)}, t29 = {this.LaneGet(29)}, t30 = {this.LaneGet(30)}, t31 = {this.LaneGet(31)} }}";
    
    #endregion // ToString
}

#endregion // int4_mt32
#region uint2_mt4

[CpuOnly]
public partial struct uint2_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => uint_mt4.LineCount;
    }

    #endregion

    #region Fields

    public uint_mt4 x;
    public uint_mt4 y;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly uint2 LaneGet(int index) => new(x[index], y[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, uint2 value)
    {
        x[index] = value.x;
        y[index] = value.y;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public uint2_mt4(uint_mt4 x, uint_mt4 y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public uint2_mt4(uint value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public uint2_mt4(uint_mt4 value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public uint2_mt4(uint2 value)
    {
        x = new(value.x);
        y = new(value.y);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator uint2_mt4(uint value) => new uint_mt4(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint2_mt4(uint_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint2_mt4(uint2 value) => new(value);

    [MethodImpl(256 | 512)]
    public static uint2_mt4 operator~(uint2_mt4 a) => new(~a.x, ~a.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt4 operator|(uint2_mt4 a, uint2_mt4 b) => new(a.x | b.x, a.y | b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt4 operator&(uint2_mt4 a, uint2_mt4 b) => new(a.x & b.x, a.y & b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt4 operator^(uint2_mt4 a, uint2_mt4 b) => new(a.x ^ b.x, a.y ^ b.y);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out uint_mt4 x, out uint_mt4 y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // Deconstruct

    #region Index

    public uint_mt4 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"uint2_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // uint2_mt4
#region uint2_mt8

[CpuOnly]
public partial struct uint2_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => uint_mt8.LineCount;
    }

    #endregion

    #region Fields

    public uint_mt8 x;
    public uint_mt8 y;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly uint2 LaneGet(int index) => new(x[index], y[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, uint2 value)
    {
        x[index] = value.x;
        y[index] = value.y;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public uint2_mt8(uint_mt8 x, uint_mt8 y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public uint2_mt8(uint value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public uint2_mt8(uint_mt8 value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public uint2_mt8(uint2 value)
    {
        x = new(value.x);
        y = new(value.y);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator uint2_mt8(uint value) => new uint_mt8(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint2_mt8(uint_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint2_mt8(uint2 value) => new(value);

    [MethodImpl(256 | 512)]
    public static uint2_mt8 operator~(uint2_mt8 a) => new(~a.x, ~a.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt8 operator|(uint2_mt8 a, uint2_mt8 b) => new(a.x | b.x, a.y | b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt8 operator&(uint2_mt8 a, uint2_mt8 b) => new(a.x & b.x, a.y & b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt8 operator^(uint2_mt8 a, uint2_mt8 b) => new(a.x ^ b.x, a.y ^ b.y);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out uint_mt8 x, out uint_mt8 y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // Deconstruct

    #region Index

    public uint_mt8 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"uint2_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // uint2_mt8
#region uint2_mt16

[CpuOnly]
public partial struct uint2_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => uint_mt16.LineCount;
    }

    #endregion

    #region Fields

    public uint_mt16 x;
    public uint_mt16 y;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly uint2 LaneGet(int index) => new(x[index], y[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, uint2 value)
    {
        x[index] = value.x;
        y[index] = value.y;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public uint2_mt16(uint_mt16 x, uint_mt16 y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public uint2_mt16(uint value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public uint2_mt16(uint_mt16 value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public uint2_mt16(uint2 value)
    {
        x = new(value.x);
        y = new(value.y);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator uint2_mt16(uint value) => new uint_mt16(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint2_mt16(uint_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint2_mt16(uint2 value) => new(value);

    [MethodImpl(256 | 512)]
    public static uint2_mt16 operator~(uint2_mt16 a) => new(~a.x, ~a.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt16 operator|(uint2_mt16 a, uint2_mt16 b) => new(a.x | b.x, a.y | b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt16 operator&(uint2_mt16 a, uint2_mt16 b) => new(a.x & b.x, a.y & b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt16 operator^(uint2_mt16 a, uint2_mt16 b) => new(a.x ^ b.x, a.y ^ b.y);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out uint_mt16 x, out uint_mt16 y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // Deconstruct

    #region Index

    public uint_mt16 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"uint2_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // uint2_mt16
#region uint2_mt32

[CpuOnly]
public partial struct uint2_mt32
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => uint_mt32.LineCount;
    }

    #endregion

    #region Fields

    public uint_mt32 x;
    public uint_mt32 y;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly uint2 LaneGet(int index) => new(x[index], y[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, uint2 value)
    {
        x[index] = value.x;
        y[index] = value.y;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public uint2_mt32(uint_mt32 x, uint_mt32 y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public uint2_mt32(uint value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public uint2_mt32(uint_mt32 value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public uint2_mt32(uint2 value)
    {
        x = new(value.x);
        y = new(value.y);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator uint2_mt32(uint value) => new uint_mt32(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint2_mt32(uint_mt32 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint2_mt32(uint2 value) => new(value);

    [MethodImpl(256 | 512)]
    public static uint2_mt32 operator~(uint2_mt32 a) => new(~a.x, ~a.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt32 operator|(uint2_mt32 a, uint2_mt32 b) => new(a.x | b.x, a.y | b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt32 operator&(uint2_mt32 a, uint2_mt32 b) => new(a.x & b.x, a.y & b.y);

    [MethodImpl(256 | 512)]
    public static uint2_mt32 operator^(uint2_mt32 a, uint2_mt32 b) => new(a.x ^ b.x, a.y ^ b.y);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out uint_mt32 x, out uint_mt32 y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // Deconstruct

    #region Index

    public uint_mt32 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"uint2_mt32 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)}, t16 = {this.LaneGet(16)}, t17 = {this.LaneGet(17)}, t18 = {this.LaneGet(18)}, t19 = {this.LaneGet(19)}, t20 = {this.LaneGet(20)}, t21 = {this.LaneGet(21)}, t22 = {this.LaneGet(22)}, t23 = {this.LaneGet(23)}, t24 = {this.LaneGet(24)}, t25 = {this.LaneGet(25)}, t26 = {this.LaneGet(26)}, t27 = {this.LaneGet(27)}, t28 = {this.LaneGet(28)}, t29 = {this.LaneGet(29)}, t30 = {this.LaneGet(30)}, t31 = {this.LaneGet(31)} }}";
    
    #endregion // ToString
}

#endregion // uint2_mt32
#region uint3_mt4

[CpuOnly]
public partial struct uint3_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => uint_mt4.LineCount;
    }

    #endregion

    #region Fields

    public uint_mt4 x;
    public uint_mt4 y;
    public uint_mt4 z;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly uint3 LaneGet(int index) => new(x[index], y[index], z[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, uint3 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public uint3_mt4(uint_mt4 x, uint_mt4 y, uint_mt4 z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public uint3_mt4(uint value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public uint3_mt4(uint_mt4 value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public uint3_mt4(uint3 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator uint3_mt4(uint value) => new uint_mt4(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint3_mt4(uint_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint3_mt4(uint3 value) => new(value);

    [MethodImpl(256 | 512)]
    public static uint3_mt4 operator~(uint3_mt4 a) => new(~a.x, ~a.y, ~a.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt4 operator|(uint3_mt4 a, uint3_mt4 b) => new(a.x | b.x, a.y | b.y, a.z | b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt4 operator&(uint3_mt4 a, uint3_mt4 b) => new(a.x & b.x, a.y & b.y, a.z & b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt4 operator^(uint3_mt4 a, uint3_mt4 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out uint_mt4 x, out uint_mt4 y, out uint_mt4 z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // Deconstruct

    #region Index

    public uint_mt4 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"uint3_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // uint3_mt4
#region uint3_mt8

[CpuOnly]
public partial struct uint3_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => uint_mt8.LineCount;
    }

    #endregion

    #region Fields

    public uint_mt8 x;
    public uint_mt8 y;
    public uint_mt8 z;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly uint3 LaneGet(int index) => new(x[index], y[index], z[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, uint3 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public uint3_mt8(uint_mt8 x, uint_mt8 y, uint_mt8 z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public uint3_mt8(uint value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public uint3_mt8(uint_mt8 value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public uint3_mt8(uint3 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator uint3_mt8(uint value) => new uint_mt8(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint3_mt8(uint_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint3_mt8(uint3 value) => new(value);

    [MethodImpl(256 | 512)]
    public static uint3_mt8 operator~(uint3_mt8 a) => new(~a.x, ~a.y, ~a.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt8 operator|(uint3_mt8 a, uint3_mt8 b) => new(a.x | b.x, a.y | b.y, a.z | b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt8 operator&(uint3_mt8 a, uint3_mt8 b) => new(a.x & b.x, a.y & b.y, a.z & b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt8 operator^(uint3_mt8 a, uint3_mt8 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out uint_mt8 x, out uint_mt8 y, out uint_mt8 z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // Deconstruct

    #region Index

    public uint_mt8 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"uint3_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // uint3_mt8
#region uint3_mt16

[CpuOnly]
public partial struct uint3_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => uint_mt16.LineCount;
    }

    #endregion

    #region Fields

    public uint_mt16 x;
    public uint_mt16 y;
    public uint_mt16 z;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly uint3 LaneGet(int index) => new(x[index], y[index], z[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, uint3 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public uint3_mt16(uint_mt16 x, uint_mt16 y, uint_mt16 z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public uint3_mt16(uint value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public uint3_mt16(uint_mt16 value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public uint3_mt16(uint3 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator uint3_mt16(uint value) => new uint_mt16(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint3_mt16(uint_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint3_mt16(uint3 value) => new(value);

    [MethodImpl(256 | 512)]
    public static uint3_mt16 operator~(uint3_mt16 a) => new(~a.x, ~a.y, ~a.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt16 operator|(uint3_mt16 a, uint3_mt16 b) => new(a.x | b.x, a.y | b.y, a.z | b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt16 operator&(uint3_mt16 a, uint3_mt16 b) => new(a.x & b.x, a.y & b.y, a.z & b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt16 operator^(uint3_mt16 a, uint3_mt16 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out uint_mt16 x, out uint_mt16 y, out uint_mt16 z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // Deconstruct

    #region Index

    public uint_mt16 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"uint3_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // uint3_mt16
#region uint3_mt32

[CpuOnly]
public partial struct uint3_mt32
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => uint_mt32.LineCount;
    }

    #endregion

    #region Fields

    public uint_mt32 x;
    public uint_mt32 y;
    public uint_mt32 z;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly uint3 LaneGet(int index) => new(x[index], y[index], z[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, uint3 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public uint3_mt32(uint_mt32 x, uint_mt32 y, uint_mt32 z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public uint3_mt32(uint value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public uint3_mt32(uint_mt32 value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public uint3_mt32(uint3 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator uint3_mt32(uint value) => new uint_mt32(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint3_mt32(uint_mt32 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint3_mt32(uint3 value) => new(value);

    [MethodImpl(256 | 512)]
    public static uint3_mt32 operator~(uint3_mt32 a) => new(~a.x, ~a.y, ~a.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt32 operator|(uint3_mt32 a, uint3_mt32 b) => new(a.x | b.x, a.y | b.y, a.z | b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt32 operator&(uint3_mt32 a, uint3_mt32 b) => new(a.x & b.x, a.y & b.y, a.z & b.z);

    [MethodImpl(256 | 512)]
    public static uint3_mt32 operator^(uint3_mt32 a, uint3_mt32 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out uint_mt32 x, out uint_mt32 y, out uint_mt32 z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // Deconstruct

    #region Index

    public uint_mt32 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"uint3_mt32 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)}, t16 = {this.LaneGet(16)}, t17 = {this.LaneGet(17)}, t18 = {this.LaneGet(18)}, t19 = {this.LaneGet(19)}, t20 = {this.LaneGet(20)}, t21 = {this.LaneGet(21)}, t22 = {this.LaneGet(22)}, t23 = {this.LaneGet(23)}, t24 = {this.LaneGet(24)}, t25 = {this.LaneGet(25)}, t26 = {this.LaneGet(26)}, t27 = {this.LaneGet(27)}, t28 = {this.LaneGet(28)}, t29 = {this.LaneGet(29)}, t30 = {this.LaneGet(30)}, t31 = {this.LaneGet(31)} }}";
    
    #endregion // ToString
}

#endregion // uint3_mt32
#region uint4_mt4

[CpuOnly]
public partial struct uint4_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => uint_mt4.LineCount;
    }

    #endregion

    #region Fields

    public uint_mt4 x;
    public uint_mt4 y;
    public uint_mt4 z;
    public uint_mt4 w;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly uint4 LaneGet(int index) => new(x[index], y[index], z[index], w[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, uint4 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
        w[index] = value.w;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public uint4_mt4(uint_mt4 x, uint_mt4 y, uint_mt4 z, uint_mt4 w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public uint4_mt4(uint value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public uint4_mt4(uint_mt4 value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public uint4_mt4(uint4 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
        w = new(value.w);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator uint4_mt4(uint value) => new uint_mt4(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint4_mt4(uint_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint4_mt4(uint4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static uint4_mt4 operator~(uint4_mt4 a) => new(~a.x, ~a.y, ~a.z, ~a.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt4 operator|(uint4_mt4 a, uint4_mt4 b) => new(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt4 operator&(uint4_mt4 a, uint4_mt4 b) => new(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt4 operator^(uint4_mt4 a, uint4_mt4 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out uint_mt4 x, out uint_mt4 y, out uint_mt4 z, out uint_mt4 w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // Deconstruct

    #region Index

    public uint_mt4 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"uint4_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // uint4_mt4
#region uint4_mt8

[CpuOnly]
public partial struct uint4_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => uint_mt8.LineCount;
    }

    #endregion

    #region Fields

    public uint_mt8 x;
    public uint_mt8 y;
    public uint_mt8 z;
    public uint_mt8 w;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly uint4 LaneGet(int index) => new(x[index], y[index], z[index], w[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, uint4 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
        w[index] = value.w;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public uint4_mt8(uint_mt8 x, uint_mt8 y, uint_mt8 z, uint_mt8 w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public uint4_mt8(uint value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public uint4_mt8(uint_mt8 value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public uint4_mt8(uint4 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
        w = new(value.w);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator uint4_mt8(uint value) => new uint_mt8(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint4_mt8(uint_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint4_mt8(uint4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static uint4_mt8 operator~(uint4_mt8 a) => new(~a.x, ~a.y, ~a.z, ~a.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt8 operator|(uint4_mt8 a, uint4_mt8 b) => new(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt8 operator&(uint4_mt8 a, uint4_mt8 b) => new(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt8 operator^(uint4_mt8 a, uint4_mt8 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out uint_mt8 x, out uint_mt8 y, out uint_mt8 z, out uint_mt8 w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // Deconstruct

    #region Index

    public uint_mt8 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"uint4_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // uint4_mt8
#region uint4_mt16

[CpuOnly]
public partial struct uint4_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => uint_mt16.LineCount;
    }

    #endregion

    #region Fields

    public uint_mt16 x;
    public uint_mt16 y;
    public uint_mt16 z;
    public uint_mt16 w;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly uint4 LaneGet(int index) => new(x[index], y[index], z[index], w[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, uint4 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
        w[index] = value.w;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public uint4_mt16(uint_mt16 x, uint_mt16 y, uint_mt16 z, uint_mt16 w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public uint4_mt16(uint value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public uint4_mt16(uint_mt16 value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public uint4_mt16(uint4 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
        w = new(value.w);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator uint4_mt16(uint value) => new uint_mt16(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint4_mt16(uint_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint4_mt16(uint4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static uint4_mt16 operator~(uint4_mt16 a) => new(~a.x, ~a.y, ~a.z, ~a.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt16 operator|(uint4_mt16 a, uint4_mt16 b) => new(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt16 operator&(uint4_mt16 a, uint4_mt16 b) => new(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt16 operator^(uint4_mt16 a, uint4_mt16 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out uint_mt16 x, out uint_mt16 y, out uint_mt16 z, out uint_mt16 w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // Deconstruct

    #region Index

    public uint_mt16 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"uint4_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // uint4_mt16
#region uint4_mt32

[CpuOnly]
public partial struct uint4_mt32
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => uint_mt32.LineCount;
    }

    #endregion

    #region Fields

    public uint_mt32 x;
    public uint_mt32 y;
    public uint_mt32 z;
    public uint_mt32 w;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly uint4 LaneGet(int index) => new(x[index], y[index], z[index], w[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, uint4 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
        w[index] = value.w;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public uint4_mt32(uint_mt32 x, uint_mt32 y, uint_mt32 z, uint_mt32 w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public uint4_mt32(uint value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public uint4_mt32(uint_mt32 value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public uint4_mt32(uint4 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
        w = new(value.w);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator uint4_mt32(uint value) => new uint_mt32(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint4_mt32(uint_mt32 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint4_mt32(uint4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static uint4_mt32 operator~(uint4_mt32 a) => new(~a.x, ~a.y, ~a.z, ~a.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt32 operator|(uint4_mt32 a, uint4_mt32 b) => new(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt32 operator&(uint4_mt32 a, uint4_mt32 b) => new(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);

    [MethodImpl(256 | 512)]
    public static uint4_mt32 operator^(uint4_mt32 a, uint4_mt32 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out uint_mt32 x, out uint_mt32 y, out uint_mt32 z, out uint_mt32 w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // Deconstruct

    #region Index

    public uint_mt32 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"uint4_mt32 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)}, t16 = {this.LaneGet(16)}, t17 = {this.LaneGet(17)}, t18 = {this.LaneGet(18)}, t19 = {this.LaneGet(19)}, t20 = {this.LaneGet(20)}, t21 = {this.LaneGet(21)}, t22 = {this.LaneGet(22)}, t23 = {this.LaneGet(23)}, t24 = {this.LaneGet(24)}, t25 = {this.LaneGet(25)}, t26 = {this.LaneGet(26)}, t27 = {this.LaneGet(27)}, t28 = {this.LaneGet(28)}, t29 = {this.LaneGet(29)}, t30 = {this.LaneGet(30)}, t31 = {this.LaneGet(31)} }}";
    
    #endregion // ToString
}

#endregion // uint4_mt32
#region long2_mt4

[CpuOnly]
public partial struct long2_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => long_mt4.LineCount;
    }

    #endregion

    #region Fields

    public long_mt4 x;
    public long_mt4 y;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly long2 LaneGet(int index) => new(x[index], y[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, long2 value)
    {
        x[index] = value.x;
        y[index] = value.y;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public long2_mt4(long_mt4 x, long_mt4 y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public long2_mt4(long value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public long2_mt4(long_mt4 value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public long2_mt4(long2 value)
    {
        x = new(value.x);
        y = new(value.y);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator long2_mt4(long value) => new long_mt4(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long2_mt4(long_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long2_mt4(long2 value) => new(value);

    [MethodImpl(256 | 512)]
    public static long2_mt4 operator~(long2_mt4 a) => new(~a.x, ~a.y);

    [MethodImpl(256 | 512)]
    public static long2_mt4 operator|(long2_mt4 a, long2_mt4 b) => new(a.x | b.x, a.y | b.y);

    [MethodImpl(256 | 512)]
    public static long2_mt4 operator&(long2_mt4 a, long2_mt4 b) => new(a.x & b.x, a.y & b.y);

    [MethodImpl(256 | 512)]
    public static long2_mt4 operator^(long2_mt4 a, long2_mt4 b) => new(a.x ^ b.x, a.y ^ b.y);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out long_mt4 x, out long_mt4 y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // Deconstruct

    #region Index

    public long_mt4 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"long2_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // long2_mt4
#region long2_mt8

[CpuOnly]
public partial struct long2_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => long_mt8.LineCount;
    }

    #endregion

    #region Fields

    public long_mt8 x;
    public long_mt8 y;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly long2 LaneGet(int index) => new(x[index], y[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, long2 value)
    {
        x[index] = value.x;
        y[index] = value.y;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public long2_mt8(long_mt8 x, long_mt8 y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public long2_mt8(long value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public long2_mt8(long_mt8 value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public long2_mt8(long2 value)
    {
        x = new(value.x);
        y = new(value.y);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator long2_mt8(long value) => new long_mt8(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long2_mt8(long_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long2_mt8(long2 value) => new(value);

    [MethodImpl(256 | 512)]
    public static long2_mt8 operator~(long2_mt8 a) => new(~a.x, ~a.y);

    [MethodImpl(256 | 512)]
    public static long2_mt8 operator|(long2_mt8 a, long2_mt8 b) => new(a.x | b.x, a.y | b.y);

    [MethodImpl(256 | 512)]
    public static long2_mt8 operator&(long2_mt8 a, long2_mt8 b) => new(a.x & b.x, a.y & b.y);

    [MethodImpl(256 | 512)]
    public static long2_mt8 operator^(long2_mt8 a, long2_mt8 b) => new(a.x ^ b.x, a.y ^ b.y);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out long_mt8 x, out long_mt8 y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // Deconstruct

    #region Index

    public long_mt8 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"long2_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // long2_mt8
#region long2_mt16

[CpuOnly]
public partial struct long2_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => long_mt16.LineCount;
    }

    #endregion

    #region Fields

    public long_mt16 x;
    public long_mt16 y;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly long2 LaneGet(int index) => new(x[index], y[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, long2 value)
    {
        x[index] = value.x;
        y[index] = value.y;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public long2_mt16(long_mt16 x, long_mt16 y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public long2_mt16(long value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public long2_mt16(long_mt16 value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public long2_mt16(long2 value)
    {
        x = new(value.x);
        y = new(value.y);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator long2_mt16(long value) => new long_mt16(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long2_mt16(long_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long2_mt16(long2 value) => new(value);

    [MethodImpl(256 | 512)]
    public static long2_mt16 operator~(long2_mt16 a) => new(~a.x, ~a.y);

    [MethodImpl(256 | 512)]
    public static long2_mt16 operator|(long2_mt16 a, long2_mt16 b) => new(a.x | b.x, a.y | b.y);

    [MethodImpl(256 | 512)]
    public static long2_mt16 operator&(long2_mt16 a, long2_mt16 b) => new(a.x & b.x, a.y & b.y);

    [MethodImpl(256 | 512)]
    public static long2_mt16 operator^(long2_mt16 a, long2_mt16 b) => new(a.x ^ b.x, a.y ^ b.y);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out long_mt16 x, out long_mt16 y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // Deconstruct

    #region Index

    public long_mt16 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"long2_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // long2_mt16
#region long2_mt32

[CpuOnly]
public partial struct long2_mt32
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => long_mt32.LineCount;
    }

    #endregion

    #region Fields

    public long_mt32 x;
    public long_mt32 y;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly long2 LaneGet(int index) => new(x[index], y[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, long2 value)
    {
        x[index] = value.x;
        y[index] = value.y;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public long2_mt32(long_mt32 x, long_mt32 y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public long2_mt32(long value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public long2_mt32(long_mt32 value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public long2_mt32(long2 value)
    {
        x = new(value.x);
        y = new(value.y);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator long2_mt32(long value) => new long_mt32(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long2_mt32(long_mt32 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long2_mt32(long2 value) => new(value);

    [MethodImpl(256 | 512)]
    public static long2_mt32 operator~(long2_mt32 a) => new(~a.x, ~a.y);

    [MethodImpl(256 | 512)]
    public static long2_mt32 operator|(long2_mt32 a, long2_mt32 b) => new(a.x | b.x, a.y | b.y);

    [MethodImpl(256 | 512)]
    public static long2_mt32 operator&(long2_mt32 a, long2_mt32 b) => new(a.x & b.x, a.y & b.y);

    [MethodImpl(256 | 512)]
    public static long2_mt32 operator^(long2_mt32 a, long2_mt32 b) => new(a.x ^ b.x, a.y ^ b.y);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out long_mt32 x, out long_mt32 y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // Deconstruct

    #region Index

    public long_mt32 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"long2_mt32 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)}, t16 = {this.LaneGet(16)}, t17 = {this.LaneGet(17)}, t18 = {this.LaneGet(18)}, t19 = {this.LaneGet(19)}, t20 = {this.LaneGet(20)}, t21 = {this.LaneGet(21)}, t22 = {this.LaneGet(22)}, t23 = {this.LaneGet(23)}, t24 = {this.LaneGet(24)}, t25 = {this.LaneGet(25)}, t26 = {this.LaneGet(26)}, t27 = {this.LaneGet(27)}, t28 = {this.LaneGet(28)}, t29 = {this.LaneGet(29)}, t30 = {this.LaneGet(30)}, t31 = {this.LaneGet(31)} }}";
    
    #endregion // ToString
}

#endregion // long2_mt32
#region long3_mt4

[CpuOnly]
public partial struct long3_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => long_mt4.LineCount;
    }

    #endregion

    #region Fields

    public long_mt4 x;
    public long_mt4 y;
    public long_mt4 z;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly long3 LaneGet(int index) => new(x[index], y[index], z[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, long3 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public long3_mt4(long_mt4 x, long_mt4 y, long_mt4 z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public long3_mt4(long value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public long3_mt4(long_mt4 value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public long3_mt4(long3 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator long3_mt4(long value) => new long_mt4(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long3_mt4(long_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long3_mt4(long3 value) => new(value);

    [MethodImpl(256 | 512)]
    public static long3_mt4 operator~(long3_mt4 a) => new(~a.x, ~a.y, ~a.z);

    [MethodImpl(256 | 512)]
    public static long3_mt4 operator|(long3_mt4 a, long3_mt4 b) => new(a.x | b.x, a.y | b.y, a.z | b.z);

    [MethodImpl(256 | 512)]
    public static long3_mt4 operator&(long3_mt4 a, long3_mt4 b) => new(a.x & b.x, a.y & b.y, a.z & b.z);

    [MethodImpl(256 | 512)]
    public static long3_mt4 operator^(long3_mt4 a, long3_mt4 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out long_mt4 x, out long_mt4 y, out long_mt4 z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // Deconstruct

    #region Index

    public long_mt4 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"long3_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // long3_mt4
#region long3_mt8

[CpuOnly]
public partial struct long3_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => long_mt8.LineCount;
    }

    #endregion

    #region Fields

    public long_mt8 x;
    public long_mt8 y;
    public long_mt8 z;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly long3 LaneGet(int index) => new(x[index], y[index], z[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, long3 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public long3_mt8(long_mt8 x, long_mt8 y, long_mt8 z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public long3_mt8(long value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public long3_mt8(long_mt8 value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public long3_mt8(long3 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator long3_mt8(long value) => new long_mt8(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long3_mt8(long_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long3_mt8(long3 value) => new(value);

    [MethodImpl(256 | 512)]
    public static long3_mt8 operator~(long3_mt8 a) => new(~a.x, ~a.y, ~a.z);

    [MethodImpl(256 | 512)]
    public static long3_mt8 operator|(long3_mt8 a, long3_mt8 b) => new(a.x | b.x, a.y | b.y, a.z | b.z);

    [MethodImpl(256 | 512)]
    public static long3_mt8 operator&(long3_mt8 a, long3_mt8 b) => new(a.x & b.x, a.y & b.y, a.z & b.z);

    [MethodImpl(256 | 512)]
    public static long3_mt8 operator^(long3_mt8 a, long3_mt8 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out long_mt8 x, out long_mt8 y, out long_mt8 z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // Deconstruct

    #region Index

    public long_mt8 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"long3_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // long3_mt8
#region long3_mt16

[CpuOnly]
public partial struct long3_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => long_mt16.LineCount;
    }

    #endregion

    #region Fields

    public long_mt16 x;
    public long_mt16 y;
    public long_mt16 z;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly long3 LaneGet(int index) => new(x[index], y[index], z[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, long3 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public long3_mt16(long_mt16 x, long_mt16 y, long_mt16 z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public long3_mt16(long value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public long3_mt16(long_mt16 value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public long3_mt16(long3 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator long3_mt16(long value) => new long_mt16(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long3_mt16(long_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long3_mt16(long3 value) => new(value);

    [MethodImpl(256 | 512)]
    public static long3_mt16 operator~(long3_mt16 a) => new(~a.x, ~a.y, ~a.z);

    [MethodImpl(256 | 512)]
    public static long3_mt16 operator|(long3_mt16 a, long3_mt16 b) => new(a.x | b.x, a.y | b.y, a.z | b.z);

    [MethodImpl(256 | 512)]
    public static long3_mt16 operator&(long3_mt16 a, long3_mt16 b) => new(a.x & b.x, a.y & b.y, a.z & b.z);

    [MethodImpl(256 | 512)]
    public static long3_mt16 operator^(long3_mt16 a, long3_mt16 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out long_mt16 x, out long_mt16 y, out long_mt16 z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // Deconstruct

    #region Index

    public long_mt16 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"long3_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // long3_mt16
#region long3_mt32

[CpuOnly]
public partial struct long3_mt32
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => long_mt32.LineCount;
    }

    #endregion

    #region Fields

    public long_mt32 x;
    public long_mt32 y;
    public long_mt32 z;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly long3 LaneGet(int index) => new(x[index], y[index], z[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, long3 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public long3_mt32(long_mt32 x, long_mt32 y, long_mt32 z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public long3_mt32(long value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public long3_mt32(long_mt32 value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public long3_mt32(long3 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator long3_mt32(long value) => new long_mt32(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long3_mt32(long_mt32 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long3_mt32(long3 value) => new(value);

    [MethodImpl(256 | 512)]
    public static long3_mt32 operator~(long3_mt32 a) => new(~a.x, ~a.y, ~a.z);

    [MethodImpl(256 | 512)]
    public static long3_mt32 operator|(long3_mt32 a, long3_mt32 b) => new(a.x | b.x, a.y | b.y, a.z | b.z);

    [MethodImpl(256 | 512)]
    public static long3_mt32 operator&(long3_mt32 a, long3_mt32 b) => new(a.x & b.x, a.y & b.y, a.z & b.z);

    [MethodImpl(256 | 512)]
    public static long3_mt32 operator^(long3_mt32 a, long3_mt32 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out long_mt32 x, out long_mt32 y, out long_mt32 z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // Deconstruct

    #region Index

    public long_mt32 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"long3_mt32 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)}, t16 = {this.LaneGet(16)}, t17 = {this.LaneGet(17)}, t18 = {this.LaneGet(18)}, t19 = {this.LaneGet(19)}, t20 = {this.LaneGet(20)}, t21 = {this.LaneGet(21)}, t22 = {this.LaneGet(22)}, t23 = {this.LaneGet(23)}, t24 = {this.LaneGet(24)}, t25 = {this.LaneGet(25)}, t26 = {this.LaneGet(26)}, t27 = {this.LaneGet(27)}, t28 = {this.LaneGet(28)}, t29 = {this.LaneGet(29)}, t30 = {this.LaneGet(30)}, t31 = {this.LaneGet(31)} }}";
    
    #endregion // ToString
}

#endregion // long3_mt32
#region long4_mt4

[CpuOnly]
public partial struct long4_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => long_mt4.LineCount;
    }

    #endregion

    #region Fields

    public long_mt4 x;
    public long_mt4 y;
    public long_mt4 z;
    public long_mt4 w;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly long4 LaneGet(int index) => new(x[index], y[index], z[index], w[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, long4 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
        w[index] = value.w;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public long4_mt4(long_mt4 x, long_mt4 y, long_mt4 z, long_mt4 w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public long4_mt4(long value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public long4_mt4(long_mt4 value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public long4_mt4(long4 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
        w = new(value.w);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator long4_mt4(long value) => new long_mt4(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long4_mt4(long_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long4_mt4(long4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static long4_mt4 operator~(long4_mt4 a) => new(~a.x, ~a.y, ~a.z, ~a.w);

    [MethodImpl(256 | 512)]
    public static long4_mt4 operator|(long4_mt4 a, long4_mt4 b) => new(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);

    [MethodImpl(256 | 512)]
    public static long4_mt4 operator&(long4_mt4 a, long4_mt4 b) => new(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);

    [MethodImpl(256 | 512)]
    public static long4_mt4 operator^(long4_mt4 a, long4_mt4 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out long_mt4 x, out long_mt4 y, out long_mt4 z, out long_mt4 w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // Deconstruct

    #region Index

    public long_mt4 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"long4_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // long4_mt4
#region long4_mt8

[CpuOnly]
public partial struct long4_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => long_mt8.LineCount;
    }

    #endregion

    #region Fields

    public long_mt8 x;
    public long_mt8 y;
    public long_mt8 z;
    public long_mt8 w;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly long4 LaneGet(int index) => new(x[index], y[index], z[index], w[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, long4 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
        w[index] = value.w;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public long4_mt8(long_mt8 x, long_mt8 y, long_mt8 z, long_mt8 w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public long4_mt8(long value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public long4_mt8(long_mt8 value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public long4_mt8(long4 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
        w = new(value.w);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator long4_mt8(long value) => new long_mt8(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long4_mt8(long_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long4_mt8(long4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static long4_mt8 operator~(long4_mt8 a) => new(~a.x, ~a.y, ~a.z, ~a.w);

    [MethodImpl(256 | 512)]
    public static long4_mt8 operator|(long4_mt8 a, long4_mt8 b) => new(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);

    [MethodImpl(256 | 512)]
    public static long4_mt8 operator&(long4_mt8 a, long4_mt8 b) => new(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);

    [MethodImpl(256 | 512)]
    public static long4_mt8 operator^(long4_mt8 a, long4_mt8 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out long_mt8 x, out long_mt8 y, out long_mt8 z, out long_mt8 w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // Deconstruct

    #region Index

    public long_mt8 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"long4_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // long4_mt8
#region long4_mt16

[CpuOnly]
public partial struct long4_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => long_mt16.LineCount;
    }

    #endregion

    #region Fields

    public long_mt16 x;
    public long_mt16 y;
    public long_mt16 z;
    public long_mt16 w;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly long4 LaneGet(int index) => new(x[index], y[index], z[index], w[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, long4 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
        w[index] = value.w;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public long4_mt16(long_mt16 x, long_mt16 y, long_mt16 z, long_mt16 w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public long4_mt16(long value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public long4_mt16(long_mt16 value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public long4_mt16(long4 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
        w = new(value.w);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator long4_mt16(long value) => new long_mt16(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long4_mt16(long_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long4_mt16(long4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static long4_mt16 operator~(long4_mt16 a) => new(~a.x, ~a.y, ~a.z, ~a.w);

    [MethodImpl(256 | 512)]
    public static long4_mt16 operator|(long4_mt16 a, long4_mt16 b) => new(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);

    [MethodImpl(256 | 512)]
    public static long4_mt16 operator&(long4_mt16 a, long4_mt16 b) => new(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);

    [MethodImpl(256 | 512)]
    public static long4_mt16 operator^(long4_mt16 a, long4_mt16 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out long_mt16 x, out long_mt16 y, out long_mt16 z, out long_mt16 w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // Deconstruct

    #region Index

    public long_mt16 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"long4_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // long4_mt16
#region long4_mt32

[CpuOnly]
public partial struct long4_mt32
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => long_mt32.LineCount;
    }

    #endregion

    #region Fields

    public long_mt32 x;
    public long_mt32 y;
    public long_mt32 z;
    public long_mt32 w;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly long4 LaneGet(int index) => new(x[index], y[index], z[index], w[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, long4 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
        w[index] = value.w;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public long4_mt32(long_mt32 x, long_mt32 y, long_mt32 z, long_mt32 w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public long4_mt32(long value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public long4_mt32(long_mt32 value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public long4_mt32(long4 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
        w = new(value.w);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator long4_mt32(long value) => new long_mt32(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long4_mt32(long_mt32 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long4_mt32(long4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static long4_mt32 operator~(long4_mt32 a) => new(~a.x, ~a.y, ~a.z, ~a.w);

    [MethodImpl(256 | 512)]
    public static long4_mt32 operator|(long4_mt32 a, long4_mt32 b) => new(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);

    [MethodImpl(256 | 512)]
    public static long4_mt32 operator&(long4_mt32 a, long4_mt32 b) => new(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);

    [MethodImpl(256 | 512)]
    public static long4_mt32 operator^(long4_mt32 a, long4_mt32 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out long_mt32 x, out long_mt32 y, out long_mt32 z, out long_mt32 w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // Deconstruct

    #region Index

    public long_mt32 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"long4_mt32 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)}, t16 = {this.LaneGet(16)}, t17 = {this.LaneGet(17)}, t18 = {this.LaneGet(18)}, t19 = {this.LaneGet(19)}, t20 = {this.LaneGet(20)}, t21 = {this.LaneGet(21)}, t22 = {this.LaneGet(22)}, t23 = {this.LaneGet(23)}, t24 = {this.LaneGet(24)}, t25 = {this.LaneGet(25)}, t26 = {this.LaneGet(26)}, t27 = {this.LaneGet(27)}, t28 = {this.LaneGet(28)}, t29 = {this.LaneGet(29)}, t30 = {this.LaneGet(30)}, t31 = {this.LaneGet(31)} }}";
    
    #endregion // ToString
}

#endregion // long4_mt32
#region ulong2_mt4

[CpuOnly]
public partial struct ulong2_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => ulong_mt4.LineCount;
    }

    #endregion

    #region Fields

    public ulong_mt4 x;
    public ulong_mt4 y;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly ulong2 LaneGet(int index) => new(x[index], y[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, ulong2 value)
    {
        x[index] = value.x;
        y[index] = value.y;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public ulong2_mt4(ulong_mt4 x, ulong_mt4 y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public ulong2_mt4(ulong value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public ulong2_mt4(ulong_mt4 value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public ulong2_mt4(ulong2 value)
    {
        x = new(value.x);
        y = new(value.y);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2_mt4(ulong value) => new ulong_mt4(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2_mt4(ulong_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2_mt4(ulong2 value) => new(value);

    [MethodImpl(256 | 512)]
    public static ulong2_mt4 operator~(ulong2_mt4 a) => new(~a.x, ~a.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt4 operator|(ulong2_mt4 a, ulong2_mt4 b) => new(a.x | b.x, a.y | b.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt4 operator&(ulong2_mt4 a, ulong2_mt4 b) => new(a.x & b.x, a.y & b.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt4 operator^(ulong2_mt4 a, ulong2_mt4 b) => new(a.x ^ b.x, a.y ^ b.y);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out ulong_mt4 x, out ulong_mt4 y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // Deconstruct

    #region Index

    public ulong_mt4 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"ulong2_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // ulong2_mt4
#region ulong2_mt8

[CpuOnly]
public partial struct ulong2_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => ulong_mt8.LineCount;
    }

    #endregion

    #region Fields

    public ulong_mt8 x;
    public ulong_mt8 y;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly ulong2 LaneGet(int index) => new(x[index], y[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, ulong2 value)
    {
        x[index] = value.x;
        y[index] = value.y;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public ulong2_mt8(ulong_mt8 x, ulong_mt8 y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public ulong2_mt8(ulong value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public ulong2_mt8(ulong_mt8 value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public ulong2_mt8(ulong2 value)
    {
        x = new(value.x);
        y = new(value.y);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2_mt8(ulong value) => new ulong_mt8(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2_mt8(ulong_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2_mt8(ulong2 value) => new(value);

    [MethodImpl(256 | 512)]
    public static ulong2_mt8 operator~(ulong2_mt8 a) => new(~a.x, ~a.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt8 operator|(ulong2_mt8 a, ulong2_mt8 b) => new(a.x | b.x, a.y | b.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt8 operator&(ulong2_mt8 a, ulong2_mt8 b) => new(a.x & b.x, a.y & b.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt8 operator^(ulong2_mt8 a, ulong2_mt8 b) => new(a.x ^ b.x, a.y ^ b.y);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out ulong_mt8 x, out ulong_mt8 y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // Deconstruct

    #region Index

    public ulong_mt8 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"ulong2_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // ulong2_mt8
#region ulong2_mt16

[CpuOnly]
public partial struct ulong2_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => ulong_mt16.LineCount;
    }

    #endregion

    #region Fields

    public ulong_mt16 x;
    public ulong_mt16 y;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly ulong2 LaneGet(int index) => new(x[index], y[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, ulong2 value)
    {
        x[index] = value.x;
        y[index] = value.y;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public ulong2_mt16(ulong_mt16 x, ulong_mt16 y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public ulong2_mt16(ulong value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public ulong2_mt16(ulong_mt16 value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public ulong2_mt16(ulong2 value)
    {
        x = new(value.x);
        y = new(value.y);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2_mt16(ulong value) => new ulong_mt16(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2_mt16(ulong_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2_mt16(ulong2 value) => new(value);

    [MethodImpl(256 | 512)]
    public static ulong2_mt16 operator~(ulong2_mt16 a) => new(~a.x, ~a.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt16 operator|(ulong2_mt16 a, ulong2_mt16 b) => new(a.x | b.x, a.y | b.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt16 operator&(ulong2_mt16 a, ulong2_mt16 b) => new(a.x & b.x, a.y & b.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt16 operator^(ulong2_mt16 a, ulong2_mt16 b) => new(a.x ^ b.x, a.y ^ b.y);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out ulong_mt16 x, out ulong_mt16 y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // Deconstruct

    #region Index

    public ulong_mt16 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"ulong2_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // ulong2_mt16
#region ulong2_mt32

[CpuOnly]
public partial struct ulong2_mt32
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => ulong_mt32.LineCount;
    }

    #endregion

    #region Fields

    public ulong_mt32 x;
    public ulong_mt32 y;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly ulong2 LaneGet(int index) => new(x[index], y[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, ulong2 value)
    {
        x[index] = value.x;
        y[index] = value.y;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public ulong2_mt32(ulong_mt32 x, ulong_mt32 y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public ulong2_mt32(ulong value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public ulong2_mt32(ulong_mt32 value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public ulong2_mt32(ulong2 value)
    {
        x = new(value.x);
        y = new(value.y);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2_mt32(ulong value) => new ulong_mt32(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2_mt32(ulong_mt32 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2_mt32(ulong2 value) => new(value);

    [MethodImpl(256 | 512)]
    public static ulong2_mt32 operator~(ulong2_mt32 a) => new(~a.x, ~a.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt32 operator|(ulong2_mt32 a, ulong2_mt32 b) => new(a.x | b.x, a.y | b.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt32 operator&(ulong2_mt32 a, ulong2_mt32 b) => new(a.x & b.x, a.y & b.y);

    [MethodImpl(256 | 512)]
    public static ulong2_mt32 operator^(ulong2_mt32 a, ulong2_mt32 b) => new(a.x ^ b.x, a.y ^ b.y);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out ulong_mt32 x, out ulong_mt32 y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // Deconstruct

    #region Index

    public ulong_mt32 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"ulong2_mt32 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)}, t16 = {this.LaneGet(16)}, t17 = {this.LaneGet(17)}, t18 = {this.LaneGet(18)}, t19 = {this.LaneGet(19)}, t20 = {this.LaneGet(20)}, t21 = {this.LaneGet(21)}, t22 = {this.LaneGet(22)}, t23 = {this.LaneGet(23)}, t24 = {this.LaneGet(24)}, t25 = {this.LaneGet(25)}, t26 = {this.LaneGet(26)}, t27 = {this.LaneGet(27)}, t28 = {this.LaneGet(28)}, t29 = {this.LaneGet(29)}, t30 = {this.LaneGet(30)}, t31 = {this.LaneGet(31)} }}";
    
    #endregion // ToString
}

#endregion // ulong2_mt32
#region ulong3_mt4

[CpuOnly]
public partial struct ulong3_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => ulong_mt4.LineCount;
    }

    #endregion

    #region Fields

    public ulong_mt4 x;
    public ulong_mt4 y;
    public ulong_mt4 z;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly ulong3 LaneGet(int index) => new(x[index], y[index], z[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, ulong3 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public ulong3_mt4(ulong_mt4 x, ulong_mt4 y, ulong_mt4 z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public ulong3_mt4(ulong value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public ulong3_mt4(ulong_mt4 value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public ulong3_mt4(ulong3 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3_mt4(ulong value) => new ulong_mt4(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3_mt4(ulong_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3_mt4(ulong3 value) => new(value);

    [MethodImpl(256 | 512)]
    public static ulong3_mt4 operator~(ulong3_mt4 a) => new(~a.x, ~a.y, ~a.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt4 operator|(ulong3_mt4 a, ulong3_mt4 b) => new(a.x | b.x, a.y | b.y, a.z | b.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt4 operator&(ulong3_mt4 a, ulong3_mt4 b) => new(a.x & b.x, a.y & b.y, a.z & b.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt4 operator^(ulong3_mt4 a, ulong3_mt4 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out ulong_mt4 x, out ulong_mt4 y, out ulong_mt4 z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // Deconstruct

    #region Index

    public ulong_mt4 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"ulong3_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // ulong3_mt4
#region ulong3_mt8

[CpuOnly]
public partial struct ulong3_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => ulong_mt8.LineCount;
    }

    #endregion

    #region Fields

    public ulong_mt8 x;
    public ulong_mt8 y;
    public ulong_mt8 z;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly ulong3 LaneGet(int index) => new(x[index], y[index], z[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, ulong3 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public ulong3_mt8(ulong_mt8 x, ulong_mt8 y, ulong_mt8 z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public ulong3_mt8(ulong value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public ulong3_mt8(ulong_mt8 value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public ulong3_mt8(ulong3 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3_mt8(ulong value) => new ulong_mt8(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3_mt8(ulong_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3_mt8(ulong3 value) => new(value);

    [MethodImpl(256 | 512)]
    public static ulong3_mt8 operator~(ulong3_mt8 a) => new(~a.x, ~a.y, ~a.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt8 operator|(ulong3_mt8 a, ulong3_mt8 b) => new(a.x | b.x, a.y | b.y, a.z | b.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt8 operator&(ulong3_mt8 a, ulong3_mt8 b) => new(a.x & b.x, a.y & b.y, a.z & b.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt8 operator^(ulong3_mt8 a, ulong3_mt8 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out ulong_mt8 x, out ulong_mt8 y, out ulong_mt8 z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // Deconstruct

    #region Index

    public ulong_mt8 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"ulong3_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // ulong3_mt8
#region ulong3_mt16

[CpuOnly]
public partial struct ulong3_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => ulong_mt16.LineCount;
    }

    #endregion

    #region Fields

    public ulong_mt16 x;
    public ulong_mt16 y;
    public ulong_mt16 z;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly ulong3 LaneGet(int index) => new(x[index], y[index], z[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, ulong3 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public ulong3_mt16(ulong_mt16 x, ulong_mt16 y, ulong_mt16 z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public ulong3_mt16(ulong value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public ulong3_mt16(ulong_mt16 value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public ulong3_mt16(ulong3 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3_mt16(ulong value) => new ulong_mt16(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3_mt16(ulong_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3_mt16(ulong3 value) => new(value);

    [MethodImpl(256 | 512)]
    public static ulong3_mt16 operator~(ulong3_mt16 a) => new(~a.x, ~a.y, ~a.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt16 operator|(ulong3_mt16 a, ulong3_mt16 b) => new(a.x | b.x, a.y | b.y, a.z | b.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt16 operator&(ulong3_mt16 a, ulong3_mt16 b) => new(a.x & b.x, a.y & b.y, a.z & b.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt16 operator^(ulong3_mt16 a, ulong3_mt16 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out ulong_mt16 x, out ulong_mt16 y, out ulong_mt16 z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // Deconstruct

    #region Index

    public ulong_mt16 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"ulong3_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // ulong3_mt16
#region ulong3_mt32

[CpuOnly]
public partial struct ulong3_mt32
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => ulong_mt32.LineCount;
    }

    #endregion

    #region Fields

    public ulong_mt32 x;
    public ulong_mt32 y;
    public ulong_mt32 z;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly ulong3 LaneGet(int index) => new(x[index], y[index], z[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, ulong3 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public ulong3_mt32(ulong_mt32 x, ulong_mt32 y, ulong_mt32 z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public ulong3_mt32(ulong value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public ulong3_mt32(ulong_mt32 value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public ulong3_mt32(ulong3 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3_mt32(ulong value) => new ulong_mt32(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3_mt32(ulong_mt32 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3_mt32(ulong3 value) => new(value);

    [MethodImpl(256 | 512)]
    public static ulong3_mt32 operator~(ulong3_mt32 a) => new(~a.x, ~a.y, ~a.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt32 operator|(ulong3_mt32 a, ulong3_mt32 b) => new(a.x | b.x, a.y | b.y, a.z | b.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt32 operator&(ulong3_mt32 a, ulong3_mt32 b) => new(a.x & b.x, a.y & b.y, a.z & b.z);

    [MethodImpl(256 | 512)]
    public static ulong3_mt32 operator^(ulong3_mt32 a, ulong3_mt32 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out ulong_mt32 x, out ulong_mt32 y, out ulong_mt32 z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // Deconstruct

    #region Index

    public ulong_mt32 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"ulong3_mt32 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)}, t16 = {this.LaneGet(16)}, t17 = {this.LaneGet(17)}, t18 = {this.LaneGet(18)}, t19 = {this.LaneGet(19)}, t20 = {this.LaneGet(20)}, t21 = {this.LaneGet(21)}, t22 = {this.LaneGet(22)}, t23 = {this.LaneGet(23)}, t24 = {this.LaneGet(24)}, t25 = {this.LaneGet(25)}, t26 = {this.LaneGet(26)}, t27 = {this.LaneGet(27)}, t28 = {this.LaneGet(28)}, t29 = {this.LaneGet(29)}, t30 = {this.LaneGet(30)}, t31 = {this.LaneGet(31)} }}";
    
    #endregion // ToString
}

#endregion // ulong3_mt32
#region ulong4_mt4

[CpuOnly]
public partial struct ulong4_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => ulong_mt4.LineCount;
    }

    #endregion

    #region Fields

    public ulong_mt4 x;
    public ulong_mt4 y;
    public ulong_mt4 z;
    public ulong_mt4 w;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly ulong4 LaneGet(int index) => new(x[index], y[index], z[index], w[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, ulong4 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
        w[index] = value.w;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public ulong4_mt4(ulong_mt4 x, ulong_mt4 y, ulong_mt4 z, ulong_mt4 w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public ulong4_mt4(ulong value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public ulong4_mt4(ulong_mt4 value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public ulong4_mt4(ulong4 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
        w = new(value.w);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4_mt4(ulong value) => new ulong_mt4(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4_mt4(ulong_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4_mt4(ulong4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static ulong4_mt4 operator~(ulong4_mt4 a) => new(~a.x, ~a.y, ~a.z, ~a.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt4 operator|(ulong4_mt4 a, ulong4_mt4 b) => new(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt4 operator&(ulong4_mt4 a, ulong4_mt4 b) => new(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt4 operator^(ulong4_mt4 a, ulong4_mt4 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out ulong_mt4 x, out ulong_mt4 y, out ulong_mt4 z, out ulong_mt4 w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // Deconstruct

    #region Index

    public ulong_mt4 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"ulong4_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // ulong4_mt4
#region ulong4_mt8

[CpuOnly]
public partial struct ulong4_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => ulong_mt8.LineCount;
    }

    #endregion

    #region Fields

    public ulong_mt8 x;
    public ulong_mt8 y;
    public ulong_mt8 z;
    public ulong_mt8 w;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly ulong4 LaneGet(int index) => new(x[index], y[index], z[index], w[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, ulong4 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
        w[index] = value.w;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public ulong4_mt8(ulong_mt8 x, ulong_mt8 y, ulong_mt8 z, ulong_mt8 w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public ulong4_mt8(ulong value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public ulong4_mt8(ulong_mt8 value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public ulong4_mt8(ulong4 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
        w = new(value.w);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4_mt8(ulong value) => new ulong_mt8(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4_mt8(ulong_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4_mt8(ulong4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static ulong4_mt8 operator~(ulong4_mt8 a) => new(~a.x, ~a.y, ~a.z, ~a.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt8 operator|(ulong4_mt8 a, ulong4_mt8 b) => new(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt8 operator&(ulong4_mt8 a, ulong4_mt8 b) => new(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt8 operator^(ulong4_mt8 a, ulong4_mt8 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out ulong_mt8 x, out ulong_mt8 y, out ulong_mt8 z, out ulong_mt8 w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // Deconstruct

    #region Index

    public ulong_mt8 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"ulong4_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // ulong4_mt8
#region ulong4_mt16

[CpuOnly]
public partial struct ulong4_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => ulong_mt16.LineCount;
    }

    #endregion

    #region Fields

    public ulong_mt16 x;
    public ulong_mt16 y;
    public ulong_mt16 z;
    public ulong_mt16 w;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly ulong4 LaneGet(int index) => new(x[index], y[index], z[index], w[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, ulong4 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
        w[index] = value.w;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public ulong4_mt16(ulong_mt16 x, ulong_mt16 y, ulong_mt16 z, ulong_mt16 w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public ulong4_mt16(ulong value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public ulong4_mt16(ulong_mt16 value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public ulong4_mt16(ulong4 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
        w = new(value.w);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4_mt16(ulong value) => new ulong_mt16(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4_mt16(ulong_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4_mt16(ulong4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static ulong4_mt16 operator~(ulong4_mt16 a) => new(~a.x, ~a.y, ~a.z, ~a.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt16 operator|(ulong4_mt16 a, ulong4_mt16 b) => new(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt16 operator&(ulong4_mt16 a, ulong4_mt16 b) => new(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt16 operator^(ulong4_mt16 a, ulong4_mt16 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out ulong_mt16 x, out ulong_mt16 y, out ulong_mt16 z, out ulong_mt16 w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // Deconstruct

    #region Index

    public ulong_mt16 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"ulong4_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // ulong4_mt16
#region ulong4_mt32

[CpuOnly]
public partial struct ulong4_mt32
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => ulong_mt32.LineCount;
    }

    #endregion

    #region Fields

    public ulong_mt32 x;
    public ulong_mt32 y;
    public ulong_mt32 z;
    public ulong_mt32 w;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly ulong4 LaneGet(int index) => new(x[index], y[index], z[index], w[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, ulong4 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
        w[index] = value.w;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public ulong4_mt32(ulong_mt32 x, ulong_mt32 y, ulong_mt32 z, ulong_mt32 w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public ulong4_mt32(ulong value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public ulong4_mt32(ulong_mt32 value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public ulong4_mt32(ulong4 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
        w = new(value.w);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4_mt32(ulong value) => new ulong_mt32(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4_mt32(ulong_mt32 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4_mt32(ulong4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static ulong4_mt32 operator~(ulong4_mt32 a) => new(~a.x, ~a.y, ~a.z, ~a.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt32 operator|(ulong4_mt32 a, ulong4_mt32 b) => new(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt32 operator&(ulong4_mt32 a, ulong4_mt32 b) => new(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);

    [MethodImpl(256 | 512)]
    public static ulong4_mt32 operator^(ulong4_mt32 a, ulong4_mt32 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out ulong_mt32 x, out ulong_mt32 y, out ulong_mt32 z, out ulong_mt32 w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // Deconstruct

    #region Index

    public ulong_mt32 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"ulong4_mt32 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)}, t16 = {this.LaneGet(16)}, t17 = {this.LaneGet(17)}, t18 = {this.LaneGet(18)}, t19 = {this.LaneGet(19)}, t20 = {this.LaneGet(20)}, t21 = {this.LaneGet(21)}, t22 = {this.LaneGet(22)}, t23 = {this.LaneGet(23)}, t24 = {this.LaneGet(24)}, t25 = {this.LaneGet(25)}, t26 = {this.LaneGet(26)}, t27 = {this.LaneGet(27)}, t28 = {this.LaneGet(28)}, t29 = {this.LaneGet(29)}, t30 = {this.LaneGet(30)}, t31 = {this.LaneGet(31)} }}";
    
    #endregion // ToString
}

#endregion // ulong4_mt32
#region b32v2_mt4

[CpuOnly]
public partial struct b32v2_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b32_mt4.LineCount;
    }

    #endregion

    #region Fields

    public b32_mt4 x;
    public b32_mt4 y;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly b32v2 LaneGet(int index) => new(x[index], y[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b32v2 value)
    {
        x[index] = value.x;
        y[index] = value.y;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public b32v2_mt4(b32_mt4 x, b32_mt4 y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public b32v2_mt4(b32 value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b32v2_mt4(b32_mt4 value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b32v2_mt4(b32v2 value)
    {
        x = new(value.x);
        y = new(value.y);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator b32v2_mt4(b32 value) => new b32_mt4(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v2_mt4(bool value) => (b32)(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v2_mt4(b32_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v2_mt4(b32v2 value) => new(value);

    [MethodImpl(256 | 512)]
    public static b32v2_mt4 operator~(b32v2_mt4 a) => new(~a.x, ~a.y);

    [MethodImpl(256 | 512)]
    public static b32v2_mt4 operator|(b32v2_mt4 a, b32v2_mt4 b) => new(a.x | b.x, a.y | b.y);

    [MethodImpl(256 | 512)]
    public static b32v2_mt4 operator&(b32v2_mt4 a, b32v2_mt4 b) => new(a.x & b.x, a.y & b.y);

    [MethodImpl(256 | 512)]
    public static b32v2_mt4 operator^(b32v2_mt4 a, b32v2_mt4 b) => new(a.x ^ b.x, a.y ^ b.y);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b32_mt4 x, out b32_mt4 y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // Deconstruct

    #region Index

    public b32_mt4 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"b32v2_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // b32v2_mt4
#region b32v2_mt8

[CpuOnly]
public partial struct b32v2_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b32_mt8.LineCount;
    }

    #endregion

    #region Fields

    public b32_mt8 x;
    public b32_mt8 y;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly b32v2 LaneGet(int index) => new(x[index], y[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b32v2 value)
    {
        x[index] = value.x;
        y[index] = value.y;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public b32v2_mt8(b32_mt8 x, b32_mt8 y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public b32v2_mt8(b32 value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b32v2_mt8(b32_mt8 value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b32v2_mt8(b32v2 value)
    {
        x = new(value.x);
        y = new(value.y);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator b32v2_mt8(b32 value) => new b32_mt8(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v2_mt8(bool value) => (b32)(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v2_mt8(b32_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v2_mt8(b32v2 value) => new(value);

    [MethodImpl(256 | 512)]
    public static b32v2_mt8 operator~(b32v2_mt8 a) => new(~a.x, ~a.y);

    [MethodImpl(256 | 512)]
    public static b32v2_mt8 operator|(b32v2_mt8 a, b32v2_mt8 b) => new(a.x | b.x, a.y | b.y);

    [MethodImpl(256 | 512)]
    public static b32v2_mt8 operator&(b32v2_mt8 a, b32v2_mt8 b) => new(a.x & b.x, a.y & b.y);

    [MethodImpl(256 | 512)]
    public static b32v2_mt8 operator^(b32v2_mt8 a, b32v2_mt8 b) => new(a.x ^ b.x, a.y ^ b.y);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b32_mt8 x, out b32_mt8 y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // Deconstruct

    #region Index

    public b32_mt8 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"b32v2_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // b32v2_mt8
#region b32v2_mt16

[CpuOnly]
public partial struct b32v2_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b32_mt16.LineCount;
    }

    #endregion

    #region Fields

    public b32_mt16 x;
    public b32_mt16 y;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly b32v2 LaneGet(int index) => new(x[index], y[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b32v2 value)
    {
        x[index] = value.x;
        y[index] = value.y;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public b32v2_mt16(b32_mt16 x, b32_mt16 y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public b32v2_mt16(b32 value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b32v2_mt16(b32_mt16 value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b32v2_mt16(b32v2 value)
    {
        x = new(value.x);
        y = new(value.y);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator b32v2_mt16(b32 value) => new b32_mt16(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v2_mt16(bool value) => (b32)(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v2_mt16(b32_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v2_mt16(b32v2 value) => new(value);

    [MethodImpl(256 | 512)]
    public static b32v2_mt16 operator~(b32v2_mt16 a) => new(~a.x, ~a.y);

    [MethodImpl(256 | 512)]
    public static b32v2_mt16 operator|(b32v2_mt16 a, b32v2_mt16 b) => new(a.x | b.x, a.y | b.y);

    [MethodImpl(256 | 512)]
    public static b32v2_mt16 operator&(b32v2_mt16 a, b32v2_mt16 b) => new(a.x & b.x, a.y & b.y);

    [MethodImpl(256 | 512)]
    public static b32v2_mt16 operator^(b32v2_mt16 a, b32v2_mt16 b) => new(a.x ^ b.x, a.y ^ b.y);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b32_mt16 x, out b32_mt16 y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // Deconstruct

    #region Index

    public b32_mt16 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"b32v2_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // b32v2_mt16
#region b32v2_mt32

[CpuOnly]
public partial struct b32v2_mt32
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b32_mt32.LineCount;
    }

    #endregion

    #region Fields

    public b32_mt32 x;
    public b32_mt32 y;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly b32v2 LaneGet(int index) => new(x[index], y[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b32v2 value)
    {
        x[index] = value.x;
        y[index] = value.y;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public b32v2_mt32(b32_mt32 x, b32_mt32 y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public b32v2_mt32(b32 value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b32v2_mt32(b32_mt32 value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b32v2_mt32(b32v2 value)
    {
        x = new(value.x);
        y = new(value.y);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator b32v2_mt32(b32 value) => new b32_mt32(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v2_mt32(bool value) => (b32)(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v2_mt32(b32_mt32 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v2_mt32(b32v2 value) => new(value);

    [MethodImpl(256 | 512)]
    public static b32v2_mt32 operator~(b32v2_mt32 a) => new(~a.x, ~a.y);

    [MethodImpl(256 | 512)]
    public static b32v2_mt32 operator|(b32v2_mt32 a, b32v2_mt32 b) => new(a.x | b.x, a.y | b.y);

    [MethodImpl(256 | 512)]
    public static b32v2_mt32 operator&(b32v2_mt32 a, b32v2_mt32 b) => new(a.x & b.x, a.y & b.y);

    [MethodImpl(256 | 512)]
    public static b32v2_mt32 operator^(b32v2_mt32 a, b32v2_mt32 b) => new(a.x ^ b.x, a.y ^ b.y);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b32_mt32 x, out b32_mt32 y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // Deconstruct

    #region Index

    public b32_mt32 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"b32v2_mt32 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)}, t16 = {this.LaneGet(16)}, t17 = {this.LaneGet(17)}, t18 = {this.LaneGet(18)}, t19 = {this.LaneGet(19)}, t20 = {this.LaneGet(20)}, t21 = {this.LaneGet(21)}, t22 = {this.LaneGet(22)}, t23 = {this.LaneGet(23)}, t24 = {this.LaneGet(24)}, t25 = {this.LaneGet(25)}, t26 = {this.LaneGet(26)}, t27 = {this.LaneGet(27)}, t28 = {this.LaneGet(28)}, t29 = {this.LaneGet(29)}, t30 = {this.LaneGet(30)}, t31 = {this.LaneGet(31)} }}";
    
    #endregion // ToString
}

#endregion // b32v2_mt32
#region b32v3_mt4

[CpuOnly]
public partial struct b32v3_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b32_mt4.LineCount;
    }

    #endregion

    #region Fields

    public b32_mt4 x;
    public b32_mt4 y;
    public b32_mt4 z;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly b32v3 LaneGet(int index) => new(x[index], y[index], z[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b32v3 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public b32v3_mt4(b32_mt4 x, b32_mt4 y, b32_mt4 z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public b32v3_mt4(b32 value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b32v3_mt4(b32_mt4 value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b32v3_mt4(b32v3 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator b32v3_mt4(b32 value) => new b32_mt4(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v3_mt4(bool value) => (b32)(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v3_mt4(b32_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v3_mt4(b32v3 value) => new(value);

    [MethodImpl(256 | 512)]
    public static b32v3_mt4 operator~(b32v3_mt4 a) => new(~a.x, ~a.y, ~a.z);

    [MethodImpl(256 | 512)]
    public static b32v3_mt4 operator|(b32v3_mt4 a, b32v3_mt4 b) => new(a.x | b.x, a.y | b.y, a.z | b.z);

    [MethodImpl(256 | 512)]
    public static b32v3_mt4 operator&(b32v3_mt4 a, b32v3_mt4 b) => new(a.x & b.x, a.y & b.y, a.z & b.z);

    [MethodImpl(256 | 512)]
    public static b32v3_mt4 operator^(b32v3_mt4 a, b32v3_mt4 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b32_mt4 x, out b32_mt4 y, out b32_mt4 z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // Deconstruct

    #region Index

    public b32_mt4 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"b32v3_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // b32v3_mt4
#region b32v3_mt8

[CpuOnly]
public partial struct b32v3_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b32_mt8.LineCount;
    }

    #endregion

    #region Fields

    public b32_mt8 x;
    public b32_mt8 y;
    public b32_mt8 z;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly b32v3 LaneGet(int index) => new(x[index], y[index], z[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b32v3 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public b32v3_mt8(b32_mt8 x, b32_mt8 y, b32_mt8 z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public b32v3_mt8(b32 value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b32v3_mt8(b32_mt8 value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b32v3_mt8(b32v3 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator b32v3_mt8(b32 value) => new b32_mt8(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v3_mt8(bool value) => (b32)(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v3_mt8(b32_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v3_mt8(b32v3 value) => new(value);

    [MethodImpl(256 | 512)]
    public static b32v3_mt8 operator~(b32v3_mt8 a) => new(~a.x, ~a.y, ~a.z);

    [MethodImpl(256 | 512)]
    public static b32v3_mt8 operator|(b32v3_mt8 a, b32v3_mt8 b) => new(a.x | b.x, a.y | b.y, a.z | b.z);

    [MethodImpl(256 | 512)]
    public static b32v3_mt8 operator&(b32v3_mt8 a, b32v3_mt8 b) => new(a.x & b.x, a.y & b.y, a.z & b.z);

    [MethodImpl(256 | 512)]
    public static b32v3_mt8 operator^(b32v3_mt8 a, b32v3_mt8 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b32_mt8 x, out b32_mt8 y, out b32_mt8 z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // Deconstruct

    #region Index

    public b32_mt8 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"b32v3_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // b32v3_mt8
#region b32v3_mt16

[CpuOnly]
public partial struct b32v3_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b32_mt16.LineCount;
    }

    #endregion

    #region Fields

    public b32_mt16 x;
    public b32_mt16 y;
    public b32_mt16 z;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly b32v3 LaneGet(int index) => new(x[index], y[index], z[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b32v3 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public b32v3_mt16(b32_mt16 x, b32_mt16 y, b32_mt16 z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public b32v3_mt16(b32 value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b32v3_mt16(b32_mt16 value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b32v3_mt16(b32v3 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator b32v3_mt16(b32 value) => new b32_mt16(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v3_mt16(bool value) => (b32)(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v3_mt16(b32_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v3_mt16(b32v3 value) => new(value);

    [MethodImpl(256 | 512)]
    public static b32v3_mt16 operator~(b32v3_mt16 a) => new(~a.x, ~a.y, ~a.z);

    [MethodImpl(256 | 512)]
    public static b32v3_mt16 operator|(b32v3_mt16 a, b32v3_mt16 b) => new(a.x | b.x, a.y | b.y, a.z | b.z);

    [MethodImpl(256 | 512)]
    public static b32v3_mt16 operator&(b32v3_mt16 a, b32v3_mt16 b) => new(a.x & b.x, a.y & b.y, a.z & b.z);

    [MethodImpl(256 | 512)]
    public static b32v3_mt16 operator^(b32v3_mt16 a, b32v3_mt16 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b32_mt16 x, out b32_mt16 y, out b32_mt16 z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // Deconstruct

    #region Index

    public b32_mt16 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"b32v3_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // b32v3_mt16
#region b32v3_mt32

[CpuOnly]
public partial struct b32v3_mt32
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b32_mt32.LineCount;
    }

    #endregion

    #region Fields

    public b32_mt32 x;
    public b32_mt32 y;
    public b32_mt32 z;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly b32v3 LaneGet(int index) => new(x[index], y[index], z[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b32v3 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public b32v3_mt32(b32_mt32 x, b32_mt32 y, b32_mt32 z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public b32v3_mt32(b32 value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b32v3_mt32(b32_mt32 value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b32v3_mt32(b32v3 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator b32v3_mt32(b32 value) => new b32_mt32(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v3_mt32(bool value) => (b32)(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v3_mt32(b32_mt32 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v3_mt32(b32v3 value) => new(value);

    [MethodImpl(256 | 512)]
    public static b32v3_mt32 operator~(b32v3_mt32 a) => new(~a.x, ~a.y, ~a.z);

    [MethodImpl(256 | 512)]
    public static b32v3_mt32 operator|(b32v3_mt32 a, b32v3_mt32 b) => new(a.x | b.x, a.y | b.y, a.z | b.z);

    [MethodImpl(256 | 512)]
    public static b32v3_mt32 operator&(b32v3_mt32 a, b32v3_mt32 b) => new(a.x & b.x, a.y & b.y, a.z & b.z);

    [MethodImpl(256 | 512)]
    public static b32v3_mt32 operator^(b32v3_mt32 a, b32v3_mt32 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b32_mt32 x, out b32_mt32 y, out b32_mt32 z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // Deconstruct

    #region Index

    public b32_mt32 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"b32v3_mt32 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)}, t16 = {this.LaneGet(16)}, t17 = {this.LaneGet(17)}, t18 = {this.LaneGet(18)}, t19 = {this.LaneGet(19)}, t20 = {this.LaneGet(20)}, t21 = {this.LaneGet(21)}, t22 = {this.LaneGet(22)}, t23 = {this.LaneGet(23)}, t24 = {this.LaneGet(24)}, t25 = {this.LaneGet(25)}, t26 = {this.LaneGet(26)}, t27 = {this.LaneGet(27)}, t28 = {this.LaneGet(28)}, t29 = {this.LaneGet(29)}, t30 = {this.LaneGet(30)}, t31 = {this.LaneGet(31)} }}";
    
    #endregion // ToString
}

#endregion // b32v3_mt32
#region b32v4_mt4

[CpuOnly]
public partial struct b32v4_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b32_mt4.LineCount;
    }

    #endregion

    #region Fields

    public b32_mt4 x;
    public b32_mt4 y;
    public b32_mt4 z;
    public b32_mt4 w;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly b32v4 LaneGet(int index) => new(x[index], y[index], z[index], w[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b32v4 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
        w[index] = value.w;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public b32v4_mt4(b32_mt4 x, b32_mt4 y, b32_mt4 z, b32_mt4 w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public b32v4_mt4(b32 value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b32v4_mt4(b32_mt4 value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b32v4_mt4(b32v4 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
        w = new(value.w);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator b32v4_mt4(b32 value) => new b32_mt4(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v4_mt4(bool value) => (b32)(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v4_mt4(b32_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v4_mt4(b32v4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static b32v4_mt4 operator~(b32v4_mt4 a) => new(~a.x, ~a.y, ~a.z, ~a.w);

    [MethodImpl(256 | 512)]
    public static b32v4_mt4 operator|(b32v4_mt4 a, b32v4_mt4 b) => new(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);

    [MethodImpl(256 | 512)]
    public static b32v4_mt4 operator&(b32v4_mt4 a, b32v4_mt4 b) => new(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);

    [MethodImpl(256 | 512)]
    public static b32v4_mt4 operator^(b32v4_mt4 a, b32v4_mt4 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b32_mt4 x, out b32_mt4 y, out b32_mt4 z, out b32_mt4 w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // Deconstruct

    #region Index

    public b32_mt4 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"b32v4_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // b32v4_mt4
#region b32v4_mt8

[CpuOnly]
public partial struct b32v4_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b32_mt8.LineCount;
    }

    #endregion

    #region Fields

    public b32_mt8 x;
    public b32_mt8 y;
    public b32_mt8 z;
    public b32_mt8 w;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly b32v4 LaneGet(int index) => new(x[index], y[index], z[index], w[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b32v4 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
        w[index] = value.w;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public b32v4_mt8(b32_mt8 x, b32_mt8 y, b32_mt8 z, b32_mt8 w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public b32v4_mt8(b32 value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b32v4_mt8(b32_mt8 value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b32v4_mt8(b32v4 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
        w = new(value.w);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator b32v4_mt8(b32 value) => new b32_mt8(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v4_mt8(bool value) => (b32)(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v4_mt8(b32_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v4_mt8(b32v4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static b32v4_mt8 operator~(b32v4_mt8 a) => new(~a.x, ~a.y, ~a.z, ~a.w);

    [MethodImpl(256 | 512)]
    public static b32v4_mt8 operator|(b32v4_mt8 a, b32v4_mt8 b) => new(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);

    [MethodImpl(256 | 512)]
    public static b32v4_mt8 operator&(b32v4_mt8 a, b32v4_mt8 b) => new(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);

    [MethodImpl(256 | 512)]
    public static b32v4_mt8 operator^(b32v4_mt8 a, b32v4_mt8 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b32_mt8 x, out b32_mt8 y, out b32_mt8 z, out b32_mt8 w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // Deconstruct

    #region Index

    public b32_mt8 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"b32v4_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // b32v4_mt8
#region b32v4_mt16

[CpuOnly]
public partial struct b32v4_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b32_mt16.LineCount;
    }

    #endregion

    #region Fields

    public b32_mt16 x;
    public b32_mt16 y;
    public b32_mt16 z;
    public b32_mt16 w;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly b32v4 LaneGet(int index) => new(x[index], y[index], z[index], w[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b32v4 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
        w[index] = value.w;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public b32v4_mt16(b32_mt16 x, b32_mt16 y, b32_mt16 z, b32_mt16 w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public b32v4_mt16(b32 value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b32v4_mt16(b32_mt16 value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b32v4_mt16(b32v4 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
        w = new(value.w);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator b32v4_mt16(b32 value) => new b32_mt16(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v4_mt16(bool value) => (b32)(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v4_mt16(b32_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v4_mt16(b32v4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static b32v4_mt16 operator~(b32v4_mt16 a) => new(~a.x, ~a.y, ~a.z, ~a.w);

    [MethodImpl(256 | 512)]
    public static b32v4_mt16 operator|(b32v4_mt16 a, b32v4_mt16 b) => new(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);

    [MethodImpl(256 | 512)]
    public static b32v4_mt16 operator&(b32v4_mt16 a, b32v4_mt16 b) => new(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);

    [MethodImpl(256 | 512)]
    public static b32v4_mt16 operator^(b32v4_mt16 a, b32v4_mt16 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b32_mt16 x, out b32_mt16 y, out b32_mt16 z, out b32_mt16 w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // Deconstruct

    #region Index

    public b32_mt16 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"b32v4_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // b32v4_mt16
#region b32v4_mt32

[CpuOnly]
public partial struct b32v4_mt32
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b32_mt32.LineCount;
    }

    #endregion

    #region Fields

    public b32_mt32 x;
    public b32_mt32 y;
    public b32_mt32 z;
    public b32_mt32 w;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly b32v4 LaneGet(int index) => new(x[index], y[index], z[index], w[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b32v4 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
        w[index] = value.w;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public b32v4_mt32(b32_mt32 x, b32_mt32 y, b32_mt32 z, b32_mt32 w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public b32v4_mt32(b32 value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b32v4_mt32(b32_mt32 value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b32v4_mt32(b32v4 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
        w = new(value.w);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator b32v4_mt32(b32 value) => new b32_mt32(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v4_mt32(bool value) => (b32)(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v4_mt32(b32_mt32 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32v4_mt32(b32v4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static b32v4_mt32 operator~(b32v4_mt32 a) => new(~a.x, ~a.y, ~a.z, ~a.w);

    [MethodImpl(256 | 512)]
    public static b32v4_mt32 operator|(b32v4_mt32 a, b32v4_mt32 b) => new(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);

    [MethodImpl(256 | 512)]
    public static b32v4_mt32 operator&(b32v4_mt32 a, b32v4_mt32 b) => new(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);

    [MethodImpl(256 | 512)]
    public static b32v4_mt32 operator^(b32v4_mt32 a, b32v4_mt32 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b32_mt32 x, out b32_mt32 y, out b32_mt32 z, out b32_mt32 w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // Deconstruct

    #region Index

    public b32_mt32 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"b32v4_mt32 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)}, t16 = {this.LaneGet(16)}, t17 = {this.LaneGet(17)}, t18 = {this.LaneGet(18)}, t19 = {this.LaneGet(19)}, t20 = {this.LaneGet(20)}, t21 = {this.LaneGet(21)}, t22 = {this.LaneGet(22)}, t23 = {this.LaneGet(23)}, t24 = {this.LaneGet(24)}, t25 = {this.LaneGet(25)}, t26 = {this.LaneGet(26)}, t27 = {this.LaneGet(27)}, t28 = {this.LaneGet(28)}, t29 = {this.LaneGet(29)}, t30 = {this.LaneGet(30)}, t31 = {this.LaneGet(31)} }}";
    
    #endregion // ToString
}

#endregion // b32v4_mt32
#region b64v2_mt4

[CpuOnly]
public partial struct b64v2_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b64_mt4.LineCount;
    }

    #endregion

    #region Fields

    public b64_mt4 x;
    public b64_mt4 y;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly b64v2 LaneGet(int index) => new(x[index], y[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b64v2 value)
    {
        x[index] = value.x;
        y[index] = value.y;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public b64v2_mt4(b64_mt4 x, b64_mt4 y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public b64v2_mt4(b64 value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b64v2_mt4(b64_mt4 value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b64v2_mt4(b64v2 value)
    {
        x = new(value.x);
        y = new(value.y);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator b64v2_mt4(b64 value) => new b64_mt4(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64v2_mt4(bool value) => (b64)(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64v2_mt4(b64_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64v2_mt4(b64v2 value) => new(value);

    [MethodImpl(256 | 512)]
    public static b64v2_mt4 operator~(b64v2_mt4 a) => new(~a.x, ~a.y);

    [MethodImpl(256 | 512)]
    public static b64v2_mt4 operator|(b64v2_mt4 a, b64v2_mt4 b) => new(a.x | b.x, a.y | b.y);

    [MethodImpl(256 | 512)]
    public static b64v2_mt4 operator&(b64v2_mt4 a, b64v2_mt4 b) => new(a.x & b.x, a.y & b.y);

    [MethodImpl(256 | 512)]
    public static b64v2_mt4 operator^(b64v2_mt4 a, b64v2_mt4 b) => new(a.x ^ b.x, a.y ^ b.y);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b64_mt4 x, out b64_mt4 y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // Deconstruct

    #region Index

    public b64_mt4 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"b64v2_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // b64v2_mt4
#region b64v2_mt8

[CpuOnly]
public partial struct b64v2_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b64_mt8.LineCount;
    }

    #endregion

    #region Fields

    public b64_mt8 x;
    public b64_mt8 y;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly b64v2 LaneGet(int index) => new(x[index], y[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b64v2 value)
    {
        x[index] = value.x;
        y[index] = value.y;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public b64v2_mt8(b64_mt8 x, b64_mt8 y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public b64v2_mt8(b64 value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b64v2_mt8(b64_mt8 value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b64v2_mt8(b64v2 value)
    {
        x = new(value.x);
        y = new(value.y);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator b64v2_mt8(b64 value) => new b64_mt8(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64v2_mt8(bool value) => (b64)(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64v2_mt8(b64_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64v2_mt8(b64v2 value) => new(value);

    [MethodImpl(256 | 512)]
    public static b64v2_mt8 operator~(b64v2_mt8 a) => new(~a.x, ~a.y);

    [MethodImpl(256 | 512)]
    public static b64v2_mt8 operator|(b64v2_mt8 a, b64v2_mt8 b) => new(a.x | b.x, a.y | b.y);

    [MethodImpl(256 | 512)]
    public static b64v2_mt8 operator&(b64v2_mt8 a, b64v2_mt8 b) => new(a.x & b.x, a.y & b.y);

    [MethodImpl(256 | 512)]
    public static b64v2_mt8 operator^(b64v2_mt8 a, b64v2_mt8 b) => new(a.x ^ b.x, a.y ^ b.y);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b64_mt8 x, out b64_mt8 y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // Deconstruct

    #region Index

    public b64_mt8 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"b64v2_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // b64v2_mt8
#region b64v2_mt16

[CpuOnly]
public partial struct b64v2_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b64_mt16.LineCount;
    }

    #endregion

    #region Fields

    public b64_mt16 x;
    public b64_mt16 y;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly b64v2 LaneGet(int index) => new(x[index], y[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b64v2 value)
    {
        x[index] = value.x;
        y[index] = value.y;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public b64v2_mt16(b64_mt16 x, b64_mt16 y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public b64v2_mt16(b64 value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b64v2_mt16(b64_mt16 value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b64v2_mt16(b64v2 value)
    {
        x = new(value.x);
        y = new(value.y);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator b64v2_mt16(b64 value) => new b64_mt16(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64v2_mt16(bool value) => (b64)(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64v2_mt16(b64_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64v2_mt16(b64v2 value) => new(value);

    [MethodImpl(256 | 512)]
    public static b64v2_mt16 operator~(b64v2_mt16 a) => new(~a.x, ~a.y);

    [MethodImpl(256 | 512)]
    public static b64v2_mt16 operator|(b64v2_mt16 a, b64v2_mt16 b) => new(a.x | b.x, a.y | b.y);

    [MethodImpl(256 | 512)]
    public static b64v2_mt16 operator&(b64v2_mt16 a, b64v2_mt16 b) => new(a.x & b.x, a.y & b.y);

    [MethodImpl(256 | 512)]
    public static b64v2_mt16 operator^(b64v2_mt16 a, b64v2_mt16 b) => new(a.x ^ b.x, a.y ^ b.y);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b64_mt16 x, out b64_mt16 y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // Deconstruct

    #region Index

    public b64_mt16 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"b64v2_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // b64v2_mt16
#region b64v2_mt32

[CpuOnly]
public partial struct b64v2_mt32
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b64_mt32.LineCount;
    }

    #endregion

    #region Fields

    public b64_mt32 x;
    public b64_mt32 y;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly b64v2 LaneGet(int index) => new(x[index], y[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b64v2 value)
    {
        x[index] = value.x;
        y[index] = value.y;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public b64v2_mt32(b64_mt32 x, b64_mt32 y)
    {
        this.x = x;
        this.y = y;
    }

    [MethodImpl(256 | 512)]
    public b64v2_mt32(b64 value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b64v2_mt32(b64_mt32 value)
    {
        y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b64v2_mt32(b64v2 value)
    {
        x = new(value.x);
        y = new(value.y);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator b64v2_mt32(b64 value) => new b64_mt32(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64v2_mt32(bool value) => (b64)(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64v2_mt32(b64_mt32 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64v2_mt32(b64v2 value) => new(value);

    [MethodImpl(256 | 512)]
    public static b64v2_mt32 operator~(b64v2_mt32 a) => new(~a.x, ~a.y);

    [MethodImpl(256 | 512)]
    public static b64v2_mt32 operator|(b64v2_mt32 a, b64v2_mt32 b) => new(a.x | b.x, a.y | b.y);

    [MethodImpl(256 | 512)]
    public static b64v2_mt32 operator&(b64v2_mt32 a, b64v2_mt32 b) => new(a.x & b.x, a.y & b.y);

    [MethodImpl(256 | 512)]
    public static b64v2_mt32 operator^(b64v2_mt32 a, b64v2_mt32 b) => new(a.x ^ b.x, a.y ^ b.y);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b64_mt32 x, out b64_mt32 y)
    {
        x = this.x;
        y = this.y;
    }

    #endregion // Deconstruct

    #region Index

    public b64_mt32 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"b64v2_mt32 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)}, t16 = {this.LaneGet(16)}, t17 = {this.LaneGet(17)}, t18 = {this.LaneGet(18)}, t19 = {this.LaneGet(19)}, t20 = {this.LaneGet(20)}, t21 = {this.LaneGet(21)}, t22 = {this.LaneGet(22)}, t23 = {this.LaneGet(23)}, t24 = {this.LaneGet(24)}, t25 = {this.LaneGet(25)}, t26 = {this.LaneGet(26)}, t27 = {this.LaneGet(27)}, t28 = {this.LaneGet(28)}, t29 = {this.LaneGet(29)}, t30 = {this.LaneGet(30)}, t31 = {this.LaneGet(31)} }}";
    
    #endregion // ToString
}

#endregion // b64v2_mt32
#region b64v3_mt4

[CpuOnly]
public partial struct b64v3_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b64_mt4.LineCount;
    }

    #endregion

    #region Fields

    public b64_mt4 x;
    public b64_mt4 y;
    public b64_mt4 z;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly b64v3 LaneGet(int index) => new(x[index], y[index], z[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b64v3 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public b64v3_mt4(b64_mt4 x, b64_mt4 y, b64_mt4 z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public b64v3_mt4(b64 value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b64v3_mt4(b64_mt4 value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b64v3_mt4(b64v3 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator b64v3_mt4(b64 value) => new b64_mt4(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64v3_mt4(bool value) => (b64)(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64v3_mt4(b64_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64v3_mt4(b64v3 value) => new(value);

    [MethodImpl(256 | 512)]
    public static b64v3_mt4 operator~(b64v3_mt4 a) => new(~a.x, ~a.y, ~a.z);

    [MethodImpl(256 | 512)]
    public static b64v3_mt4 operator|(b64v3_mt4 a, b64v3_mt4 b) => new(a.x | b.x, a.y | b.y, a.z | b.z);

    [MethodImpl(256 | 512)]
    public static b64v3_mt4 operator&(b64v3_mt4 a, b64v3_mt4 b) => new(a.x & b.x, a.y & b.y, a.z & b.z);

    [MethodImpl(256 | 512)]
    public static b64v3_mt4 operator^(b64v3_mt4 a, b64v3_mt4 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b64_mt4 x, out b64_mt4 y, out b64_mt4 z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // Deconstruct

    #region Index

    public b64_mt4 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"b64v3_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // b64v3_mt4
#region b64v3_mt8

[CpuOnly]
public partial struct b64v3_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b64_mt8.LineCount;
    }

    #endregion

    #region Fields

    public b64_mt8 x;
    public b64_mt8 y;
    public b64_mt8 z;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly b64v3 LaneGet(int index) => new(x[index], y[index], z[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b64v3 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public b64v3_mt8(b64_mt8 x, b64_mt8 y, b64_mt8 z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public b64v3_mt8(b64 value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b64v3_mt8(b64_mt8 value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b64v3_mt8(b64v3 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator b64v3_mt8(b64 value) => new b64_mt8(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64v3_mt8(bool value) => (b64)(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64v3_mt8(b64_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64v3_mt8(b64v3 value) => new(value);

    [MethodImpl(256 | 512)]
    public static b64v3_mt8 operator~(b64v3_mt8 a) => new(~a.x, ~a.y, ~a.z);

    [MethodImpl(256 | 512)]
    public static b64v3_mt8 operator|(b64v3_mt8 a, b64v3_mt8 b) => new(a.x | b.x, a.y | b.y, a.z | b.z);

    [MethodImpl(256 | 512)]
    public static b64v3_mt8 operator&(b64v3_mt8 a, b64v3_mt8 b) => new(a.x & b.x, a.y & b.y, a.z & b.z);

    [MethodImpl(256 | 512)]
    public static b64v3_mt8 operator^(b64v3_mt8 a, b64v3_mt8 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b64_mt8 x, out b64_mt8 y, out b64_mt8 z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // Deconstruct

    #region Index

    public b64_mt8 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"b64v3_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // b64v3_mt8
#region b64v3_mt16

[CpuOnly]
public partial struct b64v3_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b64_mt16.LineCount;
    }

    #endregion

    #region Fields

    public b64_mt16 x;
    public b64_mt16 y;
    public b64_mt16 z;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly b64v3 LaneGet(int index) => new(x[index], y[index], z[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b64v3 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public b64v3_mt16(b64_mt16 x, b64_mt16 y, b64_mt16 z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public b64v3_mt16(b64 value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b64v3_mt16(b64_mt16 value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b64v3_mt16(b64v3 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator b64v3_mt16(b64 value) => new b64_mt16(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64v3_mt16(bool value) => (b64)(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64v3_mt16(b64_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64v3_mt16(b64v3 value) => new(value);

    [MethodImpl(256 | 512)]
    public static b64v3_mt16 operator~(b64v3_mt16 a) => new(~a.x, ~a.y, ~a.z);

    [MethodImpl(256 | 512)]
    public static b64v3_mt16 operator|(b64v3_mt16 a, b64v3_mt16 b) => new(a.x | b.x, a.y | b.y, a.z | b.z);

    [MethodImpl(256 | 512)]
    public static b64v3_mt16 operator&(b64v3_mt16 a, b64v3_mt16 b) => new(a.x & b.x, a.y & b.y, a.z & b.z);

    [MethodImpl(256 | 512)]
    public static b64v3_mt16 operator^(b64v3_mt16 a, b64v3_mt16 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b64_mt16 x, out b64_mt16 y, out b64_mt16 z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // Deconstruct

    #region Index

    public b64_mt16 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"b64v3_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // b64v3_mt16
#region b64v3_mt32

[CpuOnly]
public partial struct b64v3_mt32
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b64_mt32.LineCount;
    }

    #endregion

    #region Fields

    public b64_mt32 x;
    public b64_mt32 y;
    public b64_mt32 z;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly b64v3 LaneGet(int index) => new(x[index], y[index], z[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b64v3 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public b64v3_mt32(b64_mt32 x, b64_mt32 y, b64_mt32 z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public b64v3_mt32(b64 value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b64v3_mt32(b64_mt32 value)
    {
        z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b64v3_mt32(b64v3 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator b64v3_mt32(b64 value) => new b64_mt32(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64v3_mt32(bool value) => (b64)(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64v3_mt32(b64_mt32 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64v3_mt32(b64v3 value) => new(value);

    [MethodImpl(256 | 512)]
    public static b64v3_mt32 operator~(b64v3_mt32 a) => new(~a.x, ~a.y, ~a.z);

    [MethodImpl(256 | 512)]
    public static b64v3_mt32 operator|(b64v3_mt32 a, b64v3_mt32 b) => new(a.x | b.x, a.y | b.y, a.z | b.z);

    [MethodImpl(256 | 512)]
    public static b64v3_mt32 operator&(b64v3_mt32 a, b64v3_mt32 b) => new(a.x & b.x, a.y & b.y, a.z & b.z);

    [MethodImpl(256 | 512)]
    public static b64v3_mt32 operator^(b64v3_mt32 a, b64v3_mt32 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b64_mt32 x, out b64_mt32 y, out b64_mt32 z)
    {
        x = this.x;
        y = this.y;
        z = this.z;
    }

    #endregion // Deconstruct

    #region Index

    public b64_mt32 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"b64v3_mt32 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)}, t16 = {this.LaneGet(16)}, t17 = {this.LaneGet(17)}, t18 = {this.LaneGet(18)}, t19 = {this.LaneGet(19)}, t20 = {this.LaneGet(20)}, t21 = {this.LaneGet(21)}, t22 = {this.LaneGet(22)}, t23 = {this.LaneGet(23)}, t24 = {this.LaneGet(24)}, t25 = {this.LaneGet(25)}, t26 = {this.LaneGet(26)}, t27 = {this.LaneGet(27)}, t28 = {this.LaneGet(28)}, t29 = {this.LaneGet(29)}, t30 = {this.LaneGet(30)}, t31 = {this.LaneGet(31)} }}";
    
    #endregion // ToString
}

#endregion // b64v3_mt32
#region b64v4_mt4

[CpuOnly]
public partial struct b64v4_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b64_mt4.LineCount;
    }

    #endregion

    #region Fields

    public b64_mt4 x;
    public b64_mt4 y;
    public b64_mt4 z;
    public b64_mt4 w;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly b64v4 LaneGet(int index) => new(x[index], y[index], z[index], w[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b64v4 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
        w[index] = value.w;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public b64v4_mt4(b64_mt4 x, b64_mt4 y, b64_mt4 z, b64_mt4 w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public b64v4_mt4(b64 value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b64v4_mt4(b64_mt4 value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b64v4_mt4(b64v4 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
        w = new(value.w);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator b64v4_mt4(b64 value) => new b64_mt4(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64v4_mt4(bool value) => (b64)(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64v4_mt4(b64_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64v4_mt4(b64v4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static b64v4_mt4 operator~(b64v4_mt4 a) => new(~a.x, ~a.y, ~a.z, ~a.w);

    [MethodImpl(256 | 512)]
    public static b64v4_mt4 operator|(b64v4_mt4 a, b64v4_mt4 b) => new(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);

    [MethodImpl(256 | 512)]
    public static b64v4_mt4 operator&(b64v4_mt4 a, b64v4_mt4 b) => new(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);

    [MethodImpl(256 | 512)]
    public static b64v4_mt4 operator^(b64v4_mt4 a, b64v4_mt4 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b64_mt4 x, out b64_mt4 y, out b64_mt4 z, out b64_mt4 w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // Deconstruct

    #region Index

    public b64_mt4 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"b64v4_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // b64v4_mt4
#region b64v4_mt8

[CpuOnly]
public partial struct b64v4_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b64_mt8.LineCount;
    }

    #endregion

    #region Fields

    public b64_mt8 x;
    public b64_mt8 y;
    public b64_mt8 z;
    public b64_mt8 w;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly b64v4 LaneGet(int index) => new(x[index], y[index], z[index], w[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b64v4 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
        w[index] = value.w;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public b64v4_mt8(b64_mt8 x, b64_mt8 y, b64_mt8 z, b64_mt8 w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public b64v4_mt8(b64 value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b64v4_mt8(b64_mt8 value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b64v4_mt8(b64v4 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
        w = new(value.w);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator b64v4_mt8(b64 value) => new b64_mt8(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64v4_mt8(bool value) => (b64)(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64v4_mt8(b64_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64v4_mt8(b64v4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static b64v4_mt8 operator~(b64v4_mt8 a) => new(~a.x, ~a.y, ~a.z, ~a.w);

    [MethodImpl(256 | 512)]
    public static b64v4_mt8 operator|(b64v4_mt8 a, b64v4_mt8 b) => new(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);

    [MethodImpl(256 | 512)]
    public static b64v4_mt8 operator&(b64v4_mt8 a, b64v4_mt8 b) => new(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);

    [MethodImpl(256 | 512)]
    public static b64v4_mt8 operator^(b64v4_mt8 a, b64v4_mt8 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b64_mt8 x, out b64_mt8 y, out b64_mt8 z, out b64_mt8 w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // Deconstruct

    #region Index

    public b64_mt8 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"b64v4_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // b64v4_mt8
#region b64v4_mt16

[CpuOnly]
public partial struct b64v4_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b64_mt16.LineCount;
    }

    #endregion

    #region Fields

    public b64_mt16 x;
    public b64_mt16 y;
    public b64_mt16 z;
    public b64_mt16 w;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly b64v4 LaneGet(int index) => new(x[index], y[index], z[index], w[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b64v4 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
        w[index] = value.w;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public b64v4_mt16(b64_mt16 x, b64_mt16 y, b64_mt16 z, b64_mt16 w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public b64v4_mt16(b64 value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b64v4_mt16(b64_mt16 value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b64v4_mt16(b64v4 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
        w = new(value.w);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator b64v4_mt16(b64 value) => new b64_mt16(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64v4_mt16(bool value) => (b64)(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64v4_mt16(b64_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64v4_mt16(b64v4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static b64v4_mt16 operator~(b64v4_mt16 a) => new(~a.x, ~a.y, ~a.z, ~a.w);

    [MethodImpl(256 | 512)]
    public static b64v4_mt16 operator|(b64v4_mt16 a, b64v4_mt16 b) => new(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);

    [MethodImpl(256 | 512)]
    public static b64v4_mt16 operator&(b64v4_mt16 a, b64v4_mt16 b) => new(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);

    [MethodImpl(256 | 512)]
    public static b64v4_mt16 operator^(b64v4_mt16 a, b64v4_mt16 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b64_mt16 x, out b64_mt16 y, out b64_mt16 z, out b64_mt16 w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // Deconstruct

    #region Index

    public b64_mt16 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"b64v4_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // b64v4_mt16
#region b64v4_mt32

[CpuOnly]
public partial struct b64v4_mt32
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b64_mt32.LineCount;
    }

    #endregion

    #region Fields

    public b64_mt32 x;
    public b64_mt32 y;
    public b64_mt32 z;
    public b64_mt32 w;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512)]
    public readonly b64v4 LaneGet(int index) => new(x[index], y[index], z[index], w[index]);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b64v4 value)
    {
        x[index] = value.x;
        y[index] = value.y;
        z[index] = value.z;
        w[index] = value.w;
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public b64v4_mt32(b64_mt32 x, b64_mt32 y, b64_mt32 z, b64_mt32 w)
    {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    [MethodImpl(256 | 512)]
    public b64v4_mt32(b64 value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b64v4_mt32(b64_mt32 value)
    {
        w = z = y = x = value;
    }

    [MethodImpl(256 | 512)]
    public b64v4_mt32(b64v4 value)
    {
        x = new(value.x);
        y = new(value.y);
        z = new(value.z);
        w = new(value.w);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator b64v4_mt32(b64 value) => new b64_mt32(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64v4_mt32(bool value) => (b64)(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64v4_mt32(b64_mt32 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64v4_mt32(b64v4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static b64v4_mt32 operator~(b64v4_mt32 a) => new(~a.x, ~a.y, ~a.z, ~a.w);

    [MethodImpl(256 | 512)]
    public static b64v4_mt32 operator|(b64v4_mt32 a, b64v4_mt32 b) => new(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);

    [MethodImpl(256 | 512)]
    public static b64v4_mt32 operator&(b64v4_mt32 a, b64v4_mt32 b) => new(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);

    [MethodImpl(256 | 512)]
    public static b64v4_mt32 operator^(b64v4_mt32 a, b64v4_mt32 b) => new(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);

    #endregion // Operators

    #region Deconstruct

    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b64_mt32 x, out b64_mt32 y, out b64_mt32 z, out b64_mt32 w)
    {
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
    }

    #endregion // Deconstruct

    #region Index

    public b64_mt32 this[int i]
    {
        [MethodImpl(256 | 512)]
        readonly get => i switch
        {
            0 => x,
            1 => y,
            2 => z,
            3 => w,
            _ => throw new IndexOutOfRangeException(nameof(i)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (i)
            {
                case 0:
                    x = value;
                    break;
                case 1:
                    y = value;
                    break;
                case 2:
                    z = value;
                    break;
                case 3:
                    w = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(i));
            }
        }
    }

    #endregion // Index

    #region ToString

    public readonly override string ToString() => $"b64v4_mt32 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)}, t16 = {this.LaneGet(16)}, t17 = {this.LaneGet(17)}, t18 = {this.LaneGet(18)}, t19 = {this.LaneGet(19)}, t20 = {this.LaneGet(20)}, t21 = {this.LaneGet(21)}, t22 = {this.LaneGet(22)}, t23 = {this.LaneGet(23)}, t24 = {this.LaneGet(24)}, t25 = {this.LaneGet(25)}, t26 = {this.LaneGet(26)}, t27 = {this.LaneGet(27)}, t28 = {this.LaneGet(28)}, t29 = {this.LaneGet(29)}, t30 = {this.LaneGet(30)}, t31 = {this.LaneGet(31)} }}";
    
    #endregion // ToString
}

#endregion // b64v4_mt32
