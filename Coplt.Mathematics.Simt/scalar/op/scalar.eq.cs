// generated by template, do not modify manually

namespace Coplt.Mathematics.Simt;

#region float_mt

public partial struct float_mt
    : IEqualityOperators<float_mt, float_mt, bool>
    , IEqualityOperators<float_mt, float_mt, b32_mt>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode()
    {
        return vector.GetHashCode();
    }

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is float_mt other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(float_mt other)
    {
        return vector.Equals(other.vector);
    }

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<float_mt, float_mt, bool>.operator ==(float_mt left, float_mt right) => left.Equals(right);
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<float_mt, float_mt, bool>.operator !=(float_mt left, float_mt right) => !left.Equals(right);

    [MethodImpl(256 | 512)]
    public readonly b32_mt LaneEquals(float_mt other)
    {
        return new(Vector512.Equals(vector, other.vector).AsUInt32());
    }

    [MethodImpl(256 | 512)]
    public readonly b32_mt LaneNotEquals(float_mt other)
    {
        return new(simd.Ne(vector, other.vector).AsUInt32());
    }

    [MethodImpl(256 | 512)]
    public static b32_mt operator ==(float_mt left, float_mt right) => left.LaneEquals(right);

    [MethodImpl(256 | 512)]
    public static b32_mt operator !=(float_mt left, float_mt right) => left.LaneNotEquals(right);
}

#endregion // float_mt
#region double_mt

public partial struct double_mt
    : IEqualityOperators<double_mt, double_mt, bool>
    , IEqualityOperators<double_mt, double_mt, b64_mt>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode()
    {
        return HashCode.Combine(vector0, vector1);
    }

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is double_mt other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(double_mt other)
    {
        return vector0.Equals(other.vector0) && vector1.Equals(other.vector1);
    }

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<double_mt, double_mt, bool>.operator ==(double_mt left, double_mt right) => left.Equals(right);
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<double_mt, double_mt, bool>.operator !=(double_mt left, double_mt right) => !left.Equals(right);

    [MethodImpl(256 | 512)]
    public readonly b64_mt LaneEquals(double_mt other)
    {
        return new(Vector512.Equals(vector0, other.vector0).AsUInt64(), Vector512.Equals(vector1, other.vector1).AsUInt64());
    }

    [MethodImpl(256 | 512)]
    public readonly b64_mt LaneNotEquals(double_mt other)
    {
        return new(simd.Ne(vector0, other.vector0).AsUInt64(), simd.Ne(vector1, other.vector1).AsUInt64());
    }

    [MethodImpl(256 | 512)]
    public static b64_mt operator ==(double_mt left, double_mt right) => left.LaneEquals(right);

    [MethodImpl(256 | 512)]
    public static b64_mt operator !=(double_mt left, double_mt right) => left.LaneNotEquals(right);
}

#endregion // double_mt
#region int_mt

public partial struct int_mt
    : IEqualityOperators<int_mt, int_mt, bool>
    , IEqualityOperators<int_mt, int_mt, b32_mt>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode()
    {
        return vector.GetHashCode();
    }

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is int_mt other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(int_mt other)
    {
        return vector.Equals(other.vector);
    }

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<int_mt, int_mt, bool>.operator ==(int_mt left, int_mt right) => left.Equals(right);
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<int_mt, int_mt, bool>.operator !=(int_mt left, int_mt right) => !left.Equals(right);

    [MethodImpl(256 | 512)]
    public readonly b32_mt LaneEquals(int_mt other)
    {
        return new(Vector512.Equals(vector, other.vector).AsUInt32());
    }

    [MethodImpl(256 | 512)]
    public readonly b32_mt LaneNotEquals(int_mt other)
    {
        return new(~Vector512.Equals(vector, other.vector).AsUInt32());
    }

    [MethodImpl(256 | 512)]
    public static b32_mt operator ==(int_mt left, int_mt right) => left.LaneEquals(right);

    [MethodImpl(256 | 512)]
    public static b32_mt operator !=(int_mt left, int_mt right) => left.LaneNotEquals(right);
}

#endregion // int_mt
#region uint_mt

public partial struct uint_mt
    : IEqualityOperators<uint_mt, uint_mt, bool>
    , IEqualityOperators<uint_mt, uint_mt, b32_mt>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode()
    {
        return vector.GetHashCode();
    }

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is uint_mt other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(uint_mt other)
    {
        return vector.Equals(other.vector);
    }

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<uint_mt, uint_mt, bool>.operator ==(uint_mt left, uint_mt right) => left.Equals(right);
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<uint_mt, uint_mt, bool>.operator !=(uint_mt left, uint_mt right) => !left.Equals(right);

    [MethodImpl(256 | 512)]
    public readonly b32_mt LaneEquals(uint_mt other)
    {
        return new(Vector512.Equals(vector, other.vector).AsUInt32());
    }

    [MethodImpl(256 | 512)]
    public readonly b32_mt LaneNotEquals(uint_mt other)
    {
        return new(~Vector512.Equals(vector, other.vector).AsUInt32());
    }

    [MethodImpl(256 | 512)]
    public static b32_mt operator ==(uint_mt left, uint_mt right) => left.LaneEquals(right);

    [MethodImpl(256 | 512)]
    public static b32_mt operator !=(uint_mt left, uint_mt right) => left.LaneNotEquals(right);
}

#endregion // uint_mt
#region long_mt

public partial struct long_mt
    : IEqualityOperators<long_mt, long_mt, bool>
    , IEqualityOperators<long_mt, long_mt, b64_mt>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode()
    {
        return HashCode.Combine(vector0, vector1);
    }

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is long_mt other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(long_mt other)
    {
        return vector0.Equals(other.vector0) && vector1.Equals(other.vector1);
    }

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<long_mt, long_mt, bool>.operator ==(long_mt left, long_mt right) => left.Equals(right);
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<long_mt, long_mt, bool>.operator !=(long_mt left, long_mt right) => !left.Equals(right);

    [MethodImpl(256 | 512)]
    public readonly b64_mt LaneEquals(long_mt other)
    {
        return new(Vector512.Equals(vector0, other.vector0).AsUInt64(), Vector512.Equals(vector1, other.vector1).AsUInt64());
    }

    [MethodImpl(256 | 512)]
    public readonly b64_mt LaneNotEquals(long_mt other)
    {
        return new(~Vector512.Equals(vector0, other.vector0).AsUInt64(), ~Vector512.Equals(vector1, other.vector1).AsUInt64());
    }

    [MethodImpl(256 | 512)]
    public static b64_mt operator ==(long_mt left, long_mt right) => left.LaneEquals(right);

    [MethodImpl(256 | 512)]
    public static b64_mt operator !=(long_mt left, long_mt right) => left.LaneNotEquals(right);
}

#endregion // long_mt
#region ulong_mt

public partial struct ulong_mt
    : IEqualityOperators<ulong_mt, ulong_mt, bool>
    , IEqualityOperators<ulong_mt, ulong_mt, b64_mt>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode()
    {
        return HashCode.Combine(vector0, vector1);
    }

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is ulong_mt other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(ulong_mt other)
    {
        return vector0.Equals(other.vector0) && vector1.Equals(other.vector1);
    }

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<ulong_mt, ulong_mt, bool>.operator ==(ulong_mt left, ulong_mt right) => left.Equals(right);
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<ulong_mt, ulong_mt, bool>.operator !=(ulong_mt left, ulong_mt right) => !left.Equals(right);

    [MethodImpl(256 | 512)]
    public readonly b64_mt LaneEquals(ulong_mt other)
    {
        return new(Vector512.Equals(vector0, other.vector0).AsUInt64(), Vector512.Equals(vector1, other.vector1).AsUInt64());
    }

    [MethodImpl(256 | 512)]
    public readonly b64_mt LaneNotEquals(ulong_mt other)
    {
        return new(~Vector512.Equals(vector0, other.vector0).AsUInt64(), ~Vector512.Equals(vector1, other.vector1).AsUInt64());
    }

    [MethodImpl(256 | 512)]
    public static b64_mt operator ==(ulong_mt left, ulong_mt right) => left.LaneEquals(right);

    [MethodImpl(256 | 512)]
    public static b64_mt operator !=(ulong_mt left, ulong_mt right) => left.LaneNotEquals(right);
}

#endregion // ulong_mt
#region b32_mt

public partial struct b32_mt
    : IEqualityOperators<b32_mt, b32_mt, bool>
    , IEqualityOperators<b32_mt, b32_mt, b32_mt>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode()
    {
        return vector.GetHashCode();
    }

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is b32_mt other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(b32_mt other)
    {
        return vector.Equals(other.vector);
    }

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<b32_mt, b32_mt, bool>.operator ==(b32_mt left, b32_mt right) => left.Equals(right);
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<b32_mt, b32_mt, bool>.operator !=(b32_mt left, b32_mt right) => !left.Equals(right);

    [MethodImpl(256 | 512)]
    public readonly b32_mt LaneEquals(b32_mt other)
    {
        return new(Vector512.Equals(vector, other.vector).AsUInt32());
    }

    [MethodImpl(256 | 512)]
    public readonly b32_mt LaneNotEquals(b32_mt other)
    {
        return new(~Vector512.Equals(vector, other.vector).AsUInt32());
    }

    [MethodImpl(256 | 512)]
    public static b32_mt operator ==(b32_mt left, b32_mt right) => left.LaneEquals(right);

    [MethodImpl(256 | 512)]
    public static b32_mt operator !=(b32_mt left, b32_mt right) => left.LaneNotEquals(right);
}

#endregion // b32_mt
#region b64_mt

public partial struct b64_mt
    : IEqualityOperators<b64_mt, b64_mt, bool>
    , IEqualityOperators<b64_mt, b64_mt, b64_mt>
{
    [MethodImpl(256 | 512)]
    public readonly override int GetHashCode()
    {
        return HashCode.Combine(vector0, vector1);
    }

    [MethodImpl(256 | 512)]
    public readonly override bool Equals(object? obj) => obj is b64_mt other && Equals(other);

    [MethodImpl(256 | 512)]
    public readonly bool Equals(b64_mt other)
    {
        return vector0.Equals(other.vector0) && vector1.Equals(other.vector1);
    }

    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<b64_mt, b64_mt, bool>.operator ==(b64_mt left, b64_mt right) => left.Equals(right);
    [MethodImpl(256 | 512)]
    static bool IEqualityOperators<b64_mt, b64_mt, bool>.operator !=(b64_mt left, b64_mt right) => !left.Equals(right);

    [MethodImpl(256 | 512)]
    public readonly b64_mt LaneEquals(b64_mt other)
    {
        return new(Vector512.Equals(vector0, other.vector0).AsUInt64(), Vector512.Equals(vector1, other.vector1).AsUInt64());
    }

    [MethodImpl(256 | 512)]
    public readonly b64_mt LaneNotEquals(b64_mt other)
    {
        return new(~Vector512.Equals(vector0, other.vector0).AsUInt64(), ~Vector512.Equals(vector1, other.vector1).AsUInt64());
    }

    [MethodImpl(256 | 512)]
    public static b64_mt operator ==(b64_mt left, b64_mt right) => left.LaneEquals(right);

    [MethodImpl(256 | 512)]
    public static b64_mt operator !=(b64_mt left, b64_mt right) => left.LaneNotEquals(right);
}

#endregion // b64_mt
