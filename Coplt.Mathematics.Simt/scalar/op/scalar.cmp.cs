// generated by template, do not modify manually

namespace Coplt.Mathematics.Simt;

#region float_mt

public partial struct float_mt : IComparable<float_mt>, IComparable
    , IComparisonOperators<float_mt, float_mt, bool>
    , IComparisonOperators<float_mt, float_mt, b32_mt>
{
    [MethodImpl(256 | 512)]
    public readonly bool LessThanAll(float_mt other)
    {
        return Vector512.LessThanAll(vector, other.vector);
    }

    [MethodImpl(256 | 512)]
    public readonly bool GreaterThanAll(float_mt other)
    {
        return Vector512.GreaterThanAll(vector, other.vector);
    }

    [MethodImpl(256 | 512)]
    public readonly bool LessThanOrEqualAll(float_mt other)
    {
        return Vector512.LessThanOrEqualAll(vector, other.vector);
    }

    [MethodImpl(256 | 512)]
    public readonly bool GreaterThanOrEqualAll(float_mt other)
    {
        return Vector512.GreaterThanOrEqualAll(vector, other.vector);
    }

    [MethodImpl(256 | 512)]
    public readonly bool LessThanAny(float_mt other)
    {
        return Vector512.LessThanAny(vector, other.vector);
    }

    [MethodImpl(256 | 512)]
    public readonly bool GreaterThanAny(float_mt other)
    {
        return Vector512.GreaterThanAny(vector, other.vector);
    }

    [MethodImpl(256 | 512)]
    public readonly bool LessThanOrEqualAny(float_mt other)
    {
        return Vector512.LessThanOrEqualAny(vector, other.vector);
    }

    [MethodImpl(256 | 512)]
    public readonly bool GreaterThanOrEqualAny(float_mt other)
    {
        return Vector512.GreaterThanOrEqualAny(vector, other.vector);
    }

    static bool IComparisonOperators<float_mt, float_mt, bool>.operator <(float_mt left, float_mt right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float_mt, float_mt, bool>.operator >(float_mt left, float_mt right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float_mt, float_mt, bool>.operator <=(float_mt left, float_mt right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float_mt, float_mt, bool>.operator >=(float_mt left, float_mt right) => 
        left.GreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(float_mt other)
    {
        if (LessThanAny(other)) return -1;
        if (GreaterThanAny(other)) return 1;
        return 0;
    }

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is float_mt other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(float_mt)}");
    }

    [MethodImpl(256 | 512)]
    public static b32_mt operator <(float_mt left, float_mt right)
    {
        return new(Vector512.LessThan(left.vector, right.vector).AsUInt32());
    }

    [MethodImpl(256 | 512)]
    public static b32_mt operator >(float_mt left, float_mt right)
    {
        return new(Vector512.GreaterThan(left.vector, right.vector).AsUInt32());
    }

    [MethodImpl(256 | 512)]
    public static b32_mt operator <=(float_mt left, float_mt right)
    {
        return new(Vector512.LessThanOrEqual(left.vector, right.vector).AsUInt32());
    }

    [MethodImpl(256 | 512)]
    public static b32_mt operator >=(float_mt left, float_mt right)
    {
        return new(Vector512.GreaterThanOrEqual(left.vector, right.vector).AsUInt32());
    }
}


#endregion // float_mt
#region double_mt

public partial struct double_mt : IComparable<double_mt>, IComparable
    , IComparisonOperators<double_mt, double_mt, bool>
    , IComparisonOperators<double_mt, double_mt, b64_mt>
{
    [MethodImpl(256 | 512)]
    public readonly bool LessThanAll(double_mt other)
    {
        return Vector512.LessThanAll(vector0, other.vector0) && Vector512.LessThanAll(vector1, other.vector1);
    }

    [MethodImpl(256 | 512)]
    public readonly bool GreaterThanAll(double_mt other)
    {
        return Vector512.GreaterThanAll(vector0, other.vector0) && Vector512.GreaterThanAll(vector1, other.vector1);
    }

    [MethodImpl(256 | 512)]
    public readonly bool LessThanOrEqualAll(double_mt other)
    {
        return Vector512.LessThanOrEqualAll(vector0, other.vector0) && Vector512.LessThanOrEqualAll(vector1, other.vector1);
    }

    [MethodImpl(256 | 512)]
    public readonly bool GreaterThanOrEqualAll(double_mt other)
    {
        return Vector512.GreaterThanOrEqualAll(vector0, other.vector0) && Vector512.GreaterThanOrEqualAll(vector1, other.vector1);
    }

    [MethodImpl(256 | 512)]
    public readonly bool LessThanAny(double_mt other)
    {
        return Vector512.LessThanAny(vector0, other.vector0) || Vector512.LessThanAny(vector1, other.vector1);
    }

    [MethodImpl(256 | 512)]
    public readonly bool GreaterThanAny(double_mt other)
    {
        return Vector512.GreaterThanAny(vector0, other.vector0) || Vector512.GreaterThanAny(vector1, other.vector1);
    }

    [MethodImpl(256 | 512)]
    public readonly bool LessThanOrEqualAny(double_mt other)
    {
        return Vector512.LessThanOrEqualAny(vector0, other.vector0) || Vector512.LessThanOrEqualAny(vector1, other.vector1);
    }

    [MethodImpl(256 | 512)]
    public readonly bool GreaterThanOrEqualAny(double_mt other)
    {
        return Vector512.GreaterThanOrEqualAny(vector0, other.vector0) || Vector512.GreaterThanOrEqualAny(vector1, other.vector1);
    }

    static bool IComparisonOperators<double_mt, double_mt, bool>.operator <(double_mt left, double_mt right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double_mt, double_mt, bool>.operator >(double_mt left, double_mt right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double_mt, double_mt, bool>.operator <=(double_mt left, double_mt right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double_mt, double_mt, bool>.operator >=(double_mt left, double_mt right) => 
        left.GreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(double_mt other)
    {
        if (LessThanAny(other)) return -1;
        if (GreaterThanAny(other)) return 1;
        return 0;
    }

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is double_mt other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(double_mt)}");
    }

    [MethodImpl(256 | 512)]
    public static b64_mt operator <(double_mt left, double_mt right)
    {
        return new(Vector512.LessThan(left.vector0, right.vector0).AsUInt64(), Vector512.LessThan(left.vector1, right.vector1).AsUInt64());
    }

    [MethodImpl(256 | 512)]
    public static b64_mt operator >(double_mt left, double_mt right)
    {
        return new(Vector512.GreaterThan(left.vector0, right.vector0).AsUInt64(), Vector512.GreaterThan(left.vector1, right.vector1).AsUInt64());
    }

    [MethodImpl(256 | 512)]
    public static b64_mt operator <=(double_mt left, double_mt right)
    {
        return new(Vector512.LessThanOrEqual(left.vector0, right.vector0).AsUInt64(), Vector512.LessThanOrEqual(left.vector1, right.vector1).AsUInt64());
    }

    [MethodImpl(256 | 512)]
    public static b64_mt operator >=(double_mt left, double_mt right)
    {
        return new(Vector512.GreaterThanOrEqual(left.vector0, right.vector0).AsUInt64(), Vector512.GreaterThanOrEqual(left.vector1, right.vector1).AsUInt64());
    }
}


#endregion // double_mt
#region int_mt

public partial struct int_mt : IComparable<int_mt>, IComparable
    , IComparisonOperators<int_mt, int_mt, bool>
    , IComparisonOperators<int_mt, int_mt, b32_mt>
{
    [MethodImpl(256 | 512)]
    public readonly bool LessThanAll(int_mt other)
    {
        return Vector512.LessThanAll(vector, other.vector);
    }

    [MethodImpl(256 | 512)]
    public readonly bool GreaterThanAll(int_mt other)
    {
        return Vector512.GreaterThanAll(vector, other.vector);
    }

    [MethodImpl(256 | 512)]
    public readonly bool LessThanOrEqualAll(int_mt other)
    {
        return Vector512.LessThanOrEqualAll(vector, other.vector);
    }

    [MethodImpl(256 | 512)]
    public readonly bool GreaterThanOrEqualAll(int_mt other)
    {
        return Vector512.GreaterThanOrEqualAll(vector, other.vector);
    }

    [MethodImpl(256 | 512)]
    public readonly bool LessThanAny(int_mt other)
    {
        return Vector512.LessThanAny(vector, other.vector);
    }

    [MethodImpl(256 | 512)]
    public readonly bool GreaterThanAny(int_mt other)
    {
        return Vector512.GreaterThanAny(vector, other.vector);
    }

    [MethodImpl(256 | 512)]
    public readonly bool LessThanOrEqualAny(int_mt other)
    {
        return Vector512.LessThanOrEqualAny(vector, other.vector);
    }

    [MethodImpl(256 | 512)]
    public readonly bool GreaterThanOrEqualAny(int_mt other)
    {
        return Vector512.GreaterThanOrEqualAny(vector, other.vector);
    }

    static bool IComparisonOperators<int_mt, int_mt, bool>.operator <(int_mt left, int_mt right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int_mt, int_mt, bool>.operator >(int_mt left, int_mt right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int_mt, int_mt, bool>.operator <=(int_mt left, int_mt right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int_mt, int_mt, bool>.operator >=(int_mt left, int_mt right) => 
        left.GreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(int_mt other)
    {
        if (LessThanAny(other)) return -1;
        if (GreaterThanAny(other)) return 1;
        return 0;
    }

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is int_mt other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(int_mt)}");
    }

    [MethodImpl(256 | 512)]
    public static b32_mt operator <(int_mt left, int_mt right)
    {
        return new(Vector512.LessThan(left.vector, right.vector).AsUInt32());
    }

    [MethodImpl(256 | 512)]
    public static b32_mt operator >(int_mt left, int_mt right)
    {
        return new(Vector512.GreaterThan(left.vector, right.vector).AsUInt32());
    }

    [MethodImpl(256 | 512)]
    public static b32_mt operator <=(int_mt left, int_mt right)
    {
        return new(Vector512.LessThanOrEqual(left.vector, right.vector).AsUInt32());
    }

    [MethodImpl(256 | 512)]
    public static b32_mt operator >=(int_mt left, int_mt right)
    {
        return new(Vector512.GreaterThanOrEqual(left.vector, right.vector).AsUInt32());
    }
}


#endregion // int_mt
#region uint_mt

public partial struct uint_mt : IComparable<uint_mt>, IComparable
    , IComparisonOperators<uint_mt, uint_mt, bool>
    , IComparisonOperators<uint_mt, uint_mt, b32_mt>
{
    [MethodImpl(256 | 512)]
    public readonly bool LessThanAll(uint_mt other)
    {
        return Vector512.LessThanAll(vector, other.vector);
    }

    [MethodImpl(256 | 512)]
    public readonly bool GreaterThanAll(uint_mt other)
    {
        return Vector512.GreaterThanAll(vector, other.vector);
    }

    [MethodImpl(256 | 512)]
    public readonly bool LessThanOrEqualAll(uint_mt other)
    {
        return Vector512.LessThanOrEqualAll(vector, other.vector);
    }

    [MethodImpl(256 | 512)]
    public readonly bool GreaterThanOrEqualAll(uint_mt other)
    {
        return Vector512.GreaterThanOrEqualAll(vector, other.vector);
    }

    [MethodImpl(256 | 512)]
    public readonly bool LessThanAny(uint_mt other)
    {
        return Vector512.LessThanAny(vector, other.vector);
    }

    [MethodImpl(256 | 512)]
    public readonly bool GreaterThanAny(uint_mt other)
    {
        return Vector512.GreaterThanAny(vector, other.vector);
    }

    [MethodImpl(256 | 512)]
    public readonly bool LessThanOrEqualAny(uint_mt other)
    {
        return Vector512.LessThanOrEqualAny(vector, other.vector);
    }

    [MethodImpl(256 | 512)]
    public readonly bool GreaterThanOrEqualAny(uint_mt other)
    {
        return Vector512.GreaterThanOrEqualAny(vector, other.vector);
    }

    static bool IComparisonOperators<uint_mt, uint_mt, bool>.operator <(uint_mt left, uint_mt right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint_mt, uint_mt, bool>.operator >(uint_mt left, uint_mt right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint_mt, uint_mt, bool>.operator <=(uint_mt left, uint_mt right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint_mt, uint_mt, bool>.operator >=(uint_mt left, uint_mt right) => 
        left.GreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(uint_mt other)
    {
        if (LessThanAny(other)) return -1;
        if (GreaterThanAny(other)) return 1;
        return 0;
    }

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is uint_mt other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(uint_mt)}");
    }

    [MethodImpl(256 | 512)]
    public static b32_mt operator <(uint_mt left, uint_mt right)
    {
        return new(Vector512.LessThan(left.vector, right.vector).AsUInt32());
    }

    [MethodImpl(256 | 512)]
    public static b32_mt operator >(uint_mt left, uint_mt right)
    {
        return new(Vector512.GreaterThan(left.vector, right.vector).AsUInt32());
    }

    [MethodImpl(256 | 512)]
    public static b32_mt operator <=(uint_mt left, uint_mt right)
    {
        return new(Vector512.LessThanOrEqual(left.vector, right.vector).AsUInt32());
    }

    [MethodImpl(256 | 512)]
    public static b32_mt operator >=(uint_mt left, uint_mt right)
    {
        return new(Vector512.GreaterThanOrEqual(left.vector, right.vector).AsUInt32());
    }
}


#endregion // uint_mt
#region long_mt

public partial struct long_mt : IComparable<long_mt>, IComparable
    , IComparisonOperators<long_mt, long_mt, bool>
    , IComparisonOperators<long_mt, long_mt, b64_mt>
{
    [MethodImpl(256 | 512)]
    public readonly bool LessThanAll(long_mt other)
    {
        return Vector512.LessThanAll(vector0, other.vector0) && Vector512.LessThanAll(vector1, other.vector1);
    }

    [MethodImpl(256 | 512)]
    public readonly bool GreaterThanAll(long_mt other)
    {
        return Vector512.GreaterThanAll(vector0, other.vector0) && Vector512.GreaterThanAll(vector1, other.vector1);
    }

    [MethodImpl(256 | 512)]
    public readonly bool LessThanOrEqualAll(long_mt other)
    {
        return Vector512.LessThanOrEqualAll(vector0, other.vector0) && Vector512.LessThanOrEqualAll(vector1, other.vector1);
    }

    [MethodImpl(256 | 512)]
    public readonly bool GreaterThanOrEqualAll(long_mt other)
    {
        return Vector512.GreaterThanOrEqualAll(vector0, other.vector0) && Vector512.GreaterThanOrEqualAll(vector1, other.vector1);
    }

    [MethodImpl(256 | 512)]
    public readonly bool LessThanAny(long_mt other)
    {
        return Vector512.LessThanAny(vector0, other.vector0) || Vector512.LessThanAny(vector1, other.vector1);
    }

    [MethodImpl(256 | 512)]
    public readonly bool GreaterThanAny(long_mt other)
    {
        return Vector512.GreaterThanAny(vector0, other.vector0) || Vector512.GreaterThanAny(vector1, other.vector1);
    }

    [MethodImpl(256 | 512)]
    public readonly bool LessThanOrEqualAny(long_mt other)
    {
        return Vector512.LessThanOrEqualAny(vector0, other.vector0) || Vector512.LessThanOrEqualAny(vector1, other.vector1);
    }

    [MethodImpl(256 | 512)]
    public readonly bool GreaterThanOrEqualAny(long_mt other)
    {
        return Vector512.GreaterThanOrEqualAny(vector0, other.vector0) || Vector512.GreaterThanOrEqualAny(vector1, other.vector1);
    }

    static bool IComparisonOperators<long_mt, long_mt, bool>.operator <(long_mt left, long_mt right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long_mt, long_mt, bool>.operator >(long_mt left, long_mt right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long_mt, long_mt, bool>.operator <=(long_mt left, long_mt right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long_mt, long_mt, bool>.operator >=(long_mt left, long_mt right) => 
        left.GreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(long_mt other)
    {
        if (LessThanAny(other)) return -1;
        if (GreaterThanAny(other)) return 1;
        return 0;
    }

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is long_mt other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(long_mt)}");
    }

    [MethodImpl(256 | 512)]
    public static b64_mt operator <(long_mt left, long_mt right)
    {
        return new(Vector512.LessThan(left.vector0, right.vector0).AsUInt64(), Vector512.LessThan(left.vector1, right.vector1).AsUInt64());
    }

    [MethodImpl(256 | 512)]
    public static b64_mt operator >(long_mt left, long_mt right)
    {
        return new(Vector512.GreaterThan(left.vector0, right.vector0).AsUInt64(), Vector512.GreaterThan(left.vector1, right.vector1).AsUInt64());
    }

    [MethodImpl(256 | 512)]
    public static b64_mt operator <=(long_mt left, long_mt right)
    {
        return new(Vector512.LessThanOrEqual(left.vector0, right.vector0).AsUInt64(), Vector512.LessThanOrEqual(left.vector1, right.vector1).AsUInt64());
    }

    [MethodImpl(256 | 512)]
    public static b64_mt operator >=(long_mt left, long_mt right)
    {
        return new(Vector512.GreaterThanOrEqual(left.vector0, right.vector0).AsUInt64(), Vector512.GreaterThanOrEqual(left.vector1, right.vector1).AsUInt64());
    }
}


#endregion // long_mt
#region ulong_mt

public partial struct ulong_mt : IComparable<ulong_mt>, IComparable
    , IComparisonOperators<ulong_mt, ulong_mt, bool>
    , IComparisonOperators<ulong_mt, ulong_mt, b64_mt>
{
    [MethodImpl(256 | 512)]
    public readonly bool LessThanAll(ulong_mt other)
    {
        return Vector512.LessThanAll(vector0, other.vector0) && Vector512.LessThanAll(vector1, other.vector1);
    }

    [MethodImpl(256 | 512)]
    public readonly bool GreaterThanAll(ulong_mt other)
    {
        return Vector512.GreaterThanAll(vector0, other.vector0) && Vector512.GreaterThanAll(vector1, other.vector1);
    }

    [MethodImpl(256 | 512)]
    public readonly bool LessThanOrEqualAll(ulong_mt other)
    {
        return Vector512.LessThanOrEqualAll(vector0, other.vector0) && Vector512.LessThanOrEqualAll(vector1, other.vector1);
    }

    [MethodImpl(256 | 512)]
    public readonly bool GreaterThanOrEqualAll(ulong_mt other)
    {
        return Vector512.GreaterThanOrEqualAll(vector0, other.vector0) && Vector512.GreaterThanOrEqualAll(vector1, other.vector1);
    }

    [MethodImpl(256 | 512)]
    public readonly bool LessThanAny(ulong_mt other)
    {
        return Vector512.LessThanAny(vector0, other.vector0) || Vector512.LessThanAny(vector1, other.vector1);
    }

    [MethodImpl(256 | 512)]
    public readonly bool GreaterThanAny(ulong_mt other)
    {
        return Vector512.GreaterThanAny(vector0, other.vector0) || Vector512.GreaterThanAny(vector1, other.vector1);
    }

    [MethodImpl(256 | 512)]
    public readonly bool LessThanOrEqualAny(ulong_mt other)
    {
        return Vector512.LessThanOrEqualAny(vector0, other.vector0) || Vector512.LessThanOrEqualAny(vector1, other.vector1);
    }

    [MethodImpl(256 | 512)]
    public readonly bool GreaterThanOrEqualAny(ulong_mt other)
    {
        return Vector512.GreaterThanOrEqualAny(vector0, other.vector0) || Vector512.GreaterThanOrEqualAny(vector1, other.vector1);
    }

    static bool IComparisonOperators<ulong_mt, ulong_mt, bool>.operator <(ulong_mt left, ulong_mt right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong_mt, ulong_mt, bool>.operator >(ulong_mt left, ulong_mt right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong_mt, ulong_mt, bool>.operator <=(ulong_mt left, ulong_mt right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong_mt, ulong_mt, bool>.operator >=(ulong_mt left, ulong_mt right) => 
        left.GreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(ulong_mt other)
    {
        if (LessThanAny(other)) return -1;
        if (GreaterThanAny(other)) return 1;
        return 0;
    }

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is ulong_mt other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(ulong_mt)}");
    }

    [MethodImpl(256 | 512)]
    public static b64_mt operator <(ulong_mt left, ulong_mt right)
    {
        return new(Vector512.LessThan(left.vector0, right.vector0).AsUInt64(), Vector512.LessThan(left.vector1, right.vector1).AsUInt64());
    }

    [MethodImpl(256 | 512)]
    public static b64_mt operator >(ulong_mt left, ulong_mt right)
    {
        return new(Vector512.GreaterThan(left.vector0, right.vector0).AsUInt64(), Vector512.GreaterThan(left.vector1, right.vector1).AsUInt64());
    }

    [MethodImpl(256 | 512)]
    public static b64_mt operator <=(ulong_mt left, ulong_mt right)
    {
        return new(Vector512.LessThanOrEqual(left.vector0, right.vector0).AsUInt64(), Vector512.LessThanOrEqual(left.vector1, right.vector1).AsUInt64());
    }

    [MethodImpl(256 | 512)]
    public static b64_mt operator >=(ulong_mt left, ulong_mt right)
    {
        return new(Vector512.GreaterThanOrEqual(left.vector0, right.vector0).AsUInt64(), Vector512.GreaterThanOrEqual(left.vector1, right.vector1).AsUInt64());
    }
}


#endregion // ulong_mt
#region b32_mt

public partial struct b32_mt : IComparable<b32_mt>, IComparable
    , IComparisonOperators<b32_mt, b32_mt, bool>
    , IComparisonOperators<b32_mt, b32_mt, b32_mt>
{
    [MethodImpl(256 | 512)]
    public readonly bool LessThanAll(b32_mt other)
    {
        return Vector512.LessThanAll(vector, other.vector);
    }

    [MethodImpl(256 | 512)]
    public readonly bool GreaterThanAll(b32_mt other)
    {
        return Vector512.GreaterThanAll(vector, other.vector);
    }

    [MethodImpl(256 | 512)]
    public readonly bool LessThanOrEqualAll(b32_mt other)
    {
        return Vector512.LessThanOrEqualAll(vector, other.vector);
    }

    [MethodImpl(256 | 512)]
    public readonly bool GreaterThanOrEqualAll(b32_mt other)
    {
        return Vector512.GreaterThanOrEqualAll(vector, other.vector);
    }

    [MethodImpl(256 | 512)]
    public readonly bool LessThanAny(b32_mt other)
    {
        return Vector512.LessThanAny(vector, other.vector);
    }

    [MethodImpl(256 | 512)]
    public readonly bool GreaterThanAny(b32_mt other)
    {
        return Vector512.GreaterThanAny(vector, other.vector);
    }

    [MethodImpl(256 | 512)]
    public readonly bool LessThanOrEqualAny(b32_mt other)
    {
        return Vector512.LessThanOrEqualAny(vector, other.vector);
    }

    [MethodImpl(256 | 512)]
    public readonly bool GreaterThanOrEqualAny(b32_mt other)
    {
        return Vector512.GreaterThanOrEqualAny(vector, other.vector);
    }

    static bool IComparisonOperators<b32_mt, b32_mt, bool>.operator <(b32_mt left, b32_mt right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32_mt, b32_mt, bool>.operator >(b32_mt left, b32_mt right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32_mt, b32_mt, bool>.operator <=(b32_mt left, b32_mt right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32_mt, b32_mt, bool>.operator >=(b32_mt left, b32_mt right) => 
        left.GreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b32_mt other)
    {
        if (LessThanAny(other)) return -1;
        if (GreaterThanAny(other)) return 1;
        return 0;
    }

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b32_mt other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b32_mt)}");
    }

    [MethodImpl(256 | 512)]
    public static b32_mt operator <(b32_mt left, b32_mt right)
    {
        return new(Vector512.LessThan(left.vector, right.vector).AsUInt32());
    }

    [MethodImpl(256 | 512)]
    public static b32_mt operator >(b32_mt left, b32_mt right)
    {
        return new(Vector512.GreaterThan(left.vector, right.vector).AsUInt32());
    }

    [MethodImpl(256 | 512)]
    public static b32_mt operator <=(b32_mt left, b32_mt right)
    {
        return new(Vector512.LessThanOrEqual(left.vector, right.vector).AsUInt32());
    }

    [MethodImpl(256 | 512)]
    public static b32_mt operator >=(b32_mt left, b32_mt right)
    {
        return new(Vector512.GreaterThanOrEqual(left.vector, right.vector).AsUInt32());
    }
}


#endregion // b32_mt
#region b64_mt

public partial struct b64_mt : IComparable<b64_mt>, IComparable
    , IComparisonOperators<b64_mt, b64_mt, bool>
    , IComparisonOperators<b64_mt, b64_mt, b64_mt>
{
    [MethodImpl(256 | 512)]
    public readonly bool LessThanAll(b64_mt other)
    {
        return Vector512.LessThanAll(vector0, other.vector0) && Vector512.LessThanAll(vector1, other.vector1);
    }

    [MethodImpl(256 | 512)]
    public readonly bool GreaterThanAll(b64_mt other)
    {
        return Vector512.GreaterThanAll(vector0, other.vector0) && Vector512.GreaterThanAll(vector1, other.vector1);
    }

    [MethodImpl(256 | 512)]
    public readonly bool LessThanOrEqualAll(b64_mt other)
    {
        return Vector512.LessThanOrEqualAll(vector0, other.vector0) && Vector512.LessThanOrEqualAll(vector1, other.vector1);
    }

    [MethodImpl(256 | 512)]
    public readonly bool GreaterThanOrEqualAll(b64_mt other)
    {
        return Vector512.GreaterThanOrEqualAll(vector0, other.vector0) && Vector512.GreaterThanOrEqualAll(vector1, other.vector1);
    }

    [MethodImpl(256 | 512)]
    public readonly bool LessThanAny(b64_mt other)
    {
        return Vector512.LessThanAny(vector0, other.vector0) || Vector512.LessThanAny(vector1, other.vector1);
    }

    [MethodImpl(256 | 512)]
    public readonly bool GreaterThanAny(b64_mt other)
    {
        return Vector512.GreaterThanAny(vector0, other.vector0) || Vector512.GreaterThanAny(vector1, other.vector1);
    }

    [MethodImpl(256 | 512)]
    public readonly bool LessThanOrEqualAny(b64_mt other)
    {
        return Vector512.LessThanOrEqualAny(vector0, other.vector0) || Vector512.LessThanOrEqualAny(vector1, other.vector1);
    }

    [MethodImpl(256 | 512)]
    public readonly bool GreaterThanOrEqualAny(b64_mt other)
    {
        return Vector512.GreaterThanOrEqualAny(vector0, other.vector0) || Vector512.GreaterThanOrEqualAny(vector1, other.vector1);
    }

    static bool IComparisonOperators<b64_mt, b64_mt, bool>.operator <(b64_mt left, b64_mt right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64_mt, b64_mt, bool>.operator >(b64_mt left, b64_mt right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64_mt, b64_mt, bool>.operator <=(b64_mt left, b64_mt right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64_mt, b64_mt, bool>.operator >=(b64_mt left, b64_mt right) => 
        left.GreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b64_mt other)
    {
        if (LessThanAny(other)) return -1;
        if (GreaterThanAny(other)) return 1;
        return 0;
    }

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b64_mt other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b64_mt)}");
    }

    [MethodImpl(256 | 512)]
    public static b64_mt operator <(b64_mt left, b64_mt right)
    {
        return new(Vector512.LessThan(left.vector0, right.vector0).AsUInt64(), Vector512.LessThan(left.vector1, right.vector1).AsUInt64());
    }

    [MethodImpl(256 | 512)]
    public static b64_mt operator >(b64_mt left, b64_mt right)
    {
        return new(Vector512.GreaterThan(left.vector0, right.vector0).AsUInt64(), Vector512.GreaterThan(left.vector1, right.vector1).AsUInt64());
    }

    [MethodImpl(256 | 512)]
    public static b64_mt operator <=(b64_mt left, b64_mt right)
    {
        return new(Vector512.LessThanOrEqual(left.vector0, right.vector0).AsUInt64(), Vector512.LessThanOrEqual(left.vector1, right.vector1).AsUInt64());
    }

    [MethodImpl(256 | 512)]
    public static b64_mt operator >=(b64_mt left, b64_mt right)
    {
        return new(Vector512.GreaterThanOrEqual(left.vector0, right.vector0).AsUInt64(), Vector512.GreaterThanOrEqual(left.vector1, right.vector1).AsUInt64());
    }
}


#endregion // b64_mt
