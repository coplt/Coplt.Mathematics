<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="../../../Coplt.Mathematics/types.ttinclude" #><#@ import namespace="System.Linq" #>// generated by template, do not modify manually

namespace Coplt.Mathematics.Simt;

<#
    var sizes = new[] { 16 };
    foreach (var typ in Typ.Typs)
    {
        if (!typ.arith) continue;
        if (!typ.simd) continue;
        if (typ.size < 4) continue;
        foreach (var size in sizes)
        {
            var byteSize = typ.size * size;
            var bitSize = 8 * byteSize;
            var num_vectors = Math.Max(1, bitSize / 512);
            bitSize = Math.Min(512, bitSize);

            var typeName = $"{typ.compType}_mt";

            IEnumerable<string> ForVectors(string name)
            {
                if (num_vectors == 1) yield return name;
                else
                {
                    for (var i = 0; i < num_vectors; i++)
                    {
                        yield return $"{name}{i}";
                    }
                }
            }

            var vectors = ForVectors("vector").ToList();
#>
#region <#= typeName #>

public partial struct <#= typeName #>
{
    #region Constants

    public static <#= typeName #> Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static <#= typeName #> One
    {
        [MethodImpl(256 | 512)]
        get => new(<#= typ.one #>);
    }

    public static <#= typeName #> Two
    {
        [MethodImpl(256 | 512)]
        get => new(<#= typ.two #>);
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator-(<#= typeName #> a) => <#=
                $"new({string.Join(", ", vectors.Select(v => $"-a.{v}"))})" #>;

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator+(<#= typeName #> a, <#= typeName #> b) => <#=
                $"new({string.Join(", ", vectors.Select(v => $"a.{v} + b.{v}"))})" #>;

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator-(<#= typeName #> a, <#= typeName #> b) => <#=
                $"new({string.Join(", ", vectors.Select(v => $"a.{v} - b.{v}"))})" #>;

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator*(<#= typeName #> a, <#= typeName #> b) => <#=
                $"new({string.Join(", ", vectors.Select(v => $"a.{v} * b.{v}"))})" #>;

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator*(<#= typeName #> a, <#= typ.compType #> b) => <#=
                $"new({string.Join(", ", vectors.Select(v => $"a.{v} * b"))})" #>;

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator*(<#= typ.compType #> a, <#= typeName #> b) => <#=
                $"new({string.Join(", ", vectors.Select(v => $"a * b.{v}"))})" #>;

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator/(<#= typeName #> a, <#= typeName #> b) => <#=
                $"new({string.Join(", ", vectors.Select(v => $"a.{v} / b.{v}"))})" #>;

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator/(<#= typeName #> a, <#= typ.compType #> b) => <#=
                $"new({string.Join(", ", vectors.Select(v => $"a.{v} / b"))})" #>;

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator%(<#= typeName #> a, <#= typeName #> b) => <#
            if (typ.i)
            {
#>a - (a / b) * b<#
            }
            else
            {
#>math_mt.rem(a, b)<#
            }
#>;

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator%(<#= typeName #> a, <#= typ.compType #> b) => <#
            if (typ.i)
            {
#>a - (a / b) * b<#
            }
            else
            {
#>math_mt.rem(a, b)<#
            }
#>;

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator++(<#= typeName #> a) => a + One;

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator--(<#= typeName #> a) => a - One;

    #endregion
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static <#= typeName #> abs([This] <#= typeName #> a)
    {
<#
            if (typ.sig)
            {
#>
        return new(<#= string.Join(", ", vectors.Select(v => $"Vector{bitSize}.Abs(a.{v})")) #>);
<#
            }
            else
            {
#>
        return a;
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> sign([This] <#= typeName #> a)
    {
<#
            if (typ.f)
            {
#>
        return new(<#= string.Join(", ", vectors.Select(v => $"simd.SignFloat(a.{v})")) #>);
<#
            }
            else if (typ.sig)
            {
#>
        return new(<#= string.Join(", ", vectors.Select(v => $"simd.SignInt(a.{v})")) #>);
<#
            }
            else
            {
#>
        return new(<#= string.Join(", ", vectors.Select(v => $"simd.SignUInt(a.{v})")) #>);
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> min([This] <#= typeName #> a, <#= typeName #> b)
    {
        return new(<#= string.Join(", ", vectors.Select(v => $"Vector{bitSize}.Min(a.{v}, b.{v})")) #>);
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> max([This] <#= typeName #> a, <#= typeName #> b)
    {
        return new(<#= string.Join(", ", vectors.Select(v => $"Vector{bitSize}.Max(a.{v}, b.{v})")) #>);
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> clamp([This] <#= typeName #> v, <#= typeName #> min, <#= typeName #> max)
    {
<#
            foreach (var v in vectors)
            {
#>
        var <#= v #> = Vector<#= bitSize #>.Min(max.<#= v #>, v.<#= v #>);
<#
            }
#>
        return new(<#= string.Join(", ", vectors.Select(v => $"Vector{bitSize}.Max(min.{v}, {v})")) #>);
    }

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> fma([This] <#= typeName #> a, <#= typeName #> b, <#= typeName #> c)
    {
<#
            if (typ.f)
            {
#>
        return new(<#= string.Join(", ", vectors.Select(v => $"simd.Fma(a.{v}, b.{v}, c.{v})")) #>);
<#
            }
            else
            {
#>
        return (a * b) + c;
<#
            }
#>
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> fms([This] <#= typeName #> a, <#= typeName #> b, <#= typeName #> c)
    {
<#
            if (typ.f)
            {
#>
        return new(<#= string.Join(", ", vectors.Select(v => $"simd.Fms(a.{v}, b.{v}, c.{v})")) #>);
<#
            }
            else
            {
#>
        return (a * b) - c;
<#
            }
#>
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> fnma([This] <#= typeName #> a, <#= typeName #> b, <#= typeName #> c)
    {
<#
            if (typ.f)
            {
#>
        return new(<#= string.Join(", ", vectors.Select(v => $"simd.Fnma(a.{v}, b.{v}, c.{v})")) #>);
<#
            }
            else
            {
#>
        return c - (a * b);
<#
            }
#>
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> fsm([This] <#= typeName #> c, <#= typeName #> a, <#= typeName #> b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> fam([This] <#= typeName #> c, <#= typeName #> a, <#= typeName #> b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> mad([This] <#= typeName #> a, <#= typeName #> b, <#= typeName #> c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> lerp(<#= typeName #> start, <#= typeName #> end, [This] <#= typeName #> t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> lerp(<#= typeName #> start, <#= typeName #> end, [This] <#= typ.simdComp #> t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> lerp(<#= typ.compType #> start, <#= typ.compType #> end, [This] <#= typeName #> t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> unlerp([This] <#= typeName #> a, <#= typeName #> start, <#= typeName #> end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> unlerp([This] <#= typ.simdComp #> a, <#= typeName #> start, <#= typeName #> end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> unlerp([This] <#= typeName #> a, <#= typ.simdComp #> start, <#= typ.simdComp #> end) => (a - start) / <#= typ.arithCast #>(end - start);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> remap([This] <#= typeName #> a, <#= typeName #> srcStart, <#= typeName #> srcEnd, <#= typeName #> dstStart, <#= typeName #> dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> remap([This] <#= typeName #> a, <#= typ.simdComp #> srcStart, <#= typ.simdComp #> srcEnd, <#= typ.simdComp #> dstStart, <#= typ.simdComp #> dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> square([This] <#= typeName #> a) => a * a;
}

#endregion // <#= typeName #>
<#
        }
    }
#>
