// generated by template, do not modify manually

namespace Coplt.Mathematics.Simt;

#region float_mt4

public partial struct float_mt4
{
    #region Constants

    public static float_mt4 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static float_mt4 One
    {
        [MethodImpl(256 | 512)]
        get => new(1.0f);
    }

    public static float_mt4 Two
    {
        [MethodImpl(256 | 512)]
        get => new(2.0f);
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static float_mt4 operator-(float_mt4 a) => new(-a.vector);

    [MethodImpl(256 | 512)]
    public static float_mt4 operator+(float_mt4 a, float_mt4 b) => new(a.vector + b.vector);

    [MethodImpl(256 | 512)]
    public static float_mt4 operator-(float_mt4 a, float_mt4 b) => new(a.vector - b.vector);

    [MethodImpl(256 | 512)]
    public static float_mt4 operator*(float_mt4 a, float_mt4 b) => new(a.vector * b.vector);

    [MethodImpl(256 | 512)]
    public static float_mt4 operator*(float_mt4 a, float b) => new(a.vector * b);

    [MethodImpl(256 | 512)]
    public static float_mt4 operator*(float a, float_mt4 b) => new(a * b.vector);

    [MethodImpl(256 | 512)]
    public static float_mt4 operator/(float_mt4 a, float_mt4 b) => new(a.vector / b.vector);

    [MethodImpl(256 | 512)]
    public static float_mt4 operator/(float_mt4 a, float b) => new(a.vector / b);

    [MethodImpl(256 | 512)]
    public static float_mt4 operator%(float_mt4 a, float_mt4 b) => math_mt.rem(a, b);

    [MethodImpl(256 | 512)]
    public static float_mt4 operator%(float_mt4 a, float b) => math_mt.rem(a, b);

    [MethodImpl(256 | 512)]
    public static float_mt4 operator++(float_mt4 a) => a + One;

    [MethodImpl(256 | 512)]
    public static float_mt4 operator--(float_mt4 a) => a - One;

    #endregion
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static float_mt4 abs([This] float_mt4 a)
    {
        return new(Vector128.Abs(a.vector));
    }

    [MethodImpl(256 | 512)]
    public static float_mt4 sign([This] float_mt4 a)
    {
        return new(simd.SignFloat(a.vector));
    }

    [MethodImpl(256 | 512)]
    public static float_mt4 min([This] float_mt4 a, float_mt4 b)
    {
        return new(Vector128.Min(a.vector, b.vector));
    }

    [MethodImpl(256 | 512)]
    public static float_mt4 max([This] float_mt4 a, float_mt4 b)
    {
        return new(Vector128.Max(a.vector, b.vector));
    }

    [MethodImpl(256 | 512)]
    public static float_mt4 clamp([This] float_mt4 v, float_mt4 min, float_mt4 max)
    {
        var vector = Vector128.Min(max.vector, v.vector);
        return new(Vector128.Max(min.vector, vector));
    }

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float_mt4 fma([This] float_mt4 a, float_mt4 b, float_mt4 c)
    {
        return new(simd.Fma(a.vector, b.vector, c.vector));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static float_mt4 fms([This] float_mt4 a, float_mt4 b, float_mt4 c)
    {
        return new(simd.Fms(a.vector, b.vector, c.vector));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static float_mt4 fnma([This] float_mt4 a, float_mt4 b, float_mt4 c)
    {
        return new(simd.Fnma(a.vector, b.vector, c.vector));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static float_mt4 fsm([This] float_mt4 c, float_mt4 a, float_mt4 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float_mt4 fam([This] float_mt4 c, float_mt4 a, float_mt4 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float_mt4 mad([This] float_mt4 a, float_mt4 b, float_mt4 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static float_mt4 lerp(float_mt4 start, float_mt4 end, [This] float_mt4 t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static float_mt4 lerp(float_mt4 start, float_mt4 end, [This] float t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static float_mt4 lerp(float start, float end, [This] float_mt4 t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static float_mt4 unlerp([This] float_mt4 a, float_mt4 start, float_mt4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static float_mt4 unlerp([This] float a, float_mt4 start, float_mt4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static float_mt4 unlerp([This] float_mt4 a, float start, float end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static float_mt4 remap([This] float_mt4 a, float_mt4 srcStart, float_mt4 srcEnd, float_mt4 dstStart, float_mt4 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static float_mt4 remap([This] float_mt4 a, float srcStart, float srcEnd, float dstStart, float dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static float_mt4 square([This] float_mt4 a) => a * a;
}

#endregion // float_mt4
#region float_mt8

public partial struct float_mt8
{
    #region Constants

    public static float_mt8 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static float_mt8 One
    {
        [MethodImpl(256 | 512)]
        get => new(1.0f);
    }

    public static float_mt8 Two
    {
        [MethodImpl(256 | 512)]
        get => new(2.0f);
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static float_mt8 operator-(float_mt8 a) => new(-a.vector);

    [MethodImpl(256 | 512)]
    public static float_mt8 operator+(float_mt8 a, float_mt8 b) => new(a.vector + b.vector);

    [MethodImpl(256 | 512)]
    public static float_mt8 operator-(float_mt8 a, float_mt8 b) => new(a.vector - b.vector);

    [MethodImpl(256 | 512)]
    public static float_mt8 operator*(float_mt8 a, float_mt8 b) => new(a.vector * b.vector);

    [MethodImpl(256 | 512)]
    public static float_mt8 operator*(float_mt8 a, float b) => new(a.vector * b);

    [MethodImpl(256 | 512)]
    public static float_mt8 operator*(float a, float_mt8 b) => new(a * b.vector);

    [MethodImpl(256 | 512)]
    public static float_mt8 operator/(float_mt8 a, float_mt8 b) => new(a.vector / b.vector);

    [MethodImpl(256 | 512)]
    public static float_mt8 operator/(float_mt8 a, float b) => new(a.vector / b);

    [MethodImpl(256 | 512)]
    public static float_mt8 operator%(float_mt8 a, float_mt8 b) => math_mt.rem(a, b);

    [MethodImpl(256 | 512)]
    public static float_mt8 operator%(float_mt8 a, float b) => math_mt.rem(a, b);

    [MethodImpl(256 | 512)]
    public static float_mt8 operator++(float_mt8 a) => a + One;

    [MethodImpl(256 | 512)]
    public static float_mt8 operator--(float_mt8 a) => a - One;

    #endregion
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static float_mt8 abs([This] float_mt8 a)
    {
        return new(Vector256.Abs(a.vector));
    }

    [MethodImpl(256 | 512)]
    public static float_mt8 sign([This] float_mt8 a)
    {
        return new(simd.SignFloat(a.vector));
    }

    [MethodImpl(256 | 512)]
    public static float_mt8 min([This] float_mt8 a, float_mt8 b)
    {
        return new(Vector256.Min(a.vector, b.vector));
    }

    [MethodImpl(256 | 512)]
    public static float_mt8 max([This] float_mt8 a, float_mt8 b)
    {
        return new(Vector256.Max(a.vector, b.vector));
    }

    [MethodImpl(256 | 512)]
    public static float_mt8 clamp([This] float_mt8 v, float_mt8 min, float_mt8 max)
    {
        var vector = Vector256.Min(max.vector, v.vector);
        return new(Vector256.Max(min.vector, vector));
    }

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float_mt8 fma([This] float_mt8 a, float_mt8 b, float_mt8 c)
    {
        return new(simd.Fma(a.vector, b.vector, c.vector));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static float_mt8 fms([This] float_mt8 a, float_mt8 b, float_mt8 c)
    {
        return new(simd.Fms(a.vector, b.vector, c.vector));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static float_mt8 fnma([This] float_mt8 a, float_mt8 b, float_mt8 c)
    {
        return new(simd.Fnma(a.vector, b.vector, c.vector));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static float_mt8 fsm([This] float_mt8 c, float_mt8 a, float_mt8 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float_mt8 fam([This] float_mt8 c, float_mt8 a, float_mt8 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float_mt8 mad([This] float_mt8 a, float_mt8 b, float_mt8 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static float_mt8 lerp(float_mt8 start, float_mt8 end, [This] float_mt8 t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static float_mt8 lerp(float_mt8 start, float_mt8 end, [This] float t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static float_mt8 lerp(float start, float end, [This] float_mt8 t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static float_mt8 unlerp([This] float_mt8 a, float_mt8 start, float_mt8 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static float_mt8 unlerp([This] float a, float_mt8 start, float_mt8 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static float_mt8 unlerp([This] float_mt8 a, float start, float end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static float_mt8 remap([This] float_mt8 a, float_mt8 srcStart, float_mt8 srcEnd, float_mt8 dstStart, float_mt8 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static float_mt8 remap([This] float_mt8 a, float srcStart, float srcEnd, float dstStart, float dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static float_mt8 square([This] float_mt8 a) => a * a;
}

#endregion // float_mt8
#region float_mt16

public partial struct float_mt16
{
    #region Constants

    public static float_mt16 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static float_mt16 One
    {
        [MethodImpl(256 | 512)]
        get => new(1.0f);
    }

    public static float_mt16 Two
    {
        [MethodImpl(256 | 512)]
        get => new(2.0f);
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static float_mt16 operator-(float_mt16 a) => new(-a.vector);

    [MethodImpl(256 | 512)]
    public static float_mt16 operator+(float_mt16 a, float_mt16 b) => new(a.vector + b.vector);

    [MethodImpl(256 | 512)]
    public static float_mt16 operator-(float_mt16 a, float_mt16 b) => new(a.vector - b.vector);

    [MethodImpl(256 | 512)]
    public static float_mt16 operator*(float_mt16 a, float_mt16 b) => new(a.vector * b.vector);

    [MethodImpl(256 | 512)]
    public static float_mt16 operator*(float_mt16 a, float b) => new(a.vector * b);

    [MethodImpl(256 | 512)]
    public static float_mt16 operator*(float a, float_mt16 b) => new(a * b.vector);

    [MethodImpl(256 | 512)]
    public static float_mt16 operator/(float_mt16 a, float_mt16 b) => new(a.vector / b.vector);

    [MethodImpl(256 | 512)]
    public static float_mt16 operator/(float_mt16 a, float b) => new(a.vector / b);

    [MethodImpl(256 | 512)]
    public static float_mt16 operator%(float_mt16 a, float_mt16 b) => math_mt.rem(a, b);

    [MethodImpl(256 | 512)]
    public static float_mt16 operator%(float_mt16 a, float b) => math_mt.rem(a, b);

    [MethodImpl(256 | 512)]
    public static float_mt16 operator++(float_mt16 a) => a + One;

    [MethodImpl(256 | 512)]
    public static float_mt16 operator--(float_mt16 a) => a - One;

    #endregion
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static float_mt16 abs([This] float_mt16 a)
    {
        return new(Vector512.Abs(a.vector));
    }

    [MethodImpl(256 | 512)]
    public static float_mt16 sign([This] float_mt16 a)
    {
        return new(simd.SignFloat(a.vector));
    }

    [MethodImpl(256 | 512)]
    public static float_mt16 min([This] float_mt16 a, float_mt16 b)
    {
        return new(Vector512.Min(a.vector, b.vector));
    }

    [MethodImpl(256 | 512)]
    public static float_mt16 max([This] float_mt16 a, float_mt16 b)
    {
        return new(Vector512.Max(a.vector, b.vector));
    }

    [MethodImpl(256 | 512)]
    public static float_mt16 clamp([This] float_mt16 v, float_mt16 min, float_mt16 max)
    {
        var vector = Vector512.Min(max.vector, v.vector);
        return new(Vector512.Max(min.vector, vector));
    }

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float_mt16 fma([This] float_mt16 a, float_mt16 b, float_mt16 c)
    {
        return new(simd.Fma(a.vector, b.vector, c.vector));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static float_mt16 fms([This] float_mt16 a, float_mt16 b, float_mt16 c)
    {
        return new(simd.Fms(a.vector, b.vector, c.vector));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static float_mt16 fnma([This] float_mt16 a, float_mt16 b, float_mt16 c)
    {
        return new(simd.Fnma(a.vector, b.vector, c.vector));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static float_mt16 fsm([This] float_mt16 c, float_mt16 a, float_mt16 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float_mt16 fam([This] float_mt16 c, float_mt16 a, float_mt16 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float_mt16 mad([This] float_mt16 a, float_mt16 b, float_mt16 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static float_mt16 lerp(float_mt16 start, float_mt16 end, [This] float_mt16 t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static float_mt16 lerp(float_mt16 start, float_mt16 end, [This] float t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static float_mt16 lerp(float start, float end, [This] float_mt16 t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static float_mt16 unlerp([This] float_mt16 a, float_mt16 start, float_mt16 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static float_mt16 unlerp([This] float a, float_mt16 start, float_mt16 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static float_mt16 unlerp([This] float_mt16 a, float start, float end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static float_mt16 remap([This] float_mt16 a, float_mt16 srcStart, float_mt16 srcEnd, float_mt16 dstStart, float_mt16 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static float_mt16 remap([This] float_mt16 a, float srcStart, float srcEnd, float dstStart, float dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static float_mt16 square([This] float_mt16 a) => a * a;
}

#endregion // float_mt16
#region float_mt32

public partial struct float_mt32
{
    #region Constants

    public static float_mt32 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static float_mt32 One
    {
        [MethodImpl(256 | 512)]
        get => new(1.0f);
    }

    public static float_mt32 Two
    {
        [MethodImpl(256 | 512)]
        get => new(2.0f);
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static float_mt32 operator-(float_mt32 a) => new(-a.vector0, -a.vector1);

    [MethodImpl(256 | 512)]
    public static float_mt32 operator+(float_mt32 a, float_mt32 b) => new(a.vector0 + b.vector0, a.vector1 + b.vector1);

    [MethodImpl(256 | 512)]
    public static float_mt32 operator-(float_mt32 a, float_mt32 b) => new(a.vector0 - b.vector0, a.vector1 - b.vector1);

    [MethodImpl(256 | 512)]
    public static float_mt32 operator*(float_mt32 a, float_mt32 b) => new(a.vector0 * b.vector0, a.vector1 * b.vector1);

    [MethodImpl(256 | 512)]
    public static float_mt32 operator*(float_mt32 a, float b) => new(a.vector0 * b, a.vector1 * b);

    [MethodImpl(256 | 512)]
    public static float_mt32 operator*(float a, float_mt32 b) => new(a * b.vector0, a * b.vector1);

    [MethodImpl(256 | 512)]
    public static float_mt32 operator/(float_mt32 a, float_mt32 b) => new(a.vector0 / b.vector0, a.vector1 / b.vector1);

    [MethodImpl(256 | 512)]
    public static float_mt32 operator/(float_mt32 a, float b) => new(a.vector0 / b, a.vector1 / b);

    [MethodImpl(256 | 512)]
    public static float_mt32 operator%(float_mt32 a, float_mt32 b) => math_mt.rem(a, b);

    [MethodImpl(256 | 512)]
    public static float_mt32 operator%(float_mt32 a, float b) => math_mt.rem(a, b);

    [MethodImpl(256 | 512)]
    public static float_mt32 operator++(float_mt32 a) => a + One;

    [MethodImpl(256 | 512)]
    public static float_mt32 operator--(float_mt32 a) => a - One;

    #endregion
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static float_mt32 abs([This] float_mt32 a)
    {
        return new(Vector512.Abs(a.vector0), Vector512.Abs(a.vector1));
    }

    [MethodImpl(256 | 512)]
    public static float_mt32 sign([This] float_mt32 a)
    {
        return new(simd.SignFloat(a.vector0), simd.SignFloat(a.vector1));
    }

    [MethodImpl(256 | 512)]
    public static float_mt32 min([This] float_mt32 a, float_mt32 b)
    {
        return new(Vector512.Min(a.vector0, b.vector0), Vector512.Min(a.vector1, b.vector1));
    }

    [MethodImpl(256 | 512)]
    public static float_mt32 max([This] float_mt32 a, float_mt32 b)
    {
        return new(Vector512.Max(a.vector0, b.vector0), Vector512.Max(a.vector1, b.vector1));
    }

    [MethodImpl(256 | 512)]
    public static float_mt32 clamp([This] float_mt32 v, float_mt32 min, float_mt32 max)
    {
        var vector0 = Vector512.Min(max.vector0, v.vector0);
        var vector1 = Vector512.Min(max.vector1, v.vector1);
        return new(Vector512.Max(min.vector0, vector0), Vector512.Max(min.vector1, vector1));
    }

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float_mt32 fma([This] float_mt32 a, float_mt32 b, float_mt32 c)
    {
        return new(simd.Fma(a.vector0, b.vector0, c.vector0), simd.Fma(a.vector1, b.vector1, c.vector1));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static float_mt32 fms([This] float_mt32 a, float_mt32 b, float_mt32 c)
    {
        return new(simd.Fms(a.vector0, b.vector0, c.vector0), simd.Fms(a.vector1, b.vector1, c.vector1));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static float_mt32 fnma([This] float_mt32 a, float_mt32 b, float_mt32 c)
    {
        return new(simd.Fnma(a.vector0, b.vector0, c.vector0), simd.Fnma(a.vector1, b.vector1, c.vector1));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static float_mt32 fsm([This] float_mt32 c, float_mt32 a, float_mt32 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float_mt32 fam([This] float_mt32 c, float_mt32 a, float_mt32 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float_mt32 mad([This] float_mt32 a, float_mt32 b, float_mt32 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static float_mt32 lerp(float_mt32 start, float_mt32 end, [This] float_mt32 t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static float_mt32 lerp(float_mt32 start, float_mt32 end, [This] float t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static float_mt32 lerp(float start, float end, [This] float_mt32 t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static float_mt32 unlerp([This] float_mt32 a, float_mt32 start, float_mt32 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static float_mt32 unlerp([This] float a, float_mt32 start, float_mt32 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static float_mt32 unlerp([This] float_mt32 a, float start, float end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static float_mt32 remap([This] float_mt32 a, float_mt32 srcStart, float_mt32 srcEnd, float_mt32 dstStart, float_mt32 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static float_mt32 remap([This] float_mt32 a, float srcStart, float srcEnd, float dstStart, float dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static float_mt32 square([This] float_mt32 a) => a * a;
}

#endregion // float_mt32
#region double_mt4

public partial struct double_mt4
{
    #region Constants

    public static double_mt4 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static double_mt4 One
    {
        [MethodImpl(256 | 512)]
        get => new(1.0);
    }

    public static double_mt4 Two
    {
        [MethodImpl(256 | 512)]
        get => new(2.0);
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static double_mt4 operator-(double_mt4 a) => new(-a.vector);

    [MethodImpl(256 | 512)]
    public static double_mt4 operator+(double_mt4 a, double_mt4 b) => new(a.vector + b.vector);

    [MethodImpl(256 | 512)]
    public static double_mt4 operator-(double_mt4 a, double_mt4 b) => new(a.vector - b.vector);

    [MethodImpl(256 | 512)]
    public static double_mt4 operator*(double_mt4 a, double_mt4 b) => new(a.vector * b.vector);

    [MethodImpl(256 | 512)]
    public static double_mt4 operator*(double_mt4 a, double b) => new(a.vector * b);

    [MethodImpl(256 | 512)]
    public static double_mt4 operator*(double a, double_mt4 b) => new(a * b.vector);

    [MethodImpl(256 | 512)]
    public static double_mt4 operator/(double_mt4 a, double_mt4 b) => new(a.vector / b.vector);

    [MethodImpl(256 | 512)]
    public static double_mt4 operator/(double_mt4 a, double b) => new(a.vector / b);

    [MethodImpl(256 | 512)]
    public static double_mt4 operator%(double_mt4 a, double_mt4 b) => math_mt.rem(a, b);

    [MethodImpl(256 | 512)]
    public static double_mt4 operator%(double_mt4 a, double b) => math_mt.rem(a, b);

    [MethodImpl(256 | 512)]
    public static double_mt4 operator++(double_mt4 a) => a + One;

    [MethodImpl(256 | 512)]
    public static double_mt4 operator--(double_mt4 a) => a - One;

    #endregion
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static double_mt4 abs([This] double_mt4 a)
    {
        return new(Vector256.Abs(a.vector));
    }

    [MethodImpl(256 | 512)]
    public static double_mt4 sign([This] double_mt4 a)
    {
        return new(simd.SignFloat(a.vector));
    }

    [MethodImpl(256 | 512)]
    public static double_mt4 min([This] double_mt4 a, double_mt4 b)
    {
        return new(Vector256.Min(a.vector, b.vector));
    }

    [MethodImpl(256 | 512)]
    public static double_mt4 max([This] double_mt4 a, double_mt4 b)
    {
        return new(Vector256.Max(a.vector, b.vector));
    }

    [MethodImpl(256 | 512)]
    public static double_mt4 clamp([This] double_mt4 v, double_mt4 min, double_mt4 max)
    {
        var vector = Vector256.Min(max.vector, v.vector);
        return new(Vector256.Max(min.vector, vector));
    }

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double_mt4 fma([This] double_mt4 a, double_mt4 b, double_mt4 c)
    {
        return new(simd.Fma(a.vector, b.vector, c.vector));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static double_mt4 fms([This] double_mt4 a, double_mt4 b, double_mt4 c)
    {
        return new(simd.Fms(a.vector, b.vector, c.vector));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static double_mt4 fnma([This] double_mt4 a, double_mt4 b, double_mt4 c)
    {
        return new(simd.Fnma(a.vector, b.vector, c.vector));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static double_mt4 fsm([This] double_mt4 c, double_mt4 a, double_mt4 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double_mt4 fam([This] double_mt4 c, double_mt4 a, double_mt4 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double_mt4 mad([This] double_mt4 a, double_mt4 b, double_mt4 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static double_mt4 lerp(double_mt4 start, double_mt4 end, [This] double_mt4 t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static double_mt4 lerp(double_mt4 start, double_mt4 end, [This] double t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static double_mt4 lerp(double start, double end, [This] double_mt4 t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static double_mt4 unlerp([This] double_mt4 a, double_mt4 start, double_mt4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static double_mt4 unlerp([This] double a, double_mt4 start, double_mt4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static double_mt4 unlerp([This] double_mt4 a, double start, double end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static double_mt4 remap([This] double_mt4 a, double_mt4 srcStart, double_mt4 srcEnd, double_mt4 dstStart, double_mt4 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static double_mt4 remap([This] double_mt4 a, double srcStart, double srcEnd, double dstStart, double dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static double_mt4 square([This] double_mt4 a) => a * a;
}

#endregion // double_mt4
#region double_mt8

public partial struct double_mt8
{
    #region Constants

    public static double_mt8 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static double_mt8 One
    {
        [MethodImpl(256 | 512)]
        get => new(1.0);
    }

    public static double_mt8 Two
    {
        [MethodImpl(256 | 512)]
        get => new(2.0);
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static double_mt8 operator-(double_mt8 a) => new(-a.vector);

    [MethodImpl(256 | 512)]
    public static double_mt8 operator+(double_mt8 a, double_mt8 b) => new(a.vector + b.vector);

    [MethodImpl(256 | 512)]
    public static double_mt8 operator-(double_mt8 a, double_mt8 b) => new(a.vector - b.vector);

    [MethodImpl(256 | 512)]
    public static double_mt8 operator*(double_mt8 a, double_mt8 b) => new(a.vector * b.vector);

    [MethodImpl(256 | 512)]
    public static double_mt8 operator*(double_mt8 a, double b) => new(a.vector * b);

    [MethodImpl(256 | 512)]
    public static double_mt8 operator*(double a, double_mt8 b) => new(a * b.vector);

    [MethodImpl(256 | 512)]
    public static double_mt8 operator/(double_mt8 a, double_mt8 b) => new(a.vector / b.vector);

    [MethodImpl(256 | 512)]
    public static double_mt8 operator/(double_mt8 a, double b) => new(a.vector / b);

    [MethodImpl(256 | 512)]
    public static double_mt8 operator%(double_mt8 a, double_mt8 b) => math_mt.rem(a, b);

    [MethodImpl(256 | 512)]
    public static double_mt8 operator%(double_mt8 a, double b) => math_mt.rem(a, b);

    [MethodImpl(256 | 512)]
    public static double_mt8 operator++(double_mt8 a) => a + One;

    [MethodImpl(256 | 512)]
    public static double_mt8 operator--(double_mt8 a) => a - One;

    #endregion
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static double_mt8 abs([This] double_mt8 a)
    {
        return new(Vector512.Abs(a.vector));
    }

    [MethodImpl(256 | 512)]
    public static double_mt8 sign([This] double_mt8 a)
    {
        return new(simd.SignFloat(a.vector));
    }

    [MethodImpl(256 | 512)]
    public static double_mt8 min([This] double_mt8 a, double_mt8 b)
    {
        return new(Vector512.Min(a.vector, b.vector));
    }

    [MethodImpl(256 | 512)]
    public static double_mt8 max([This] double_mt8 a, double_mt8 b)
    {
        return new(Vector512.Max(a.vector, b.vector));
    }

    [MethodImpl(256 | 512)]
    public static double_mt8 clamp([This] double_mt8 v, double_mt8 min, double_mt8 max)
    {
        var vector = Vector512.Min(max.vector, v.vector);
        return new(Vector512.Max(min.vector, vector));
    }

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double_mt8 fma([This] double_mt8 a, double_mt8 b, double_mt8 c)
    {
        return new(simd.Fma(a.vector, b.vector, c.vector));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static double_mt8 fms([This] double_mt8 a, double_mt8 b, double_mt8 c)
    {
        return new(simd.Fms(a.vector, b.vector, c.vector));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static double_mt8 fnma([This] double_mt8 a, double_mt8 b, double_mt8 c)
    {
        return new(simd.Fnma(a.vector, b.vector, c.vector));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static double_mt8 fsm([This] double_mt8 c, double_mt8 a, double_mt8 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double_mt8 fam([This] double_mt8 c, double_mt8 a, double_mt8 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double_mt8 mad([This] double_mt8 a, double_mt8 b, double_mt8 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static double_mt8 lerp(double_mt8 start, double_mt8 end, [This] double_mt8 t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static double_mt8 lerp(double_mt8 start, double_mt8 end, [This] double t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static double_mt8 lerp(double start, double end, [This] double_mt8 t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static double_mt8 unlerp([This] double_mt8 a, double_mt8 start, double_mt8 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static double_mt8 unlerp([This] double a, double_mt8 start, double_mt8 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static double_mt8 unlerp([This] double_mt8 a, double start, double end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static double_mt8 remap([This] double_mt8 a, double_mt8 srcStart, double_mt8 srcEnd, double_mt8 dstStart, double_mt8 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static double_mt8 remap([This] double_mt8 a, double srcStart, double srcEnd, double dstStart, double dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static double_mt8 square([This] double_mt8 a) => a * a;
}

#endregion // double_mt8
#region double_mt16

public partial struct double_mt16
{
    #region Constants

    public static double_mt16 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static double_mt16 One
    {
        [MethodImpl(256 | 512)]
        get => new(1.0);
    }

    public static double_mt16 Two
    {
        [MethodImpl(256 | 512)]
        get => new(2.0);
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static double_mt16 operator-(double_mt16 a) => new(-a.vector0, -a.vector1);

    [MethodImpl(256 | 512)]
    public static double_mt16 operator+(double_mt16 a, double_mt16 b) => new(a.vector0 + b.vector0, a.vector1 + b.vector1);

    [MethodImpl(256 | 512)]
    public static double_mt16 operator-(double_mt16 a, double_mt16 b) => new(a.vector0 - b.vector0, a.vector1 - b.vector1);

    [MethodImpl(256 | 512)]
    public static double_mt16 operator*(double_mt16 a, double_mt16 b) => new(a.vector0 * b.vector0, a.vector1 * b.vector1);

    [MethodImpl(256 | 512)]
    public static double_mt16 operator*(double_mt16 a, double b) => new(a.vector0 * b, a.vector1 * b);

    [MethodImpl(256 | 512)]
    public static double_mt16 operator*(double a, double_mt16 b) => new(a * b.vector0, a * b.vector1);

    [MethodImpl(256 | 512)]
    public static double_mt16 operator/(double_mt16 a, double_mt16 b) => new(a.vector0 / b.vector0, a.vector1 / b.vector1);

    [MethodImpl(256 | 512)]
    public static double_mt16 operator/(double_mt16 a, double b) => new(a.vector0 / b, a.vector1 / b);

    [MethodImpl(256 | 512)]
    public static double_mt16 operator%(double_mt16 a, double_mt16 b) => math_mt.rem(a, b);

    [MethodImpl(256 | 512)]
    public static double_mt16 operator%(double_mt16 a, double b) => math_mt.rem(a, b);

    [MethodImpl(256 | 512)]
    public static double_mt16 operator++(double_mt16 a) => a + One;

    [MethodImpl(256 | 512)]
    public static double_mt16 operator--(double_mt16 a) => a - One;

    #endregion
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static double_mt16 abs([This] double_mt16 a)
    {
        return new(Vector512.Abs(a.vector0), Vector512.Abs(a.vector1));
    }

    [MethodImpl(256 | 512)]
    public static double_mt16 sign([This] double_mt16 a)
    {
        return new(simd.SignFloat(a.vector0), simd.SignFloat(a.vector1));
    }

    [MethodImpl(256 | 512)]
    public static double_mt16 min([This] double_mt16 a, double_mt16 b)
    {
        return new(Vector512.Min(a.vector0, b.vector0), Vector512.Min(a.vector1, b.vector1));
    }

    [MethodImpl(256 | 512)]
    public static double_mt16 max([This] double_mt16 a, double_mt16 b)
    {
        return new(Vector512.Max(a.vector0, b.vector0), Vector512.Max(a.vector1, b.vector1));
    }

    [MethodImpl(256 | 512)]
    public static double_mt16 clamp([This] double_mt16 v, double_mt16 min, double_mt16 max)
    {
        var vector0 = Vector512.Min(max.vector0, v.vector0);
        var vector1 = Vector512.Min(max.vector1, v.vector1);
        return new(Vector512.Max(min.vector0, vector0), Vector512.Max(min.vector1, vector1));
    }

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double_mt16 fma([This] double_mt16 a, double_mt16 b, double_mt16 c)
    {
        return new(simd.Fma(a.vector0, b.vector0, c.vector0), simd.Fma(a.vector1, b.vector1, c.vector1));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static double_mt16 fms([This] double_mt16 a, double_mt16 b, double_mt16 c)
    {
        return new(simd.Fms(a.vector0, b.vector0, c.vector0), simd.Fms(a.vector1, b.vector1, c.vector1));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static double_mt16 fnma([This] double_mt16 a, double_mt16 b, double_mt16 c)
    {
        return new(simd.Fnma(a.vector0, b.vector0, c.vector0), simd.Fnma(a.vector1, b.vector1, c.vector1));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static double_mt16 fsm([This] double_mt16 c, double_mt16 a, double_mt16 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double_mt16 fam([This] double_mt16 c, double_mt16 a, double_mt16 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double_mt16 mad([This] double_mt16 a, double_mt16 b, double_mt16 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static double_mt16 lerp(double_mt16 start, double_mt16 end, [This] double_mt16 t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static double_mt16 lerp(double_mt16 start, double_mt16 end, [This] double t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static double_mt16 lerp(double start, double end, [This] double_mt16 t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static double_mt16 unlerp([This] double_mt16 a, double_mt16 start, double_mt16 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static double_mt16 unlerp([This] double a, double_mt16 start, double_mt16 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static double_mt16 unlerp([This] double_mt16 a, double start, double end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static double_mt16 remap([This] double_mt16 a, double_mt16 srcStart, double_mt16 srcEnd, double_mt16 dstStart, double_mt16 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static double_mt16 remap([This] double_mt16 a, double srcStart, double srcEnd, double dstStart, double dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static double_mt16 square([This] double_mt16 a) => a * a;
}

#endregion // double_mt16
#region double_mt32

public partial struct double_mt32
{
    #region Constants

    public static double_mt32 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static double_mt32 One
    {
        [MethodImpl(256 | 512)]
        get => new(1.0);
    }

    public static double_mt32 Two
    {
        [MethodImpl(256 | 512)]
        get => new(2.0);
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static double_mt32 operator-(double_mt32 a) => new(-a.vector0, -a.vector1, -a.vector2, -a.vector3);

    [MethodImpl(256 | 512)]
    public static double_mt32 operator+(double_mt32 a, double_mt32 b) => new(a.vector0 + b.vector0, a.vector1 + b.vector1, a.vector2 + b.vector2, a.vector3 + b.vector3);

    [MethodImpl(256 | 512)]
    public static double_mt32 operator-(double_mt32 a, double_mt32 b) => new(a.vector0 - b.vector0, a.vector1 - b.vector1, a.vector2 - b.vector2, a.vector3 - b.vector3);

    [MethodImpl(256 | 512)]
    public static double_mt32 operator*(double_mt32 a, double_mt32 b) => new(a.vector0 * b.vector0, a.vector1 * b.vector1, a.vector2 * b.vector2, a.vector3 * b.vector3);

    [MethodImpl(256 | 512)]
    public static double_mt32 operator*(double_mt32 a, double b) => new(a.vector0 * b, a.vector1 * b, a.vector2 * b, a.vector3 * b);

    [MethodImpl(256 | 512)]
    public static double_mt32 operator*(double a, double_mt32 b) => new(a * b.vector0, a * b.vector1, a * b.vector2, a * b.vector3);

    [MethodImpl(256 | 512)]
    public static double_mt32 operator/(double_mt32 a, double_mt32 b) => new(a.vector0 / b.vector0, a.vector1 / b.vector1, a.vector2 / b.vector2, a.vector3 / b.vector3);

    [MethodImpl(256 | 512)]
    public static double_mt32 operator/(double_mt32 a, double b) => new(a.vector0 / b, a.vector1 / b, a.vector2 / b, a.vector3 / b);

    [MethodImpl(256 | 512)]
    public static double_mt32 operator%(double_mt32 a, double_mt32 b) => math_mt.rem(a, b);

    [MethodImpl(256 | 512)]
    public static double_mt32 operator%(double_mt32 a, double b) => math_mt.rem(a, b);

    [MethodImpl(256 | 512)]
    public static double_mt32 operator++(double_mt32 a) => a + One;

    [MethodImpl(256 | 512)]
    public static double_mt32 operator--(double_mt32 a) => a - One;

    #endregion
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static double_mt32 abs([This] double_mt32 a)
    {
        return new(Vector512.Abs(a.vector0), Vector512.Abs(a.vector1), Vector512.Abs(a.vector2), Vector512.Abs(a.vector3));
    }

    [MethodImpl(256 | 512)]
    public static double_mt32 sign([This] double_mt32 a)
    {
        return new(simd.SignFloat(a.vector0), simd.SignFloat(a.vector1), simd.SignFloat(a.vector2), simd.SignFloat(a.vector3));
    }

    [MethodImpl(256 | 512)]
    public static double_mt32 min([This] double_mt32 a, double_mt32 b)
    {
        return new(Vector512.Min(a.vector0, b.vector0), Vector512.Min(a.vector1, b.vector1), Vector512.Min(a.vector2, b.vector2), Vector512.Min(a.vector3, b.vector3));
    }

    [MethodImpl(256 | 512)]
    public static double_mt32 max([This] double_mt32 a, double_mt32 b)
    {
        return new(Vector512.Max(a.vector0, b.vector0), Vector512.Max(a.vector1, b.vector1), Vector512.Max(a.vector2, b.vector2), Vector512.Max(a.vector3, b.vector3));
    }

    [MethodImpl(256 | 512)]
    public static double_mt32 clamp([This] double_mt32 v, double_mt32 min, double_mt32 max)
    {
        var vector0 = Vector512.Min(max.vector0, v.vector0);
        var vector1 = Vector512.Min(max.vector1, v.vector1);
        var vector2 = Vector512.Min(max.vector2, v.vector2);
        var vector3 = Vector512.Min(max.vector3, v.vector3);
        return new(Vector512.Max(min.vector0, vector0), Vector512.Max(min.vector1, vector1), Vector512.Max(min.vector2, vector2), Vector512.Max(min.vector3, vector3));
    }

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double_mt32 fma([This] double_mt32 a, double_mt32 b, double_mt32 c)
    {
        return new(simd.Fma(a.vector0, b.vector0, c.vector0), simd.Fma(a.vector1, b.vector1, c.vector1), simd.Fma(a.vector2, b.vector2, c.vector2), simd.Fma(a.vector3, b.vector3, c.vector3));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static double_mt32 fms([This] double_mt32 a, double_mt32 b, double_mt32 c)
    {
        return new(simd.Fms(a.vector0, b.vector0, c.vector0), simd.Fms(a.vector1, b.vector1, c.vector1), simd.Fms(a.vector2, b.vector2, c.vector2), simd.Fms(a.vector3, b.vector3, c.vector3));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static double_mt32 fnma([This] double_mt32 a, double_mt32 b, double_mt32 c)
    {
        return new(simd.Fnma(a.vector0, b.vector0, c.vector0), simd.Fnma(a.vector1, b.vector1, c.vector1), simd.Fnma(a.vector2, b.vector2, c.vector2), simd.Fnma(a.vector3, b.vector3, c.vector3));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static double_mt32 fsm([This] double_mt32 c, double_mt32 a, double_mt32 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double_mt32 fam([This] double_mt32 c, double_mt32 a, double_mt32 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double_mt32 mad([This] double_mt32 a, double_mt32 b, double_mt32 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static double_mt32 lerp(double_mt32 start, double_mt32 end, [This] double_mt32 t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static double_mt32 lerp(double_mt32 start, double_mt32 end, [This] double t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static double_mt32 lerp(double start, double end, [This] double_mt32 t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static double_mt32 unlerp([This] double_mt32 a, double_mt32 start, double_mt32 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static double_mt32 unlerp([This] double a, double_mt32 start, double_mt32 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static double_mt32 unlerp([This] double_mt32 a, double start, double end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static double_mt32 remap([This] double_mt32 a, double_mt32 srcStart, double_mt32 srcEnd, double_mt32 dstStart, double_mt32 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static double_mt32 remap([This] double_mt32 a, double srcStart, double srcEnd, double dstStart, double dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static double_mt32 square([This] double_mt32 a) => a * a;
}

#endregion // double_mt32
#region int_mt4

public partial struct int_mt4
{
    #region Constants

    public static int_mt4 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static int_mt4 One
    {
        [MethodImpl(256 | 512)]
        get => new(1);
    }

    public static int_mt4 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1 + 1));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static int_mt4 operator-(int_mt4 a) => new(-a.vector);

    [MethodImpl(256 | 512)]
    public static int_mt4 operator+(int_mt4 a, int_mt4 b) => new(a.vector + b.vector);

    [MethodImpl(256 | 512)]
    public static int_mt4 operator-(int_mt4 a, int_mt4 b) => new(a.vector - b.vector);

    [MethodImpl(256 | 512)]
    public static int_mt4 operator*(int_mt4 a, int_mt4 b) => new(a.vector * b.vector);

    [MethodImpl(256 | 512)]
    public static int_mt4 operator*(int_mt4 a, int b) => new(a.vector * b);

    [MethodImpl(256 | 512)]
    public static int_mt4 operator*(int a, int_mt4 b) => new(a * b.vector);

    [MethodImpl(256 | 512)]
    public static int_mt4 operator/(int_mt4 a, int_mt4 b) => new(a.vector / b.vector);

    [MethodImpl(256 | 512)]
    public static int_mt4 operator/(int_mt4 a, int b) => new(a.vector / b);

    [MethodImpl(256 | 512)]
    public static int_mt4 operator%(int_mt4 a, int_mt4 b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static int_mt4 operator%(int_mt4 a, int b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static int_mt4 operator++(int_mt4 a) => a + One;

    [MethodImpl(256 | 512)]
    public static int_mt4 operator--(int_mt4 a) => a - One;

    #endregion
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static int_mt4 abs([This] int_mt4 a)
    {
        return new(Vector128.Abs(a.vector));
    }

    [MethodImpl(256 | 512)]
    public static int_mt4 sign([This] int_mt4 a)
    {
        return new(simd.SignInt(a.vector));
    }

    [MethodImpl(256 | 512)]
    public static int_mt4 min([This] int_mt4 a, int_mt4 b)
    {
        return new(Vector128.Min(a.vector, b.vector));
    }

    [MethodImpl(256 | 512)]
    public static int_mt4 max([This] int_mt4 a, int_mt4 b)
    {
        return new(Vector128.Max(a.vector, b.vector));
    }

    [MethodImpl(256 | 512)]
    public static int_mt4 clamp([This] int_mt4 v, int_mt4 min, int_mt4 max)
    {
        var vector = Vector128.Min(max.vector, v.vector);
        return new(Vector128.Max(min.vector, vector));
    }

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static int_mt4 fma([This] int_mt4 a, int_mt4 b, int_mt4 c)
    {
        return (a * b) + c;
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static int_mt4 fms([This] int_mt4 a, int_mt4 b, int_mt4 c)
    {
        return (a * b) - c;
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static int_mt4 fnma([This] int_mt4 a, int_mt4 b, int_mt4 c)
    {
        return c - (a * b);
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static int_mt4 fsm([This] int_mt4 c, int_mt4 a, int_mt4 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static int_mt4 fam([This] int_mt4 c, int_mt4 a, int_mt4 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static int_mt4 mad([This] int_mt4 a, int_mt4 b, int_mt4 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static int_mt4 lerp(int_mt4 start, int_mt4 end, [This] int_mt4 t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static int_mt4 lerp(int_mt4 start, int_mt4 end, [This] int t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static int_mt4 lerp(int start, int end, [This] int_mt4 t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static int_mt4 unlerp([This] int_mt4 a, int_mt4 start, int_mt4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static int_mt4 unlerp([This] int a, int_mt4 start, int_mt4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static int_mt4 unlerp([This] int_mt4 a, int start, int end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static int_mt4 remap([This] int_mt4 a, int_mt4 srcStart, int_mt4 srcEnd, int_mt4 dstStart, int_mt4 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static int_mt4 remap([This] int_mt4 a, int srcStart, int srcEnd, int dstStart, int dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static int_mt4 square([This] int_mt4 a) => a * a;
}

#endregion // int_mt4
#region int_mt8

public partial struct int_mt8
{
    #region Constants

    public static int_mt8 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static int_mt8 One
    {
        [MethodImpl(256 | 512)]
        get => new(1);
    }

    public static int_mt8 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1 + 1));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static int_mt8 operator-(int_mt8 a) => new(-a.vector);

    [MethodImpl(256 | 512)]
    public static int_mt8 operator+(int_mt8 a, int_mt8 b) => new(a.vector + b.vector);

    [MethodImpl(256 | 512)]
    public static int_mt8 operator-(int_mt8 a, int_mt8 b) => new(a.vector - b.vector);

    [MethodImpl(256 | 512)]
    public static int_mt8 operator*(int_mt8 a, int_mt8 b) => new(a.vector * b.vector);

    [MethodImpl(256 | 512)]
    public static int_mt8 operator*(int_mt8 a, int b) => new(a.vector * b);

    [MethodImpl(256 | 512)]
    public static int_mt8 operator*(int a, int_mt8 b) => new(a * b.vector);

    [MethodImpl(256 | 512)]
    public static int_mt8 operator/(int_mt8 a, int_mt8 b) => new(a.vector / b.vector);

    [MethodImpl(256 | 512)]
    public static int_mt8 operator/(int_mt8 a, int b) => new(a.vector / b);

    [MethodImpl(256 | 512)]
    public static int_mt8 operator%(int_mt8 a, int_mt8 b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static int_mt8 operator%(int_mt8 a, int b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static int_mt8 operator++(int_mt8 a) => a + One;

    [MethodImpl(256 | 512)]
    public static int_mt8 operator--(int_mt8 a) => a - One;

    #endregion
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static int_mt8 abs([This] int_mt8 a)
    {
        return new(Vector256.Abs(a.vector));
    }

    [MethodImpl(256 | 512)]
    public static int_mt8 sign([This] int_mt8 a)
    {
        return new(simd.SignInt(a.vector));
    }

    [MethodImpl(256 | 512)]
    public static int_mt8 min([This] int_mt8 a, int_mt8 b)
    {
        return new(Vector256.Min(a.vector, b.vector));
    }

    [MethodImpl(256 | 512)]
    public static int_mt8 max([This] int_mt8 a, int_mt8 b)
    {
        return new(Vector256.Max(a.vector, b.vector));
    }

    [MethodImpl(256 | 512)]
    public static int_mt8 clamp([This] int_mt8 v, int_mt8 min, int_mt8 max)
    {
        var vector = Vector256.Min(max.vector, v.vector);
        return new(Vector256.Max(min.vector, vector));
    }

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static int_mt8 fma([This] int_mt8 a, int_mt8 b, int_mt8 c)
    {
        return (a * b) + c;
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static int_mt8 fms([This] int_mt8 a, int_mt8 b, int_mt8 c)
    {
        return (a * b) - c;
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static int_mt8 fnma([This] int_mt8 a, int_mt8 b, int_mt8 c)
    {
        return c - (a * b);
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static int_mt8 fsm([This] int_mt8 c, int_mt8 a, int_mt8 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static int_mt8 fam([This] int_mt8 c, int_mt8 a, int_mt8 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static int_mt8 mad([This] int_mt8 a, int_mt8 b, int_mt8 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static int_mt8 lerp(int_mt8 start, int_mt8 end, [This] int_mt8 t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static int_mt8 lerp(int_mt8 start, int_mt8 end, [This] int t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static int_mt8 lerp(int start, int end, [This] int_mt8 t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static int_mt8 unlerp([This] int_mt8 a, int_mt8 start, int_mt8 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static int_mt8 unlerp([This] int a, int_mt8 start, int_mt8 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static int_mt8 unlerp([This] int_mt8 a, int start, int end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static int_mt8 remap([This] int_mt8 a, int_mt8 srcStart, int_mt8 srcEnd, int_mt8 dstStart, int_mt8 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static int_mt8 remap([This] int_mt8 a, int srcStart, int srcEnd, int dstStart, int dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static int_mt8 square([This] int_mt8 a) => a * a;
}

#endregion // int_mt8
#region int_mt16

public partial struct int_mt16
{
    #region Constants

    public static int_mt16 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static int_mt16 One
    {
        [MethodImpl(256 | 512)]
        get => new(1);
    }

    public static int_mt16 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1 + 1));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static int_mt16 operator-(int_mt16 a) => new(-a.vector);

    [MethodImpl(256 | 512)]
    public static int_mt16 operator+(int_mt16 a, int_mt16 b) => new(a.vector + b.vector);

    [MethodImpl(256 | 512)]
    public static int_mt16 operator-(int_mt16 a, int_mt16 b) => new(a.vector - b.vector);

    [MethodImpl(256 | 512)]
    public static int_mt16 operator*(int_mt16 a, int_mt16 b) => new(a.vector * b.vector);

    [MethodImpl(256 | 512)]
    public static int_mt16 operator*(int_mt16 a, int b) => new(a.vector * b);

    [MethodImpl(256 | 512)]
    public static int_mt16 operator*(int a, int_mt16 b) => new(a * b.vector);

    [MethodImpl(256 | 512)]
    public static int_mt16 operator/(int_mt16 a, int_mt16 b) => new(a.vector / b.vector);

    [MethodImpl(256 | 512)]
    public static int_mt16 operator/(int_mt16 a, int b) => new(a.vector / b);

    [MethodImpl(256 | 512)]
    public static int_mt16 operator%(int_mt16 a, int_mt16 b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static int_mt16 operator%(int_mt16 a, int b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static int_mt16 operator++(int_mt16 a) => a + One;

    [MethodImpl(256 | 512)]
    public static int_mt16 operator--(int_mt16 a) => a - One;

    #endregion
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static int_mt16 abs([This] int_mt16 a)
    {
        return new(Vector512.Abs(a.vector));
    }

    [MethodImpl(256 | 512)]
    public static int_mt16 sign([This] int_mt16 a)
    {
        return new(simd.SignInt(a.vector));
    }

    [MethodImpl(256 | 512)]
    public static int_mt16 min([This] int_mt16 a, int_mt16 b)
    {
        return new(Vector512.Min(a.vector, b.vector));
    }

    [MethodImpl(256 | 512)]
    public static int_mt16 max([This] int_mt16 a, int_mt16 b)
    {
        return new(Vector512.Max(a.vector, b.vector));
    }

    [MethodImpl(256 | 512)]
    public static int_mt16 clamp([This] int_mt16 v, int_mt16 min, int_mt16 max)
    {
        var vector = Vector512.Min(max.vector, v.vector);
        return new(Vector512.Max(min.vector, vector));
    }

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static int_mt16 fma([This] int_mt16 a, int_mt16 b, int_mt16 c)
    {
        return (a * b) + c;
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static int_mt16 fms([This] int_mt16 a, int_mt16 b, int_mt16 c)
    {
        return (a * b) - c;
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static int_mt16 fnma([This] int_mt16 a, int_mt16 b, int_mt16 c)
    {
        return c - (a * b);
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static int_mt16 fsm([This] int_mt16 c, int_mt16 a, int_mt16 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static int_mt16 fam([This] int_mt16 c, int_mt16 a, int_mt16 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static int_mt16 mad([This] int_mt16 a, int_mt16 b, int_mt16 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static int_mt16 lerp(int_mt16 start, int_mt16 end, [This] int_mt16 t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static int_mt16 lerp(int_mt16 start, int_mt16 end, [This] int t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static int_mt16 lerp(int start, int end, [This] int_mt16 t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static int_mt16 unlerp([This] int_mt16 a, int_mt16 start, int_mt16 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static int_mt16 unlerp([This] int a, int_mt16 start, int_mt16 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static int_mt16 unlerp([This] int_mt16 a, int start, int end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static int_mt16 remap([This] int_mt16 a, int_mt16 srcStart, int_mt16 srcEnd, int_mt16 dstStart, int_mt16 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static int_mt16 remap([This] int_mt16 a, int srcStart, int srcEnd, int dstStart, int dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static int_mt16 square([This] int_mt16 a) => a * a;
}

#endregion // int_mt16
#region int_mt32

public partial struct int_mt32
{
    #region Constants

    public static int_mt32 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static int_mt32 One
    {
        [MethodImpl(256 | 512)]
        get => new(1);
    }

    public static int_mt32 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1 + 1));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static int_mt32 operator-(int_mt32 a) => new(-a.vector0, -a.vector1);

    [MethodImpl(256 | 512)]
    public static int_mt32 operator+(int_mt32 a, int_mt32 b) => new(a.vector0 + b.vector0, a.vector1 + b.vector1);

    [MethodImpl(256 | 512)]
    public static int_mt32 operator-(int_mt32 a, int_mt32 b) => new(a.vector0 - b.vector0, a.vector1 - b.vector1);

    [MethodImpl(256 | 512)]
    public static int_mt32 operator*(int_mt32 a, int_mt32 b) => new(a.vector0 * b.vector0, a.vector1 * b.vector1);

    [MethodImpl(256 | 512)]
    public static int_mt32 operator*(int_mt32 a, int b) => new(a.vector0 * b, a.vector1 * b);

    [MethodImpl(256 | 512)]
    public static int_mt32 operator*(int a, int_mt32 b) => new(a * b.vector0, a * b.vector1);

    [MethodImpl(256 | 512)]
    public static int_mt32 operator/(int_mt32 a, int_mt32 b) => new(a.vector0 / b.vector0, a.vector1 / b.vector1);

    [MethodImpl(256 | 512)]
    public static int_mt32 operator/(int_mt32 a, int b) => new(a.vector0 / b, a.vector1 / b);

    [MethodImpl(256 | 512)]
    public static int_mt32 operator%(int_mt32 a, int_mt32 b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static int_mt32 operator%(int_mt32 a, int b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static int_mt32 operator++(int_mt32 a) => a + One;

    [MethodImpl(256 | 512)]
    public static int_mt32 operator--(int_mt32 a) => a - One;

    #endregion
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static int_mt32 abs([This] int_mt32 a)
    {
        return new(Vector512.Abs(a.vector0), Vector512.Abs(a.vector1));
    }

    [MethodImpl(256 | 512)]
    public static int_mt32 sign([This] int_mt32 a)
    {
        return new(simd.SignInt(a.vector0), simd.SignInt(a.vector1));
    }

    [MethodImpl(256 | 512)]
    public static int_mt32 min([This] int_mt32 a, int_mt32 b)
    {
        return new(Vector512.Min(a.vector0, b.vector0), Vector512.Min(a.vector1, b.vector1));
    }

    [MethodImpl(256 | 512)]
    public static int_mt32 max([This] int_mt32 a, int_mt32 b)
    {
        return new(Vector512.Max(a.vector0, b.vector0), Vector512.Max(a.vector1, b.vector1));
    }

    [MethodImpl(256 | 512)]
    public static int_mt32 clamp([This] int_mt32 v, int_mt32 min, int_mt32 max)
    {
        var vector0 = Vector512.Min(max.vector0, v.vector0);
        var vector1 = Vector512.Min(max.vector1, v.vector1);
        return new(Vector512.Max(min.vector0, vector0), Vector512.Max(min.vector1, vector1));
    }

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static int_mt32 fma([This] int_mt32 a, int_mt32 b, int_mt32 c)
    {
        return (a * b) + c;
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static int_mt32 fms([This] int_mt32 a, int_mt32 b, int_mt32 c)
    {
        return (a * b) - c;
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static int_mt32 fnma([This] int_mt32 a, int_mt32 b, int_mt32 c)
    {
        return c - (a * b);
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static int_mt32 fsm([This] int_mt32 c, int_mt32 a, int_mt32 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static int_mt32 fam([This] int_mt32 c, int_mt32 a, int_mt32 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static int_mt32 mad([This] int_mt32 a, int_mt32 b, int_mt32 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static int_mt32 lerp(int_mt32 start, int_mt32 end, [This] int_mt32 t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static int_mt32 lerp(int_mt32 start, int_mt32 end, [This] int t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static int_mt32 lerp(int start, int end, [This] int_mt32 t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static int_mt32 unlerp([This] int_mt32 a, int_mt32 start, int_mt32 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static int_mt32 unlerp([This] int a, int_mt32 start, int_mt32 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static int_mt32 unlerp([This] int_mt32 a, int start, int end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static int_mt32 remap([This] int_mt32 a, int_mt32 srcStart, int_mt32 srcEnd, int_mt32 dstStart, int_mt32 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static int_mt32 remap([This] int_mt32 a, int srcStart, int srcEnd, int dstStart, int dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static int_mt32 square([This] int_mt32 a) => a * a;
}

#endregion // int_mt32
#region uint_mt4

public partial struct uint_mt4
{
    #region Constants

    public static uint_mt4 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static uint_mt4 One
    {
        [MethodImpl(256 | 512)]
        get => new(1u);
    }

    public static uint_mt4 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1u + 1u));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static uint_mt4 operator-(uint_mt4 a) => new(-a.vector);

    [MethodImpl(256 | 512)]
    public static uint_mt4 operator+(uint_mt4 a, uint_mt4 b) => new(a.vector + b.vector);

    [MethodImpl(256 | 512)]
    public static uint_mt4 operator-(uint_mt4 a, uint_mt4 b) => new(a.vector - b.vector);

    [MethodImpl(256 | 512)]
    public static uint_mt4 operator*(uint_mt4 a, uint_mt4 b) => new(a.vector * b.vector);

    [MethodImpl(256 | 512)]
    public static uint_mt4 operator*(uint_mt4 a, uint b) => new(a.vector * b);

    [MethodImpl(256 | 512)]
    public static uint_mt4 operator*(uint a, uint_mt4 b) => new(a * b.vector);

    [MethodImpl(256 | 512)]
    public static uint_mt4 operator/(uint_mt4 a, uint_mt4 b) => new(a.vector / b.vector);

    [MethodImpl(256 | 512)]
    public static uint_mt4 operator/(uint_mt4 a, uint b) => new(a.vector / b);

    [MethodImpl(256 | 512)]
    public static uint_mt4 operator%(uint_mt4 a, uint_mt4 b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static uint_mt4 operator%(uint_mt4 a, uint b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static uint_mt4 operator++(uint_mt4 a) => a + One;

    [MethodImpl(256 | 512)]
    public static uint_mt4 operator--(uint_mt4 a) => a - One;

    #endregion
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static uint_mt4 abs([This] uint_mt4 a)
    {
        return a;
    }

    [MethodImpl(256 | 512)]
    public static uint_mt4 sign([This] uint_mt4 a)
    {
        return new(simd.SignUInt(a.vector));
    }

    [MethodImpl(256 | 512)]
    public static uint_mt4 min([This] uint_mt4 a, uint_mt4 b)
    {
        return new(Vector128.Min(a.vector, b.vector));
    }

    [MethodImpl(256 | 512)]
    public static uint_mt4 max([This] uint_mt4 a, uint_mt4 b)
    {
        return new(Vector128.Max(a.vector, b.vector));
    }

    [MethodImpl(256 | 512)]
    public static uint_mt4 clamp([This] uint_mt4 v, uint_mt4 min, uint_mt4 max)
    {
        var vector = Vector128.Min(max.vector, v.vector);
        return new(Vector128.Max(min.vector, vector));
    }

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static uint_mt4 fma([This] uint_mt4 a, uint_mt4 b, uint_mt4 c)
    {
        return (a * b) + c;
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static uint_mt4 fms([This] uint_mt4 a, uint_mt4 b, uint_mt4 c)
    {
        return (a * b) - c;
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static uint_mt4 fnma([This] uint_mt4 a, uint_mt4 b, uint_mt4 c)
    {
        return c - (a * b);
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static uint_mt4 fsm([This] uint_mt4 c, uint_mt4 a, uint_mt4 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static uint_mt4 fam([This] uint_mt4 c, uint_mt4 a, uint_mt4 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static uint_mt4 mad([This] uint_mt4 a, uint_mt4 b, uint_mt4 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static uint_mt4 lerp(uint_mt4 start, uint_mt4 end, [This] uint_mt4 t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static uint_mt4 lerp(uint_mt4 start, uint_mt4 end, [This] uint t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static uint_mt4 lerp(uint start, uint end, [This] uint_mt4 t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static uint_mt4 unlerp([This] uint_mt4 a, uint_mt4 start, uint_mt4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static uint_mt4 unlerp([This] uint a, uint_mt4 start, uint_mt4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static uint_mt4 unlerp([This] uint_mt4 a, uint start, uint end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static uint_mt4 remap([This] uint_mt4 a, uint_mt4 srcStart, uint_mt4 srcEnd, uint_mt4 dstStart, uint_mt4 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static uint_mt4 remap([This] uint_mt4 a, uint srcStart, uint srcEnd, uint dstStart, uint dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static uint_mt4 square([This] uint_mt4 a) => a * a;
}

#endregion // uint_mt4
#region uint_mt8

public partial struct uint_mt8
{
    #region Constants

    public static uint_mt8 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static uint_mt8 One
    {
        [MethodImpl(256 | 512)]
        get => new(1u);
    }

    public static uint_mt8 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1u + 1u));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static uint_mt8 operator-(uint_mt8 a) => new(-a.vector);

    [MethodImpl(256 | 512)]
    public static uint_mt8 operator+(uint_mt8 a, uint_mt8 b) => new(a.vector + b.vector);

    [MethodImpl(256 | 512)]
    public static uint_mt8 operator-(uint_mt8 a, uint_mt8 b) => new(a.vector - b.vector);

    [MethodImpl(256 | 512)]
    public static uint_mt8 operator*(uint_mt8 a, uint_mt8 b) => new(a.vector * b.vector);

    [MethodImpl(256 | 512)]
    public static uint_mt8 operator*(uint_mt8 a, uint b) => new(a.vector * b);

    [MethodImpl(256 | 512)]
    public static uint_mt8 operator*(uint a, uint_mt8 b) => new(a * b.vector);

    [MethodImpl(256 | 512)]
    public static uint_mt8 operator/(uint_mt8 a, uint_mt8 b) => new(a.vector / b.vector);

    [MethodImpl(256 | 512)]
    public static uint_mt8 operator/(uint_mt8 a, uint b) => new(a.vector / b);

    [MethodImpl(256 | 512)]
    public static uint_mt8 operator%(uint_mt8 a, uint_mt8 b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static uint_mt8 operator%(uint_mt8 a, uint b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static uint_mt8 operator++(uint_mt8 a) => a + One;

    [MethodImpl(256 | 512)]
    public static uint_mt8 operator--(uint_mt8 a) => a - One;

    #endregion
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static uint_mt8 abs([This] uint_mt8 a)
    {
        return a;
    }

    [MethodImpl(256 | 512)]
    public static uint_mt8 sign([This] uint_mt8 a)
    {
        return new(simd.SignUInt(a.vector));
    }

    [MethodImpl(256 | 512)]
    public static uint_mt8 min([This] uint_mt8 a, uint_mt8 b)
    {
        return new(Vector256.Min(a.vector, b.vector));
    }

    [MethodImpl(256 | 512)]
    public static uint_mt8 max([This] uint_mt8 a, uint_mt8 b)
    {
        return new(Vector256.Max(a.vector, b.vector));
    }

    [MethodImpl(256 | 512)]
    public static uint_mt8 clamp([This] uint_mt8 v, uint_mt8 min, uint_mt8 max)
    {
        var vector = Vector256.Min(max.vector, v.vector);
        return new(Vector256.Max(min.vector, vector));
    }

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static uint_mt8 fma([This] uint_mt8 a, uint_mt8 b, uint_mt8 c)
    {
        return (a * b) + c;
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static uint_mt8 fms([This] uint_mt8 a, uint_mt8 b, uint_mt8 c)
    {
        return (a * b) - c;
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static uint_mt8 fnma([This] uint_mt8 a, uint_mt8 b, uint_mt8 c)
    {
        return c - (a * b);
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static uint_mt8 fsm([This] uint_mt8 c, uint_mt8 a, uint_mt8 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static uint_mt8 fam([This] uint_mt8 c, uint_mt8 a, uint_mt8 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static uint_mt8 mad([This] uint_mt8 a, uint_mt8 b, uint_mt8 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static uint_mt8 lerp(uint_mt8 start, uint_mt8 end, [This] uint_mt8 t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static uint_mt8 lerp(uint_mt8 start, uint_mt8 end, [This] uint t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static uint_mt8 lerp(uint start, uint end, [This] uint_mt8 t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static uint_mt8 unlerp([This] uint_mt8 a, uint_mt8 start, uint_mt8 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static uint_mt8 unlerp([This] uint a, uint_mt8 start, uint_mt8 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static uint_mt8 unlerp([This] uint_mt8 a, uint start, uint end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static uint_mt8 remap([This] uint_mt8 a, uint_mt8 srcStart, uint_mt8 srcEnd, uint_mt8 dstStart, uint_mt8 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static uint_mt8 remap([This] uint_mt8 a, uint srcStart, uint srcEnd, uint dstStart, uint dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static uint_mt8 square([This] uint_mt8 a) => a * a;
}

#endregion // uint_mt8
#region uint_mt16

public partial struct uint_mt16
{
    #region Constants

    public static uint_mt16 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static uint_mt16 One
    {
        [MethodImpl(256 | 512)]
        get => new(1u);
    }

    public static uint_mt16 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1u + 1u));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static uint_mt16 operator-(uint_mt16 a) => new(-a.vector);

    [MethodImpl(256 | 512)]
    public static uint_mt16 operator+(uint_mt16 a, uint_mt16 b) => new(a.vector + b.vector);

    [MethodImpl(256 | 512)]
    public static uint_mt16 operator-(uint_mt16 a, uint_mt16 b) => new(a.vector - b.vector);

    [MethodImpl(256 | 512)]
    public static uint_mt16 operator*(uint_mt16 a, uint_mt16 b) => new(a.vector * b.vector);

    [MethodImpl(256 | 512)]
    public static uint_mt16 operator*(uint_mt16 a, uint b) => new(a.vector * b);

    [MethodImpl(256 | 512)]
    public static uint_mt16 operator*(uint a, uint_mt16 b) => new(a * b.vector);

    [MethodImpl(256 | 512)]
    public static uint_mt16 operator/(uint_mt16 a, uint_mt16 b) => new(a.vector / b.vector);

    [MethodImpl(256 | 512)]
    public static uint_mt16 operator/(uint_mt16 a, uint b) => new(a.vector / b);

    [MethodImpl(256 | 512)]
    public static uint_mt16 operator%(uint_mt16 a, uint_mt16 b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static uint_mt16 operator%(uint_mt16 a, uint b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static uint_mt16 operator++(uint_mt16 a) => a + One;

    [MethodImpl(256 | 512)]
    public static uint_mt16 operator--(uint_mt16 a) => a - One;

    #endregion
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static uint_mt16 abs([This] uint_mt16 a)
    {
        return a;
    }

    [MethodImpl(256 | 512)]
    public static uint_mt16 sign([This] uint_mt16 a)
    {
        return new(simd.SignUInt(a.vector));
    }

    [MethodImpl(256 | 512)]
    public static uint_mt16 min([This] uint_mt16 a, uint_mt16 b)
    {
        return new(Vector512.Min(a.vector, b.vector));
    }

    [MethodImpl(256 | 512)]
    public static uint_mt16 max([This] uint_mt16 a, uint_mt16 b)
    {
        return new(Vector512.Max(a.vector, b.vector));
    }

    [MethodImpl(256 | 512)]
    public static uint_mt16 clamp([This] uint_mt16 v, uint_mt16 min, uint_mt16 max)
    {
        var vector = Vector512.Min(max.vector, v.vector);
        return new(Vector512.Max(min.vector, vector));
    }

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static uint_mt16 fma([This] uint_mt16 a, uint_mt16 b, uint_mt16 c)
    {
        return (a * b) + c;
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static uint_mt16 fms([This] uint_mt16 a, uint_mt16 b, uint_mt16 c)
    {
        return (a * b) - c;
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static uint_mt16 fnma([This] uint_mt16 a, uint_mt16 b, uint_mt16 c)
    {
        return c - (a * b);
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static uint_mt16 fsm([This] uint_mt16 c, uint_mt16 a, uint_mt16 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static uint_mt16 fam([This] uint_mt16 c, uint_mt16 a, uint_mt16 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static uint_mt16 mad([This] uint_mt16 a, uint_mt16 b, uint_mt16 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static uint_mt16 lerp(uint_mt16 start, uint_mt16 end, [This] uint_mt16 t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static uint_mt16 lerp(uint_mt16 start, uint_mt16 end, [This] uint t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static uint_mt16 lerp(uint start, uint end, [This] uint_mt16 t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static uint_mt16 unlerp([This] uint_mt16 a, uint_mt16 start, uint_mt16 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static uint_mt16 unlerp([This] uint a, uint_mt16 start, uint_mt16 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static uint_mt16 unlerp([This] uint_mt16 a, uint start, uint end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static uint_mt16 remap([This] uint_mt16 a, uint_mt16 srcStart, uint_mt16 srcEnd, uint_mt16 dstStart, uint_mt16 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static uint_mt16 remap([This] uint_mt16 a, uint srcStart, uint srcEnd, uint dstStart, uint dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static uint_mt16 square([This] uint_mt16 a) => a * a;
}

#endregion // uint_mt16
#region uint_mt32

public partial struct uint_mt32
{
    #region Constants

    public static uint_mt32 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static uint_mt32 One
    {
        [MethodImpl(256 | 512)]
        get => new(1u);
    }

    public static uint_mt32 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1u + 1u));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static uint_mt32 operator-(uint_mt32 a) => new(-a.vector0, -a.vector1);

    [MethodImpl(256 | 512)]
    public static uint_mt32 operator+(uint_mt32 a, uint_mt32 b) => new(a.vector0 + b.vector0, a.vector1 + b.vector1);

    [MethodImpl(256 | 512)]
    public static uint_mt32 operator-(uint_mt32 a, uint_mt32 b) => new(a.vector0 - b.vector0, a.vector1 - b.vector1);

    [MethodImpl(256 | 512)]
    public static uint_mt32 operator*(uint_mt32 a, uint_mt32 b) => new(a.vector0 * b.vector0, a.vector1 * b.vector1);

    [MethodImpl(256 | 512)]
    public static uint_mt32 operator*(uint_mt32 a, uint b) => new(a.vector0 * b, a.vector1 * b);

    [MethodImpl(256 | 512)]
    public static uint_mt32 operator*(uint a, uint_mt32 b) => new(a * b.vector0, a * b.vector1);

    [MethodImpl(256 | 512)]
    public static uint_mt32 operator/(uint_mt32 a, uint_mt32 b) => new(a.vector0 / b.vector0, a.vector1 / b.vector1);

    [MethodImpl(256 | 512)]
    public static uint_mt32 operator/(uint_mt32 a, uint b) => new(a.vector0 / b, a.vector1 / b);

    [MethodImpl(256 | 512)]
    public static uint_mt32 operator%(uint_mt32 a, uint_mt32 b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static uint_mt32 operator%(uint_mt32 a, uint b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static uint_mt32 operator++(uint_mt32 a) => a + One;

    [MethodImpl(256 | 512)]
    public static uint_mt32 operator--(uint_mt32 a) => a - One;

    #endregion
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static uint_mt32 abs([This] uint_mt32 a)
    {
        return a;
    }

    [MethodImpl(256 | 512)]
    public static uint_mt32 sign([This] uint_mt32 a)
    {
        return new(simd.SignUInt(a.vector0), simd.SignUInt(a.vector1));
    }

    [MethodImpl(256 | 512)]
    public static uint_mt32 min([This] uint_mt32 a, uint_mt32 b)
    {
        return new(Vector512.Min(a.vector0, b.vector0), Vector512.Min(a.vector1, b.vector1));
    }

    [MethodImpl(256 | 512)]
    public static uint_mt32 max([This] uint_mt32 a, uint_mt32 b)
    {
        return new(Vector512.Max(a.vector0, b.vector0), Vector512.Max(a.vector1, b.vector1));
    }

    [MethodImpl(256 | 512)]
    public static uint_mt32 clamp([This] uint_mt32 v, uint_mt32 min, uint_mt32 max)
    {
        var vector0 = Vector512.Min(max.vector0, v.vector0);
        var vector1 = Vector512.Min(max.vector1, v.vector1);
        return new(Vector512.Max(min.vector0, vector0), Vector512.Max(min.vector1, vector1));
    }

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static uint_mt32 fma([This] uint_mt32 a, uint_mt32 b, uint_mt32 c)
    {
        return (a * b) + c;
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static uint_mt32 fms([This] uint_mt32 a, uint_mt32 b, uint_mt32 c)
    {
        return (a * b) - c;
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static uint_mt32 fnma([This] uint_mt32 a, uint_mt32 b, uint_mt32 c)
    {
        return c - (a * b);
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static uint_mt32 fsm([This] uint_mt32 c, uint_mt32 a, uint_mt32 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static uint_mt32 fam([This] uint_mt32 c, uint_mt32 a, uint_mt32 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static uint_mt32 mad([This] uint_mt32 a, uint_mt32 b, uint_mt32 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static uint_mt32 lerp(uint_mt32 start, uint_mt32 end, [This] uint_mt32 t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static uint_mt32 lerp(uint_mt32 start, uint_mt32 end, [This] uint t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static uint_mt32 lerp(uint start, uint end, [This] uint_mt32 t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static uint_mt32 unlerp([This] uint_mt32 a, uint_mt32 start, uint_mt32 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static uint_mt32 unlerp([This] uint a, uint_mt32 start, uint_mt32 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static uint_mt32 unlerp([This] uint_mt32 a, uint start, uint end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static uint_mt32 remap([This] uint_mt32 a, uint_mt32 srcStart, uint_mt32 srcEnd, uint_mt32 dstStart, uint_mt32 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static uint_mt32 remap([This] uint_mt32 a, uint srcStart, uint srcEnd, uint dstStart, uint dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static uint_mt32 square([This] uint_mt32 a) => a * a;
}

#endregion // uint_mt32
#region long_mt4

public partial struct long_mt4
{
    #region Constants

    public static long_mt4 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static long_mt4 One
    {
        [MethodImpl(256 | 512)]
        get => new(1L);
    }

    public static long_mt4 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1L + 1L));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static long_mt4 operator-(long_mt4 a) => new(-a.vector);

    [MethodImpl(256 | 512)]
    public static long_mt4 operator+(long_mt4 a, long_mt4 b) => new(a.vector + b.vector);

    [MethodImpl(256 | 512)]
    public static long_mt4 operator-(long_mt4 a, long_mt4 b) => new(a.vector - b.vector);

    [MethodImpl(256 | 512)]
    public static long_mt4 operator*(long_mt4 a, long_mt4 b) => new(a.vector * b.vector);

    [MethodImpl(256 | 512)]
    public static long_mt4 operator*(long_mt4 a, long b) => new(a.vector * b);

    [MethodImpl(256 | 512)]
    public static long_mt4 operator*(long a, long_mt4 b) => new(a * b.vector);

    [MethodImpl(256 | 512)]
    public static long_mt4 operator/(long_mt4 a, long_mt4 b) => new(a.vector / b.vector);

    [MethodImpl(256 | 512)]
    public static long_mt4 operator/(long_mt4 a, long b) => new(a.vector / b);

    [MethodImpl(256 | 512)]
    public static long_mt4 operator%(long_mt4 a, long_mt4 b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static long_mt4 operator%(long_mt4 a, long b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static long_mt4 operator++(long_mt4 a) => a + One;

    [MethodImpl(256 | 512)]
    public static long_mt4 operator--(long_mt4 a) => a - One;

    #endregion
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static long_mt4 abs([This] long_mt4 a)
    {
        return new(Vector256.Abs(a.vector));
    }

    [MethodImpl(256 | 512)]
    public static long_mt4 sign([This] long_mt4 a)
    {
        return new(simd.SignInt(a.vector));
    }

    [MethodImpl(256 | 512)]
    public static long_mt4 min([This] long_mt4 a, long_mt4 b)
    {
        return new(Vector256.Min(a.vector, b.vector));
    }

    [MethodImpl(256 | 512)]
    public static long_mt4 max([This] long_mt4 a, long_mt4 b)
    {
        return new(Vector256.Max(a.vector, b.vector));
    }

    [MethodImpl(256 | 512)]
    public static long_mt4 clamp([This] long_mt4 v, long_mt4 min, long_mt4 max)
    {
        var vector = Vector256.Min(max.vector, v.vector);
        return new(Vector256.Max(min.vector, vector));
    }

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static long_mt4 fma([This] long_mt4 a, long_mt4 b, long_mt4 c)
    {
        return (a * b) + c;
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static long_mt4 fms([This] long_mt4 a, long_mt4 b, long_mt4 c)
    {
        return (a * b) - c;
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static long_mt4 fnma([This] long_mt4 a, long_mt4 b, long_mt4 c)
    {
        return c - (a * b);
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static long_mt4 fsm([This] long_mt4 c, long_mt4 a, long_mt4 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static long_mt4 fam([This] long_mt4 c, long_mt4 a, long_mt4 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static long_mt4 mad([This] long_mt4 a, long_mt4 b, long_mt4 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static long_mt4 lerp(long_mt4 start, long_mt4 end, [This] long_mt4 t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static long_mt4 lerp(long_mt4 start, long_mt4 end, [This] long t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static long_mt4 lerp(long start, long end, [This] long_mt4 t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static long_mt4 unlerp([This] long_mt4 a, long_mt4 start, long_mt4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static long_mt4 unlerp([This] long a, long_mt4 start, long_mt4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static long_mt4 unlerp([This] long_mt4 a, long start, long end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static long_mt4 remap([This] long_mt4 a, long_mt4 srcStart, long_mt4 srcEnd, long_mt4 dstStart, long_mt4 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static long_mt4 remap([This] long_mt4 a, long srcStart, long srcEnd, long dstStart, long dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static long_mt4 square([This] long_mt4 a) => a * a;
}

#endregion // long_mt4
#region long_mt8

public partial struct long_mt8
{
    #region Constants

    public static long_mt8 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static long_mt8 One
    {
        [MethodImpl(256 | 512)]
        get => new(1L);
    }

    public static long_mt8 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1L + 1L));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static long_mt8 operator-(long_mt8 a) => new(-a.vector);

    [MethodImpl(256 | 512)]
    public static long_mt8 operator+(long_mt8 a, long_mt8 b) => new(a.vector + b.vector);

    [MethodImpl(256 | 512)]
    public static long_mt8 operator-(long_mt8 a, long_mt8 b) => new(a.vector - b.vector);

    [MethodImpl(256 | 512)]
    public static long_mt8 operator*(long_mt8 a, long_mt8 b) => new(a.vector * b.vector);

    [MethodImpl(256 | 512)]
    public static long_mt8 operator*(long_mt8 a, long b) => new(a.vector * b);

    [MethodImpl(256 | 512)]
    public static long_mt8 operator*(long a, long_mt8 b) => new(a * b.vector);

    [MethodImpl(256 | 512)]
    public static long_mt8 operator/(long_mt8 a, long_mt8 b) => new(a.vector / b.vector);

    [MethodImpl(256 | 512)]
    public static long_mt8 operator/(long_mt8 a, long b) => new(a.vector / b);

    [MethodImpl(256 | 512)]
    public static long_mt8 operator%(long_mt8 a, long_mt8 b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static long_mt8 operator%(long_mt8 a, long b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static long_mt8 operator++(long_mt8 a) => a + One;

    [MethodImpl(256 | 512)]
    public static long_mt8 operator--(long_mt8 a) => a - One;

    #endregion
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static long_mt8 abs([This] long_mt8 a)
    {
        return new(Vector512.Abs(a.vector));
    }

    [MethodImpl(256 | 512)]
    public static long_mt8 sign([This] long_mt8 a)
    {
        return new(simd.SignInt(a.vector));
    }

    [MethodImpl(256 | 512)]
    public static long_mt8 min([This] long_mt8 a, long_mt8 b)
    {
        return new(Vector512.Min(a.vector, b.vector));
    }

    [MethodImpl(256 | 512)]
    public static long_mt8 max([This] long_mt8 a, long_mt8 b)
    {
        return new(Vector512.Max(a.vector, b.vector));
    }

    [MethodImpl(256 | 512)]
    public static long_mt8 clamp([This] long_mt8 v, long_mt8 min, long_mt8 max)
    {
        var vector = Vector512.Min(max.vector, v.vector);
        return new(Vector512.Max(min.vector, vector));
    }

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static long_mt8 fma([This] long_mt8 a, long_mt8 b, long_mt8 c)
    {
        return (a * b) + c;
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static long_mt8 fms([This] long_mt8 a, long_mt8 b, long_mt8 c)
    {
        return (a * b) - c;
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static long_mt8 fnma([This] long_mt8 a, long_mt8 b, long_mt8 c)
    {
        return c - (a * b);
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static long_mt8 fsm([This] long_mt8 c, long_mt8 a, long_mt8 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static long_mt8 fam([This] long_mt8 c, long_mt8 a, long_mt8 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static long_mt8 mad([This] long_mt8 a, long_mt8 b, long_mt8 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static long_mt8 lerp(long_mt8 start, long_mt8 end, [This] long_mt8 t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static long_mt8 lerp(long_mt8 start, long_mt8 end, [This] long t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static long_mt8 lerp(long start, long end, [This] long_mt8 t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static long_mt8 unlerp([This] long_mt8 a, long_mt8 start, long_mt8 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static long_mt8 unlerp([This] long a, long_mt8 start, long_mt8 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static long_mt8 unlerp([This] long_mt8 a, long start, long end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static long_mt8 remap([This] long_mt8 a, long_mt8 srcStart, long_mt8 srcEnd, long_mt8 dstStart, long_mt8 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static long_mt8 remap([This] long_mt8 a, long srcStart, long srcEnd, long dstStart, long dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static long_mt8 square([This] long_mt8 a) => a * a;
}

#endregion // long_mt8
#region long_mt16

public partial struct long_mt16
{
    #region Constants

    public static long_mt16 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static long_mt16 One
    {
        [MethodImpl(256 | 512)]
        get => new(1L);
    }

    public static long_mt16 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1L + 1L));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static long_mt16 operator-(long_mt16 a) => new(-a.vector0, -a.vector1);

    [MethodImpl(256 | 512)]
    public static long_mt16 operator+(long_mt16 a, long_mt16 b) => new(a.vector0 + b.vector0, a.vector1 + b.vector1);

    [MethodImpl(256 | 512)]
    public static long_mt16 operator-(long_mt16 a, long_mt16 b) => new(a.vector0 - b.vector0, a.vector1 - b.vector1);

    [MethodImpl(256 | 512)]
    public static long_mt16 operator*(long_mt16 a, long_mt16 b) => new(a.vector0 * b.vector0, a.vector1 * b.vector1);

    [MethodImpl(256 | 512)]
    public static long_mt16 operator*(long_mt16 a, long b) => new(a.vector0 * b, a.vector1 * b);

    [MethodImpl(256 | 512)]
    public static long_mt16 operator*(long a, long_mt16 b) => new(a * b.vector0, a * b.vector1);

    [MethodImpl(256 | 512)]
    public static long_mt16 operator/(long_mt16 a, long_mt16 b) => new(a.vector0 / b.vector0, a.vector1 / b.vector1);

    [MethodImpl(256 | 512)]
    public static long_mt16 operator/(long_mt16 a, long b) => new(a.vector0 / b, a.vector1 / b);

    [MethodImpl(256 | 512)]
    public static long_mt16 operator%(long_mt16 a, long_mt16 b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static long_mt16 operator%(long_mt16 a, long b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static long_mt16 operator++(long_mt16 a) => a + One;

    [MethodImpl(256 | 512)]
    public static long_mt16 operator--(long_mt16 a) => a - One;

    #endregion
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static long_mt16 abs([This] long_mt16 a)
    {
        return new(Vector512.Abs(a.vector0), Vector512.Abs(a.vector1));
    }

    [MethodImpl(256 | 512)]
    public static long_mt16 sign([This] long_mt16 a)
    {
        return new(simd.SignInt(a.vector0), simd.SignInt(a.vector1));
    }

    [MethodImpl(256 | 512)]
    public static long_mt16 min([This] long_mt16 a, long_mt16 b)
    {
        return new(Vector512.Min(a.vector0, b.vector0), Vector512.Min(a.vector1, b.vector1));
    }

    [MethodImpl(256 | 512)]
    public static long_mt16 max([This] long_mt16 a, long_mt16 b)
    {
        return new(Vector512.Max(a.vector0, b.vector0), Vector512.Max(a.vector1, b.vector1));
    }

    [MethodImpl(256 | 512)]
    public static long_mt16 clamp([This] long_mt16 v, long_mt16 min, long_mt16 max)
    {
        var vector0 = Vector512.Min(max.vector0, v.vector0);
        var vector1 = Vector512.Min(max.vector1, v.vector1);
        return new(Vector512.Max(min.vector0, vector0), Vector512.Max(min.vector1, vector1));
    }

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static long_mt16 fma([This] long_mt16 a, long_mt16 b, long_mt16 c)
    {
        return (a * b) + c;
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static long_mt16 fms([This] long_mt16 a, long_mt16 b, long_mt16 c)
    {
        return (a * b) - c;
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static long_mt16 fnma([This] long_mt16 a, long_mt16 b, long_mt16 c)
    {
        return c - (a * b);
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static long_mt16 fsm([This] long_mt16 c, long_mt16 a, long_mt16 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static long_mt16 fam([This] long_mt16 c, long_mt16 a, long_mt16 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static long_mt16 mad([This] long_mt16 a, long_mt16 b, long_mt16 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static long_mt16 lerp(long_mt16 start, long_mt16 end, [This] long_mt16 t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static long_mt16 lerp(long_mt16 start, long_mt16 end, [This] long t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static long_mt16 lerp(long start, long end, [This] long_mt16 t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static long_mt16 unlerp([This] long_mt16 a, long_mt16 start, long_mt16 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static long_mt16 unlerp([This] long a, long_mt16 start, long_mt16 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static long_mt16 unlerp([This] long_mt16 a, long start, long end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static long_mt16 remap([This] long_mt16 a, long_mt16 srcStart, long_mt16 srcEnd, long_mt16 dstStart, long_mt16 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static long_mt16 remap([This] long_mt16 a, long srcStart, long srcEnd, long dstStart, long dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static long_mt16 square([This] long_mt16 a) => a * a;
}

#endregion // long_mt16
#region long_mt32

public partial struct long_mt32
{
    #region Constants

    public static long_mt32 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static long_mt32 One
    {
        [MethodImpl(256 | 512)]
        get => new(1L);
    }

    public static long_mt32 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1L + 1L));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static long_mt32 operator-(long_mt32 a) => new(-a.vector0, -a.vector1, -a.vector2, -a.vector3);

    [MethodImpl(256 | 512)]
    public static long_mt32 operator+(long_mt32 a, long_mt32 b) => new(a.vector0 + b.vector0, a.vector1 + b.vector1, a.vector2 + b.vector2, a.vector3 + b.vector3);

    [MethodImpl(256 | 512)]
    public static long_mt32 operator-(long_mt32 a, long_mt32 b) => new(a.vector0 - b.vector0, a.vector1 - b.vector1, a.vector2 - b.vector2, a.vector3 - b.vector3);

    [MethodImpl(256 | 512)]
    public static long_mt32 operator*(long_mt32 a, long_mt32 b) => new(a.vector0 * b.vector0, a.vector1 * b.vector1, a.vector2 * b.vector2, a.vector3 * b.vector3);

    [MethodImpl(256 | 512)]
    public static long_mt32 operator*(long_mt32 a, long b) => new(a.vector0 * b, a.vector1 * b, a.vector2 * b, a.vector3 * b);

    [MethodImpl(256 | 512)]
    public static long_mt32 operator*(long a, long_mt32 b) => new(a * b.vector0, a * b.vector1, a * b.vector2, a * b.vector3);

    [MethodImpl(256 | 512)]
    public static long_mt32 operator/(long_mt32 a, long_mt32 b) => new(a.vector0 / b.vector0, a.vector1 / b.vector1, a.vector2 / b.vector2, a.vector3 / b.vector3);

    [MethodImpl(256 | 512)]
    public static long_mt32 operator/(long_mt32 a, long b) => new(a.vector0 / b, a.vector1 / b, a.vector2 / b, a.vector3 / b);

    [MethodImpl(256 | 512)]
    public static long_mt32 operator%(long_mt32 a, long_mt32 b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static long_mt32 operator%(long_mt32 a, long b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static long_mt32 operator++(long_mt32 a) => a + One;

    [MethodImpl(256 | 512)]
    public static long_mt32 operator--(long_mt32 a) => a - One;

    #endregion
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static long_mt32 abs([This] long_mt32 a)
    {
        return new(Vector512.Abs(a.vector0), Vector512.Abs(a.vector1), Vector512.Abs(a.vector2), Vector512.Abs(a.vector3));
    }

    [MethodImpl(256 | 512)]
    public static long_mt32 sign([This] long_mt32 a)
    {
        return new(simd.SignInt(a.vector0), simd.SignInt(a.vector1), simd.SignInt(a.vector2), simd.SignInt(a.vector3));
    }

    [MethodImpl(256 | 512)]
    public static long_mt32 min([This] long_mt32 a, long_mt32 b)
    {
        return new(Vector512.Min(a.vector0, b.vector0), Vector512.Min(a.vector1, b.vector1), Vector512.Min(a.vector2, b.vector2), Vector512.Min(a.vector3, b.vector3));
    }

    [MethodImpl(256 | 512)]
    public static long_mt32 max([This] long_mt32 a, long_mt32 b)
    {
        return new(Vector512.Max(a.vector0, b.vector0), Vector512.Max(a.vector1, b.vector1), Vector512.Max(a.vector2, b.vector2), Vector512.Max(a.vector3, b.vector3));
    }

    [MethodImpl(256 | 512)]
    public static long_mt32 clamp([This] long_mt32 v, long_mt32 min, long_mt32 max)
    {
        var vector0 = Vector512.Min(max.vector0, v.vector0);
        var vector1 = Vector512.Min(max.vector1, v.vector1);
        var vector2 = Vector512.Min(max.vector2, v.vector2);
        var vector3 = Vector512.Min(max.vector3, v.vector3);
        return new(Vector512.Max(min.vector0, vector0), Vector512.Max(min.vector1, vector1), Vector512.Max(min.vector2, vector2), Vector512.Max(min.vector3, vector3));
    }

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static long_mt32 fma([This] long_mt32 a, long_mt32 b, long_mt32 c)
    {
        return (a * b) + c;
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static long_mt32 fms([This] long_mt32 a, long_mt32 b, long_mt32 c)
    {
        return (a * b) - c;
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static long_mt32 fnma([This] long_mt32 a, long_mt32 b, long_mt32 c)
    {
        return c - (a * b);
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static long_mt32 fsm([This] long_mt32 c, long_mt32 a, long_mt32 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static long_mt32 fam([This] long_mt32 c, long_mt32 a, long_mt32 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static long_mt32 mad([This] long_mt32 a, long_mt32 b, long_mt32 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static long_mt32 lerp(long_mt32 start, long_mt32 end, [This] long_mt32 t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static long_mt32 lerp(long_mt32 start, long_mt32 end, [This] long t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static long_mt32 lerp(long start, long end, [This] long_mt32 t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static long_mt32 unlerp([This] long_mt32 a, long_mt32 start, long_mt32 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static long_mt32 unlerp([This] long a, long_mt32 start, long_mt32 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static long_mt32 unlerp([This] long_mt32 a, long start, long end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static long_mt32 remap([This] long_mt32 a, long_mt32 srcStart, long_mt32 srcEnd, long_mt32 dstStart, long_mt32 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static long_mt32 remap([This] long_mt32 a, long srcStart, long srcEnd, long dstStart, long dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static long_mt32 square([This] long_mt32 a) => a * a;
}

#endregion // long_mt32
#region ulong_mt4

public partial struct ulong_mt4
{
    #region Constants

    public static ulong_mt4 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static ulong_mt4 One
    {
        [MethodImpl(256 | 512)]
        get => new(1UL);
    }

    public static ulong_mt4 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1UL + 1UL));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static ulong_mt4 operator-(ulong_mt4 a) => new(-a.vector);

    [MethodImpl(256 | 512)]
    public static ulong_mt4 operator+(ulong_mt4 a, ulong_mt4 b) => new(a.vector + b.vector);

    [MethodImpl(256 | 512)]
    public static ulong_mt4 operator-(ulong_mt4 a, ulong_mt4 b) => new(a.vector - b.vector);

    [MethodImpl(256 | 512)]
    public static ulong_mt4 operator*(ulong_mt4 a, ulong_mt4 b) => new(a.vector * b.vector);

    [MethodImpl(256 | 512)]
    public static ulong_mt4 operator*(ulong_mt4 a, ulong b) => new(a.vector * b);

    [MethodImpl(256 | 512)]
    public static ulong_mt4 operator*(ulong a, ulong_mt4 b) => new(a * b.vector);

    [MethodImpl(256 | 512)]
    public static ulong_mt4 operator/(ulong_mt4 a, ulong_mt4 b) => new(a.vector / b.vector);

    [MethodImpl(256 | 512)]
    public static ulong_mt4 operator/(ulong_mt4 a, ulong b) => new(a.vector / b);

    [MethodImpl(256 | 512)]
    public static ulong_mt4 operator%(ulong_mt4 a, ulong_mt4 b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static ulong_mt4 operator%(ulong_mt4 a, ulong b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static ulong_mt4 operator++(ulong_mt4 a) => a + One;

    [MethodImpl(256 | 512)]
    public static ulong_mt4 operator--(ulong_mt4 a) => a - One;

    #endregion
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static ulong_mt4 abs([This] ulong_mt4 a)
    {
        return a;
    }

    [MethodImpl(256 | 512)]
    public static ulong_mt4 sign([This] ulong_mt4 a)
    {
        return new(simd.SignUInt(a.vector));
    }

    [MethodImpl(256 | 512)]
    public static ulong_mt4 min([This] ulong_mt4 a, ulong_mt4 b)
    {
        return new(Vector256.Min(a.vector, b.vector));
    }

    [MethodImpl(256 | 512)]
    public static ulong_mt4 max([This] ulong_mt4 a, ulong_mt4 b)
    {
        return new(Vector256.Max(a.vector, b.vector));
    }

    [MethodImpl(256 | 512)]
    public static ulong_mt4 clamp([This] ulong_mt4 v, ulong_mt4 min, ulong_mt4 max)
    {
        var vector = Vector256.Min(max.vector, v.vector);
        return new(Vector256.Max(min.vector, vector));
    }

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ulong_mt4 fma([This] ulong_mt4 a, ulong_mt4 b, ulong_mt4 c)
    {
        return (a * b) + c;
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static ulong_mt4 fms([This] ulong_mt4 a, ulong_mt4 b, ulong_mt4 c)
    {
        return (a * b) - c;
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static ulong_mt4 fnma([This] ulong_mt4 a, ulong_mt4 b, ulong_mt4 c)
    {
        return c - (a * b);
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static ulong_mt4 fsm([This] ulong_mt4 c, ulong_mt4 a, ulong_mt4 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ulong_mt4 fam([This] ulong_mt4 c, ulong_mt4 a, ulong_mt4 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ulong_mt4 mad([This] ulong_mt4 a, ulong_mt4 b, ulong_mt4 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static ulong_mt4 lerp(ulong_mt4 start, ulong_mt4 end, [This] ulong_mt4 t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static ulong_mt4 lerp(ulong_mt4 start, ulong_mt4 end, [This] ulong t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static ulong_mt4 lerp(ulong start, ulong end, [This] ulong_mt4 t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static ulong_mt4 unlerp([This] ulong_mt4 a, ulong_mt4 start, ulong_mt4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ulong_mt4 unlerp([This] ulong a, ulong_mt4 start, ulong_mt4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ulong_mt4 unlerp([This] ulong_mt4 a, ulong start, ulong end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ulong_mt4 remap([This] ulong_mt4 a, ulong_mt4 srcStart, ulong_mt4 srcEnd, ulong_mt4 dstStart, ulong_mt4 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static ulong_mt4 remap([This] ulong_mt4 a, ulong srcStart, ulong srcEnd, ulong dstStart, ulong dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static ulong_mt4 square([This] ulong_mt4 a) => a * a;
}

#endregion // ulong_mt4
#region ulong_mt8

public partial struct ulong_mt8
{
    #region Constants

    public static ulong_mt8 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static ulong_mt8 One
    {
        [MethodImpl(256 | 512)]
        get => new(1UL);
    }

    public static ulong_mt8 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1UL + 1UL));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static ulong_mt8 operator-(ulong_mt8 a) => new(-a.vector);

    [MethodImpl(256 | 512)]
    public static ulong_mt8 operator+(ulong_mt8 a, ulong_mt8 b) => new(a.vector + b.vector);

    [MethodImpl(256 | 512)]
    public static ulong_mt8 operator-(ulong_mt8 a, ulong_mt8 b) => new(a.vector - b.vector);

    [MethodImpl(256 | 512)]
    public static ulong_mt8 operator*(ulong_mt8 a, ulong_mt8 b) => new(a.vector * b.vector);

    [MethodImpl(256 | 512)]
    public static ulong_mt8 operator*(ulong_mt8 a, ulong b) => new(a.vector * b);

    [MethodImpl(256 | 512)]
    public static ulong_mt8 operator*(ulong a, ulong_mt8 b) => new(a * b.vector);

    [MethodImpl(256 | 512)]
    public static ulong_mt8 operator/(ulong_mt8 a, ulong_mt8 b) => new(a.vector / b.vector);

    [MethodImpl(256 | 512)]
    public static ulong_mt8 operator/(ulong_mt8 a, ulong b) => new(a.vector / b);

    [MethodImpl(256 | 512)]
    public static ulong_mt8 operator%(ulong_mt8 a, ulong_mt8 b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static ulong_mt8 operator%(ulong_mt8 a, ulong b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static ulong_mt8 operator++(ulong_mt8 a) => a + One;

    [MethodImpl(256 | 512)]
    public static ulong_mt8 operator--(ulong_mt8 a) => a - One;

    #endregion
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static ulong_mt8 abs([This] ulong_mt8 a)
    {
        return a;
    }

    [MethodImpl(256 | 512)]
    public static ulong_mt8 sign([This] ulong_mt8 a)
    {
        return new(simd.SignUInt(a.vector));
    }

    [MethodImpl(256 | 512)]
    public static ulong_mt8 min([This] ulong_mt8 a, ulong_mt8 b)
    {
        return new(Vector512.Min(a.vector, b.vector));
    }

    [MethodImpl(256 | 512)]
    public static ulong_mt8 max([This] ulong_mt8 a, ulong_mt8 b)
    {
        return new(Vector512.Max(a.vector, b.vector));
    }

    [MethodImpl(256 | 512)]
    public static ulong_mt8 clamp([This] ulong_mt8 v, ulong_mt8 min, ulong_mt8 max)
    {
        var vector = Vector512.Min(max.vector, v.vector);
        return new(Vector512.Max(min.vector, vector));
    }

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ulong_mt8 fma([This] ulong_mt8 a, ulong_mt8 b, ulong_mt8 c)
    {
        return (a * b) + c;
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static ulong_mt8 fms([This] ulong_mt8 a, ulong_mt8 b, ulong_mt8 c)
    {
        return (a * b) - c;
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static ulong_mt8 fnma([This] ulong_mt8 a, ulong_mt8 b, ulong_mt8 c)
    {
        return c - (a * b);
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static ulong_mt8 fsm([This] ulong_mt8 c, ulong_mt8 a, ulong_mt8 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ulong_mt8 fam([This] ulong_mt8 c, ulong_mt8 a, ulong_mt8 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ulong_mt8 mad([This] ulong_mt8 a, ulong_mt8 b, ulong_mt8 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static ulong_mt8 lerp(ulong_mt8 start, ulong_mt8 end, [This] ulong_mt8 t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static ulong_mt8 lerp(ulong_mt8 start, ulong_mt8 end, [This] ulong t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static ulong_mt8 lerp(ulong start, ulong end, [This] ulong_mt8 t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static ulong_mt8 unlerp([This] ulong_mt8 a, ulong_mt8 start, ulong_mt8 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ulong_mt8 unlerp([This] ulong a, ulong_mt8 start, ulong_mt8 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ulong_mt8 unlerp([This] ulong_mt8 a, ulong start, ulong end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ulong_mt8 remap([This] ulong_mt8 a, ulong_mt8 srcStart, ulong_mt8 srcEnd, ulong_mt8 dstStart, ulong_mt8 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static ulong_mt8 remap([This] ulong_mt8 a, ulong srcStart, ulong srcEnd, ulong dstStart, ulong dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static ulong_mt8 square([This] ulong_mt8 a) => a * a;
}

#endregion // ulong_mt8
#region ulong_mt16

public partial struct ulong_mt16
{
    #region Constants

    public static ulong_mt16 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static ulong_mt16 One
    {
        [MethodImpl(256 | 512)]
        get => new(1UL);
    }

    public static ulong_mt16 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1UL + 1UL));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static ulong_mt16 operator-(ulong_mt16 a) => new(-a.vector0, -a.vector1);

    [MethodImpl(256 | 512)]
    public static ulong_mt16 operator+(ulong_mt16 a, ulong_mt16 b) => new(a.vector0 + b.vector0, a.vector1 + b.vector1);

    [MethodImpl(256 | 512)]
    public static ulong_mt16 operator-(ulong_mt16 a, ulong_mt16 b) => new(a.vector0 - b.vector0, a.vector1 - b.vector1);

    [MethodImpl(256 | 512)]
    public static ulong_mt16 operator*(ulong_mt16 a, ulong_mt16 b) => new(a.vector0 * b.vector0, a.vector1 * b.vector1);

    [MethodImpl(256 | 512)]
    public static ulong_mt16 operator*(ulong_mt16 a, ulong b) => new(a.vector0 * b, a.vector1 * b);

    [MethodImpl(256 | 512)]
    public static ulong_mt16 operator*(ulong a, ulong_mt16 b) => new(a * b.vector0, a * b.vector1);

    [MethodImpl(256 | 512)]
    public static ulong_mt16 operator/(ulong_mt16 a, ulong_mt16 b) => new(a.vector0 / b.vector0, a.vector1 / b.vector1);

    [MethodImpl(256 | 512)]
    public static ulong_mt16 operator/(ulong_mt16 a, ulong b) => new(a.vector0 / b, a.vector1 / b);

    [MethodImpl(256 | 512)]
    public static ulong_mt16 operator%(ulong_mt16 a, ulong_mt16 b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static ulong_mt16 operator%(ulong_mt16 a, ulong b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static ulong_mt16 operator++(ulong_mt16 a) => a + One;

    [MethodImpl(256 | 512)]
    public static ulong_mt16 operator--(ulong_mt16 a) => a - One;

    #endregion
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static ulong_mt16 abs([This] ulong_mt16 a)
    {
        return a;
    }

    [MethodImpl(256 | 512)]
    public static ulong_mt16 sign([This] ulong_mt16 a)
    {
        return new(simd.SignUInt(a.vector0), simd.SignUInt(a.vector1));
    }

    [MethodImpl(256 | 512)]
    public static ulong_mt16 min([This] ulong_mt16 a, ulong_mt16 b)
    {
        return new(Vector512.Min(a.vector0, b.vector0), Vector512.Min(a.vector1, b.vector1));
    }

    [MethodImpl(256 | 512)]
    public static ulong_mt16 max([This] ulong_mt16 a, ulong_mt16 b)
    {
        return new(Vector512.Max(a.vector0, b.vector0), Vector512.Max(a.vector1, b.vector1));
    }

    [MethodImpl(256 | 512)]
    public static ulong_mt16 clamp([This] ulong_mt16 v, ulong_mt16 min, ulong_mt16 max)
    {
        var vector0 = Vector512.Min(max.vector0, v.vector0);
        var vector1 = Vector512.Min(max.vector1, v.vector1);
        return new(Vector512.Max(min.vector0, vector0), Vector512.Max(min.vector1, vector1));
    }

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ulong_mt16 fma([This] ulong_mt16 a, ulong_mt16 b, ulong_mt16 c)
    {
        return (a * b) + c;
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static ulong_mt16 fms([This] ulong_mt16 a, ulong_mt16 b, ulong_mt16 c)
    {
        return (a * b) - c;
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static ulong_mt16 fnma([This] ulong_mt16 a, ulong_mt16 b, ulong_mt16 c)
    {
        return c - (a * b);
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static ulong_mt16 fsm([This] ulong_mt16 c, ulong_mt16 a, ulong_mt16 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ulong_mt16 fam([This] ulong_mt16 c, ulong_mt16 a, ulong_mt16 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ulong_mt16 mad([This] ulong_mt16 a, ulong_mt16 b, ulong_mt16 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static ulong_mt16 lerp(ulong_mt16 start, ulong_mt16 end, [This] ulong_mt16 t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static ulong_mt16 lerp(ulong_mt16 start, ulong_mt16 end, [This] ulong t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static ulong_mt16 lerp(ulong start, ulong end, [This] ulong_mt16 t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static ulong_mt16 unlerp([This] ulong_mt16 a, ulong_mt16 start, ulong_mt16 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ulong_mt16 unlerp([This] ulong a, ulong_mt16 start, ulong_mt16 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ulong_mt16 unlerp([This] ulong_mt16 a, ulong start, ulong end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ulong_mt16 remap([This] ulong_mt16 a, ulong_mt16 srcStart, ulong_mt16 srcEnd, ulong_mt16 dstStart, ulong_mt16 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static ulong_mt16 remap([This] ulong_mt16 a, ulong srcStart, ulong srcEnd, ulong dstStart, ulong dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static ulong_mt16 square([This] ulong_mt16 a) => a * a;
}

#endregion // ulong_mt16
#region ulong_mt32

public partial struct ulong_mt32
{
    #region Constants

    public static ulong_mt32 Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static ulong_mt32 One
    {
        [MethodImpl(256 | 512)]
        get => new(1UL);
    }

    public static ulong_mt32 Two
    {
        [MethodImpl(256 | 512)]
        get => new((1UL + 1UL));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static ulong_mt32 operator-(ulong_mt32 a) => new(-a.vector0, -a.vector1, -a.vector2, -a.vector3);

    [MethodImpl(256 | 512)]
    public static ulong_mt32 operator+(ulong_mt32 a, ulong_mt32 b) => new(a.vector0 + b.vector0, a.vector1 + b.vector1, a.vector2 + b.vector2, a.vector3 + b.vector3);

    [MethodImpl(256 | 512)]
    public static ulong_mt32 operator-(ulong_mt32 a, ulong_mt32 b) => new(a.vector0 - b.vector0, a.vector1 - b.vector1, a.vector2 - b.vector2, a.vector3 - b.vector3);

    [MethodImpl(256 | 512)]
    public static ulong_mt32 operator*(ulong_mt32 a, ulong_mt32 b) => new(a.vector0 * b.vector0, a.vector1 * b.vector1, a.vector2 * b.vector2, a.vector3 * b.vector3);

    [MethodImpl(256 | 512)]
    public static ulong_mt32 operator*(ulong_mt32 a, ulong b) => new(a.vector0 * b, a.vector1 * b, a.vector2 * b, a.vector3 * b);

    [MethodImpl(256 | 512)]
    public static ulong_mt32 operator*(ulong a, ulong_mt32 b) => new(a * b.vector0, a * b.vector1, a * b.vector2, a * b.vector3);

    [MethodImpl(256 | 512)]
    public static ulong_mt32 operator/(ulong_mt32 a, ulong_mt32 b) => new(a.vector0 / b.vector0, a.vector1 / b.vector1, a.vector2 / b.vector2, a.vector3 / b.vector3);

    [MethodImpl(256 | 512)]
    public static ulong_mt32 operator/(ulong_mt32 a, ulong b) => new(a.vector0 / b, a.vector1 / b, a.vector2 / b, a.vector3 / b);

    [MethodImpl(256 | 512)]
    public static ulong_mt32 operator%(ulong_mt32 a, ulong_mt32 b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static ulong_mt32 operator%(ulong_mt32 a, ulong b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static ulong_mt32 operator++(ulong_mt32 a) => a + One;

    [MethodImpl(256 | 512)]
    public static ulong_mt32 operator--(ulong_mt32 a) => a - One;

    #endregion
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static ulong_mt32 abs([This] ulong_mt32 a)
    {
        return a;
    }

    [MethodImpl(256 | 512)]
    public static ulong_mt32 sign([This] ulong_mt32 a)
    {
        return new(simd.SignUInt(a.vector0), simd.SignUInt(a.vector1), simd.SignUInt(a.vector2), simd.SignUInt(a.vector3));
    }

    [MethodImpl(256 | 512)]
    public static ulong_mt32 min([This] ulong_mt32 a, ulong_mt32 b)
    {
        return new(Vector512.Min(a.vector0, b.vector0), Vector512.Min(a.vector1, b.vector1), Vector512.Min(a.vector2, b.vector2), Vector512.Min(a.vector3, b.vector3));
    }

    [MethodImpl(256 | 512)]
    public static ulong_mt32 max([This] ulong_mt32 a, ulong_mt32 b)
    {
        return new(Vector512.Max(a.vector0, b.vector0), Vector512.Max(a.vector1, b.vector1), Vector512.Max(a.vector2, b.vector2), Vector512.Max(a.vector3, b.vector3));
    }

    [MethodImpl(256 | 512)]
    public static ulong_mt32 clamp([This] ulong_mt32 v, ulong_mt32 min, ulong_mt32 max)
    {
        var vector0 = Vector512.Min(max.vector0, v.vector0);
        var vector1 = Vector512.Min(max.vector1, v.vector1);
        var vector2 = Vector512.Min(max.vector2, v.vector2);
        var vector3 = Vector512.Min(max.vector3, v.vector3);
        return new(Vector512.Max(min.vector0, vector0), Vector512.Max(min.vector1, vector1), Vector512.Max(min.vector2, vector2), Vector512.Max(min.vector3, vector3));
    }

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ulong_mt32 fma([This] ulong_mt32 a, ulong_mt32 b, ulong_mt32 c)
    {
        return (a * b) + c;
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static ulong_mt32 fms([This] ulong_mt32 a, ulong_mt32 b, ulong_mt32 c)
    {
        return (a * b) - c;
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static ulong_mt32 fnma([This] ulong_mt32 a, ulong_mt32 b, ulong_mt32 c)
    {
        return c - (a * b);
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static ulong_mt32 fsm([This] ulong_mt32 c, ulong_mt32 a, ulong_mt32 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ulong_mt32 fam([This] ulong_mt32 c, ulong_mt32 a, ulong_mt32 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ulong_mt32 mad([This] ulong_mt32 a, ulong_mt32 b, ulong_mt32 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static ulong_mt32 lerp(ulong_mt32 start, ulong_mt32 end, [This] ulong_mt32 t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static ulong_mt32 lerp(ulong_mt32 start, ulong_mt32 end, [This] ulong t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static ulong_mt32 lerp(ulong start, ulong end, [This] ulong_mt32 t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static ulong_mt32 unlerp([This] ulong_mt32 a, ulong_mt32 start, ulong_mt32 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ulong_mt32 unlerp([This] ulong a, ulong_mt32 start, ulong_mt32 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ulong_mt32 unlerp([This] ulong_mt32 a, ulong start, ulong end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ulong_mt32 remap([This] ulong_mt32 a, ulong_mt32 srcStart, ulong_mt32 srcEnd, ulong_mt32 dstStart, ulong_mt32 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static ulong_mt32 remap([This] ulong_mt32 a, ulong srcStart, ulong srcEnd, ulong dstStart, ulong dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static ulong_mt32 square([This] ulong_mt32 a) => a * a;
}

#endregion // ulong_mt32
