// generated by template, do not modify manually

namespace Coplt.Mathematics.Simt;

#region float_mt

public partial struct float_mt
{
    #region Constants

    public static float_mt Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static float_mt One
    {
        [MethodImpl(256 | 512)]
        get => new(1.0f);
    }

    public static float_mt Two
    {
        [MethodImpl(256 | 512)]
        get => new(2.0f);
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static float_mt operator-(float_mt a) => new(-a.vector);

    [MethodImpl(256 | 512)]
    public static float_mt operator+(float_mt a, float_mt b) => new(a.vector + b.vector);

    [MethodImpl(256 | 512)]
    public static float_mt operator-(float_mt a, float_mt b) => new(a.vector - b.vector);

    [MethodImpl(256 | 512)]
    public static float_mt operator*(float_mt a, float_mt b) => new(a.vector * b.vector);

    [MethodImpl(256 | 512)]
    public static float_mt operator*(float_mt a, float b) => new(a.vector * b);

    [MethodImpl(256 | 512)]
    public static float_mt operator*(float a, float_mt b) => new(a * b.vector);

    [MethodImpl(256 | 512)]
    public static float_mt operator/(float_mt a, float_mt b) => new(a.vector / b.vector);

    [MethodImpl(256 | 512)]
    public static float_mt operator/(float_mt a, float b) => new(a.vector / b);

    [MethodImpl(256 | 512)]
    public static float_mt operator%(float_mt a, float_mt b) => math_mt.rem(a, b);

    [MethodImpl(256 | 512)]
    public static float_mt operator%(float_mt a, float b) => math_mt.rem(a, b);

    [MethodImpl(256 | 512)]
    public static float_mt operator++(float_mt a) => a + One;

    [MethodImpl(256 | 512)]
    public static float_mt operator--(float_mt a) => a - One;

    #endregion
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static float_mt abs([This] float_mt a)
    {
        return new(Vector512.Abs(a.vector));
    }

    [MethodImpl(256 | 512)]
    public static float_mt sign([This] float_mt a)
    {
        return new(simd.SignFloat(a.vector));
    }

    [MethodImpl(256 | 512)]
    public static float_mt min([This] float_mt a, float_mt b)
    {
        return new(Vector512.Min(a.vector, b.vector));
    }

    [MethodImpl(256 | 512)]
    public static float_mt max([This] float_mt a, float_mt b)
    {
        return new(Vector512.Max(a.vector, b.vector));
    }

    [MethodImpl(256 | 512)]
    public static float_mt clamp([This] float_mt v, float_mt min, float_mt max)
    {
        var vector = Vector512.Min(max.vector, v.vector);
        return new(Vector512.Max(min.vector, vector));
    }

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float_mt fma([This] float_mt a, float_mt b, float_mt c)
    {
        return new(simd.Fma(a.vector, b.vector, c.vector));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static float_mt fms([This] float_mt a, float_mt b, float_mt c)
    {
        return new(simd.Fms(a.vector, b.vector, c.vector));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static float_mt fnma([This] float_mt a, float_mt b, float_mt c)
    {
        return new(simd.Fnma(a.vector, b.vector, c.vector));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static float_mt fsm([This] float_mt c, float_mt a, float_mt b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float_mt fam([This] float_mt c, float_mt a, float_mt b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float_mt mad([This] float_mt a, float_mt b, float_mt c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static float_mt lerp(float_mt start, float_mt end, [This] float_mt t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static float_mt lerp(float_mt start, float_mt end, [This] float t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static float_mt lerp(float start, float end, [This] float_mt t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static float_mt unlerp([This] float_mt a, float_mt start, float_mt end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static float_mt unlerp([This] float a, float_mt start, float_mt end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static float_mt unlerp([This] float_mt a, float start, float end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static float_mt remap([This] float_mt a, float_mt srcStart, float_mt srcEnd, float_mt dstStart, float_mt dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static float_mt remap([This] float_mt a, float srcStart, float srcEnd, float dstStart, float dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static float_mt square([This] float_mt a) => a * a;
}

#endregion // float_mt
#region double_mt

public partial struct double_mt
{
    #region Constants

    public static double_mt Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static double_mt One
    {
        [MethodImpl(256 | 512)]
        get => new(1.0);
    }

    public static double_mt Two
    {
        [MethodImpl(256 | 512)]
        get => new(2.0);
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static double_mt operator-(double_mt a) => new(-a.vector0, -a.vector1);

    [MethodImpl(256 | 512)]
    public static double_mt operator+(double_mt a, double_mt b) => new(a.vector0 + b.vector0, a.vector1 + b.vector1);

    [MethodImpl(256 | 512)]
    public static double_mt operator-(double_mt a, double_mt b) => new(a.vector0 - b.vector0, a.vector1 - b.vector1);

    [MethodImpl(256 | 512)]
    public static double_mt operator*(double_mt a, double_mt b) => new(a.vector0 * b.vector0, a.vector1 * b.vector1);

    [MethodImpl(256 | 512)]
    public static double_mt operator*(double_mt a, double b) => new(a.vector0 * b, a.vector1 * b);

    [MethodImpl(256 | 512)]
    public static double_mt operator*(double a, double_mt b) => new(a * b.vector0, a * b.vector1);

    [MethodImpl(256 | 512)]
    public static double_mt operator/(double_mt a, double_mt b) => new(a.vector0 / b.vector0, a.vector1 / b.vector1);

    [MethodImpl(256 | 512)]
    public static double_mt operator/(double_mt a, double b) => new(a.vector0 / b, a.vector1 / b);

    [MethodImpl(256 | 512)]
    public static double_mt operator%(double_mt a, double_mt b) => math_mt.rem(a, b);

    [MethodImpl(256 | 512)]
    public static double_mt operator%(double_mt a, double b) => math_mt.rem(a, b);

    [MethodImpl(256 | 512)]
    public static double_mt operator++(double_mt a) => a + One;

    [MethodImpl(256 | 512)]
    public static double_mt operator--(double_mt a) => a - One;

    #endregion
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static double_mt abs([This] double_mt a)
    {
        return new(Vector512.Abs(a.vector0), Vector512.Abs(a.vector1));
    }

    [MethodImpl(256 | 512)]
    public static double_mt sign([This] double_mt a)
    {
        return new(simd.SignFloat(a.vector0), simd.SignFloat(a.vector1));
    }

    [MethodImpl(256 | 512)]
    public static double_mt min([This] double_mt a, double_mt b)
    {
        return new(Vector512.Min(a.vector0, b.vector0), Vector512.Min(a.vector1, b.vector1));
    }

    [MethodImpl(256 | 512)]
    public static double_mt max([This] double_mt a, double_mt b)
    {
        return new(Vector512.Max(a.vector0, b.vector0), Vector512.Max(a.vector1, b.vector1));
    }

    [MethodImpl(256 | 512)]
    public static double_mt clamp([This] double_mt v, double_mt min, double_mt max)
    {
        var vector0 = Vector512.Min(max.vector0, v.vector0);
        var vector1 = Vector512.Min(max.vector1, v.vector1);
        return new(Vector512.Max(min.vector0, vector0), Vector512.Max(min.vector1, vector1));
    }

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double_mt fma([This] double_mt a, double_mt b, double_mt c)
    {
        return new(simd.Fma(a.vector0, b.vector0, c.vector0), simd.Fma(a.vector1, b.vector1, c.vector1));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static double_mt fms([This] double_mt a, double_mt b, double_mt c)
    {
        return new(simd.Fms(a.vector0, b.vector0, c.vector0), simd.Fms(a.vector1, b.vector1, c.vector1));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static double_mt fnma([This] double_mt a, double_mt b, double_mt c)
    {
        return new(simd.Fnma(a.vector0, b.vector0, c.vector0), simd.Fnma(a.vector1, b.vector1, c.vector1));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static double_mt fsm([This] double_mt c, double_mt a, double_mt b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double_mt fam([This] double_mt c, double_mt a, double_mt b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double_mt mad([This] double_mt a, double_mt b, double_mt c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static double_mt lerp(double_mt start, double_mt end, [This] double_mt t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static double_mt lerp(double_mt start, double_mt end, [This] double t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static double_mt lerp(double start, double end, [This] double_mt t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static double_mt unlerp([This] double_mt a, double_mt start, double_mt end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static double_mt unlerp([This] double a, double_mt start, double_mt end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static double_mt unlerp([This] double_mt a, double start, double end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static double_mt remap([This] double_mt a, double_mt srcStart, double_mt srcEnd, double_mt dstStart, double_mt dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static double_mt remap([This] double_mt a, double srcStart, double srcEnd, double dstStart, double dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static double_mt square([This] double_mt a) => a * a;
}

#endregion // double_mt
#region int_mt

public partial struct int_mt
{
    #region Constants

    public static int_mt Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static int_mt One
    {
        [MethodImpl(256 | 512)]
        get => new(1);
    }

    public static int_mt Two
    {
        [MethodImpl(256 | 512)]
        get => new((1 + 1));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static int_mt operator-(int_mt a) => new(-a.vector);

    [MethodImpl(256 | 512)]
    public static int_mt operator+(int_mt a, int_mt b) => new(a.vector + b.vector);

    [MethodImpl(256 | 512)]
    public static int_mt operator-(int_mt a, int_mt b) => new(a.vector - b.vector);

    [MethodImpl(256 | 512)]
    public static int_mt operator*(int_mt a, int_mt b) => new(a.vector * b.vector);

    [MethodImpl(256 | 512)]
    public static int_mt operator*(int_mt a, int b) => new(a.vector * b);

    [MethodImpl(256 | 512)]
    public static int_mt operator*(int a, int_mt b) => new(a * b.vector);

    [MethodImpl(256 | 512)]
    public static int_mt operator/(int_mt a, int_mt b) => new(a.vector / b.vector);

    [MethodImpl(256 | 512)]
    public static int_mt operator/(int_mt a, int b) => new(a.vector / b);

    [MethodImpl(256 | 512)]
    public static int_mt operator%(int_mt a, int_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static int_mt operator%(int_mt a, int b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static int_mt operator++(int_mt a) => a + One;

    [MethodImpl(256 | 512)]
    public static int_mt operator--(int_mt a) => a - One;

    #endregion
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static int_mt abs([This] int_mt a)
    {
        return new(Vector512.Abs(a.vector));
    }

    [MethodImpl(256 | 512)]
    public static int_mt sign([This] int_mt a)
    {
        return new(simd.SignInt(a.vector));
    }

    [MethodImpl(256 | 512)]
    public static int_mt min([This] int_mt a, int_mt b)
    {
        return new(Vector512.Min(a.vector, b.vector));
    }

    [MethodImpl(256 | 512)]
    public static int_mt max([This] int_mt a, int_mt b)
    {
        return new(Vector512.Max(a.vector, b.vector));
    }

    [MethodImpl(256 | 512)]
    public static int_mt clamp([This] int_mt v, int_mt min, int_mt max)
    {
        var vector = Vector512.Min(max.vector, v.vector);
        return new(Vector512.Max(min.vector, vector));
    }

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static int_mt fma([This] int_mt a, int_mt b, int_mt c)
    {
        return (a * b) + c;
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static int_mt fms([This] int_mt a, int_mt b, int_mt c)
    {
        return (a * b) - c;
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static int_mt fnma([This] int_mt a, int_mt b, int_mt c)
    {
        return c - (a * b);
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static int_mt fsm([This] int_mt c, int_mt a, int_mt b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static int_mt fam([This] int_mt c, int_mt a, int_mt b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static int_mt mad([This] int_mt a, int_mt b, int_mt c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static int_mt lerp(int_mt start, int_mt end, [This] int_mt t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static int_mt lerp(int_mt start, int_mt end, [This] int t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static int_mt lerp(int start, int end, [This] int_mt t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static int_mt unlerp([This] int_mt a, int_mt start, int_mt end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static int_mt unlerp([This] int a, int_mt start, int_mt end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static int_mt unlerp([This] int_mt a, int start, int end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static int_mt remap([This] int_mt a, int_mt srcStart, int_mt srcEnd, int_mt dstStart, int_mt dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static int_mt remap([This] int_mt a, int srcStart, int srcEnd, int dstStart, int dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static int_mt square([This] int_mt a) => a * a;
}

#endregion // int_mt
#region uint_mt

public partial struct uint_mt
{
    #region Constants

    public static uint_mt Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static uint_mt One
    {
        [MethodImpl(256 | 512)]
        get => new(1u);
    }

    public static uint_mt Two
    {
        [MethodImpl(256 | 512)]
        get => new((1u + 1u));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static uint_mt operator-(uint_mt a) => new(-a.vector);

    [MethodImpl(256 | 512)]
    public static uint_mt operator+(uint_mt a, uint_mt b) => new(a.vector + b.vector);

    [MethodImpl(256 | 512)]
    public static uint_mt operator-(uint_mt a, uint_mt b) => new(a.vector - b.vector);

    [MethodImpl(256 | 512)]
    public static uint_mt operator*(uint_mt a, uint_mt b) => new(a.vector * b.vector);

    [MethodImpl(256 | 512)]
    public static uint_mt operator*(uint_mt a, uint b) => new(a.vector * b);

    [MethodImpl(256 | 512)]
    public static uint_mt operator*(uint a, uint_mt b) => new(a * b.vector);

    [MethodImpl(256 | 512)]
    public static uint_mt operator/(uint_mt a, uint_mt b) => new(a.vector / b.vector);

    [MethodImpl(256 | 512)]
    public static uint_mt operator/(uint_mt a, uint b) => new(a.vector / b);

    [MethodImpl(256 | 512)]
    public static uint_mt operator%(uint_mt a, uint_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static uint_mt operator%(uint_mt a, uint b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static uint_mt operator++(uint_mt a) => a + One;

    [MethodImpl(256 | 512)]
    public static uint_mt operator--(uint_mt a) => a - One;

    #endregion
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static uint_mt abs([This] uint_mt a)
    {
        return a;
    }

    [MethodImpl(256 | 512)]
    public static uint_mt sign([This] uint_mt a)
    {
        return new(simd.SignUInt(a.vector));
    }

    [MethodImpl(256 | 512)]
    public static uint_mt min([This] uint_mt a, uint_mt b)
    {
        return new(Vector512.Min(a.vector, b.vector));
    }

    [MethodImpl(256 | 512)]
    public static uint_mt max([This] uint_mt a, uint_mt b)
    {
        return new(Vector512.Max(a.vector, b.vector));
    }

    [MethodImpl(256 | 512)]
    public static uint_mt clamp([This] uint_mt v, uint_mt min, uint_mt max)
    {
        var vector = Vector512.Min(max.vector, v.vector);
        return new(Vector512.Max(min.vector, vector));
    }

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static uint_mt fma([This] uint_mt a, uint_mt b, uint_mt c)
    {
        return (a * b) + c;
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static uint_mt fms([This] uint_mt a, uint_mt b, uint_mt c)
    {
        return (a * b) - c;
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static uint_mt fnma([This] uint_mt a, uint_mt b, uint_mt c)
    {
        return c - (a * b);
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static uint_mt fsm([This] uint_mt c, uint_mt a, uint_mt b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static uint_mt fam([This] uint_mt c, uint_mt a, uint_mt b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static uint_mt mad([This] uint_mt a, uint_mt b, uint_mt c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static uint_mt lerp(uint_mt start, uint_mt end, [This] uint_mt t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static uint_mt lerp(uint_mt start, uint_mt end, [This] uint t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static uint_mt lerp(uint start, uint end, [This] uint_mt t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static uint_mt unlerp([This] uint_mt a, uint_mt start, uint_mt end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static uint_mt unlerp([This] uint a, uint_mt start, uint_mt end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static uint_mt unlerp([This] uint_mt a, uint start, uint end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static uint_mt remap([This] uint_mt a, uint_mt srcStart, uint_mt srcEnd, uint_mt dstStart, uint_mt dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static uint_mt remap([This] uint_mt a, uint srcStart, uint srcEnd, uint dstStart, uint dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static uint_mt square([This] uint_mt a) => a * a;
}

#endregion // uint_mt
#region long_mt

public partial struct long_mt
{
    #region Constants

    public static long_mt Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static long_mt One
    {
        [MethodImpl(256 | 512)]
        get => new(1L);
    }

    public static long_mt Two
    {
        [MethodImpl(256 | 512)]
        get => new((1L + 1L));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static long_mt operator-(long_mt a) => new(-a.vector0, -a.vector1);

    [MethodImpl(256 | 512)]
    public static long_mt operator+(long_mt a, long_mt b) => new(a.vector0 + b.vector0, a.vector1 + b.vector1);

    [MethodImpl(256 | 512)]
    public static long_mt operator-(long_mt a, long_mt b) => new(a.vector0 - b.vector0, a.vector1 - b.vector1);

    [MethodImpl(256 | 512)]
    public static long_mt operator*(long_mt a, long_mt b) => new(a.vector0 * b.vector0, a.vector1 * b.vector1);

    [MethodImpl(256 | 512)]
    public static long_mt operator*(long_mt a, long b) => new(a.vector0 * b, a.vector1 * b);

    [MethodImpl(256 | 512)]
    public static long_mt operator*(long a, long_mt b) => new(a * b.vector0, a * b.vector1);

    [MethodImpl(256 | 512)]
    public static long_mt operator/(long_mt a, long_mt b) => new(a.vector0 / b.vector0, a.vector1 / b.vector1);

    [MethodImpl(256 | 512)]
    public static long_mt operator/(long_mt a, long b) => new(a.vector0 / b, a.vector1 / b);

    [MethodImpl(256 | 512)]
    public static long_mt operator%(long_mt a, long_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static long_mt operator%(long_mt a, long b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static long_mt operator++(long_mt a) => a + One;

    [MethodImpl(256 | 512)]
    public static long_mt operator--(long_mt a) => a - One;

    #endregion
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static long_mt abs([This] long_mt a)
    {
        return new(Vector512.Abs(a.vector0), Vector512.Abs(a.vector1));
    }

    [MethodImpl(256 | 512)]
    public static long_mt sign([This] long_mt a)
    {
        return new(simd.SignInt(a.vector0), simd.SignInt(a.vector1));
    }

    [MethodImpl(256 | 512)]
    public static long_mt min([This] long_mt a, long_mt b)
    {
        return new(Vector512.Min(a.vector0, b.vector0), Vector512.Min(a.vector1, b.vector1));
    }

    [MethodImpl(256 | 512)]
    public static long_mt max([This] long_mt a, long_mt b)
    {
        return new(Vector512.Max(a.vector0, b.vector0), Vector512.Max(a.vector1, b.vector1));
    }

    [MethodImpl(256 | 512)]
    public static long_mt clamp([This] long_mt v, long_mt min, long_mt max)
    {
        var vector0 = Vector512.Min(max.vector0, v.vector0);
        var vector1 = Vector512.Min(max.vector1, v.vector1);
        return new(Vector512.Max(min.vector0, vector0), Vector512.Max(min.vector1, vector1));
    }

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static long_mt fma([This] long_mt a, long_mt b, long_mt c)
    {
        return (a * b) + c;
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static long_mt fms([This] long_mt a, long_mt b, long_mt c)
    {
        return (a * b) - c;
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static long_mt fnma([This] long_mt a, long_mt b, long_mt c)
    {
        return c - (a * b);
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static long_mt fsm([This] long_mt c, long_mt a, long_mt b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static long_mt fam([This] long_mt c, long_mt a, long_mt b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static long_mt mad([This] long_mt a, long_mt b, long_mt c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static long_mt lerp(long_mt start, long_mt end, [This] long_mt t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static long_mt lerp(long_mt start, long_mt end, [This] long t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static long_mt lerp(long start, long end, [This] long_mt t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static long_mt unlerp([This] long_mt a, long_mt start, long_mt end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static long_mt unlerp([This] long a, long_mt start, long_mt end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static long_mt unlerp([This] long_mt a, long start, long end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static long_mt remap([This] long_mt a, long_mt srcStart, long_mt srcEnd, long_mt dstStart, long_mt dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static long_mt remap([This] long_mt a, long srcStart, long srcEnd, long dstStart, long dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static long_mt square([This] long_mt a) => a * a;
}

#endregion // long_mt
#region ulong_mt

public partial struct ulong_mt
{
    #region Constants

    public static ulong_mt Zero
    {
        [MethodImpl(256 | 512)]
        get => default;
    }

    public static ulong_mt One
    {
        [MethodImpl(256 | 512)]
        get => new(1UL);
    }

    public static ulong_mt Two
    {
        [MethodImpl(256 | 512)]
        get => new((1UL + 1UL));
    }

    #endregion

    #region Operators

    [MethodImpl(256 | 512)]
    public static ulong_mt operator-(ulong_mt a) => new(-a.vector0, -a.vector1);

    [MethodImpl(256 | 512)]
    public static ulong_mt operator+(ulong_mt a, ulong_mt b) => new(a.vector0 + b.vector0, a.vector1 + b.vector1);

    [MethodImpl(256 | 512)]
    public static ulong_mt operator-(ulong_mt a, ulong_mt b) => new(a.vector0 - b.vector0, a.vector1 - b.vector1);

    [MethodImpl(256 | 512)]
    public static ulong_mt operator*(ulong_mt a, ulong_mt b) => new(a.vector0 * b.vector0, a.vector1 * b.vector1);

    [MethodImpl(256 | 512)]
    public static ulong_mt operator*(ulong_mt a, ulong b) => new(a.vector0 * b, a.vector1 * b);

    [MethodImpl(256 | 512)]
    public static ulong_mt operator*(ulong a, ulong_mt b) => new(a * b.vector0, a * b.vector1);

    [MethodImpl(256 | 512)]
    public static ulong_mt operator/(ulong_mt a, ulong_mt b) => new(a.vector0 / b.vector0, a.vector1 / b.vector1);

    [MethodImpl(256 | 512)]
    public static ulong_mt operator/(ulong_mt a, ulong b) => new(a.vector0 / b, a.vector1 / b);

    [MethodImpl(256 | 512)]
    public static ulong_mt operator%(ulong_mt a, ulong_mt b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static ulong_mt operator%(ulong_mt a, ulong b) => a - (a / b) * b;

    [MethodImpl(256 | 512)]
    public static ulong_mt operator++(ulong_mt a) => a + One;

    [MethodImpl(256 | 512)]
    public static ulong_mt operator--(ulong_mt a) => a - One;

    #endregion
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static ulong_mt abs([This] ulong_mt a)
    {
        return a;
    }

    [MethodImpl(256 | 512)]
    public static ulong_mt sign([This] ulong_mt a)
    {
        return new(simd.SignUInt(a.vector0), simd.SignUInt(a.vector1));
    }

    [MethodImpl(256 | 512)]
    public static ulong_mt min([This] ulong_mt a, ulong_mt b)
    {
        return new(Vector512.Min(a.vector0, b.vector0), Vector512.Min(a.vector1, b.vector1));
    }

    [MethodImpl(256 | 512)]
    public static ulong_mt max([This] ulong_mt a, ulong_mt b)
    {
        return new(Vector512.Max(a.vector0, b.vector0), Vector512.Max(a.vector1, b.vector1));
    }

    [MethodImpl(256 | 512)]
    public static ulong_mt clamp([This] ulong_mt v, ulong_mt min, ulong_mt max)
    {
        var vector0 = Vector512.Min(max.vector0, v.vector0);
        var vector1 = Vector512.Min(max.vector1, v.vector1);
        return new(Vector512.Max(min.vector0, vector0), Vector512.Max(min.vector1, vector1));
    }

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ulong_mt fma([This] ulong_mt a, ulong_mt b, ulong_mt c)
    {
        return (a * b) + c;
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static ulong_mt fms([This] ulong_mt a, ulong_mt b, ulong_mt c)
    {
        return (a * b) - c;
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static ulong_mt fnma([This] ulong_mt a, ulong_mt b, ulong_mt c)
    {
        return c - (a * b);
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static ulong_mt fsm([This] ulong_mt c, ulong_mt a, ulong_mt b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ulong_mt fam([This] ulong_mt c, ulong_mt a, ulong_mt b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ulong_mt mad([This] ulong_mt a, ulong_mt b, ulong_mt c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static ulong_mt lerp(ulong_mt start, ulong_mt end, [This] ulong_mt t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static ulong_mt lerp(ulong_mt start, ulong_mt end, [This] ulong t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static ulong_mt lerp(ulong start, ulong end, [This] ulong_mt t)
    {
        return fma(t, end - start, start);
    }

    [MethodImpl(256 | 512)]
    public static ulong_mt unlerp([This] ulong_mt a, ulong_mt start, ulong_mt end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ulong_mt unlerp([This] ulong a, ulong_mt start, ulong_mt end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ulong_mt unlerp([This] ulong_mt a, ulong start, ulong end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ulong_mt remap([This] ulong_mt a, ulong_mt srcStart, ulong_mt srcEnd, ulong_mt dstStart, ulong_mt dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static ulong_mt remap([This] ulong_mt a, ulong srcStart, ulong srcEnd, ulong dstStart, ulong dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static ulong_mt square([This] ulong_mt a) => a * a;
}

#endregion // ulong_mt
