// generated by template, do not modify manually

namespace Coplt.Mathematics.Simt;

#region float_mt

[CpuOnly]
public partial struct float_mt
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => 16;
    }

    #endregion

    #region Fields

    public Vector512<float> vector;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512), UnscopedRef]
    public readonly ref readonly Vector512<float> VectorAtRo(int index)
    {
        switch(index)
        {
            case 0: return ref vector;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector512<float> VectorAt(int index)
    {
        switch(index)
        {
            case 0: return ref vector;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    public float this[int index]
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            return vector[index];
        }
        [MethodImpl(256 | 512)]
        set
        {
            vector = vector.WithElement(index, value);
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public float_mt(Vector512<float> vector)
    {
        this.vector = vector;
    }

    [MethodImpl(256 | 512)]
    private float_mt(ref readonly float values)
    {
        ref var vs = ref Unsafe.AsRef(in values);
        vector = Vector512.LoadUnsafe(in vs);
    }

    [MethodImpl(256 | 512)]
    public static float_mt LoadUnsafe(ref readonly float values) => new(in values);

    [MethodImpl(256 | 512)]
    public static float_mt LoadUnsafe(params ReadOnlySpan<float> values) => new(in values.GetPinnableReference());

    [MethodImpl(256 | 512)]
    public float_mt(float value)
    {
        vector = Vector512.Create(value);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator float_mt(float value) => new(value);

    [MethodImpl(256 | 512)]
    public static float_mt operator~(float_mt a) => new(~a.vector);

    [MethodImpl(256 | 512)]
    public static float_mt operator|(float_mt a, float_mt b) => new(a.vector | b.vector);

    [MethodImpl(256 | 512)]
    public static float_mt operator&(float_mt a, float_mt b) => new(a.vector & b.vector);

    [MethodImpl(256 | 512)]
    public static float_mt operator^(float_mt a, float_mt b) => new(a.vector ^ b.vector);

    [MethodImpl(256 | 512)]
    public static float_mt operator<<(float_mt a, int b) => new(a.vector << b);

    [MethodImpl(256 | 512)]
    public static float_mt operator>>(float_mt a, int b) => new(a.vector >> b);

    [MethodImpl(256 | 512)]
    public static float_mt operator>>>(float_mt a, int b) => new(a.vector >>> b);

    #endregion  // Operators

    #region ToString

    public readonly override string ToString() => $"float_mt {{ t0 = {this[0]}, t1 = {this[1]}, t2 = {this[2]}, t3 = {this[3]}, t4 = {this[4]}, t5 = {this[5]}, t6 = {this[6]}, t7 = {this[7]}, t8 = {this[8]}, t9 = {this[9]}, t10 = {this[10]}, t11 = {this[11]}, t12 = {this[12]}, t13 = {this[13]}, t14 = {this[14]}, t15 = {this[15]} }}";

    #endregion  // ToString
}

#endregion // float_mt
#region double_mt

[CpuOnly]
public partial struct double_mt
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => 16;
    }

    #endregion

    #region Fields

    public Vector512<double> vector0;
    public Vector512<double> vector1;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512), UnscopedRef]
    public readonly ref readonly Vector512<double> VectorAtRo(int index)
    {
        switch(index)
        {
            case 0: return ref vector0;
            case 1: return ref vector1;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector512<double> VectorAt(int index)
    {
        switch(index)
        {
            case 0: return ref vector0;
            case 1: return ref vector1;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    public double this[int index]
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            var (q, r) = Math.DivRem(index, Vector512<double>.Count);
            return VectorAtRo(q)[r];
        }
        [MethodImpl(256 | 512)]
        set
        {
            var (q, r) = Math.DivRem(index, Vector512<double>.Count);
            ref var vector = ref VectorAt(q);
            vector = vector.WithElement(r, value);
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public double_mt(Vector512<double> vector0, Vector512<double> vector1)
    {
        this.vector0 = vector0;
        this.vector1 = vector1;
    }

    [MethodImpl(256 | 512)]
    private double_mt(ref readonly double values)
    {
        ref var vs = ref Unsafe.AsRef(in values);
        vector0 = Vector512.LoadUnsafe(in vs);
        vector1 = Vector512.LoadUnsafe(in Unsafe.Add(ref vs, 16));
    }

    [MethodImpl(256 | 512)]
    public static double_mt LoadUnsafe(ref readonly double values) => new(in values);

    [MethodImpl(256 | 512)]
    public static double_mt LoadUnsafe(params ReadOnlySpan<double> values) => new(in values.GetPinnableReference());

    [MethodImpl(256 | 512)]
    public double_mt(double value)
    {
        vector0 = Vector512.Create(value);
        vector1 = Vector512.Create(value);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator double_mt(double value) => new(value);

    [MethodImpl(256 | 512)]
    public static double_mt operator~(double_mt a) => new(~a.vector0, ~a.vector1);

    [MethodImpl(256 | 512)]
    public static double_mt operator|(double_mt a, double_mt b) => new(a.vector0 | b.vector0, a.vector1 | b.vector1);

    [MethodImpl(256 | 512)]
    public static double_mt operator&(double_mt a, double_mt b) => new(a.vector0 & b.vector0, a.vector1 & b.vector1);

    [MethodImpl(256 | 512)]
    public static double_mt operator^(double_mt a, double_mt b) => new(a.vector0 ^ b.vector0, a.vector1 ^ b.vector1);

    [MethodImpl(256 | 512)]
    public static double_mt operator<<(double_mt a, int b) => new(a.vector0 << b, a.vector1 << b);

    [MethodImpl(256 | 512)]
    public static double_mt operator>>(double_mt a, int b) => new(a.vector0 >> b, a.vector1 >> b);

    [MethodImpl(256 | 512)]
    public static double_mt operator>>>(double_mt a, int b) => new(a.vector0 >>> b, a.vector1 >>> b);

    #endregion  // Operators

    #region ToString

    public readonly override string ToString() => $"double_mt {{ t0 = {this[0]}, t1 = {this[1]}, t2 = {this[2]}, t3 = {this[3]}, t4 = {this[4]}, t5 = {this[5]}, t6 = {this[6]}, t7 = {this[7]}, t8 = {this[8]}, t9 = {this[9]}, t10 = {this[10]}, t11 = {this[11]}, t12 = {this[12]}, t13 = {this[13]}, t14 = {this[14]}, t15 = {this[15]} }}";

    #endregion  // ToString
}

#endregion // double_mt
#region int_mt

[CpuOnly]
public partial struct int_mt
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => 16;
    }

    #endregion

    #region Fields

    public Vector512<int> vector;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512), UnscopedRef]
    public readonly ref readonly Vector512<int> VectorAtRo(int index)
    {
        switch(index)
        {
            case 0: return ref vector;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector512<int> VectorAt(int index)
    {
        switch(index)
        {
            case 0: return ref vector;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    public int this[int index]
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            return vector[index];
        }
        [MethodImpl(256 | 512)]
        set
        {
            vector = vector.WithElement(index, value);
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public int_mt(Vector512<int> vector)
    {
        this.vector = vector;
    }

    [MethodImpl(256 | 512)]
    private int_mt(ref readonly int values)
    {
        ref var vs = ref Unsafe.AsRef(in values);
        vector = Vector512.LoadUnsafe(in vs);
    }

    [MethodImpl(256 | 512)]
    public static int_mt LoadUnsafe(ref readonly int values) => new(in values);

    [MethodImpl(256 | 512)]
    public static int_mt LoadUnsafe(params ReadOnlySpan<int> values) => new(in values.GetPinnableReference());

    [MethodImpl(256 | 512)]
    public int_mt(int value)
    {
        vector = Vector512.Create(value);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator int_mt(int value) => new(value);

    [MethodImpl(256 | 512)]
    public static int_mt operator~(int_mt a) => new(~a.vector);

    [MethodImpl(256 | 512)]
    public static int_mt operator|(int_mt a, int_mt b) => new(a.vector | b.vector);

    [MethodImpl(256 | 512)]
    public static int_mt operator&(int_mt a, int_mt b) => new(a.vector & b.vector);

    [MethodImpl(256 | 512)]
    public static int_mt operator^(int_mt a, int_mt b) => new(a.vector ^ b.vector);

    [MethodImpl(256 | 512)]
    public static int_mt operator<<(int_mt a, int b) => new(a.vector << b);

    [MethodImpl(256 | 512)]
    public static int_mt operator>>(int_mt a, int b) => new(a.vector >> b);

    [MethodImpl(256 | 512)]
    public static int_mt operator>>>(int_mt a, int b) => new(a.vector >>> b);

    #endregion  // Operators

    #region ToString

    public readonly override string ToString() => $"int_mt {{ t0 = {this[0]}, t1 = {this[1]}, t2 = {this[2]}, t3 = {this[3]}, t4 = {this[4]}, t5 = {this[5]}, t6 = {this[6]}, t7 = {this[7]}, t8 = {this[8]}, t9 = {this[9]}, t10 = {this[10]}, t11 = {this[11]}, t12 = {this[12]}, t13 = {this[13]}, t14 = {this[14]}, t15 = {this[15]} }}";

    #endregion  // ToString
}

#endregion // int_mt
#region uint_mt

[CpuOnly]
public partial struct uint_mt
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => 16;
    }

    #endregion

    #region Fields

    public Vector512<uint> vector;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512), UnscopedRef]
    public readonly ref readonly Vector512<uint> VectorAtRo(int index)
    {
        switch(index)
        {
            case 0: return ref vector;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector512<uint> VectorAt(int index)
    {
        switch(index)
        {
            case 0: return ref vector;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    public uint this[int index]
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            return vector[index];
        }
        [MethodImpl(256 | 512)]
        set
        {
            vector = vector.WithElement(index, value);
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public uint_mt(Vector512<uint> vector)
    {
        this.vector = vector;
    }

    [MethodImpl(256 | 512)]
    private uint_mt(ref readonly uint values)
    {
        ref var vs = ref Unsafe.AsRef(in values);
        vector = Vector512.LoadUnsafe(in vs);
    }

    [MethodImpl(256 | 512)]
    public static uint_mt LoadUnsafe(ref readonly uint values) => new(in values);

    [MethodImpl(256 | 512)]
    public static uint_mt LoadUnsafe(params ReadOnlySpan<uint> values) => new(in values.GetPinnableReference());

    [MethodImpl(256 | 512)]
    public uint_mt(uint value)
    {
        vector = Vector512.Create(value);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator uint_mt(uint value) => new(value);

    [MethodImpl(256 | 512)]
    public static uint_mt operator~(uint_mt a) => new(~a.vector);

    [MethodImpl(256 | 512)]
    public static uint_mt operator|(uint_mt a, uint_mt b) => new(a.vector | b.vector);

    [MethodImpl(256 | 512)]
    public static uint_mt operator&(uint_mt a, uint_mt b) => new(a.vector & b.vector);

    [MethodImpl(256 | 512)]
    public static uint_mt operator^(uint_mt a, uint_mt b) => new(a.vector ^ b.vector);

    [MethodImpl(256 | 512)]
    public static uint_mt operator<<(uint_mt a, int b) => new(a.vector << b);

    [MethodImpl(256 | 512)]
    public static uint_mt operator>>(uint_mt a, int b) => new(a.vector >> b);

    [MethodImpl(256 | 512)]
    public static uint_mt operator>>>(uint_mt a, int b) => new(a.vector >>> b);

    #endregion  // Operators

    #region ToString

    public readonly override string ToString() => $"uint_mt {{ t0 = {this[0]}, t1 = {this[1]}, t2 = {this[2]}, t3 = {this[3]}, t4 = {this[4]}, t5 = {this[5]}, t6 = {this[6]}, t7 = {this[7]}, t8 = {this[8]}, t9 = {this[9]}, t10 = {this[10]}, t11 = {this[11]}, t12 = {this[12]}, t13 = {this[13]}, t14 = {this[14]}, t15 = {this[15]} }}";

    #endregion  // ToString
}

#endregion // uint_mt
#region long_mt

[CpuOnly]
public partial struct long_mt
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => 16;
    }

    #endregion

    #region Fields

    public Vector512<long> vector0;
    public Vector512<long> vector1;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512), UnscopedRef]
    public readonly ref readonly Vector512<long> VectorAtRo(int index)
    {
        switch(index)
        {
            case 0: return ref vector0;
            case 1: return ref vector1;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector512<long> VectorAt(int index)
    {
        switch(index)
        {
            case 0: return ref vector0;
            case 1: return ref vector1;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    public long this[int index]
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            var (q, r) = Math.DivRem(index, Vector512<long>.Count);
            return VectorAtRo(q)[r];
        }
        [MethodImpl(256 | 512)]
        set
        {
            var (q, r) = Math.DivRem(index, Vector512<long>.Count);
            ref var vector = ref VectorAt(q);
            vector = vector.WithElement(r, value);
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public long_mt(Vector512<long> vector0, Vector512<long> vector1)
    {
        this.vector0 = vector0;
        this.vector1 = vector1;
    }

    [MethodImpl(256 | 512)]
    private long_mt(ref readonly long values)
    {
        ref var vs = ref Unsafe.AsRef(in values);
        vector0 = Vector512.LoadUnsafe(in vs);
        vector1 = Vector512.LoadUnsafe(in Unsafe.Add(ref vs, 16));
    }

    [MethodImpl(256 | 512)]
    public static long_mt LoadUnsafe(ref readonly long values) => new(in values);

    [MethodImpl(256 | 512)]
    public static long_mt LoadUnsafe(params ReadOnlySpan<long> values) => new(in values.GetPinnableReference());

    [MethodImpl(256 | 512)]
    public long_mt(long value)
    {
        vector0 = Vector512.Create(value);
        vector1 = Vector512.Create(value);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator long_mt(long value) => new(value);

    [MethodImpl(256 | 512)]
    public static long_mt operator~(long_mt a) => new(~a.vector0, ~a.vector1);

    [MethodImpl(256 | 512)]
    public static long_mt operator|(long_mt a, long_mt b) => new(a.vector0 | b.vector0, a.vector1 | b.vector1);

    [MethodImpl(256 | 512)]
    public static long_mt operator&(long_mt a, long_mt b) => new(a.vector0 & b.vector0, a.vector1 & b.vector1);

    [MethodImpl(256 | 512)]
    public static long_mt operator^(long_mt a, long_mt b) => new(a.vector0 ^ b.vector0, a.vector1 ^ b.vector1);

    [MethodImpl(256 | 512)]
    public static long_mt operator<<(long_mt a, int b) => new(a.vector0 << b, a.vector1 << b);

    [MethodImpl(256 | 512)]
    public static long_mt operator>>(long_mt a, int b) => new(a.vector0 >> b, a.vector1 >> b);

    [MethodImpl(256 | 512)]
    public static long_mt operator>>>(long_mt a, int b) => new(a.vector0 >>> b, a.vector1 >>> b);

    #endregion  // Operators

    #region ToString

    public readonly override string ToString() => $"long_mt {{ t0 = {this[0]}, t1 = {this[1]}, t2 = {this[2]}, t3 = {this[3]}, t4 = {this[4]}, t5 = {this[5]}, t6 = {this[6]}, t7 = {this[7]}, t8 = {this[8]}, t9 = {this[9]}, t10 = {this[10]}, t11 = {this[11]}, t12 = {this[12]}, t13 = {this[13]}, t14 = {this[14]}, t15 = {this[15]} }}";

    #endregion  // ToString
}

#endregion // long_mt
#region ulong_mt

[CpuOnly]
public partial struct ulong_mt
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => 16;
    }

    #endregion

    #region Fields

    public Vector512<ulong> vector0;
    public Vector512<ulong> vector1;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512), UnscopedRef]
    public readonly ref readonly Vector512<ulong> VectorAtRo(int index)
    {
        switch(index)
        {
            case 0: return ref vector0;
            case 1: return ref vector1;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector512<ulong> VectorAt(int index)
    {
        switch(index)
        {
            case 0: return ref vector0;
            case 1: return ref vector1;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    public ulong this[int index]
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            var (q, r) = Math.DivRem(index, Vector512<ulong>.Count);
            return VectorAtRo(q)[r];
        }
        [MethodImpl(256 | 512)]
        set
        {
            var (q, r) = Math.DivRem(index, Vector512<ulong>.Count);
            ref var vector = ref VectorAt(q);
            vector = vector.WithElement(r, value);
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public ulong_mt(Vector512<ulong> vector0, Vector512<ulong> vector1)
    {
        this.vector0 = vector0;
        this.vector1 = vector1;
    }

    [MethodImpl(256 | 512)]
    private ulong_mt(ref readonly ulong values)
    {
        ref var vs = ref Unsafe.AsRef(in values);
        vector0 = Vector512.LoadUnsafe(in vs);
        vector1 = Vector512.LoadUnsafe(in Unsafe.Add(ref vs, 16));
    }

    [MethodImpl(256 | 512)]
    public static ulong_mt LoadUnsafe(ref readonly ulong values) => new(in values);

    [MethodImpl(256 | 512)]
    public static ulong_mt LoadUnsafe(params ReadOnlySpan<ulong> values) => new(in values.GetPinnableReference());

    [MethodImpl(256 | 512)]
    public ulong_mt(ulong value)
    {
        vector0 = Vector512.Create(value);
        vector1 = Vector512.Create(value);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator ulong_mt(ulong value) => new(value);

    [MethodImpl(256 | 512)]
    public static ulong_mt operator~(ulong_mt a) => new(~a.vector0, ~a.vector1);

    [MethodImpl(256 | 512)]
    public static ulong_mt operator|(ulong_mt a, ulong_mt b) => new(a.vector0 | b.vector0, a.vector1 | b.vector1);

    [MethodImpl(256 | 512)]
    public static ulong_mt operator&(ulong_mt a, ulong_mt b) => new(a.vector0 & b.vector0, a.vector1 & b.vector1);

    [MethodImpl(256 | 512)]
    public static ulong_mt operator^(ulong_mt a, ulong_mt b) => new(a.vector0 ^ b.vector0, a.vector1 ^ b.vector1);

    [MethodImpl(256 | 512)]
    public static ulong_mt operator<<(ulong_mt a, int b) => new(a.vector0 << b, a.vector1 << b);

    [MethodImpl(256 | 512)]
    public static ulong_mt operator>>(ulong_mt a, int b) => new(a.vector0 >> b, a.vector1 >> b);

    [MethodImpl(256 | 512)]
    public static ulong_mt operator>>>(ulong_mt a, int b) => new(a.vector0 >>> b, a.vector1 >>> b);

    #endregion  // Operators

    #region ToString

    public readonly override string ToString() => $"ulong_mt {{ t0 = {this[0]}, t1 = {this[1]}, t2 = {this[2]}, t3 = {this[3]}, t4 = {this[4]}, t5 = {this[5]}, t6 = {this[6]}, t7 = {this[7]}, t8 = {this[8]}, t9 = {this[9]}, t10 = {this[10]}, t11 = {this[11]}, t12 = {this[12]}, t13 = {this[13]}, t14 = {this[14]}, t15 = {this[15]} }}";

    #endregion  // ToString
}

#endregion // ulong_mt
#region b32_mt

[CpuOnly]
public partial struct b32_mt
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => 16;
    }

    #endregion

    #region Fields

    public Vector512<uint> vector;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512), UnscopedRef]
    public readonly ref readonly Vector512<uint> VectorAtRo(int index)
    {
        switch(index)
        {
            case 0: return ref vector;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector512<uint> VectorAt(int index)
    {
        switch(index)
        {
            case 0: return ref vector;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    public b32 this[int index]
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            return vector[index];
        }
        [MethodImpl(256 | 512)]
        set
        {
            vector = vector.WithElement(index, value);
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public b32_mt(Vector512<uint> vector)
    {
        this.vector = vector;
    }

    [MethodImpl(256 | 512)]
    private b32_mt(ref readonly b32 values)
    {
        ref var vs = ref Unsafe.AsRef(in values);
        vector = Vector512.LoadUnsafe(in Unsafe.As<b32, uint>(ref vs));
    }

    [MethodImpl(256 | 512)]
    public static b32_mt LoadUnsafe(ref readonly b32 values) => new(in values);

    [MethodImpl(256 | 512)]
    public static b32_mt LoadUnsafe(params ReadOnlySpan<b32> values) => new(in values.GetPinnableReference());

    [MethodImpl(256 | 512)]
    public b32_mt(b32 value)
    {
        vector = Vector512.Create((uint)value);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator b32_mt(b32 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32_mt(bool value) => (b32)(value);

    [MethodImpl(256 | 512)]
    public static b32_mt operator~(b32_mt a) => new(~a.vector);

    [MethodImpl(256 | 512)]
    public static b32_mt operator|(b32_mt a, b32_mt b) => new(a.vector | b.vector);

    [MethodImpl(256 | 512)]
    public static b32_mt operator&(b32_mt a, b32_mt b) => new(a.vector & b.vector);

    [MethodImpl(256 | 512)]
    public static b32_mt operator^(b32_mt a, b32_mt b) => new(a.vector ^ b.vector);

    [MethodImpl(256 | 512)]
    public static b32_mt operator<<(b32_mt a, int b) => new(a.vector << b);

    [MethodImpl(256 | 512)]
    public static b32_mt operator>>(b32_mt a, int b) => new(a.vector >> b);

    [MethodImpl(256 | 512)]
    public static b32_mt operator>>>(b32_mt a, int b) => new(a.vector >>> b);

    #endregion  // Operators

    #region ToString

    public readonly override string ToString() => $"b32_mt {{ t0 = {this[0]}, t1 = {this[1]}, t2 = {this[2]}, t3 = {this[3]}, t4 = {this[4]}, t5 = {this[5]}, t6 = {this[6]}, t7 = {this[7]}, t8 = {this[8]}, t9 = {this[9]}, t10 = {this[10]}, t11 = {this[11]}, t12 = {this[12]}, t13 = {this[13]}, t14 = {this[14]}, t15 = {this[15]} }}";

    #endregion  // ToString
}

#endregion // b32_mt
#region b64_mt

[CpuOnly]
public partial struct b64_mt
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => 16;
    }

    #endregion

    #region Fields

    public Vector512<ulong> vector0;
    public Vector512<ulong> vector1;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512), UnscopedRef]
    public readonly ref readonly Vector512<ulong> VectorAtRo(int index)
    {
        switch(index)
        {
            case 0: return ref vector0;
            case 1: return ref vector1;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector512<ulong> VectorAt(int index)
    {
        switch(index)
        {
            case 0: return ref vector0;
            case 1: return ref vector1;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    public b64 this[int index]
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            var (q, r) = Math.DivRem(index, Vector512<ulong>.Count);
            return VectorAtRo(q)[r];
        }
        [MethodImpl(256 | 512)]
        set
        {
            var (q, r) = Math.DivRem(index, Vector512<ulong>.Count);
            ref var vector = ref VectorAt(q);
            vector = vector.WithElement(r, value);
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public b64_mt(Vector512<ulong> vector0, Vector512<ulong> vector1)
    {
        this.vector0 = vector0;
        this.vector1 = vector1;
    }

    [MethodImpl(256 | 512)]
    private b64_mt(ref readonly b64 values)
    {
        ref var vs = ref Unsafe.AsRef(in values);
        vector0 = Vector512.LoadUnsafe(in Unsafe.As<b64, ulong>(ref vs));
        vector1 = Vector512.LoadUnsafe(in Unsafe.As<b64, ulong>(ref Unsafe.Add(ref vs, 16)));
    }

    [MethodImpl(256 | 512)]
    public static b64_mt LoadUnsafe(ref readonly b64 values) => new(in values);

    [MethodImpl(256 | 512)]
    public static b64_mt LoadUnsafe(params ReadOnlySpan<b64> values) => new(in values.GetPinnableReference());

    [MethodImpl(256 | 512)]
    public b64_mt(b64 value)
    {
        vector0 = Vector512.Create((ulong)value);
        vector1 = Vector512.Create((ulong)value);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator b64_mt(b64 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64_mt(bool value) => (b64)(value);

    [MethodImpl(256 | 512)]
    public static b64_mt operator~(b64_mt a) => new(~a.vector0, ~a.vector1);

    [MethodImpl(256 | 512)]
    public static b64_mt operator|(b64_mt a, b64_mt b) => new(a.vector0 | b.vector0, a.vector1 | b.vector1);

    [MethodImpl(256 | 512)]
    public static b64_mt operator&(b64_mt a, b64_mt b) => new(a.vector0 & b.vector0, a.vector1 & b.vector1);

    [MethodImpl(256 | 512)]
    public static b64_mt operator^(b64_mt a, b64_mt b) => new(a.vector0 ^ b.vector0, a.vector1 ^ b.vector1);

    [MethodImpl(256 | 512)]
    public static b64_mt operator<<(b64_mt a, int b) => new(a.vector0 << b, a.vector1 << b);

    [MethodImpl(256 | 512)]
    public static b64_mt operator>>(b64_mt a, int b) => new(a.vector0 >> b, a.vector1 >> b);

    [MethodImpl(256 | 512)]
    public static b64_mt operator>>>(b64_mt a, int b) => new(a.vector0 >>> b, a.vector1 >>> b);

    #endregion  // Operators

    #region ToString

    public readonly override string ToString() => $"b64_mt {{ t0 = {this[0]}, t1 = {this[1]}, t2 = {this[2]}, t3 = {this[3]}, t4 = {this[4]}, t5 = {this[5]}, t6 = {this[6]}, t7 = {this[7]}, t8 = {this[8]}, t9 = {this[9]}, t10 = {this[10]}, t11 = {this[11]}, t12 = {this[12]}, t13 = {this[13]}, t14 = {this[14]}, t15 = {this[15]} }}";

    #endregion  // ToString
}

#endregion // b64_mt
