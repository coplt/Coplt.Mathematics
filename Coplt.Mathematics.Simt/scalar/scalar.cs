// generated by template, do not modify manually

namespace Coplt.Mathematics.Simt;

#region float_mt4

[CpuOnly]
public partial struct float_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => 4;
    }

    #endregion

    #region Fields

    public Vector128<float> vector;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512), UnscopedRef]
    public readonly ref readonly Vector128<float> VectorAtRo(int index)
    {
        switch(index)
        {
            case 0: return ref vector;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector128<float> VectorAt(int index)
    {
        switch(index)
        {
            case 0: return ref vector;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    public float this[int index]
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            return vector[index];
        }
        [MethodImpl(256 | 512)]
        set
        {
            vector = vector.WithElement(index, value);
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public float_mt4(Vector128<float> vector)
    {
        this.vector = vector;
    }

    [MethodImpl(256 | 512)]
    private float_mt4(ref readonly float values)
    {
        ref var vs = ref Unsafe.AsRef(in values);
        vector = Vector128.LoadUnsafe(in vs);
    }

    [MethodImpl(256 | 512)]
    public static float_mt4 LoadUnsafe(ref readonly float values) => new(in values);

    [MethodImpl(256 | 512)]
    public static float_mt4 LoadUnsafe(params ReadOnlySpan<float> values) => new(in values.GetPinnableReference());

    [MethodImpl(256 | 512)]
    public float_mt4(float value)
    {
        vector = Vector128.Create(value);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator float_mt4(float value) => new(value);

    [MethodImpl(256 | 512)]
    public static float_mt4 operator~(float_mt4 a) => new(~a.vector);

    [MethodImpl(256 | 512)]
    public static float_mt4 operator|(float_mt4 a, float_mt4 b) => new(a.vector | b.vector);

    [MethodImpl(256 | 512)]
    public static float_mt4 operator&(float_mt4 a, float_mt4 b) => new(a.vector & b.vector);

    [MethodImpl(256 | 512)]
    public static float_mt4 operator^(float_mt4 a, float_mt4 b) => new(a.vector ^ b.vector);

    [MethodImpl(256 | 512)]
    public static float_mt4 operator<<(float_mt4 a, int b) => new(a.vector << b);

    [MethodImpl(256 | 512)]
    public static float_mt4 operator>>(float_mt4 a, int b) => new(a.vector >> b);

    [MethodImpl(256 | 512)]
    public static float_mt4 operator>>>(float_mt4 a, int b) => new(a.vector >>> b);

    #endregion  // Operators

    #region ToString

    public readonly override string ToString() => $"float_mt4 {{ t0 = {this[0]}, t1 = {this[1]}, t2 = {this[2]}, t3 = {this[3]} }}";

    #endregion  // ToString
}

#endregion // float_mt4
#region float_mt8

[CpuOnly]
public partial struct float_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => 8;
    }

    #endregion

    #region Fields

    public Vector256<float> vector;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512), UnscopedRef]
    public readonly ref readonly Vector256<float> VectorAtRo(int index)
    {
        switch(index)
        {
            case 0: return ref vector;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector256<float> VectorAt(int index)
    {
        switch(index)
        {
            case 0: return ref vector;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    public float this[int index]
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            return vector[index];
        }
        [MethodImpl(256 | 512)]
        set
        {
            vector = vector.WithElement(index, value);
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public float_mt8(Vector256<float> vector)
    {
        this.vector = vector;
    }

    [MethodImpl(256 | 512)]
    private float_mt8(ref readonly float values)
    {
        ref var vs = ref Unsafe.AsRef(in values);
        vector = Vector256.LoadUnsafe(in vs);
    }

    [MethodImpl(256 | 512)]
    public static float_mt8 LoadUnsafe(ref readonly float values) => new(in values);

    [MethodImpl(256 | 512)]
    public static float_mt8 LoadUnsafe(params ReadOnlySpan<float> values) => new(in values.GetPinnableReference());

    [MethodImpl(256 | 512)]
    public float_mt8(float value)
    {
        vector = Vector256.Create(value);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator float_mt8(float value) => new(value);

    [MethodImpl(256 | 512)]
    public static float_mt8 operator~(float_mt8 a) => new(~a.vector);

    [MethodImpl(256 | 512)]
    public static float_mt8 operator|(float_mt8 a, float_mt8 b) => new(a.vector | b.vector);

    [MethodImpl(256 | 512)]
    public static float_mt8 operator&(float_mt8 a, float_mt8 b) => new(a.vector & b.vector);

    [MethodImpl(256 | 512)]
    public static float_mt8 operator^(float_mt8 a, float_mt8 b) => new(a.vector ^ b.vector);

    [MethodImpl(256 | 512)]
    public static float_mt8 operator<<(float_mt8 a, int b) => new(a.vector << b);

    [MethodImpl(256 | 512)]
    public static float_mt8 operator>>(float_mt8 a, int b) => new(a.vector >> b);

    [MethodImpl(256 | 512)]
    public static float_mt8 operator>>>(float_mt8 a, int b) => new(a.vector >>> b);

    #endregion  // Operators

    #region ToString

    public readonly override string ToString() => $"float_mt8 {{ t0 = {this[0]}, t1 = {this[1]}, t2 = {this[2]}, t3 = {this[3]}, t4 = {this[4]}, t5 = {this[5]}, t6 = {this[6]}, t7 = {this[7]} }}";

    #endregion  // ToString
}

#endregion // float_mt8
#region float_mt16

[CpuOnly]
public partial struct float_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => 16;
    }

    #endregion

    #region Fields

    public Vector512<float> vector;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512), UnscopedRef]
    public readonly ref readonly Vector512<float> VectorAtRo(int index)
    {
        switch(index)
        {
            case 0: return ref vector;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector512<float> VectorAt(int index)
    {
        switch(index)
        {
            case 0: return ref vector;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    public float this[int index]
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            return vector[index];
        }
        [MethodImpl(256 | 512)]
        set
        {
            vector = vector.WithElement(index, value);
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public float_mt16(Vector512<float> vector)
    {
        this.vector = vector;
    }

    [MethodImpl(256 | 512)]
    private float_mt16(ref readonly float values)
    {
        ref var vs = ref Unsafe.AsRef(in values);
        vector = Vector512.LoadUnsafe(in vs);
    }

    [MethodImpl(256 | 512)]
    public static float_mt16 LoadUnsafe(ref readonly float values) => new(in values);

    [MethodImpl(256 | 512)]
    public static float_mt16 LoadUnsafe(params ReadOnlySpan<float> values) => new(in values.GetPinnableReference());

    [MethodImpl(256 | 512)]
    public float_mt16(float value)
    {
        vector = Vector512.Create(value);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator float_mt16(float value) => new(value);

    [MethodImpl(256 | 512)]
    public static float_mt16 operator~(float_mt16 a) => new(~a.vector);

    [MethodImpl(256 | 512)]
    public static float_mt16 operator|(float_mt16 a, float_mt16 b) => new(a.vector | b.vector);

    [MethodImpl(256 | 512)]
    public static float_mt16 operator&(float_mt16 a, float_mt16 b) => new(a.vector & b.vector);

    [MethodImpl(256 | 512)]
    public static float_mt16 operator^(float_mt16 a, float_mt16 b) => new(a.vector ^ b.vector);

    [MethodImpl(256 | 512)]
    public static float_mt16 operator<<(float_mt16 a, int b) => new(a.vector << b);

    [MethodImpl(256 | 512)]
    public static float_mt16 operator>>(float_mt16 a, int b) => new(a.vector >> b);

    [MethodImpl(256 | 512)]
    public static float_mt16 operator>>>(float_mt16 a, int b) => new(a.vector >>> b);

    #endregion  // Operators

    #region ToString

    public readonly override string ToString() => $"float_mt16 {{ t0 = {this[0]}, t1 = {this[1]}, t2 = {this[2]}, t3 = {this[3]}, t4 = {this[4]}, t5 = {this[5]}, t6 = {this[6]}, t7 = {this[7]}, t8 = {this[8]}, t9 = {this[9]}, t10 = {this[10]}, t11 = {this[11]}, t12 = {this[12]}, t13 = {this[13]}, t14 = {this[14]}, t15 = {this[15]} }}";

    #endregion  // ToString
}

#endregion // float_mt16
#region float_mt32

[CpuOnly]
public partial struct float_mt32
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => 32;
    }

    #endregion

    #region Fields

    public Vector512<float> vector0;
    public Vector512<float> vector1;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512), UnscopedRef]
    public readonly ref readonly Vector512<float> VectorAtRo(int index)
    {
        switch(index)
        {
            case 0: return ref vector0;
            case 1: return ref vector1;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector512<float> VectorAt(int index)
    {
        switch(index)
        {
            case 0: return ref vector0;
            case 1: return ref vector1;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    public float this[int index]
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            var (q, r) = Math.DivRem(index, Vector512<float>.Count);
            return VectorAtRo(q)[r];
        }
        [MethodImpl(256 | 512)]
        set
        {
            var (q, r) = Math.DivRem(index, Vector512<float>.Count);
            ref var vector = ref VectorAt(q);
            vector = vector.WithElement(r, value);
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public float_mt32(Vector512<float> vector0, Vector512<float> vector1)
    {
        this.vector0 = vector0;
        this.vector1 = vector1;
    }

    [MethodImpl(256 | 512)]
    private float_mt32(ref readonly float values)
    {
        ref var vs = ref Unsafe.AsRef(in values);
        vector0 = Vector512.LoadUnsafe(in vs);
        vector1 = Vector512.LoadUnsafe(in Unsafe.Add(ref vs, 32));
    }

    [MethodImpl(256 | 512)]
    public static float_mt32 LoadUnsafe(ref readonly float values) => new(in values);

    [MethodImpl(256 | 512)]
    public static float_mt32 LoadUnsafe(params ReadOnlySpan<float> values) => new(in values.GetPinnableReference());

    [MethodImpl(256 | 512)]
    public float_mt32(float value)
    {
        vector0 = Vector512.Create(value);
        vector1 = Vector512.Create(value);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator float_mt32(float value) => new(value);

    [MethodImpl(256 | 512)]
    public static float_mt32 operator~(float_mt32 a) => new(~a.vector0, ~a.vector1);

    [MethodImpl(256 | 512)]
    public static float_mt32 operator|(float_mt32 a, float_mt32 b) => new(a.vector0 | b.vector0, a.vector1 | b.vector1);

    [MethodImpl(256 | 512)]
    public static float_mt32 operator&(float_mt32 a, float_mt32 b) => new(a.vector0 & b.vector0, a.vector1 & b.vector1);

    [MethodImpl(256 | 512)]
    public static float_mt32 operator^(float_mt32 a, float_mt32 b) => new(a.vector0 ^ b.vector0, a.vector1 ^ b.vector1);

    [MethodImpl(256 | 512)]
    public static float_mt32 operator<<(float_mt32 a, int b) => new(a.vector0 << b, a.vector1 << b);

    [MethodImpl(256 | 512)]
    public static float_mt32 operator>>(float_mt32 a, int b) => new(a.vector0 >> b, a.vector1 >> b);

    [MethodImpl(256 | 512)]
    public static float_mt32 operator>>>(float_mt32 a, int b) => new(a.vector0 >>> b, a.vector1 >>> b);

    #endregion  // Operators

    #region ToString

    public readonly override string ToString() => $"float_mt32 {{ t0 = {this[0]}, t1 = {this[1]}, t2 = {this[2]}, t3 = {this[3]}, t4 = {this[4]}, t5 = {this[5]}, t6 = {this[6]}, t7 = {this[7]}, t8 = {this[8]}, t9 = {this[9]}, t10 = {this[10]}, t11 = {this[11]}, t12 = {this[12]}, t13 = {this[13]}, t14 = {this[14]}, t15 = {this[15]}, t16 = {this[16]}, t17 = {this[17]}, t18 = {this[18]}, t19 = {this[19]}, t20 = {this[20]}, t21 = {this[21]}, t22 = {this[22]}, t23 = {this[23]}, t24 = {this[24]}, t25 = {this[25]}, t26 = {this[26]}, t27 = {this[27]}, t28 = {this[28]}, t29 = {this[29]}, t30 = {this[30]}, t31 = {this[31]} }}";

    #endregion  // ToString
}

#endregion // float_mt32
#region double_mt4

[CpuOnly]
public partial struct double_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => 4;
    }

    #endregion

    #region Fields

    public Vector256<double> vector;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512), UnscopedRef]
    public readonly ref readonly Vector256<double> VectorAtRo(int index)
    {
        switch(index)
        {
            case 0: return ref vector;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector256<double> VectorAt(int index)
    {
        switch(index)
        {
            case 0: return ref vector;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    public double this[int index]
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            return vector[index];
        }
        [MethodImpl(256 | 512)]
        set
        {
            vector = vector.WithElement(index, value);
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public double_mt4(Vector256<double> vector)
    {
        this.vector = vector;
    }

    [MethodImpl(256 | 512)]
    private double_mt4(ref readonly double values)
    {
        ref var vs = ref Unsafe.AsRef(in values);
        vector = Vector256.LoadUnsafe(in vs);
    }

    [MethodImpl(256 | 512)]
    public static double_mt4 LoadUnsafe(ref readonly double values) => new(in values);

    [MethodImpl(256 | 512)]
    public static double_mt4 LoadUnsafe(params ReadOnlySpan<double> values) => new(in values.GetPinnableReference());

    [MethodImpl(256 | 512)]
    public double_mt4(double value)
    {
        vector = Vector256.Create(value);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator double_mt4(double value) => new(value);

    [MethodImpl(256 | 512)]
    public static double_mt4 operator~(double_mt4 a) => new(~a.vector);

    [MethodImpl(256 | 512)]
    public static double_mt4 operator|(double_mt4 a, double_mt4 b) => new(a.vector | b.vector);

    [MethodImpl(256 | 512)]
    public static double_mt4 operator&(double_mt4 a, double_mt4 b) => new(a.vector & b.vector);

    [MethodImpl(256 | 512)]
    public static double_mt4 operator^(double_mt4 a, double_mt4 b) => new(a.vector ^ b.vector);

    [MethodImpl(256 | 512)]
    public static double_mt4 operator<<(double_mt4 a, int b) => new(a.vector << b);

    [MethodImpl(256 | 512)]
    public static double_mt4 operator>>(double_mt4 a, int b) => new(a.vector >> b);

    [MethodImpl(256 | 512)]
    public static double_mt4 operator>>>(double_mt4 a, int b) => new(a.vector >>> b);

    #endregion  // Operators

    #region ToString

    public readonly override string ToString() => $"double_mt4 {{ t0 = {this[0]}, t1 = {this[1]}, t2 = {this[2]}, t3 = {this[3]} }}";

    #endregion  // ToString
}

#endregion // double_mt4
#region double_mt8

[CpuOnly]
public partial struct double_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => 8;
    }

    #endregion

    #region Fields

    public Vector512<double> vector;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512), UnscopedRef]
    public readonly ref readonly Vector512<double> VectorAtRo(int index)
    {
        switch(index)
        {
            case 0: return ref vector;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector512<double> VectorAt(int index)
    {
        switch(index)
        {
            case 0: return ref vector;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    public double this[int index]
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            return vector[index];
        }
        [MethodImpl(256 | 512)]
        set
        {
            vector = vector.WithElement(index, value);
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public double_mt8(Vector512<double> vector)
    {
        this.vector = vector;
    }

    [MethodImpl(256 | 512)]
    private double_mt8(ref readonly double values)
    {
        ref var vs = ref Unsafe.AsRef(in values);
        vector = Vector512.LoadUnsafe(in vs);
    }

    [MethodImpl(256 | 512)]
    public static double_mt8 LoadUnsafe(ref readonly double values) => new(in values);

    [MethodImpl(256 | 512)]
    public static double_mt8 LoadUnsafe(params ReadOnlySpan<double> values) => new(in values.GetPinnableReference());

    [MethodImpl(256 | 512)]
    public double_mt8(double value)
    {
        vector = Vector512.Create(value);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator double_mt8(double value) => new(value);

    [MethodImpl(256 | 512)]
    public static double_mt8 operator~(double_mt8 a) => new(~a.vector);

    [MethodImpl(256 | 512)]
    public static double_mt8 operator|(double_mt8 a, double_mt8 b) => new(a.vector | b.vector);

    [MethodImpl(256 | 512)]
    public static double_mt8 operator&(double_mt8 a, double_mt8 b) => new(a.vector & b.vector);

    [MethodImpl(256 | 512)]
    public static double_mt8 operator^(double_mt8 a, double_mt8 b) => new(a.vector ^ b.vector);

    [MethodImpl(256 | 512)]
    public static double_mt8 operator<<(double_mt8 a, int b) => new(a.vector << b);

    [MethodImpl(256 | 512)]
    public static double_mt8 operator>>(double_mt8 a, int b) => new(a.vector >> b);

    [MethodImpl(256 | 512)]
    public static double_mt8 operator>>>(double_mt8 a, int b) => new(a.vector >>> b);

    #endregion  // Operators

    #region ToString

    public readonly override string ToString() => $"double_mt8 {{ t0 = {this[0]}, t1 = {this[1]}, t2 = {this[2]}, t3 = {this[3]}, t4 = {this[4]}, t5 = {this[5]}, t6 = {this[6]}, t7 = {this[7]} }}";

    #endregion  // ToString
}

#endregion // double_mt8
#region double_mt16

[CpuOnly]
public partial struct double_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => 16;
    }

    #endregion

    #region Fields

    public Vector512<double> vector0;
    public Vector512<double> vector1;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512), UnscopedRef]
    public readonly ref readonly Vector512<double> VectorAtRo(int index)
    {
        switch(index)
        {
            case 0: return ref vector0;
            case 1: return ref vector1;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector512<double> VectorAt(int index)
    {
        switch(index)
        {
            case 0: return ref vector0;
            case 1: return ref vector1;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    public double this[int index]
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            var (q, r) = Math.DivRem(index, Vector512<double>.Count);
            return VectorAtRo(q)[r];
        }
        [MethodImpl(256 | 512)]
        set
        {
            var (q, r) = Math.DivRem(index, Vector512<double>.Count);
            ref var vector = ref VectorAt(q);
            vector = vector.WithElement(r, value);
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public double_mt16(Vector512<double> vector0, Vector512<double> vector1)
    {
        this.vector0 = vector0;
        this.vector1 = vector1;
    }

    [MethodImpl(256 | 512)]
    private double_mt16(ref readonly double values)
    {
        ref var vs = ref Unsafe.AsRef(in values);
        vector0 = Vector512.LoadUnsafe(in vs);
        vector1 = Vector512.LoadUnsafe(in Unsafe.Add(ref vs, 16));
    }

    [MethodImpl(256 | 512)]
    public static double_mt16 LoadUnsafe(ref readonly double values) => new(in values);

    [MethodImpl(256 | 512)]
    public static double_mt16 LoadUnsafe(params ReadOnlySpan<double> values) => new(in values.GetPinnableReference());

    [MethodImpl(256 | 512)]
    public double_mt16(double value)
    {
        vector0 = Vector512.Create(value);
        vector1 = Vector512.Create(value);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator double_mt16(double value) => new(value);

    [MethodImpl(256 | 512)]
    public static double_mt16 operator~(double_mt16 a) => new(~a.vector0, ~a.vector1);

    [MethodImpl(256 | 512)]
    public static double_mt16 operator|(double_mt16 a, double_mt16 b) => new(a.vector0 | b.vector0, a.vector1 | b.vector1);

    [MethodImpl(256 | 512)]
    public static double_mt16 operator&(double_mt16 a, double_mt16 b) => new(a.vector0 & b.vector0, a.vector1 & b.vector1);

    [MethodImpl(256 | 512)]
    public static double_mt16 operator^(double_mt16 a, double_mt16 b) => new(a.vector0 ^ b.vector0, a.vector1 ^ b.vector1);

    [MethodImpl(256 | 512)]
    public static double_mt16 operator<<(double_mt16 a, int b) => new(a.vector0 << b, a.vector1 << b);

    [MethodImpl(256 | 512)]
    public static double_mt16 operator>>(double_mt16 a, int b) => new(a.vector0 >> b, a.vector1 >> b);

    [MethodImpl(256 | 512)]
    public static double_mt16 operator>>>(double_mt16 a, int b) => new(a.vector0 >>> b, a.vector1 >>> b);

    #endregion  // Operators

    #region ToString

    public readonly override string ToString() => $"double_mt16 {{ t0 = {this[0]}, t1 = {this[1]}, t2 = {this[2]}, t3 = {this[3]}, t4 = {this[4]}, t5 = {this[5]}, t6 = {this[6]}, t7 = {this[7]}, t8 = {this[8]}, t9 = {this[9]}, t10 = {this[10]}, t11 = {this[11]}, t12 = {this[12]}, t13 = {this[13]}, t14 = {this[14]}, t15 = {this[15]} }}";

    #endregion  // ToString
}

#endregion // double_mt16
#region double_mt32

[CpuOnly]
public partial struct double_mt32
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => 32;
    }

    #endregion

    #region Fields

    public Vector512<double> vector0;
    public Vector512<double> vector1;
    public Vector512<double> vector2;
    public Vector512<double> vector3;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512), UnscopedRef]
    public readonly ref readonly Vector512<double> VectorAtRo(int index)
    {
        switch(index)
        {
            case 0: return ref vector0;
            case 1: return ref vector1;
            case 2: return ref vector2;
            case 3: return ref vector3;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector512<double> VectorAt(int index)
    {
        switch(index)
        {
            case 0: return ref vector0;
            case 1: return ref vector1;
            case 2: return ref vector2;
            case 3: return ref vector3;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    public double this[int index]
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            var (q, r) = Math.DivRem(index, Vector512<double>.Count);
            return VectorAtRo(q)[r];
        }
        [MethodImpl(256 | 512)]
        set
        {
            var (q, r) = Math.DivRem(index, Vector512<double>.Count);
            ref var vector = ref VectorAt(q);
            vector = vector.WithElement(r, value);
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public double_mt32(Vector512<double> vector0, Vector512<double> vector1, Vector512<double> vector2, Vector512<double> vector3)
    {
        this.vector0 = vector0;
        this.vector1 = vector1;
        this.vector2 = vector2;
        this.vector3 = vector3;
    }

    [MethodImpl(256 | 512)]
    private double_mt32(ref readonly double values)
    {
        ref var vs = ref Unsafe.AsRef(in values);
        vector0 = Vector512.LoadUnsafe(in vs);
        vector1 = Vector512.LoadUnsafe(in Unsafe.Add(ref vs, 32));
        vector2 = Vector512.LoadUnsafe(in Unsafe.Add(ref vs, 64));
        vector3 = Vector512.LoadUnsafe(in Unsafe.Add(ref vs, 96));
    }

    [MethodImpl(256 | 512)]
    public static double_mt32 LoadUnsafe(ref readonly double values) => new(in values);

    [MethodImpl(256 | 512)]
    public static double_mt32 LoadUnsafe(params ReadOnlySpan<double> values) => new(in values.GetPinnableReference());

    [MethodImpl(256 | 512)]
    public double_mt32(double value)
    {
        vector0 = Vector512.Create(value);
        vector1 = Vector512.Create(value);
        vector2 = Vector512.Create(value);
        vector3 = Vector512.Create(value);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator double_mt32(double value) => new(value);

    [MethodImpl(256 | 512)]
    public static double_mt32 operator~(double_mt32 a) => new(~a.vector0, ~a.vector1, ~a.vector2, ~a.vector3);

    [MethodImpl(256 | 512)]
    public static double_mt32 operator|(double_mt32 a, double_mt32 b) => new(a.vector0 | b.vector0, a.vector1 | b.vector1, a.vector2 | b.vector2, a.vector3 | b.vector3);

    [MethodImpl(256 | 512)]
    public static double_mt32 operator&(double_mt32 a, double_mt32 b) => new(a.vector0 & b.vector0, a.vector1 & b.vector1, a.vector2 & b.vector2, a.vector3 & b.vector3);

    [MethodImpl(256 | 512)]
    public static double_mt32 operator^(double_mt32 a, double_mt32 b) => new(a.vector0 ^ b.vector0, a.vector1 ^ b.vector1, a.vector2 ^ b.vector2, a.vector3 ^ b.vector3);

    [MethodImpl(256 | 512)]
    public static double_mt32 operator<<(double_mt32 a, int b) => new(a.vector0 << b, a.vector1 << b, a.vector2 << b, a.vector3 << b);

    [MethodImpl(256 | 512)]
    public static double_mt32 operator>>(double_mt32 a, int b) => new(a.vector0 >> b, a.vector1 >> b, a.vector2 >> b, a.vector3 >> b);

    [MethodImpl(256 | 512)]
    public static double_mt32 operator>>>(double_mt32 a, int b) => new(a.vector0 >>> b, a.vector1 >>> b, a.vector2 >>> b, a.vector3 >>> b);

    #endregion  // Operators

    #region ToString

    public readonly override string ToString() => $"double_mt32 {{ t0 = {this[0]}, t1 = {this[1]}, t2 = {this[2]}, t3 = {this[3]}, t4 = {this[4]}, t5 = {this[5]}, t6 = {this[6]}, t7 = {this[7]}, t8 = {this[8]}, t9 = {this[9]}, t10 = {this[10]}, t11 = {this[11]}, t12 = {this[12]}, t13 = {this[13]}, t14 = {this[14]}, t15 = {this[15]}, t16 = {this[16]}, t17 = {this[17]}, t18 = {this[18]}, t19 = {this[19]}, t20 = {this[20]}, t21 = {this[21]}, t22 = {this[22]}, t23 = {this[23]}, t24 = {this[24]}, t25 = {this[25]}, t26 = {this[26]}, t27 = {this[27]}, t28 = {this[28]}, t29 = {this[29]}, t30 = {this[30]}, t31 = {this[31]} }}";

    #endregion  // ToString
}

#endregion // double_mt32
#region int_mt4

[CpuOnly]
public partial struct int_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => 4;
    }

    #endregion

    #region Fields

    public Vector128<int> vector;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512), UnscopedRef]
    public readonly ref readonly Vector128<int> VectorAtRo(int index)
    {
        switch(index)
        {
            case 0: return ref vector;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector128<int> VectorAt(int index)
    {
        switch(index)
        {
            case 0: return ref vector;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    public int this[int index]
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            return vector[index];
        }
        [MethodImpl(256 | 512)]
        set
        {
            vector = vector.WithElement(index, value);
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public int_mt4(Vector128<int> vector)
    {
        this.vector = vector;
    }

    [MethodImpl(256 | 512)]
    private int_mt4(ref readonly int values)
    {
        ref var vs = ref Unsafe.AsRef(in values);
        vector = Vector128.LoadUnsafe(in vs);
    }

    [MethodImpl(256 | 512)]
    public static int_mt4 LoadUnsafe(ref readonly int values) => new(in values);

    [MethodImpl(256 | 512)]
    public static int_mt4 LoadUnsafe(params ReadOnlySpan<int> values) => new(in values.GetPinnableReference());

    [MethodImpl(256 | 512)]
    public int_mt4(int value)
    {
        vector = Vector128.Create(value);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator int_mt4(int value) => new(value);

    [MethodImpl(256 | 512)]
    public static int_mt4 operator~(int_mt4 a) => new(~a.vector);

    [MethodImpl(256 | 512)]
    public static int_mt4 operator|(int_mt4 a, int_mt4 b) => new(a.vector | b.vector);

    [MethodImpl(256 | 512)]
    public static int_mt4 operator&(int_mt4 a, int_mt4 b) => new(a.vector & b.vector);

    [MethodImpl(256 | 512)]
    public static int_mt4 operator^(int_mt4 a, int_mt4 b) => new(a.vector ^ b.vector);

    [MethodImpl(256 | 512)]
    public static int_mt4 operator<<(int_mt4 a, int b) => new(a.vector << b);

    [MethodImpl(256 | 512)]
    public static int_mt4 operator>>(int_mt4 a, int b) => new(a.vector >> b);

    [MethodImpl(256 | 512)]
    public static int_mt4 operator>>>(int_mt4 a, int b) => new(a.vector >>> b);

    #endregion  // Operators

    #region ToString

    public readonly override string ToString() => $"int_mt4 {{ t0 = {this[0]}, t1 = {this[1]}, t2 = {this[2]}, t3 = {this[3]} }}";

    #endregion  // ToString
}

#endregion // int_mt4
#region int_mt8

[CpuOnly]
public partial struct int_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => 8;
    }

    #endregion

    #region Fields

    public Vector256<int> vector;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512), UnscopedRef]
    public readonly ref readonly Vector256<int> VectorAtRo(int index)
    {
        switch(index)
        {
            case 0: return ref vector;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector256<int> VectorAt(int index)
    {
        switch(index)
        {
            case 0: return ref vector;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    public int this[int index]
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            return vector[index];
        }
        [MethodImpl(256 | 512)]
        set
        {
            vector = vector.WithElement(index, value);
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public int_mt8(Vector256<int> vector)
    {
        this.vector = vector;
    }

    [MethodImpl(256 | 512)]
    private int_mt8(ref readonly int values)
    {
        ref var vs = ref Unsafe.AsRef(in values);
        vector = Vector256.LoadUnsafe(in vs);
    }

    [MethodImpl(256 | 512)]
    public static int_mt8 LoadUnsafe(ref readonly int values) => new(in values);

    [MethodImpl(256 | 512)]
    public static int_mt8 LoadUnsafe(params ReadOnlySpan<int> values) => new(in values.GetPinnableReference());

    [MethodImpl(256 | 512)]
    public int_mt8(int value)
    {
        vector = Vector256.Create(value);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator int_mt8(int value) => new(value);

    [MethodImpl(256 | 512)]
    public static int_mt8 operator~(int_mt8 a) => new(~a.vector);

    [MethodImpl(256 | 512)]
    public static int_mt8 operator|(int_mt8 a, int_mt8 b) => new(a.vector | b.vector);

    [MethodImpl(256 | 512)]
    public static int_mt8 operator&(int_mt8 a, int_mt8 b) => new(a.vector & b.vector);

    [MethodImpl(256 | 512)]
    public static int_mt8 operator^(int_mt8 a, int_mt8 b) => new(a.vector ^ b.vector);

    [MethodImpl(256 | 512)]
    public static int_mt8 operator<<(int_mt8 a, int b) => new(a.vector << b);

    [MethodImpl(256 | 512)]
    public static int_mt8 operator>>(int_mt8 a, int b) => new(a.vector >> b);

    [MethodImpl(256 | 512)]
    public static int_mt8 operator>>>(int_mt8 a, int b) => new(a.vector >>> b);

    #endregion  // Operators

    #region ToString

    public readonly override string ToString() => $"int_mt8 {{ t0 = {this[0]}, t1 = {this[1]}, t2 = {this[2]}, t3 = {this[3]}, t4 = {this[4]}, t5 = {this[5]}, t6 = {this[6]}, t7 = {this[7]} }}";

    #endregion  // ToString
}

#endregion // int_mt8
#region int_mt16

[CpuOnly]
public partial struct int_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => 16;
    }

    #endregion

    #region Fields

    public Vector512<int> vector;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512), UnscopedRef]
    public readonly ref readonly Vector512<int> VectorAtRo(int index)
    {
        switch(index)
        {
            case 0: return ref vector;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector512<int> VectorAt(int index)
    {
        switch(index)
        {
            case 0: return ref vector;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    public int this[int index]
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            return vector[index];
        }
        [MethodImpl(256 | 512)]
        set
        {
            vector = vector.WithElement(index, value);
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public int_mt16(Vector512<int> vector)
    {
        this.vector = vector;
    }

    [MethodImpl(256 | 512)]
    private int_mt16(ref readonly int values)
    {
        ref var vs = ref Unsafe.AsRef(in values);
        vector = Vector512.LoadUnsafe(in vs);
    }

    [MethodImpl(256 | 512)]
    public static int_mt16 LoadUnsafe(ref readonly int values) => new(in values);

    [MethodImpl(256 | 512)]
    public static int_mt16 LoadUnsafe(params ReadOnlySpan<int> values) => new(in values.GetPinnableReference());

    [MethodImpl(256 | 512)]
    public int_mt16(int value)
    {
        vector = Vector512.Create(value);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator int_mt16(int value) => new(value);

    [MethodImpl(256 | 512)]
    public static int_mt16 operator~(int_mt16 a) => new(~a.vector);

    [MethodImpl(256 | 512)]
    public static int_mt16 operator|(int_mt16 a, int_mt16 b) => new(a.vector | b.vector);

    [MethodImpl(256 | 512)]
    public static int_mt16 operator&(int_mt16 a, int_mt16 b) => new(a.vector & b.vector);

    [MethodImpl(256 | 512)]
    public static int_mt16 operator^(int_mt16 a, int_mt16 b) => new(a.vector ^ b.vector);

    [MethodImpl(256 | 512)]
    public static int_mt16 operator<<(int_mt16 a, int b) => new(a.vector << b);

    [MethodImpl(256 | 512)]
    public static int_mt16 operator>>(int_mt16 a, int b) => new(a.vector >> b);

    [MethodImpl(256 | 512)]
    public static int_mt16 operator>>>(int_mt16 a, int b) => new(a.vector >>> b);

    #endregion  // Operators

    #region ToString

    public readonly override string ToString() => $"int_mt16 {{ t0 = {this[0]}, t1 = {this[1]}, t2 = {this[2]}, t3 = {this[3]}, t4 = {this[4]}, t5 = {this[5]}, t6 = {this[6]}, t7 = {this[7]}, t8 = {this[8]}, t9 = {this[9]}, t10 = {this[10]}, t11 = {this[11]}, t12 = {this[12]}, t13 = {this[13]}, t14 = {this[14]}, t15 = {this[15]} }}";

    #endregion  // ToString
}

#endregion // int_mt16
#region int_mt32

[CpuOnly]
public partial struct int_mt32
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => 32;
    }

    #endregion

    #region Fields

    public Vector512<int> vector0;
    public Vector512<int> vector1;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512), UnscopedRef]
    public readonly ref readonly Vector512<int> VectorAtRo(int index)
    {
        switch(index)
        {
            case 0: return ref vector0;
            case 1: return ref vector1;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector512<int> VectorAt(int index)
    {
        switch(index)
        {
            case 0: return ref vector0;
            case 1: return ref vector1;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    public int this[int index]
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            var (q, r) = Math.DivRem(index, Vector512<int>.Count);
            return VectorAtRo(q)[r];
        }
        [MethodImpl(256 | 512)]
        set
        {
            var (q, r) = Math.DivRem(index, Vector512<int>.Count);
            ref var vector = ref VectorAt(q);
            vector = vector.WithElement(r, value);
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public int_mt32(Vector512<int> vector0, Vector512<int> vector1)
    {
        this.vector0 = vector0;
        this.vector1 = vector1;
    }

    [MethodImpl(256 | 512)]
    private int_mt32(ref readonly int values)
    {
        ref var vs = ref Unsafe.AsRef(in values);
        vector0 = Vector512.LoadUnsafe(in vs);
        vector1 = Vector512.LoadUnsafe(in Unsafe.Add(ref vs, 32));
    }

    [MethodImpl(256 | 512)]
    public static int_mt32 LoadUnsafe(ref readonly int values) => new(in values);

    [MethodImpl(256 | 512)]
    public static int_mt32 LoadUnsafe(params ReadOnlySpan<int> values) => new(in values.GetPinnableReference());

    [MethodImpl(256 | 512)]
    public int_mt32(int value)
    {
        vector0 = Vector512.Create(value);
        vector1 = Vector512.Create(value);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator int_mt32(int value) => new(value);

    [MethodImpl(256 | 512)]
    public static int_mt32 operator~(int_mt32 a) => new(~a.vector0, ~a.vector1);

    [MethodImpl(256 | 512)]
    public static int_mt32 operator|(int_mt32 a, int_mt32 b) => new(a.vector0 | b.vector0, a.vector1 | b.vector1);

    [MethodImpl(256 | 512)]
    public static int_mt32 operator&(int_mt32 a, int_mt32 b) => new(a.vector0 & b.vector0, a.vector1 & b.vector1);

    [MethodImpl(256 | 512)]
    public static int_mt32 operator^(int_mt32 a, int_mt32 b) => new(a.vector0 ^ b.vector0, a.vector1 ^ b.vector1);

    [MethodImpl(256 | 512)]
    public static int_mt32 operator<<(int_mt32 a, int b) => new(a.vector0 << b, a.vector1 << b);

    [MethodImpl(256 | 512)]
    public static int_mt32 operator>>(int_mt32 a, int b) => new(a.vector0 >> b, a.vector1 >> b);

    [MethodImpl(256 | 512)]
    public static int_mt32 operator>>>(int_mt32 a, int b) => new(a.vector0 >>> b, a.vector1 >>> b);

    #endregion  // Operators

    #region ToString

    public readonly override string ToString() => $"int_mt32 {{ t0 = {this[0]}, t1 = {this[1]}, t2 = {this[2]}, t3 = {this[3]}, t4 = {this[4]}, t5 = {this[5]}, t6 = {this[6]}, t7 = {this[7]}, t8 = {this[8]}, t9 = {this[9]}, t10 = {this[10]}, t11 = {this[11]}, t12 = {this[12]}, t13 = {this[13]}, t14 = {this[14]}, t15 = {this[15]}, t16 = {this[16]}, t17 = {this[17]}, t18 = {this[18]}, t19 = {this[19]}, t20 = {this[20]}, t21 = {this[21]}, t22 = {this[22]}, t23 = {this[23]}, t24 = {this[24]}, t25 = {this[25]}, t26 = {this[26]}, t27 = {this[27]}, t28 = {this[28]}, t29 = {this[29]}, t30 = {this[30]}, t31 = {this[31]} }}";

    #endregion  // ToString
}

#endregion // int_mt32
#region uint_mt4

[CpuOnly]
public partial struct uint_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => 4;
    }

    #endregion

    #region Fields

    public Vector128<uint> vector;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512), UnscopedRef]
    public readonly ref readonly Vector128<uint> VectorAtRo(int index)
    {
        switch(index)
        {
            case 0: return ref vector;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector128<uint> VectorAt(int index)
    {
        switch(index)
        {
            case 0: return ref vector;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    public uint this[int index]
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            return vector[index];
        }
        [MethodImpl(256 | 512)]
        set
        {
            vector = vector.WithElement(index, value);
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public uint_mt4(Vector128<uint> vector)
    {
        this.vector = vector;
    }

    [MethodImpl(256 | 512)]
    private uint_mt4(ref readonly uint values)
    {
        ref var vs = ref Unsafe.AsRef(in values);
        vector = Vector128.LoadUnsafe(in vs);
    }

    [MethodImpl(256 | 512)]
    public static uint_mt4 LoadUnsafe(ref readonly uint values) => new(in values);

    [MethodImpl(256 | 512)]
    public static uint_mt4 LoadUnsafe(params ReadOnlySpan<uint> values) => new(in values.GetPinnableReference());

    [MethodImpl(256 | 512)]
    public uint_mt4(uint value)
    {
        vector = Vector128.Create(value);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator uint_mt4(uint value) => new(value);

    [MethodImpl(256 | 512)]
    public static uint_mt4 operator~(uint_mt4 a) => new(~a.vector);

    [MethodImpl(256 | 512)]
    public static uint_mt4 operator|(uint_mt4 a, uint_mt4 b) => new(a.vector | b.vector);

    [MethodImpl(256 | 512)]
    public static uint_mt4 operator&(uint_mt4 a, uint_mt4 b) => new(a.vector & b.vector);

    [MethodImpl(256 | 512)]
    public static uint_mt4 operator^(uint_mt4 a, uint_mt4 b) => new(a.vector ^ b.vector);

    [MethodImpl(256 | 512)]
    public static uint_mt4 operator<<(uint_mt4 a, int b) => new(a.vector << b);

    [MethodImpl(256 | 512)]
    public static uint_mt4 operator>>(uint_mt4 a, int b) => new(a.vector >> b);

    [MethodImpl(256 | 512)]
    public static uint_mt4 operator>>>(uint_mt4 a, int b) => new(a.vector >>> b);

    #endregion  // Operators

    #region ToString

    public readonly override string ToString() => $"uint_mt4 {{ t0 = {this[0]}, t1 = {this[1]}, t2 = {this[2]}, t3 = {this[3]} }}";

    #endregion  // ToString
}

#endregion // uint_mt4
#region uint_mt8

[CpuOnly]
public partial struct uint_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => 8;
    }

    #endregion

    #region Fields

    public Vector256<uint> vector;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512), UnscopedRef]
    public readonly ref readonly Vector256<uint> VectorAtRo(int index)
    {
        switch(index)
        {
            case 0: return ref vector;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector256<uint> VectorAt(int index)
    {
        switch(index)
        {
            case 0: return ref vector;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    public uint this[int index]
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            return vector[index];
        }
        [MethodImpl(256 | 512)]
        set
        {
            vector = vector.WithElement(index, value);
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public uint_mt8(Vector256<uint> vector)
    {
        this.vector = vector;
    }

    [MethodImpl(256 | 512)]
    private uint_mt8(ref readonly uint values)
    {
        ref var vs = ref Unsafe.AsRef(in values);
        vector = Vector256.LoadUnsafe(in vs);
    }

    [MethodImpl(256 | 512)]
    public static uint_mt8 LoadUnsafe(ref readonly uint values) => new(in values);

    [MethodImpl(256 | 512)]
    public static uint_mt8 LoadUnsafe(params ReadOnlySpan<uint> values) => new(in values.GetPinnableReference());

    [MethodImpl(256 | 512)]
    public uint_mt8(uint value)
    {
        vector = Vector256.Create(value);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator uint_mt8(uint value) => new(value);

    [MethodImpl(256 | 512)]
    public static uint_mt8 operator~(uint_mt8 a) => new(~a.vector);

    [MethodImpl(256 | 512)]
    public static uint_mt8 operator|(uint_mt8 a, uint_mt8 b) => new(a.vector | b.vector);

    [MethodImpl(256 | 512)]
    public static uint_mt8 operator&(uint_mt8 a, uint_mt8 b) => new(a.vector & b.vector);

    [MethodImpl(256 | 512)]
    public static uint_mt8 operator^(uint_mt8 a, uint_mt8 b) => new(a.vector ^ b.vector);

    [MethodImpl(256 | 512)]
    public static uint_mt8 operator<<(uint_mt8 a, int b) => new(a.vector << b);

    [MethodImpl(256 | 512)]
    public static uint_mt8 operator>>(uint_mt8 a, int b) => new(a.vector >> b);

    [MethodImpl(256 | 512)]
    public static uint_mt8 operator>>>(uint_mt8 a, int b) => new(a.vector >>> b);

    #endregion  // Operators

    #region ToString

    public readonly override string ToString() => $"uint_mt8 {{ t0 = {this[0]}, t1 = {this[1]}, t2 = {this[2]}, t3 = {this[3]}, t4 = {this[4]}, t5 = {this[5]}, t6 = {this[6]}, t7 = {this[7]} }}";

    #endregion  // ToString
}

#endregion // uint_mt8
#region uint_mt16

[CpuOnly]
public partial struct uint_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => 16;
    }

    #endregion

    #region Fields

    public Vector512<uint> vector;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512), UnscopedRef]
    public readonly ref readonly Vector512<uint> VectorAtRo(int index)
    {
        switch(index)
        {
            case 0: return ref vector;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector512<uint> VectorAt(int index)
    {
        switch(index)
        {
            case 0: return ref vector;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    public uint this[int index]
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            return vector[index];
        }
        [MethodImpl(256 | 512)]
        set
        {
            vector = vector.WithElement(index, value);
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public uint_mt16(Vector512<uint> vector)
    {
        this.vector = vector;
    }

    [MethodImpl(256 | 512)]
    private uint_mt16(ref readonly uint values)
    {
        ref var vs = ref Unsafe.AsRef(in values);
        vector = Vector512.LoadUnsafe(in vs);
    }

    [MethodImpl(256 | 512)]
    public static uint_mt16 LoadUnsafe(ref readonly uint values) => new(in values);

    [MethodImpl(256 | 512)]
    public static uint_mt16 LoadUnsafe(params ReadOnlySpan<uint> values) => new(in values.GetPinnableReference());

    [MethodImpl(256 | 512)]
    public uint_mt16(uint value)
    {
        vector = Vector512.Create(value);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator uint_mt16(uint value) => new(value);

    [MethodImpl(256 | 512)]
    public static uint_mt16 operator~(uint_mt16 a) => new(~a.vector);

    [MethodImpl(256 | 512)]
    public static uint_mt16 operator|(uint_mt16 a, uint_mt16 b) => new(a.vector | b.vector);

    [MethodImpl(256 | 512)]
    public static uint_mt16 operator&(uint_mt16 a, uint_mt16 b) => new(a.vector & b.vector);

    [MethodImpl(256 | 512)]
    public static uint_mt16 operator^(uint_mt16 a, uint_mt16 b) => new(a.vector ^ b.vector);

    [MethodImpl(256 | 512)]
    public static uint_mt16 operator<<(uint_mt16 a, int b) => new(a.vector << b);

    [MethodImpl(256 | 512)]
    public static uint_mt16 operator>>(uint_mt16 a, int b) => new(a.vector >> b);

    [MethodImpl(256 | 512)]
    public static uint_mt16 operator>>>(uint_mt16 a, int b) => new(a.vector >>> b);

    #endregion  // Operators

    #region ToString

    public readonly override string ToString() => $"uint_mt16 {{ t0 = {this[0]}, t1 = {this[1]}, t2 = {this[2]}, t3 = {this[3]}, t4 = {this[4]}, t5 = {this[5]}, t6 = {this[6]}, t7 = {this[7]}, t8 = {this[8]}, t9 = {this[9]}, t10 = {this[10]}, t11 = {this[11]}, t12 = {this[12]}, t13 = {this[13]}, t14 = {this[14]}, t15 = {this[15]} }}";

    #endregion  // ToString
}

#endregion // uint_mt16
#region uint_mt32

[CpuOnly]
public partial struct uint_mt32
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => 32;
    }

    #endregion

    #region Fields

    public Vector512<uint> vector0;
    public Vector512<uint> vector1;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512), UnscopedRef]
    public readonly ref readonly Vector512<uint> VectorAtRo(int index)
    {
        switch(index)
        {
            case 0: return ref vector0;
            case 1: return ref vector1;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector512<uint> VectorAt(int index)
    {
        switch(index)
        {
            case 0: return ref vector0;
            case 1: return ref vector1;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    public uint this[int index]
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            var (q, r) = Math.DivRem(index, Vector512<uint>.Count);
            return VectorAtRo(q)[r];
        }
        [MethodImpl(256 | 512)]
        set
        {
            var (q, r) = Math.DivRem(index, Vector512<uint>.Count);
            ref var vector = ref VectorAt(q);
            vector = vector.WithElement(r, value);
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public uint_mt32(Vector512<uint> vector0, Vector512<uint> vector1)
    {
        this.vector0 = vector0;
        this.vector1 = vector1;
    }

    [MethodImpl(256 | 512)]
    private uint_mt32(ref readonly uint values)
    {
        ref var vs = ref Unsafe.AsRef(in values);
        vector0 = Vector512.LoadUnsafe(in vs);
        vector1 = Vector512.LoadUnsafe(in Unsafe.Add(ref vs, 32));
    }

    [MethodImpl(256 | 512)]
    public static uint_mt32 LoadUnsafe(ref readonly uint values) => new(in values);

    [MethodImpl(256 | 512)]
    public static uint_mt32 LoadUnsafe(params ReadOnlySpan<uint> values) => new(in values.GetPinnableReference());

    [MethodImpl(256 | 512)]
    public uint_mt32(uint value)
    {
        vector0 = Vector512.Create(value);
        vector1 = Vector512.Create(value);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator uint_mt32(uint value) => new(value);

    [MethodImpl(256 | 512)]
    public static uint_mt32 operator~(uint_mt32 a) => new(~a.vector0, ~a.vector1);

    [MethodImpl(256 | 512)]
    public static uint_mt32 operator|(uint_mt32 a, uint_mt32 b) => new(a.vector0 | b.vector0, a.vector1 | b.vector1);

    [MethodImpl(256 | 512)]
    public static uint_mt32 operator&(uint_mt32 a, uint_mt32 b) => new(a.vector0 & b.vector0, a.vector1 & b.vector1);

    [MethodImpl(256 | 512)]
    public static uint_mt32 operator^(uint_mt32 a, uint_mt32 b) => new(a.vector0 ^ b.vector0, a.vector1 ^ b.vector1);

    [MethodImpl(256 | 512)]
    public static uint_mt32 operator<<(uint_mt32 a, int b) => new(a.vector0 << b, a.vector1 << b);

    [MethodImpl(256 | 512)]
    public static uint_mt32 operator>>(uint_mt32 a, int b) => new(a.vector0 >> b, a.vector1 >> b);

    [MethodImpl(256 | 512)]
    public static uint_mt32 operator>>>(uint_mt32 a, int b) => new(a.vector0 >>> b, a.vector1 >>> b);

    #endregion  // Operators

    #region ToString

    public readonly override string ToString() => $"uint_mt32 {{ t0 = {this[0]}, t1 = {this[1]}, t2 = {this[2]}, t3 = {this[3]}, t4 = {this[4]}, t5 = {this[5]}, t6 = {this[6]}, t7 = {this[7]}, t8 = {this[8]}, t9 = {this[9]}, t10 = {this[10]}, t11 = {this[11]}, t12 = {this[12]}, t13 = {this[13]}, t14 = {this[14]}, t15 = {this[15]}, t16 = {this[16]}, t17 = {this[17]}, t18 = {this[18]}, t19 = {this[19]}, t20 = {this[20]}, t21 = {this[21]}, t22 = {this[22]}, t23 = {this[23]}, t24 = {this[24]}, t25 = {this[25]}, t26 = {this[26]}, t27 = {this[27]}, t28 = {this[28]}, t29 = {this[29]}, t30 = {this[30]}, t31 = {this[31]} }}";

    #endregion  // ToString
}

#endregion // uint_mt32
#region long_mt4

[CpuOnly]
public partial struct long_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => 4;
    }

    #endregion

    #region Fields

    public Vector256<long> vector;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512), UnscopedRef]
    public readonly ref readonly Vector256<long> VectorAtRo(int index)
    {
        switch(index)
        {
            case 0: return ref vector;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector256<long> VectorAt(int index)
    {
        switch(index)
        {
            case 0: return ref vector;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    public long this[int index]
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            return vector[index];
        }
        [MethodImpl(256 | 512)]
        set
        {
            vector = vector.WithElement(index, value);
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public long_mt4(Vector256<long> vector)
    {
        this.vector = vector;
    }

    [MethodImpl(256 | 512)]
    private long_mt4(ref readonly long values)
    {
        ref var vs = ref Unsafe.AsRef(in values);
        vector = Vector256.LoadUnsafe(in vs);
    }

    [MethodImpl(256 | 512)]
    public static long_mt4 LoadUnsafe(ref readonly long values) => new(in values);

    [MethodImpl(256 | 512)]
    public static long_mt4 LoadUnsafe(params ReadOnlySpan<long> values) => new(in values.GetPinnableReference());

    [MethodImpl(256 | 512)]
    public long_mt4(long value)
    {
        vector = Vector256.Create(value);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator long_mt4(long value) => new(value);

    [MethodImpl(256 | 512)]
    public static long_mt4 operator~(long_mt4 a) => new(~a.vector);

    [MethodImpl(256 | 512)]
    public static long_mt4 operator|(long_mt4 a, long_mt4 b) => new(a.vector | b.vector);

    [MethodImpl(256 | 512)]
    public static long_mt4 operator&(long_mt4 a, long_mt4 b) => new(a.vector & b.vector);

    [MethodImpl(256 | 512)]
    public static long_mt4 operator^(long_mt4 a, long_mt4 b) => new(a.vector ^ b.vector);

    [MethodImpl(256 | 512)]
    public static long_mt4 operator<<(long_mt4 a, int b) => new(a.vector << b);

    [MethodImpl(256 | 512)]
    public static long_mt4 operator>>(long_mt4 a, int b) => new(a.vector >> b);

    [MethodImpl(256 | 512)]
    public static long_mt4 operator>>>(long_mt4 a, int b) => new(a.vector >>> b);

    #endregion  // Operators

    #region ToString

    public readonly override string ToString() => $"long_mt4 {{ t0 = {this[0]}, t1 = {this[1]}, t2 = {this[2]}, t3 = {this[3]} }}";

    #endregion  // ToString
}

#endregion // long_mt4
#region long_mt8

[CpuOnly]
public partial struct long_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => 8;
    }

    #endregion

    #region Fields

    public Vector512<long> vector;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512), UnscopedRef]
    public readonly ref readonly Vector512<long> VectorAtRo(int index)
    {
        switch(index)
        {
            case 0: return ref vector;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector512<long> VectorAt(int index)
    {
        switch(index)
        {
            case 0: return ref vector;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    public long this[int index]
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            return vector[index];
        }
        [MethodImpl(256 | 512)]
        set
        {
            vector = vector.WithElement(index, value);
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public long_mt8(Vector512<long> vector)
    {
        this.vector = vector;
    }

    [MethodImpl(256 | 512)]
    private long_mt8(ref readonly long values)
    {
        ref var vs = ref Unsafe.AsRef(in values);
        vector = Vector512.LoadUnsafe(in vs);
    }

    [MethodImpl(256 | 512)]
    public static long_mt8 LoadUnsafe(ref readonly long values) => new(in values);

    [MethodImpl(256 | 512)]
    public static long_mt8 LoadUnsafe(params ReadOnlySpan<long> values) => new(in values.GetPinnableReference());

    [MethodImpl(256 | 512)]
    public long_mt8(long value)
    {
        vector = Vector512.Create(value);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator long_mt8(long value) => new(value);

    [MethodImpl(256 | 512)]
    public static long_mt8 operator~(long_mt8 a) => new(~a.vector);

    [MethodImpl(256 | 512)]
    public static long_mt8 operator|(long_mt8 a, long_mt8 b) => new(a.vector | b.vector);

    [MethodImpl(256 | 512)]
    public static long_mt8 operator&(long_mt8 a, long_mt8 b) => new(a.vector & b.vector);

    [MethodImpl(256 | 512)]
    public static long_mt8 operator^(long_mt8 a, long_mt8 b) => new(a.vector ^ b.vector);

    [MethodImpl(256 | 512)]
    public static long_mt8 operator<<(long_mt8 a, int b) => new(a.vector << b);

    [MethodImpl(256 | 512)]
    public static long_mt8 operator>>(long_mt8 a, int b) => new(a.vector >> b);

    [MethodImpl(256 | 512)]
    public static long_mt8 operator>>>(long_mt8 a, int b) => new(a.vector >>> b);

    #endregion  // Operators

    #region ToString

    public readonly override string ToString() => $"long_mt8 {{ t0 = {this[0]}, t1 = {this[1]}, t2 = {this[2]}, t3 = {this[3]}, t4 = {this[4]}, t5 = {this[5]}, t6 = {this[6]}, t7 = {this[7]} }}";

    #endregion  // ToString
}

#endregion // long_mt8
#region long_mt16

[CpuOnly]
public partial struct long_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => 16;
    }

    #endregion

    #region Fields

    public Vector512<long> vector0;
    public Vector512<long> vector1;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512), UnscopedRef]
    public readonly ref readonly Vector512<long> VectorAtRo(int index)
    {
        switch(index)
        {
            case 0: return ref vector0;
            case 1: return ref vector1;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector512<long> VectorAt(int index)
    {
        switch(index)
        {
            case 0: return ref vector0;
            case 1: return ref vector1;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    public long this[int index]
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            var (q, r) = Math.DivRem(index, Vector512<long>.Count);
            return VectorAtRo(q)[r];
        }
        [MethodImpl(256 | 512)]
        set
        {
            var (q, r) = Math.DivRem(index, Vector512<long>.Count);
            ref var vector = ref VectorAt(q);
            vector = vector.WithElement(r, value);
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public long_mt16(Vector512<long> vector0, Vector512<long> vector1)
    {
        this.vector0 = vector0;
        this.vector1 = vector1;
    }

    [MethodImpl(256 | 512)]
    private long_mt16(ref readonly long values)
    {
        ref var vs = ref Unsafe.AsRef(in values);
        vector0 = Vector512.LoadUnsafe(in vs);
        vector1 = Vector512.LoadUnsafe(in Unsafe.Add(ref vs, 16));
    }

    [MethodImpl(256 | 512)]
    public static long_mt16 LoadUnsafe(ref readonly long values) => new(in values);

    [MethodImpl(256 | 512)]
    public static long_mt16 LoadUnsafe(params ReadOnlySpan<long> values) => new(in values.GetPinnableReference());

    [MethodImpl(256 | 512)]
    public long_mt16(long value)
    {
        vector0 = Vector512.Create(value);
        vector1 = Vector512.Create(value);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator long_mt16(long value) => new(value);

    [MethodImpl(256 | 512)]
    public static long_mt16 operator~(long_mt16 a) => new(~a.vector0, ~a.vector1);

    [MethodImpl(256 | 512)]
    public static long_mt16 operator|(long_mt16 a, long_mt16 b) => new(a.vector0 | b.vector0, a.vector1 | b.vector1);

    [MethodImpl(256 | 512)]
    public static long_mt16 operator&(long_mt16 a, long_mt16 b) => new(a.vector0 & b.vector0, a.vector1 & b.vector1);

    [MethodImpl(256 | 512)]
    public static long_mt16 operator^(long_mt16 a, long_mt16 b) => new(a.vector0 ^ b.vector0, a.vector1 ^ b.vector1);

    [MethodImpl(256 | 512)]
    public static long_mt16 operator<<(long_mt16 a, int b) => new(a.vector0 << b, a.vector1 << b);

    [MethodImpl(256 | 512)]
    public static long_mt16 operator>>(long_mt16 a, int b) => new(a.vector0 >> b, a.vector1 >> b);

    [MethodImpl(256 | 512)]
    public static long_mt16 operator>>>(long_mt16 a, int b) => new(a.vector0 >>> b, a.vector1 >>> b);

    #endregion  // Operators

    #region ToString

    public readonly override string ToString() => $"long_mt16 {{ t0 = {this[0]}, t1 = {this[1]}, t2 = {this[2]}, t3 = {this[3]}, t4 = {this[4]}, t5 = {this[5]}, t6 = {this[6]}, t7 = {this[7]}, t8 = {this[8]}, t9 = {this[9]}, t10 = {this[10]}, t11 = {this[11]}, t12 = {this[12]}, t13 = {this[13]}, t14 = {this[14]}, t15 = {this[15]} }}";

    #endregion  // ToString
}

#endregion // long_mt16
#region long_mt32

[CpuOnly]
public partial struct long_mt32
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => 32;
    }

    #endregion

    #region Fields

    public Vector512<long> vector0;
    public Vector512<long> vector1;
    public Vector512<long> vector2;
    public Vector512<long> vector3;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512), UnscopedRef]
    public readonly ref readonly Vector512<long> VectorAtRo(int index)
    {
        switch(index)
        {
            case 0: return ref vector0;
            case 1: return ref vector1;
            case 2: return ref vector2;
            case 3: return ref vector3;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector512<long> VectorAt(int index)
    {
        switch(index)
        {
            case 0: return ref vector0;
            case 1: return ref vector1;
            case 2: return ref vector2;
            case 3: return ref vector3;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    public long this[int index]
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            var (q, r) = Math.DivRem(index, Vector512<long>.Count);
            return VectorAtRo(q)[r];
        }
        [MethodImpl(256 | 512)]
        set
        {
            var (q, r) = Math.DivRem(index, Vector512<long>.Count);
            ref var vector = ref VectorAt(q);
            vector = vector.WithElement(r, value);
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public long_mt32(Vector512<long> vector0, Vector512<long> vector1, Vector512<long> vector2, Vector512<long> vector3)
    {
        this.vector0 = vector0;
        this.vector1 = vector1;
        this.vector2 = vector2;
        this.vector3 = vector3;
    }

    [MethodImpl(256 | 512)]
    private long_mt32(ref readonly long values)
    {
        ref var vs = ref Unsafe.AsRef(in values);
        vector0 = Vector512.LoadUnsafe(in vs);
        vector1 = Vector512.LoadUnsafe(in Unsafe.Add(ref vs, 32));
        vector2 = Vector512.LoadUnsafe(in Unsafe.Add(ref vs, 64));
        vector3 = Vector512.LoadUnsafe(in Unsafe.Add(ref vs, 96));
    }

    [MethodImpl(256 | 512)]
    public static long_mt32 LoadUnsafe(ref readonly long values) => new(in values);

    [MethodImpl(256 | 512)]
    public static long_mt32 LoadUnsafe(params ReadOnlySpan<long> values) => new(in values.GetPinnableReference());

    [MethodImpl(256 | 512)]
    public long_mt32(long value)
    {
        vector0 = Vector512.Create(value);
        vector1 = Vector512.Create(value);
        vector2 = Vector512.Create(value);
        vector3 = Vector512.Create(value);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator long_mt32(long value) => new(value);

    [MethodImpl(256 | 512)]
    public static long_mt32 operator~(long_mt32 a) => new(~a.vector0, ~a.vector1, ~a.vector2, ~a.vector3);

    [MethodImpl(256 | 512)]
    public static long_mt32 operator|(long_mt32 a, long_mt32 b) => new(a.vector0 | b.vector0, a.vector1 | b.vector1, a.vector2 | b.vector2, a.vector3 | b.vector3);

    [MethodImpl(256 | 512)]
    public static long_mt32 operator&(long_mt32 a, long_mt32 b) => new(a.vector0 & b.vector0, a.vector1 & b.vector1, a.vector2 & b.vector2, a.vector3 & b.vector3);

    [MethodImpl(256 | 512)]
    public static long_mt32 operator^(long_mt32 a, long_mt32 b) => new(a.vector0 ^ b.vector0, a.vector1 ^ b.vector1, a.vector2 ^ b.vector2, a.vector3 ^ b.vector3);

    [MethodImpl(256 | 512)]
    public static long_mt32 operator<<(long_mt32 a, int b) => new(a.vector0 << b, a.vector1 << b, a.vector2 << b, a.vector3 << b);

    [MethodImpl(256 | 512)]
    public static long_mt32 operator>>(long_mt32 a, int b) => new(a.vector0 >> b, a.vector1 >> b, a.vector2 >> b, a.vector3 >> b);

    [MethodImpl(256 | 512)]
    public static long_mt32 operator>>>(long_mt32 a, int b) => new(a.vector0 >>> b, a.vector1 >>> b, a.vector2 >>> b, a.vector3 >>> b);

    #endregion  // Operators

    #region ToString

    public readonly override string ToString() => $"long_mt32 {{ t0 = {this[0]}, t1 = {this[1]}, t2 = {this[2]}, t3 = {this[3]}, t4 = {this[4]}, t5 = {this[5]}, t6 = {this[6]}, t7 = {this[7]}, t8 = {this[8]}, t9 = {this[9]}, t10 = {this[10]}, t11 = {this[11]}, t12 = {this[12]}, t13 = {this[13]}, t14 = {this[14]}, t15 = {this[15]}, t16 = {this[16]}, t17 = {this[17]}, t18 = {this[18]}, t19 = {this[19]}, t20 = {this[20]}, t21 = {this[21]}, t22 = {this[22]}, t23 = {this[23]}, t24 = {this[24]}, t25 = {this[25]}, t26 = {this[26]}, t27 = {this[27]}, t28 = {this[28]}, t29 = {this[29]}, t30 = {this[30]}, t31 = {this[31]} }}";

    #endregion  // ToString
}

#endregion // long_mt32
#region ulong_mt4

[CpuOnly]
public partial struct ulong_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => 4;
    }

    #endregion

    #region Fields

    public Vector256<ulong> vector;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512), UnscopedRef]
    public readonly ref readonly Vector256<ulong> VectorAtRo(int index)
    {
        switch(index)
        {
            case 0: return ref vector;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector256<ulong> VectorAt(int index)
    {
        switch(index)
        {
            case 0: return ref vector;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    public ulong this[int index]
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            return vector[index];
        }
        [MethodImpl(256 | 512)]
        set
        {
            vector = vector.WithElement(index, value);
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public ulong_mt4(Vector256<ulong> vector)
    {
        this.vector = vector;
    }

    [MethodImpl(256 | 512)]
    private ulong_mt4(ref readonly ulong values)
    {
        ref var vs = ref Unsafe.AsRef(in values);
        vector = Vector256.LoadUnsafe(in vs);
    }

    [MethodImpl(256 | 512)]
    public static ulong_mt4 LoadUnsafe(ref readonly ulong values) => new(in values);

    [MethodImpl(256 | 512)]
    public static ulong_mt4 LoadUnsafe(params ReadOnlySpan<ulong> values) => new(in values.GetPinnableReference());

    [MethodImpl(256 | 512)]
    public ulong_mt4(ulong value)
    {
        vector = Vector256.Create(value);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator ulong_mt4(ulong value) => new(value);

    [MethodImpl(256 | 512)]
    public static ulong_mt4 operator~(ulong_mt4 a) => new(~a.vector);

    [MethodImpl(256 | 512)]
    public static ulong_mt4 operator|(ulong_mt4 a, ulong_mt4 b) => new(a.vector | b.vector);

    [MethodImpl(256 | 512)]
    public static ulong_mt4 operator&(ulong_mt4 a, ulong_mt4 b) => new(a.vector & b.vector);

    [MethodImpl(256 | 512)]
    public static ulong_mt4 operator^(ulong_mt4 a, ulong_mt4 b) => new(a.vector ^ b.vector);

    [MethodImpl(256 | 512)]
    public static ulong_mt4 operator<<(ulong_mt4 a, int b) => new(a.vector << b);

    [MethodImpl(256 | 512)]
    public static ulong_mt4 operator>>(ulong_mt4 a, int b) => new(a.vector >> b);

    [MethodImpl(256 | 512)]
    public static ulong_mt4 operator>>>(ulong_mt4 a, int b) => new(a.vector >>> b);

    #endregion  // Operators

    #region ToString

    public readonly override string ToString() => $"ulong_mt4 {{ t0 = {this[0]}, t1 = {this[1]}, t2 = {this[2]}, t3 = {this[3]} }}";

    #endregion  // ToString
}

#endregion // ulong_mt4
#region ulong_mt8

[CpuOnly]
public partial struct ulong_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => 8;
    }

    #endregion

    #region Fields

    public Vector512<ulong> vector;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512), UnscopedRef]
    public readonly ref readonly Vector512<ulong> VectorAtRo(int index)
    {
        switch(index)
        {
            case 0: return ref vector;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector512<ulong> VectorAt(int index)
    {
        switch(index)
        {
            case 0: return ref vector;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    public ulong this[int index]
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            return vector[index];
        }
        [MethodImpl(256 | 512)]
        set
        {
            vector = vector.WithElement(index, value);
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public ulong_mt8(Vector512<ulong> vector)
    {
        this.vector = vector;
    }

    [MethodImpl(256 | 512)]
    private ulong_mt8(ref readonly ulong values)
    {
        ref var vs = ref Unsafe.AsRef(in values);
        vector = Vector512.LoadUnsafe(in vs);
    }

    [MethodImpl(256 | 512)]
    public static ulong_mt8 LoadUnsafe(ref readonly ulong values) => new(in values);

    [MethodImpl(256 | 512)]
    public static ulong_mt8 LoadUnsafe(params ReadOnlySpan<ulong> values) => new(in values.GetPinnableReference());

    [MethodImpl(256 | 512)]
    public ulong_mt8(ulong value)
    {
        vector = Vector512.Create(value);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator ulong_mt8(ulong value) => new(value);

    [MethodImpl(256 | 512)]
    public static ulong_mt8 operator~(ulong_mt8 a) => new(~a.vector);

    [MethodImpl(256 | 512)]
    public static ulong_mt8 operator|(ulong_mt8 a, ulong_mt8 b) => new(a.vector | b.vector);

    [MethodImpl(256 | 512)]
    public static ulong_mt8 operator&(ulong_mt8 a, ulong_mt8 b) => new(a.vector & b.vector);

    [MethodImpl(256 | 512)]
    public static ulong_mt8 operator^(ulong_mt8 a, ulong_mt8 b) => new(a.vector ^ b.vector);

    [MethodImpl(256 | 512)]
    public static ulong_mt8 operator<<(ulong_mt8 a, int b) => new(a.vector << b);

    [MethodImpl(256 | 512)]
    public static ulong_mt8 operator>>(ulong_mt8 a, int b) => new(a.vector >> b);

    [MethodImpl(256 | 512)]
    public static ulong_mt8 operator>>>(ulong_mt8 a, int b) => new(a.vector >>> b);

    #endregion  // Operators

    #region ToString

    public readonly override string ToString() => $"ulong_mt8 {{ t0 = {this[0]}, t1 = {this[1]}, t2 = {this[2]}, t3 = {this[3]}, t4 = {this[4]}, t5 = {this[5]}, t6 = {this[6]}, t7 = {this[7]} }}";

    #endregion  // ToString
}

#endregion // ulong_mt8
#region ulong_mt16

[CpuOnly]
public partial struct ulong_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => 16;
    }

    #endregion

    #region Fields

    public Vector512<ulong> vector0;
    public Vector512<ulong> vector1;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512), UnscopedRef]
    public readonly ref readonly Vector512<ulong> VectorAtRo(int index)
    {
        switch(index)
        {
            case 0: return ref vector0;
            case 1: return ref vector1;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector512<ulong> VectorAt(int index)
    {
        switch(index)
        {
            case 0: return ref vector0;
            case 1: return ref vector1;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    public ulong this[int index]
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            var (q, r) = Math.DivRem(index, Vector512<ulong>.Count);
            return VectorAtRo(q)[r];
        }
        [MethodImpl(256 | 512)]
        set
        {
            var (q, r) = Math.DivRem(index, Vector512<ulong>.Count);
            ref var vector = ref VectorAt(q);
            vector = vector.WithElement(r, value);
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public ulong_mt16(Vector512<ulong> vector0, Vector512<ulong> vector1)
    {
        this.vector0 = vector0;
        this.vector1 = vector1;
    }

    [MethodImpl(256 | 512)]
    private ulong_mt16(ref readonly ulong values)
    {
        ref var vs = ref Unsafe.AsRef(in values);
        vector0 = Vector512.LoadUnsafe(in vs);
        vector1 = Vector512.LoadUnsafe(in Unsafe.Add(ref vs, 16));
    }

    [MethodImpl(256 | 512)]
    public static ulong_mt16 LoadUnsafe(ref readonly ulong values) => new(in values);

    [MethodImpl(256 | 512)]
    public static ulong_mt16 LoadUnsafe(params ReadOnlySpan<ulong> values) => new(in values.GetPinnableReference());

    [MethodImpl(256 | 512)]
    public ulong_mt16(ulong value)
    {
        vector0 = Vector512.Create(value);
        vector1 = Vector512.Create(value);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator ulong_mt16(ulong value) => new(value);

    [MethodImpl(256 | 512)]
    public static ulong_mt16 operator~(ulong_mt16 a) => new(~a.vector0, ~a.vector1);

    [MethodImpl(256 | 512)]
    public static ulong_mt16 operator|(ulong_mt16 a, ulong_mt16 b) => new(a.vector0 | b.vector0, a.vector1 | b.vector1);

    [MethodImpl(256 | 512)]
    public static ulong_mt16 operator&(ulong_mt16 a, ulong_mt16 b) => new(a.vector0 & b.vector0, a.vector1 & b.vector1);

    [MethodImpl(256 | 512)]
    public static ulong_mt16 operator^(ulong_mt16 a, ulong_mt16 b) => new(a.vector0 ^ b.vector0, a.vector1 ^ b.vector1);

    [MethodImpl(256 | 512)]
    public static ulong_mt16 operator<<(ulong_mt16 a, int b) => new(a.vector0 << b, a.vector1 << b);

    [MethodImpl(256 | 512)]
    public static ulong_mt16 operator>>(ulong_mt16 a, int b) => new(a.vector0 >> b, a.vector1 >> b);

    [MethodImpl(256 | 512)]
    public static ulong_mt16 operator>>>(ulong_mt16 a, int b) => new(a.vector0 >>> b, a.vector1 >>> b);

    #endregion  // Operators

    #region ToString

    public readonly override string ToString() => $"ulong_mt16 {{ t0 = {this[0]}, t1 = {this[1]}, t2 = {this[2]}, t3 = {this[3]}, t4 = {this[4]}, t5 = {this[5]}, t6 = {this[6]}, t7 = {this[7]}, t8 = {this[8]}, t9 = {this[9]}, t10 = {this[10]}, t11 = {this[11]}, t12 = {this[12]}, t13 = {this[13]}, t14 = {this[14]}, t15 = {this[15]} }}";

    #endregion  // ToString
}

#endregion // ulong_mt16
#region ulong_mt32

[CpuOnly]
public partial struct ulong_mt32
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => 32;
    }

    #endregion

    #region Fields

    public Vector512<ulong> vector0;
    public Vector512<ulong> vector1;
    public Vector512<ulong> vector2;
    public Vector512<ulong> vector3;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512), UnscopedRef]
    public readonly ref readonly Vector512<ulong> VectorAtRo(int index)
    {
        switch(index)
        {
            case 0: return ref vector0;
            case 1: return ref vector1;
            case 2: return ref vector2;
            case 3: return ref vector3;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector512<ulong> VectorAt(int index)
    {
        switch(index)
        {
            case 0: return ref vector0;
            case 1: return ref vector1;
            case 2: return ref vector2;
            case 3: return ref vector3;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    public ulong this[int index]
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            var (q, r) = Math.DivRem(index, Vector512<ulong>.Count);
            return VectorAtRo(q)[r];
        }
        [MethodImpl(256 | 512)]
        set
        {
            var (q, r) = Math.DivRem(index, Vector512<ulong>.Count);
            ref var vector = ref VectorAt(q);
            vector = vector.WithElement(r, value);
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public ulong_mt32(Vector512<ulong> vector0, Vector512<ulong> vector1, Vector512<ulong> vector2, Vector512<ulong> vector3)
    {
        this.vector0 = vector0;
        this.vector1 = vector1;
        this.vector2 = vector2;
        this.vector3 = vector3;
    }

    [MethodImpl(256 | 512)]
    private ulong_mt32(ref readonly ulong values)
    {
        ref var vs = ref Unsafe.AsRef(in values);
        vector0 = Vector512.LoadUnsafe(in vs);
        vector1 = Vector512.LoadUnsafe(in Unsafe.Add(ref vs, 32));
        vector2 = Vector512.LoadUnsafe(in Unsafe.Add(ref vs, 64));
        vector3 = Vector512.LoadUnsafe(in Unsafe.Add(ref vs, 96));
    }

    [MethodImpl(256 | 512)]
    public static ulong_mt32 LoadUnsafe(ref readonly ulong values) => new(in values);

    [MethodImpl(256 | 512)]
    public static ulong_mt32 LoadUnsafe(params ReadOnlySpan<ulong> values) => new(in values.GetPinnableReference());

    [MethodImpl(256 | 512)]
    public ulong_mt32(ulong value)
    {
        vector0 = Vector512.Create(value);
        vector1 = Vector512.Create(value);
        vector2 = Vector512.Create(value);
        vector3 = Vector512.Create(value);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator ulong_mt32(ulong value) => new(value);

    [MethodImpl(256 | 512)]
    public static ulong_mt32 operator~(ulong_mt32 a) => new(~a.vector0, ~a.vector1, ~a.vector2, ~a.vector3);

    [MethodImpl(256 | 512)]
    public static ulong_mt32 operator|(ulong_mt32 a, ulong_mt32 b) => new(a.vector0 | b.vector0, a.vector1 | b.vector1, a.vector2 | b.vector2, a.vector3 | b.vector3);

    [MethodImpl(256 | 512)]
    public static ulong_mt32 operator&(ulong_mt32 a, ulong_mt32 b) => new(a.vector0 & b.vector0, a.vector1 & b.vector1, a.vector2 & b.vector2, a.vector3 & b.vector3);

    [MethodImpl(256 | 512)]
    public static ulong_mt32 operator^(ulong_mt32 a, ulong_mt32 b) => new(a.vector0 ^ b.vector0, a.vector1 ^ b.vector1, a.vector2 ^ b.vector2, a.vector3 ^ b.vector3);

    [MethodImpl(256 | 512)]
    public static ulong_mt32 operator<<(ulong_mt32 a, int b) => new(a.vector0 << b, a.vector1 << b, a.vector2 << b, a.vector3 << b);

    [MethodImpl(256 | 512)]
    public static ulong_mt32 operator>>(ulong_mt32 a, int b) => new(a.vector0 >> b, a.vector1 >> b, a.vector2 >> b, a.vector3 >> b);

    [MethodImpl(256 | 512)]
    public static ulong_mt32 operator>>>(ulong_mt32 a, int b) => new(a.vector0 >>> b, a.vector1 >>> b, a.vector2 >>> b, a.vector3 >>> b);

    #endregion  // Operators

    #region ToString

    public readonly override string ToString() => $"ulong_mt32 {{ t0 = {this[0]}, t1 = {this[1]}, t2 = {this[2]}, t3 = {this[3]}, t4 = {this[4]}, t5 = {this[5]}, t6 = {this[6]}, t7 = {this[7]}, t8 = {this[8]}, t9 = {this[9]}, t10 = {this[10]}, t11 = {this[11]}, t12 = {this[12]}, t13 = {this[13]}, t14 = {this[14]}, t15 = {this[15]}, t16 = {this[16]}, t17 = {this[17]}, t18 = {this[18]}, t19 = {this[19]}, t20 = {this[20]}, t21 = {this[21]}, t22 = {this[22]}, t23 = {this[23]}, t24 = {this[24]}, t25 = {this[25]}, t26 = {this[26]}, t27 = {this[27]}, t28 = {this[28]}, t29 = {this[29]}, t30 = {this[30]}, t31 = {this[31]} }}";

    #endregion  // ToString
}

#endregion // ulong_mt32
#region b32_mt4

[CpuOnly]
public partial struct b32_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => 4;
    }

    #endregion

    #region Fields

    public Vector128<uint> vector;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512), UnscopedRef]
    public readonly ref readonly Vector128<uint> VectorAtRo(int index)
    {
        switch(index)
        {
            case 0: return ref vector;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector128<uint> VectorAt(int index)
    {
        switch(index)
        {
            case 0: return ref vector;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    public b32 this[int index]
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            return vector[index];
        }
        [MethodImpl(256 | 512)]
        set
        {
            vector = vector.WithElement(index, value);
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public b32_mt4(Vector128<uint> vector)
    {
        this.vector = vector;
    }

    [MethodImpl(256 | 512)]
    private b32_mt4(ref readonly b32 values)
    {
        ref var vs = ref Unsafe.AsRef(in values);
        vector = Vector128.LoadUnsafe(in Unsafe.As<b32, uint>(ref vs));
    }

    [MethodImpl(256 | 512)]
    public static b32_mt4 LoadUnsafe(ref readonly b32 values) => new(in values);

    [MethodImpl(256 | 512)]
    public static b32_mt4 LoadUnsafe(params ReadOnlySpan<b32> values) => new(in values.GetPinnableReference());

    [MethodImpl(256 | 512)]
    public b32_mt4(b32 value)
    {
        vector = Vector128.Create((uint)value);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator b32_mt4(b32 value) => new(value);

    [MethodImpl(256 | 512)]
    public static b32_mt4 operator~(b32_mt4 a) => new(~a.vector);

    [MethodImpl(256 | 512)]
    public static b32_mt4 operator|(b32_mt4 a, b32_mt4 b) => new(a.vector | b.vector);

    [MethodImpl(256 | 512)]
    public static b32_mt4 operator&(b32_mt4 a, b32_mt4 b) => new(a.vector & b.vector);

    [MethodImpl(256 | 512)]
    public static b32_mt4 operator^(b32_mt4 a, b32_mt4 b) => new(a.vector ^ b.vector);

    [MethodImpl(256 | 512)]
    public static b32_mt4 operator<<(b32_mt4 a, int b) => new(a.vector << b);

    [MethodImpl(256 | 512)]
    public static b32_mt4 operator>>(b32_mt4 a, int b) => new(a.vector >> b);

    [MethodImpl(256 | 512)]
    public static b32_mt4 operator>>>(b32_mt4 a, int b) => new(a.vector >>> b);

    #endregion  // Operators

    #region ToString

    public readonly override string ToString() => $"b32_mt4 {{ t0 = {this[0]}, t1 = {this[1]}, t2 = {this[2]}, t3 = {this[3]} }}";

    #endregion  // ToString
}

#endregion // b32_mt4
#region b32_mt8

[CpuOnly]
public partial struct b32_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => 8;
    }

    #endregion

    #region Fields

    public Vector256<uint> vector;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512), UnscopedRef]
    public readonly ref readonly Vector256<uint> VectorAtRo(int index)
    {
        switch(index)
        {
            case 0: return ref vector;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector256<uint> VectorAt(int index)
    {
        switch(index)
        {
            case 0: return ref vector;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    public b32 this[int index]
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            return vector[index];
        }
        [MethodImpl(256 | 512)]
        set
        {
            vector = vector.WithElement(index, value);
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public b32_mt8(Vector256<uint> vector)
    {
        this.vector = vector;
    }

    [MethodImpl(256 | 512)]
    private b32_mt8(ref readonly b32 values)
    {
        ref var vs = ref Unsafe.AsRef(in values);
        vector = Vector256.LoadUnsafe(in Unsafe.As<b32, uint>(ref vs));
    }

    [MethodImpl(256 | 512)]
    public static b32_mt8 LoadUnsafe(ref readonly b32 values) => new(in values);

    [MethodImpl(256 | 512)]
    public static b32_mt8 LoadUnsafe(params ReadOnlySpan<b32> values) => new(in values.GetPinnableReference());

    [MethodImpl(256 | 512)]
    public b32_mt8(b32 value)
    {
        vector = Vector256.Create((uint)value);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator b32_mt8(b32 value) => new(value);

    [MethodImpl(256 | 512)]
    public static b32_mt8 operator~(b32_mt8 a) => new(~a.vector);

    [MethodImpl(256 | 512)]
    public static b32_mt8 operator|(b32_mt8 a, b32_mt8 b) => new(a.vector | b.vector);

    [MethodImpl(256 | 512)]
    public static b32_mt8 operator&(b32_mt8 a, b32_mt8 b) => new(a.vector & b.vector);

    [MethodImpl(256 | 512)]
    public static b32_mt8 operator^(b32_mt8 a, b32_mt8 b) => new(a.vector ^ b.vector);

    [MethodImpl(256 | 512)]
    public static b32_mt8 operator<<(b32_mt8 a, int b) => new(a.vector << b);

    [MethodImpl(256 | 512)]
    public static b32_mt8 operator>>(b32_mt8 a, int b) => new(a.vector >> b);

    [MethodImpl(256 | 512)]
    public static b32_mt8 operator>>>(b32_mt8 a, int b) => new(a.vector >>> b);

    #endregion  // Operators

    #region ToString

    public readonly override string ToString() => $"b32_mt8 {{ t0 = {this[0]}, t1 = {this[1]}, t2 = {this[2]}, t3 = {this[3]}, t4 = {this[4]}, t5 = {this[5]}, t6 = {this[6]}, t7 = {this[7]} }}";

    #endregion  // ToString
}

#endregion // b32_mt8
#region b32_mt16

[CpuOnly]
public partial struct b32_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => 16;
    }

    #endregion

    #region Fields

    public Vector512<uint> vector;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512), UnscopedRef]
    public readonly ref readonly Vector512<uint> VectorAtRo(int index)
    {
        switch(index)
        {
            case 0: return ref vector;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector512<uint> VectorAt(int index)
    {
        switch(index)
        {
            case 0: return ref vector;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    public b32 this[int index]
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            return vector[index];
        }
        [MethodImpl(256 | 512)]
        set
        {
            vector = vector.WithElement(index, value);
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public b32_mt16(Vector512<uint> vector)
    {
        this.vector = vector;
    }

    [MethodImpl(256 | 512)]
    private b32_mt16(ref readonly b32 values)
    {
        ref var vs = ref Unsafe.AsRef(in values);
        vector = Vector512.LoadUnsafe(in Unsafe.As<b32, uint>(ref vs));
    }

    [MethodImpl(256 | 512)]
    public static b32_mt16 LoadUnsafe(ref readonly b32 values) => new(in values);

    [MethodImpl(256 | 512)]
    public static b32_mt16 LoadUnsafe(params ReadOnlySpan<b32> values) => new(in values.GetPinnableReference());

    [MethodImpl(256 | 512)]
    public b32_mt16(b32 value)
    {
        vector = Vector512.Create((uint)value);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator b32_mt16(b32 value) => new(value);

    [MethodImpl(256 | 512)]
    public static b32_mt16 operator~(b32_mt16 a) => new(~a.vector);

    [MethodImpl(256 | 512)]
    public static b32_mt16 operator|(b32_mt16 a, b32_mt16 b) => new(a.vector | b.vector);

    [MethodImpl(256 | 512)]
    public static b32_mt16 operator&(b32_mt16 a, b32_mt16 b) => new(a.vector & b.vector);

    [MethodImpl(256 | 512)]
    public static b32_mt16 operator^(b32_mt16 a, b32_mt16 b) => new(a.vector ^ b.vector);

    [MethodImpl(256 | 512)]
    public static b32_mt16 operator<<(b32_mt16 a, int b) => new(a.vector << b);

    [MethodImpl(256 | 512)]
    public static b32_mt16 operator>>(b32_mt16 a, int b) => new(a.vector >> b);

    [MethodImpl(256 | 512)]
    public static b32_mt16 operator>>>(b32_mt16 a, int b) => new(a.vector >>> b);

    #endregion  // Operators

    #region ToString

    public readonly override string ToString() => $"b32_mt16 {{ t0 = {this[0]}, t1 = {this[1]}, t2 = {this[2]}, t3 = {this[3]}, t4 = {this[4]}, t5 = {this[5]}, t6 = {this[6]}, t7 = {this[7]}, t8 = {this[8]}, t9 = {this[9]}, t10 = {this[10]}, t11 = {this[11]}, t12 = {this[12]}, t13 = {this[13]}, t14 = {this[14]}, t15 = {this[15]} }}";

    #endregion  // ToString
}

#endregion // b32_mt16
#region b32_mt32

[CpuOnly]
public partial struct b32_mt32
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => 32;
    }

    #endregion

    #region Fields

    public Vector512<uint> vector0;
    public Vector512<uint> vector1;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512), UnscopedRef]
    public readonly ref readonly Vector512<uint> VectorAtRo(int index)
    {
        switch(index)
        {
            case 0: return ref vector0;
            case 1: return ref vector1;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector512<uint> VectorAt(int index)
    {
        switch(index)
        {
            case 0: return ref vector0;
            case 1: return ref vector1;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    public b32 this[int index]
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            var (q, r) = Math.DivRem(index, Vector512<uint>.Count);
            return VectorAtRo(q)[r];
        }
        [MethodImpl(256 | 512)]
        set
        {
            var (q, r) = Math.DivRem(index, Vector512<uint>.Count);
            ref var vector = ref VectorAt(q);
            vector = vector.WithElement(r, value);
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public b32_mt32(Vector512<uint> vector0, Vector512<uint> vector1)
    {
        this.vector0 = vector0;
        this.vector1 = vector1;
    }

    [MethodImpl(256 | 512)]
    private b32_mt32(ref readonly b32 values)
    {
        ref var vs = ref Unsafe.AsRef(in values);
        vector0 = Vector512.LoadUnsafe(in Unsafe.As<b32, uint>(ref vs));
        vector1 = Vector512.LoadUnsafe(in Unsafe.As<b32, uint>(ref Unsafe.Add(ref vs, 32)));
    }

    [MethodImpl(256 | 512)]
    public static b32_mt32 LoadUnsafe(ref readonly b32 values) => new(in values);

    [MethodImpl(256 | 512)]
    public static b32_mt32 LoadUnsafe(params ReadOnlySpan<b32> values) => new(in values.GetPinnableReference());

    [MethodImpl(256 | 512)]
    public b32_mt32(b32 value)
    {
        vector0 = Vector512.Create((uint)value);
        vector1 = Vector512.Create((uint)value);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator b32_mt32(b32 value) => new(value);

    [MethodImpl(256 | 512)]
    public static b32_mt32 operator~(b32_mt32 a) => new(~a.vector0, ~a.vector1);

    [MethodImpl(256 | 512)]
    public static b32_mt32 operator|(b32_mt32 a, b32_mt32 b) => new(a.vector0 | b.vector0, a.vector1 | b.vector1);

    [MethodImpl(256 | 512)]
    public static b32_mt32 operator&(b32_mt32 a, b32_mt32 b) => new(a.vector0 & b.vector0, a.vector1 & b.vector1);

    [MethodImpl(256 | 512)]
    public static b32_mt32 operator^(b32_mt32 a, b32_mt32 b) => new(a.vector0 ^ b.vector0, a.vector1 ^ b.vector1);

    [MethodImpl(256 | 512)]
    public static b32_mt32 operator<<(b32_mt32 a, int b) => new(a.vector0 << b, a.vector1 << b);

    [MethodImpl(256 | 512)]
    public static b32_mt32 operator>>(b32_mt32 a, int b) => new(a.vector0 >> b, a.vector1 >> b);

    [MethodImpl(256 | 512)]
    public static b32_mt32 operator>>>(b32_mt32 a, int b) => new(a.vector0 >>> b, a.vector1 >>> b);

    #endregion  // Operators

    #region ToString

    public readonly override string ToString() => $"b32_mt32 {{ t0 = {this[0]}, t1 = {this[1]}, t2 = {this[2]}, t3 = {this[3]}, t4 = {this[4]}, t5 = {this[5]}, t6 = {this[6]}, t7 = {this[7]}, t8 = {this[8]}, t9 = {this[9]}, t10 = {this[10]}, t11 = {this[11]}, t12 = {this[12]}, t13 = {this[13]}, t14 = {this[14]}, t15 = {this[15]}, t16 = {this[16]}, t17 = {this[17]}, t18 = {this[18]}, t19 = {this[19]}, t20 = {this[20]}, t21 = {this[21]}, t22 = {this[22]}, t23 = {this[23]}, t24 = {this[24]}, t25 = {this[25]}, t26 = {this[26]}, t27 = {this[27]}, t28 = {this[28]}, t29 = {this[29]}, t30 = {this[30]}, t31 = {this[31]} }}";

    #endregion  // ToString
}

#endregion // b32_mt32
#region b64_mt4

[CpuOnly]
public partial struct b64_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => 4;
    }

    #endregion

    #region Fields

    public Vector256<ulong> vector;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512), UnscopedRef]
    public readonly ref readonly Vector256<ulong> VectorAtRo(int index)
    {
        switch(index)
        {
            case 0: return ref vector;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector256<ulong> VectorAt(int index)
    {
        switch(index)
        {
            case 0: return ref vector;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    public b64 this[int index]
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            return vector[index];
        }
        [MethodImpl(256 | 512)]
        set
        {
            vector = vector.WithElement(index, value);
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public b64_mt4(Vector256<ulong> vector)
    {
        this.vector = vector;
    }

    [MethodImpl(256 | 512)]
    private b64_mt4(ref readonly b64 values)
    {
        ref var vs = ref Unsafe.AsRef(in values);
        vector = Vector256.LoadUnsafe(in Unsafe.As<b64, ulong>(ref vs));
    }

    [MethodImpl(256 | 512)]
    public static b64_mt4 LoadUnsafe(ref readonly b64 values) => new(in values);

    [MethodImpl(256 | 512)]
    public static b64_mt4 LoadUnsafe(params ReadOnlySpan<b64> values) => new(in values.GetPinnableReference());

    [MethodImpl(256 | 512)]
    public b64_mt4(b64 value)
    {
        vector = Vector256.Create((ulong)value);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator b64_mt4(b64 value) => new(value);

    [MethodImpl(256 | 512)]
    public static b64_mt4 operator~(b64_mt4 a) => new(~a.vector);

    [MethodImpl(256 | 512)]
    public static b64_mt4 operator|(b64_mt4 a, b64_mt4 b) => new(a.vector | b.vector);

    [MethodImpl(256 | 512)]
    public static b64_mt4 operator&(b64_mt4 a, b64_mt4 b) => new(a.vector & b.vector);

    [MethodImpl(256 | 512)]
    public static b64_mt4 operator^(b64_mt4 a, b64_mt4 b) => new(a.vector ^ b.vector);

    [MethodImpl(256 | 512)]
    public static b64_mt4 operator<<(b64_mt4 a, int b) => new(a.vector << b);

    [MethodImpl(256 | 512)]
    public static b64_mt4 operator>>(b64_mt4 a, int b) => new(a.vector >> b);

    [MethodImpl(256 | 512)]
    public static b64_mt4 operator>>>(b64_mt4 a, int b) => new(a.vector >>> b);

    #endregion  // Operators

    #region ToString

    public readonly override string ToString() => $"b64_mt4 {{ t0 = {this[0]}, t1 = {this[1]}, t2 = {this[2]}, t3 = {this[3]} }}";

    #endregion  // ToString
}

#endregion // b64_mt4
#region b64_mt8

[CpuOnly]
public partial struct b64_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => 8;
    }

    #endregion

    #region Fields

    public Vector512<ulong> vector;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512), UnscopedRef]
    public readonly ref readonly Vector512<ulong> VectorAtRo(int index)
    {
        switch(index)
        {
            case 0: return ref vector;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector512<ulong> VectorAt(int index)
    {
        switch(index)
        {
            case 0: return ref vector;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    public b64 this[int index]
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            return vector[index];
        }
        [MethodImpl(256 | 512)]
        set
        {
            vector = vector.WithElement(index, value);
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public b64_mt8(Vector512<ulong> vector)
    {
        this.vector = vector;
    }

    [MethodImpl(256 | 512)]
    private b64_mt8(ref readonly b64 values)
    {
        ref var vs = ref Unsafe.AsRef(in values);
        vector = Vector512.LoadUnsafe(in Unsafe.As<b64, ulong>(ref vs));
    }

    [MethodImpl(256 | 512)]
    public static b64_mt8 LoadUnsafe(ref readonly b64 values) => new(in values);

    [MethodImpl(256 | 512)]
    public static b64_mt8 LoadUnsafe(params ReadOnlySpan<b64> values) => new(in values.GetPinnableReference());

    [MethodImpl(256 | 512)]
    public b64_mt8(b64 value)
    {
        vector = Vector512.Create((ulong)value);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator b64_mt8(b64 value) => new(value);

    [MethodImpl(256 | 512)]
    public static b64_mt8 operator~(b64_mt8 a) => new(~a.vector);

    [MethodImpl(256 | 512)]
    public static b64_mt8 operator|(b64_mt8 a, b64_mt8 b) => new(a.vector | b.vector);

    [MethodImpl(256 | 512)]
    public static b64_mt8 operator&(b64_mt8 a, b64_mt8 b) => new(a.vector & b.vector);

    [MethodImpl(256 | 512)]
    public static b64_mt8 operator^(b64_mt8 a, b64_mt8 b) => new(a.vector ^ b.vector);

    [MethodImpl(256 | 512)]
    public static b64_mt8 operator<<(b64_mt8 a, int b) => new(a.vector << b);

    [MethodImpl(256 | 512)]
    public static b64_mt8 operator>>(b64_mt8 a, int b) => new(a.vector >> b);

    [MethodImpl(256 | 512)]
    public static b64_mt8 operator>>>(b64_mt8 a, int b) => new(a.vector >>> b);

    #endregion  // Operators

    #region ToString

    public readonly override string ToString() => $"b64_mt8 {{ t0 = {this[0]}, t1 = {this[1]}, t2 = {this[2]}, t3 = {this[3]}, t4 = {this[4]}, t5 = {this[5]}, t6 = {this[6]}, t7 = {this[7]} }}";

    #endregion  // ToString
}

#endregion // b64_mt8
#region b64_mt16

[CpuOnly]
public partial struct b64_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => 16;
    }

    #endregion

    #region Fields

    public Vector512<ulong> vector0;
    public Vector512<ulong> vector1;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512), UnscopedRef]
    public readonly ref readonly Vector512<ulong> VectorAtRo(int index)
    {
        switch(index)
        {
            case 0: return ref vector0;
            case 1: return ref vector1;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector512<ulong> VectorAt(int index)
    {
        switch(index)
        {
            case 0: return ref vector0;
            case 1: return ref vector1;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    public b64 this[int index]
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            var (q, r) = Math.DivRem(index, Vector512<ulong>.Count);
            return VectorAtRo(q)[r];
        }
        [MethodImpl(256 | 512)]
        set
        {
            var (q, r) = Math.DivRem(index, Vector512<ulong>.Count);
            ref var vector = ref VectorAt(q);
            vector = vector.WithElement(r, value);
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public b64_mt16(Vector512<ulong> vector0, Vector512<ulong> vector1)
    {
        this.vector0 = vector0;
        this.vector1 = vector1;
    }

    [MethodImpl(256 | 512)]
    private b64_mt16(ref readonly b64 values)
    {
        ref var vs = ref Unsafe.AsRef(in values);
        vector0 = Vector512.LoadUnsafe(in Unsafe.As<b64, ulong>(ref vs));
        vector1 = Vector512.LoadUnsafe(in Unsafe.As<b64, ulong>(ref Unsafe.Add(ref vs, 16)));
    }

    [MethodImpl(256 | 512)]
    public static b64_mt16 LoadUnsafe(ref readonly b64 values) => new(in values);

    [MethodImpl(256 | 512)]
    public static b64_mt16 LoadUnsafe(params ReadOnlySpan<b64> values) => new(in values.GetPinnableReference());

    [MethodImpl(256 | 512)]
    public b64_mt16(b64 value)
    {
        vector0 = Vector512.Create((ulong)value);
        vector1 = Vector512.Create((ulong)value);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator b64_mt16(b64 value) => new(value);

    [MethodImpl(256 | 512)]
    public static b64_mt16 operator~(b64_mt16 a) => new(~a.vector0, ~a.vector1);

    [MethodImpl(256 | 512)]
    public static b64_mt16 operator|(b64_mt16 a, b64_mt16 b) => new(a.vector0 | b.vector0, a.vector1 | b.vector1);

    [MethodImpl(256 | 512)]
    public static b64_mt16 operator&(b64_mt16 a, b64_mt16 b) => new(a.vector0 & b.vector0, a.vector1 & b.vector1);

    [MethodImpl(256 | 512)]
    public static b64_mt16 operator^(b64_mt16 a, b64_mt16 b) => new(a.vector0 ^ b.vector0, a.vector1 ^ b.vector1);

    [MethodImpl(256 | 512)]
    public static b64_mt16 operator<<(b64_mt16 a, int b) => new(a.vector0 << b, a.vector1 << b);

    [MethodImpl(256 | 512)]
    public static b64_mt16 operator>>(b64_mt16 a, int b) => new(a.vector0 >> b, a.vector1 >> b);

    [MethodImpl(256 | 512)]
    public static b64_mt16 operator>>>(b64_mt16 a, int b) => new(a.vector0 >>> b, a.vector1 >>> b);

    #endregion  // Operators

    #region ToString

    public readonly override string ToString() => $"b64_mt16 {{ t0 = {this[0]}, t1 = {this[1]}, t2 = {this[2]}, t3 = {this[3]}, t4 = {this[4]}, t5 = {this[5]}, t6 = {this[6]}, t7 = {this[7]}, t8 = {this[8]}, t9 = {this[9]}, t10 = {this[10]}, t11 = {this[11]}, t12 = {this[12]}, t13 = {this[13]}, t14 = {this[14]}, t15 = {this[15]} }}";

    #endregion  // ToString
}

#endregion // b64_mt16
#region b64_mt32

[CpuOnly]
public partial struct b64_mt32
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => 32;
    }

    #endregion

    #region Fields

    public Vector512<ulong> vector0;
    public Vector512<ulong> vector1;
    public Vector512<ulong> vector2;
    public Vector512<ulong> vector3;

    #endregion // Fields

    #region Properties

    [MethodImpl(256 | 512), UnscopedRef]
    public readonly ref readonly Vector512<ulong> VectorAtRo(int index)
    {
        switch(index)
        {
            case 0: return ref vector0;
            case 1: return ref vector1;
            case 2: return ref vector2;
            case 3: return ref vector3;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    [MethodImpl(256 | 512), UnscopedRef]
    public ref Vector512<ulong> VectorAt(int index)
    {
        switch(index)
        {
            case 0: return ref vector0;
            case 1: return ref vector1;
            case 2: return ref vector2;
            case 3: return ref vector3;
            default: throw new IndexOutOfRangeException("Index out of range for vector access");
        }
    }

    public b64 this[int index]
    {
        [MethodImpl(256 | 512)]
        readonly get
        {
            var (q, r) = Math.DivRem(index, Vector512<ulong>.Count);
            return VectorAtRo(q)[r];
        }
        [MethodImpl(256 | 512)]
        set
        {
            var (q, r) = Math.DivRem(index, Vector512<ulong>.Count);
            ref var vector = ref VectorAt(q);
            vector = vector.WithElement(r, value);
        }
    }

    #endregion // Properties

    #region Ctor

    [MethodImpl(256 | 512)]
    public b64_mt32(Vector512<ulong> vector0, Vector512<ulong> vector1, Vector512<ulong> vector2, Vector512<ulong> vector3)
    {
        this.vector0 = vector0;
        this.vector1 = vector1;
        this.vector2 = vector2;
        this.vector3 = vector3;
    }

    [MethodImpl(256 | 512)]
    private b64_mt32(ref readonly b64 values)
    {
        ref var vs = ref Unsafe.AsRef(in values);
        vector0 = Vector512.LoadUnsafe(in Unsafe.As<b64, ulong>(ref vs));
        vector1 = Vector512.LoadUnsafe(in Unsafe.As<b64, ulong>(ref Unsafe.Add(ref vs, 32)));
        vector2 = Vector512.LoadUnsafe(in Unsafe.As<b64, ulong>(ref Unsafe.Add(ref vs, 64)));
        vector3 = Vector512.LoadUnsafe(in Unsafe.As<b64, ulong>(ref Unsafe.Add(ref vs, 96)));
    }

    [MethodImpl(256 | 512)]
    public static b64_mt32 LoadUnsafe(ref readonly b64 values) => new(in values);

    [MethodImpl(256 | 512)]
    public static b64_mt32 LoadUnsafe(params ReadOnlySpan<b64> values) => new(in values.GetPinnableReference());

    [MethodImpl(256 | 512)]
    public b64_mt32(b64 value)
    {
        vector0 = Vector512.Create((ulong)value);
        vector1 = Vector512.Create((ulong)value);
        vector2 = Vector512.Create((ulong)value);
        vector3 = Vector512.Create((ulong)value);
    }

    #endregion // Ctor

    #region Operators

    [MethodImpl(256 | 512)]
    public static implicit operator b64_mt32(b64 value) => new(value);

    [MethodImpl(256 | 512)]
    public static b64_mt32 operator~(b64_mt32 a) => new(~a.vector0, ~a.vector1, ~a.vector2, ~a.vector3);

    [MethodImpl(256 | 512)]
    public static b64_mt32 operator|(b64_mt32 a, b64_mt32 b) => new(a.vector0 | b.vector0, a.vector1 | b.vector1, a.vector2 | b.vector2, a.vector3 | b.vector3);

    [MethodImpl(256 | 512)]
    public static b64_mt32 operator&(b64_mt32 a, b64_mt32 b) => new(a.vector0 & b.vector0, a.vector1 & b.vector1, a.vector2 & b.vector2, a.vector3 & b.vector3);

    [MethodImpl(256 | 512)]
    public static b64_mt32 operator^(b64_mt32 a, b64_mt32 b) => new(a.vector0 ^ b.vector0, a.vector1 ^ b.vector1, a.vector2 ^ b.vector2, a.vector3 ^ b.vector3);

    [MethodImpl(256 | 512)]
    public static b64_mt32 operator<<(b64_mt32 a, int b) => new(a.vector0 << b, a.vector1 << b, a.vector2 << b, a.vector3 << b);

    [MethodImpl(256 | 512)]
    public static b64_mt32 operator>>(b64_mt32 a, int b) => new(a.vector0 >> b, a.vector1 >> b, a.vector2 >> b, a.vector3 >> b);

    [MethodImpl(256 | 512)]
    public static b64_mt32 operator>>>(b64_mt32 a, int b) => new(a.vector0 >>> b, a.vector1 >>> b, a.vector2 >>> b, a.vector3 >>> b);

    #endregion  // Operators

    #region ToString

    public readonly override string ToString() => $"b64_mt32 {{ t0 = {this[0]}, t1 = {this[1]}, t2 = {this[2]}, t3 = {this[3]}, t4 = {this[4]}, t5 = {this[5]}, t6 = {this[6]}, t7 = {this[7]}, t8 = {this[8]}, t9 = {this[9]}, t10 = {this[10]}, t11 = {this[11]}, t12 = {this[12]}, t13 = {this[13]}, t14 = {this[14]}, t15 = {this[15]}, t16 = {this[16]}, t17 = {this[17]}, t18 = {this[18]}, t19 = {this[19]}, t20 = {this[20]}, t21 = {this[21]}, t22 = {this[22]}, t23 = {this[23]}, t24 = {this[24]}, t25 = {this[25]}, t26 = {this[26]}, t27 = {this[27]}, t28 = {this[28]}, t29 = {this[29]}, t30 = {this[30]}, t31 = {this[31]} }}";

    #endregion  // ToString
}

#endregion // b64_mt32
