// generated by template, do not modify manually

namespace Coplt.Mathematics.Simt;

#region float2x2_mt4

[CpuOnly]
public partial struct float2x2_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => float_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 2); 
    }

    public static float2x2_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0f, default,
            default, 1.0f
        ); 
    }

    #endregion

    #region Fields

    public float2_mt4 c0;
    public float2_mt4 c1;

    #endregion

    #region Properties

    public float_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public float_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public float_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public float_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly float2x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, float2x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public float2x2_mt4(float2_mt4 c0, float2_mt4 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public float2x2_mt4((float2_mt4 c0, float2_mt4 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x2_mt4((float2_mt4 c0, float2_mt4 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float2x2_mt4(
        float_mt4 m00, float_mt4 m01,
        float_mt4 m10, float_mt4 m11
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x2_mt4((
        float_mt4 m00, float_mt4 m01,
        float_mt4 m10, float_mt4 m11
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float2x2_mt4((
        float_mt4 m00, float_mt4 m01,
        float_mt4 m10, float_mt4 m11
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x2_mt4((
        (float_mt4 m00, float_mt4 m01) r0,
        (float_mt4 m10, float_mt4 m11) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float2x2_mt4((
        (float_mt4 m00, float_mt4 m01) r0,
        (float_mt4 m10, float_mt4 m11) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x2_mt4(float_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float2x2_mt4(float value) => (float_mt4)(value);

    [MethodImpl(256 | 512)]
    public float2x2_mt4(float_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x2_mt4(float2_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public float2x2_mt4(float2_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out float2_mt4 c0, out float2_mt4 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out float_mt4 m00, out float_mt4 m01,
        out float_mt4 m10, out float_mt4 m11
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
    }

    #endregion // Deconstruct

    #region Index

    public float2_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public float_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static float2x2_mt4 operator~(float2x2_mt4 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static float2x2_mt4 operator|(float2x2_mt4 a, float2x2_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static float2x2_mt4 operator&(float2x2_mt4 a, float2x2_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static float2x2_mt4 operator^(float2x2_mt4 a, float2x2_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"float2x2_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // float2x2_mt4

#region float2x2_mt8

[CpuOnly]
public partial struct float2x2_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => float_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 2); 
    }

    public static float2x2_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0f, default,
            default, 1.0f
        ); 
    }

    #endregion

    #region Fields

    public float2_mt8 c0;
    public float2_mt8 c1;

    #endregion

    #region Properties

    public float_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public float_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public float_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public float_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly float2x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, float2x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public float2x2_mt8(float2_mt8 c0, float2_mt8 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public float2x2_mt8((float2_mt8 c0, float2_mt8 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x2_mt8((float2_mt8 c0, float2_mt8 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float2x2_mt8(
        float_mt8 m00, float_mt8 m01,
        float_mt8 m10, float_mt8 m11
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x2_mt8((
        float_mt8 m00, float_mt8 m01,
        float_mt8 m10, float_mt8 m11
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float2x2_mt8((
        float_mt8 m00, float_mt8 m01,
        float_mt8 m10, float_mt8 m11
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x2_mt8((
        (float_mt8 m00, float_mt8 m01) r0,
        (float_mt8 m10, float_mt8 m11) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float2x2_mt8((
        (float_mt8 m00, float_mt8 m01) r0,
        (float_mt8 m10, float_mt8 m11) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x2_mt8(float_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float2x2_mt8(float value) => (float_mt8)(value);

    [MethodImpl(256 | 512)]
    public float2x2_mt8(float_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x2_mt8(float2_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public float2x2_mt8(float2_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out float2_mt8 c0, out float2_mt8 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out float_mt8 m00, out float_mt8 m01,
        out float_mt8 m10, out float_mt8 m11
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
    }

    #endregion // Deconstruct

    #region Index

    public float2_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public float_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static float2x2_mt8 operator~(float2x2_mt8 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static float2x2_mt8 operator|(float2x2_mt8 a, float2x2_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static float2x2_mt8 operator&(float2x2_mt8 a, float2x2_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static float2x2_mt8 operator^(float2x2_mt8 a, float2x2_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"float2x2_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // float2x2_mt8

#region float2x2_mt16

[CpuOnly]
public partial struct float2x2_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => float_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 2); 
    }

    public static float2x2_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0f, default,
            default, 1.0f
        ); 
    }

    #endregion

    #region Fields

    public float2_mt16 c0;
    public float2_mt16 c1;

    #endregion

    #region Properties

    public float_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public float_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public float_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public float_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly float2x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, float2x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public float2x2_mt16(float2_mt16 c0, float2_mt16 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public float2x2_mt16((float2_mt16 c0, float2_mt16 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x2_mt16((float2_mt16 c0, float2_mt16 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float2x2_mt16(
        float_mt16 m00, float_mt16 m01,
        float_mt16 m10, float_mt16 m11
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x2_mt16((
        float_mt16 m00, float_mt16 m01,
        float_mt16 m10, float_mt16 m11
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float2x2_mt16((
        float_mt16 m00, float_mt16 m01,
        float_mt16 m10, float_mt16 m11
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x2_mt16((
        (float_mt16 m00, float_mt16 m01) r0,
        (float_mt16 m10, float_mt16 m11) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float2x2_mt16((
        (float_mt16 m00, float_mt16 m01) r0,
        (float_mt16 m10, float_mt16 m11) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x2_mt16(float_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float2x2_mt16(float value) => (float_mt16)(value);

    [MethodImpl(256 | 512)]
    public float2x2_mt16(float_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x2_mt16(float2_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public float2x2_mt16(float2_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out float2_mt16 c0, out float2_mt16 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out float_mt16 m00, out float_mt16 m01,
        out float_mt16 m10, out float_mt16 m11
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
    }

    #endregion // Deconstruct

    #region Index

    public float2_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public float_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static float2x2_mt16 operator~(float2x2_mt16 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static float2x2_mt16 operator|(float2x2_mt16 a, float2x2_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static float2x2_mt16 operator&(float2x2_mt16 a, float2x2_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static float2x2_mt16 operator^(float2x2_mt16 a, float2x2_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"float2x2_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // float2x2_mt16

#region float2x3_mt4

[CpuOnly]
public partial struct float2x3_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => float_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 3); 
    }

    public static float2x3_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0f, default, default,
            default, 1.0f, default
        ); 
    }

    #endregion

    #region Fields

    public float2_mt4 c0;
    public float2_mt4 c1;
    public float2_mt4 c2;

    #endregion

    #region Properties

    public float_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public float_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public float_mt4 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public float_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public float_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public float_mt4 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly float2x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, float2x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public float2x3_mt4(float2_mt4 c0, float2_mt4 c1, float2_mt4 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public float2x3_mt4((float2_mt4 c0, float2_mt4 c1, float2_mt4 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x3_mt4((float2_mt4 c0, float2_mt4 c1, float2_mt4 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float2x3_mt4(
        float_mt4 m00, float_mt4 m01, float_mt4 m02,
        float_mt4 m10, float_mt4 m11, float_mt4 m12
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x3_mt4((
        float_mt4 m00, float_mt4 m01, float_mt4 m02,
        float_mt4 m10, float_mt4 m11, float_mt4 m12
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float2x3_mt4((
        float_mt4 m00, float_mt4 m01, float_mt4 m02,
        float_mt4 m10, float_mt4 m11, float_mt4 m12
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x3_mt4((
        (float_mt4 m00, float_mt4 m01, float_mt4 m02) r0,
        (float_mt4 m10, float_mt4 m11, float_mt4 m12) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float2x3_mt4((
        (float_mt4 m00, float_mt4 m01, float_mt4 m02) r0,
        (float_mt4 m10, float_mt4 m11, float_mt4 m12) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x3_mt4(float_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float2x3_mt4(float value) => (float_mt4)(value);

    [MethodImpl(256 | 512)]
    public float2x3_mt4(float_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x3_mt4(float2_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public float2x3_mt4(float2_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out float2_mt4 c0, out float2_mt4 c1, out float2_mt4 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out float_mt4 m00, out float_mt4 m01, out float_mt4 m02,
        out float_mt4 m10, out float_mt4 m11, out float_mt4 m12
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
    }

    #endregion // Deconstruct

    #region Index

    public float2_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public float_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static float2x3_mt4 operator~(float2x3_mt4 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static float2x3_mt4 operator|(float2x3_mt4 a, float2x3_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static float2x3_mt4 operator&(float2x3_mt4 a, float2x3_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static float2x3_mt4 operator^(float2x3_mt4 a, float2x3_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"float2x3_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // float2x3_mt4

#region float2x3_mt8

[CpuOnly]
public partial struct float2x3_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => float_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 3); 
    }

    public static float2x3_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0f, default, default,
            default, 1.0f, default
        ); 
    }

    #endregion

    #region Fields

    public float2_mt8 c0;
    public float2_mt8 c1;
    public float2_mt8 c2;

    #endregion

    #region Properties

    public float_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public float_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public float_mt8 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public float_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public float_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public float_mt8 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly float2x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, float2x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public float2x3_mt8(float2_mt8 c0, float2_mt8 c1, float2_mt8 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public float2x3_mt8((float2_mt8 c0, float2_mt8 c1, float2_mt8 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x3_mt8((float2_mt8 c0, float2_mt8 c1, float2_mt8 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float2x3_mt8(
        float_mt8 m00, float_mt8 m01, float_mt8 m02,
        float_mt8 m10, float_mt8 m11, float_mt8 m12
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x3_mt8((
        float_mt8 m00, float_mt8 m01, float_mt8 m02,
        float_mt8 m10, float_mt8 m11, float_mt8 m12
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float2x3_mt8((
        float_mt8 m00, float_mt8 m01, float_mt8 m02,
        float_mt8 m10, float_mt8 m11, float_mt8 m12
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x3_mt8((
        (float_mt8 m00, float_mt8 m01, float_mt8 m02) r0,
        (float_mt8 m10, float_mt8 m11, float_mt8 m12) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float2x3_mt8((
        (float_mt8 m00, float_mt8 m01, float_mt8 m02) r0,
        (float_mt8 m10, float_mt8 m11, float_mt8 m12) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x3_mt8(float_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float2x3_mt8(float value) => (float_mt8)(value);

    [MethodImpl(256 | 512)]
    public float2x3_mt8(float_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x3_mt8(float2_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public float2x3_mt8(float2_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out float2_mt8 c0, out float2_mt8 c1, out float2_mt8 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out float_mt8 m00, out float_mt8 m01, out float_mt8 m02,
        out float_mt8 m10, out float_mt8 m11, out float_mt8 m12
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
    }

    #endregion // Deconstruct

    #region Index

    public float2_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public float_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static float2x3_mt8 operator~(float2x3_mt8 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static float2x3_mt8 operator|(float2x3_mt8 a, float2x3_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static float2x3_mt8 operator&(float2x3_mt8 a, float2x3_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static float2x3_mt8 operator^(float2x3_mt8 a, float2x3_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"float2x3_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // float2x3_mt8

#region float2x3_mt16

[CpuOnly]
public partial struct float2x3_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => float_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 3); 
    }

    public static float2x3_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0f, default, default,
            default, 1.0f, default
        ); 
    }

    #endregion

    #region Fields

    public float2_mt16 c0;
    public float2_mt16 c1;
    public float2_mt16 c2;

    #endregion

    #region Properties

    public float_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public float_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public float_mt16 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public float_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public float_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public float_mt16 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly float2x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, float2x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public float2x3_mt16(float2_mt16 c0, float2_mt16 c1, float2_mt16 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public float2x3_mt16((float2_mt16 c0, float2_mt16 c1, float2_mt16 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x3_mt16((float2_mt16 c0, float2_mt16 c1, float2_mt16 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float2x3_mt16(
        float_mt16 m00, float_mt16 m01, float_mt16 m02,
        float_mt16 m10, float_mt16 m11, float_mt16 m12
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x3_mt16((
        float_mt16 m00, float_mt16 m01, float_mt16 m02,
        float_mt16 m10, float_mt16 m11, float_mt16 m12
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float2x3_mt16((
        float_mt16 m00, float_mt16 m01, float_mt16 m02,
        float_mt16 m10, float_mt16 m11, float_mt16 m12
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x3_mt16((
        (float_mt16 m00, float_mt16 m01, float_mt16 m02) r0,
        (float_mt16 m10, float_mt16 m11, float_mt16 m12) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float2x3_mt16((
        (float_mt16 m00, float_mt16 m01, float_mt16 m02) r0,
        (float_mt16 m10, float_mt16 m11, float_mt16 m12) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x3_mt16(float_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float2x3_mt16(float value) => (float_mt16)(value);

    [MethodImpl(256 | 512)]
    public float2x3_mt16(float_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x3_mt16(float2_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public float2x3_mt16(float2_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out float2_mt16 c0, out float2_mt16 c1, out float2_mt16 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out float_mt16 m00, out float_mt16 m01, out float_mt16 m02,
        out float_mt16 m10, out float_mt16 m11, out float_mt16 m12
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
    }

    #endregion // Deconstruct

    #region Index

    public float2_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public float_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static float2x3_mt16 operator~(float2x3_mt16 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static float2x3_mt16 operator|(float2x3_mt16 a, float2x3_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static float2x3_mt16 operator&(float2x3_mt16 a, float2x3_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static float2x3_mt16 operator^(float2x3_mt16 a, float2x3_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"float2x3_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // float2x3_mt16

#region float2x4_mt4

[CpuOnly]
public partial struct float2x4_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => float_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 4); 
    }

    public static float2x4_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0f, default, default, default,
            default, 1.0f, default, default
        ); 
    }

    #endregion

    #region Fields

    public float2_mt4 c0;
    public float2_mt4 c1;
    public float2_mt4 c2;
    public float2_mt4 c3;

    #endregion

    #region Properties

    public float_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public float_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public float_mt4 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public float_mt4 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public float_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public float_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public float_mt4 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public float_mt4 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly float2x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, float2x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public float2x4_mt4(float2_mt4 c0, float2_mt4 c1, float2_mt4 c2, float2_mt4 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public float2x4_mt4((float2_mt4 c0, float2_mt4 c1, float2_mt4 c2, float2_mt4 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x4_mt4((float2_mt4 c0, float2_mt4 c1, float2_mt4 c2, float2_mt4 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float2x4_mt4(
        float_mt4 m00, float_mt4 m01, float_mt4 m02, float_mt4 m03,
        float_mt4 m10, float_mt4 m11, float_mt4 m12, float_mt4 m13
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
        this.c3 = new(m03, m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x4_mt4((
        float_mt4 m00, float_mt4 m01, float_mt4 m02, float_mt4 m03,
        float_mt4 m10, float_mt4 m11, float_mt4 m12, float_mt4 m13
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float2x4_mt4((
        float_mt4 m00, float_mt4 m01, float_mt4 m02, float_mt4 m03,
        float_mt4 m10, float_mt4 m11, float_mt4 m12, float_mt4 m13
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
        this.c3 = new(tuple.m03, tuple.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x4_mt4((
        (float_mt4 m00, float_mt4 m01, float_mt4 m02, float_mt4 m03) r0,
        (float_mt4 m10, float_mt4 m11, float_mt4 m12, float_mt4 m13) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float2x4_mt4((
        (float_mt4 m00, float_mt4 m01, float_mt4 m02, float_mt4 m03) r0,
        (float_mt4 m10, float_mt4 m11, float_mt4 m12, float_mt4 m13) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x4_mt4(float_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float2x4_mt4(float value) => (float_mt4)(value);

    [MethodImpl(256 | 512)]
    public float2x4_mt4(float_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x4_mt4(float2_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public float2x4_mt4(float2_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out float2_mt4 c0, out float2_mt4 c1, out float2_mt4 c2, out float2_mt4 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out float_mt4 m00, out float_mt4 m01, out float_mt4 m02, out float_mt4 m03,
        out float_mt4 m10, out float_mt4 m11, out float_mt4 m12, out float_mt4 m13
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
        this.c3.Deconstruct(out m03, out m13);
    }

    #endregion // Deconstruct

    #region Index

    public float2_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public float_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static float2x4_mt4 operator~(float2x4_mt4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static float2x4_mt4 operator|(float2x4_mt4 a, float2x4_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static float2x4_mt4 operator&(float2x4_mt4 a, float2x4_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static float2x4_mt4 operator^(float2x4_mt4 a, float2x4_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"float2x4_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // float2x4_mt4

#region float2x4_mt8

[CpuOnly]
public partial struct float2x4_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => float_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 4); 
    }

    public static float2x4_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0f, default, default, default,
            default, 1.0f, default, default
        ); 
    }

    #endregion

    #region Fields

    public float2_mt8 c0;
    public float2_mt8 c1;
    public float2_mt8 c2;
    public float2_mt8 c3;

    #endregion

    #region Properties

    public float_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public float_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public float_mt8 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public float_mt8 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public float_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public float_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public float_mt8 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public float_mt8 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly float2x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, float2x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public float2x4_mt8(float2_mt8 c0, float2_mt8 c1, float2_mt8 c2, float2_mt8 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public float2x4_mt8((float2_mt8 c0, float2_mt8 c1, float2_mt8 c2, float2_mt8 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x4_mt8((float2_mt8 c0, float2_mt8 c1, float2_mt8 c2, float2_mt8 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float2x4_mt8(
        float_mt8 m00, float_mt8 m01, float_mt8 m02, float_mt8 m03,
        float_mt8 m10, float_mt8 m11, float_mt8 m12, float_mt8 m13
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
        this.c3 = new(m03, m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x4_mt8((
        float_mt8 m00, float_mt8 m01, float_mt8 m02, float_mt8 m03,
        float_mt8 m10, float_mt8 m11, float_mt8 m12, float_mt8 m13
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float2x4_mt8((
        float_mt8 m00, float_mt8 m01, float_mt8 m02, float_mt8 m03,
        float_mt8 m10, float_mt8 m11, float_mt8 m12, float_mt8 m13
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
        this.c3 = new(tuple.m03, tuple.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x4_mt8((
        (float_mt8 m00, float_mt8 m01, float_mt8 m02, float_mt8 m03) r0,
        (float_mt8 m10, float_mt8 m11, float_mt8 m12, float_mt8 m13) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float2x4_mt8((
        (float_mt8 m00, float_mt8 m01, float_mt8 m02, float_mt8 m03) r0,
        (float_mt8 m10, float_mt8 m11, float_mt8 m12, float_mt8 m13) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x4_mt8(float_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float2x4_mt8(float value) => (float_mt8)(value);

    [MethodImpl(256 | 512)]
    public float2x4_mt8(float_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x4_mt8(float2_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public float2x4_mt8(float2_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out float2_mt8 c0, out float2_mt8 c1, out float2_mt8 c2, out float2_mt8 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out float_mt8 m00, out float_mt8 m01, out float_mt8 m02, out float_mt8 m03,
        out float_mt8 m10, out float_mt8 m11, out float_mt8 m12, out float_mt8 m13
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
        this.c3.Deconstruct(out m03, out m13);
    }

    #endregion // Deconstruct

    #region Index

    public float2_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public float_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static float2x4_mt8 operator~(float2x4_mt8 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static float2x4_mt8 operator|(float2x4_mt8 a, float2x4_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static float2x4_mt8 operator&(float2x4_mt8 a, float2x4_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static float2x4_mt8 operator^(float2x4_mt8 a, float2x4_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"float2x4_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // float2x4_mt8

#region float2x4_mt16

[CpuOnly]
public partial struct float2x4_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => float_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 4); 
    }

    public static float2x4_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0f, default, default, default,
            default, 1.0f, default, default
        ); 
    }

    #endregion

    #region Fields

    public float2_mt16 c0;
    public float2_mt16 c1;
    public float2_mt16 c2;
    public float2_mt16 c3;

    #endregion

    #region Properties

    public float_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public float_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public float_mt16 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public float_mt16 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public float_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public float_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public float_mt16 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public float_mt16 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly float2x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, float2x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public float2x4_mt16(float2_mt16 c0, float2_mt16 c1, float2_mt16 c2, float2_mt16 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public float2x4_mt16((float2_mt16 c0, float2_mt16 c1, float2_mt16 c2, float2_mt16 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x4_mt16((float2_mt16 c0, float2_mt16 c1, float2_mt16 c2, float2_mt16 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float2x4_mt16(
        float_mt16 m00, float_mt16 m01, float_mt16 m02, float_mt16 m03,
        float_mt16 m10, float_mt16 m11, float_mt16 m12, float_mt16 m13
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
        this.c3 = new(m03, m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x4_mt16((
        float_mt16 m00, float_mt16 m01, float_mt16 m02, float_mt16 m03,
        float_mt16 m10, float_mt16 m11, float_mt16 m12, float_mt16 m13
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float2x4_mt16((
        float_mt16 m00, float_mt16 m01, float_mt16 m02, float_mt16 m03,
        float_mt16 m10, float_mt16 m11, float_mt16 m12, float_mt16 m13
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
        this.c3 = new(tuple.m03, tuple.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x4_mt16((
        (float_mt16 m00, float_mt16 m01, float_mt16 m02, float_mt16 m03) r0,
        (float_mt16 m10, float_mt16 m11, float_mt16 m12, float_mt16 m13) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float2x4_mt16((
        (float_mt16 m00, float_mt16 m01, float_mt16 m02, float_mt16 m03) r0,
        (float_mt16 m10, float_mt16 m11, float_mt16 m12, float_mt16 m13) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x4_mt16(float_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float2x4_mt16(float value) => (float_mt16)(value);

    [MethodImpl(256 | 512)]
    public float2x4_mt16(float_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float2x4_mt16(float2_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public float2x4_mt16(float2_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out float2_mt16 c0, out float2_mt16 c1, out float2_mt16 c2, out float2_mt16 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out float_mt16 m00, out float_mt16 m01, out float_mt16 m02, out float_mt16 m03,
        out float_mt16 m10, out float_mt16 m11, out float_mt16 m12, out float_mt16 m13
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
        this.c3.Deconstruct(out m03, out m13);
    }

    #endregion // Deconstruct

    #region Index

    public float2_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public float_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static float2x4_mt16 operator~(float2x4_mt16 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static float2x4_mt16 operator|(float2x4_mt16 a, float2x4_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static float2x4_mt16 operator&(float2x4_mt16 a, float2x4_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static float2x4_mt16 operator^(float2x4_mt16 a, float2x4_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"float2x4_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // float2x4_mt16

#region float3x2_mt4

[CpuOnly]
public partial struct float3x2_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => float_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 2); 
    }

    public static float3x2_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0f, default,
            default, 1.0f,
            default, default
        ); 
    }

    #endregion

    #region Fields

    public float3_mt4 c0;
    public float3_mt4 c1;

    #endregion

    #region Properties

    public float_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public float_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public float_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public float_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public float_mt4 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public float_mt4 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly float3x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, float3x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public float3x2_mt4(float3_mt4 c0, float3_mt4 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public float3x2_mt4((float3_mt4 c0, float3_mt4 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x2_mt4((float3_mt4 c0, float3_mt4 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float3x2_mt4(
        float_mt4 m00, float_mt4 m01,
        float_mt4 m10, float_mt4 m11,
        float_mt4 m20, float_mt4 m21
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x2_mt4((
        float_mt4 m00, float_mt4 m01,
        float_mt4 m10, float_mt4 m11,
        float_mt4 m20, float_mt4 m21
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float3x2_mt4((
        float_mt4 m00, float_mt4 m01,
        float_mt4 m10, float_mt4 m11,
        float_mt4 m20, float_mt4 m21
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x2_mt4((
        (float_mt4 m00, float_mt4 m01) r0,
        (float_mt4 m10, float_mt4 m11) r1,
        (float_mt4 m20, float_mt4 m21) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float3x2_mt4((
        (float_mt4 m00, float_mt4 m01) r0,
        (float_mt4 m10, float_mt4 m11) r1,
        (float_mt4 m20, float_mt4 m21) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x2_mt4(float_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float3x2_mt4(float value) => (float_mt4)(value);

    [MethodImpl(256 | 512)]
    public float3x2_mt4(float_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x2_mt4(float3_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public float3x2_mt4(float3_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out float3_mt4 c0, out float3_mt4 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out float_mt4 m00, out float_mt4 m01,
        out float_mt4 m10, out float_mt4 m11,
        out float_mt4 m20, out float_mt4 m21
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
    }

    #endregion // Deconstruct

    #region Index

    public float3_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public float_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static float3x2_mt4 operator~(float3x2_mt4 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static float3x2_mt4 operator|(float3x2_mt4 a, float3x2_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static float3x2_mt4 operator&(float3x2_mt4 a, float3x2_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static float3x2_mt4 operator^(float3x2_mt4 a, float3x2_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"float3x2_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // float3x2_mt4

#region float3x2_mt8

[CpuOnly]
public partial struct float3x2_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => float_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 2); 
    }

    public static float3x2_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0f, default,
            default, 1.0f,
            default, default
        ); 
    }

    #endregion

    #region Fields

    public float3_mt8 c0;
    public float3_mt8 c1;

    #endregion

    #region Properties

    public float_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public float_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public float_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public float_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public float_mt8 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public float_mt8 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly float3x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, float3x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public float3x2_mt8(float3_mt8 c0, float3_mt8 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public float3x2_mt8((float3_mt8 c0, float3_mt8 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x2_mt8((float3_mt8 c0, float3_mt8 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float3x2_mt8(
        float_mt8 m00, float_mt8 m01,
        float_mt8 m10, float_mt8 m11,
        float_mt8 m20, float_mt8 m21
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x2_mt8((
        float_mt8 m00, float_mt8 m01,
        float_mt8 m10, float_mt8 m11,
        float_mt8 m20, float_mt8 m21
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float3x2_mt8((
        float_mt8 m00, float_mt8 m01,
        float_mt8 m10, float_mt8 m11,
        float_mt8 m20, float_mt8 m21
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x2_mt8((
        (float_mt8 m00, float_mt8 m01) r0,
        (float_mt8 m10, float_mt8 m11) r1,
        (float_mt8 m20, float_mt8 m21) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float3x2_mt8((
        (float_mt8 m00, float_mt8 m01) r0,
        (float_mt8 m10, float_mt8 m11) r1,
        (float_mt8 m20, float_mt8 m21) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x2_mt8(float_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float3x2_mt8(float value) => (float_mt8)(value);

    [MethodImpl(256 | 512)]
    public float3x2_mt8(float_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x2_mt8(float3_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public float3x2_mt8(float3_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out float3_mt8 c0, out float3_mt8 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out float_mt8 m00, out float_mt8 m01,
        out float_mt8 m10, out float_mt8 m11,
        out float_mt8 m20, out float_mt8 m21
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
    }

    #endregion // Deconstruct

    #region Index

    public float3_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public float_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static float3x2_mt8 operator~(float3x2_mt8 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static float3x2_mt8 operator|(float3x2_mt8 a, float3x2_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static float3x2_mt8 operator&(float3x2_mt8 a, float3x2_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static float3x2_mt8 operator^(float3x2_mt8 a, float3x2_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"float3x2_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // float3x2_mt8

#region float3x2_mt16

[CpuOnly]
public partial struct float3x2_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => float_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 2); 
    }

    public static float3x2_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0f, default,
            default, 1.0f,
            default, default
        ); 
    }

    #endregion

    #region Fields

    public float3_mt16 c0;
    public float3_mt16 c1;

    #endregion

    #region Properties

    public float_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public float_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public float_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public float_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public float_mt16 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public float_mt16 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly float3x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, float3x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public float3x2_mt16(float3_mt16 c0, float3_mt16 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public float3x2_mt16((float3_mt16 c0, float3_mt16 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x2_mt16((float3_mt16 c0, float3_mt16 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float3x2_mt16(
        float_mt16 m00, float_mt16 m01,
        float_mt16 m10, float_mt16 m11,
        float_mt16 m20, float_mt16 m21
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x2_mt16((
        float_mt16 m00, float_mt16 m01,
        float_mt16 m10, float_mt16 m11,
        float_mt16 m20, float_mt16 m21
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float3x2_mt16((
        float_mt16 m00, float_mt16 m01,
        float_mt16 m10, float_mt16 m11,
        float_mt16 m20, float_mt16 m21
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x2_mt16((
        (float_mt16 m00, float_mt16 m01) r0,
        (float_mt16 m10, float_mt16 m11) r1,
        (float_mt16 m20, float_mt16 m21) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float3x2_mt16((
        (float_mt16 m00, float_mt16 m01) r0,
        (float_mt16 m10, float_mt16 m11) r1,
        (float_mt16 m20, float_mt16 m21) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x2_mt16(float_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float3x2_mt16(float value) => (float_mt16)(value);

    [MethodImpl(256 | 512)]
    public float3x2_mt16(float_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x2_mt16(float3_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public float3x2_mt16(float3_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out float3_mt16 c0, out float3_mt16 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out float_mt16 m00, out float_mt16 m01,
        out float_mt16 m10, out float_mt16 m11,
        out float_mt16 m20, out float_mt16 m21
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
    }

    #endregion // Deconstruct

    #region Index

    public float3_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public float_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static float3x2_mt16 operator~(float3x2_mt16 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static float3x2_mt16 operator|(float3x2_mt16 a, float3x2_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static float3x2_mt16 operator&(float3x2_mt16 a, float3x2_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static float3x2_mt16 operator^(float3x2_mt16 a, float3x2_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"float3x2_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // float3x2_mt16

#region float3x3_mt4

[CpuOnly]
public partial struct float3x3_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => float_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 9; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 3); 
    }

    public static float3x3_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0f, default, default,
            default, 1.0f, default,
            default, default, 1.0f
        ); 
    }

    #endregion

    #region Fields

    public float3_mt4 c0;
    public float3_mt4 c1;
    public float3_mt4 c2;

    #endregion

    #region Properties

    public float_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public float_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public float_mt4 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public float_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public float_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public float_mt4 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public float_mt4 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public float_mt4 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public float_mt4 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly float3x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, float3x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public float3x3_mt4(float3_mt4 c0, float3_mt4 c1, float3_mt4 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public float3x3_mt4((float3_mt4 c0, float3_mt4 c1, float3_mt4 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x3_mt4((float3_mt4 c0, float3_mt4 c1, float3_mt4 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float3x3_mt4(
        float_mt4 m00, float_mt4 m01, float_mt4 m02,
        float_mt4 m10, float_mt4 m11, float_mt4 m12,
        float_mt4 m20, float_mt4 m21, float_mt4 m22
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x3_mt4((
        float_mt4 m00, float_mt4 m01, float_mt4 m02,
        float_mt4 m10, float_mt4 m11, float_mt4 m12,
        float_mt4 m20, float_mt4 m21, float_mt4 m22
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float3x3_mt4((
        float_mt4 m00, float_mt4 m01, float_mt4 m02,
        float_mt4 m10, float_mt4 m11, float_mt4 m12,
        float_mt4 m20, float_mt4 m21, float_mt4 m22
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x3_mt4((
        (float_mt4 m00, float_mt4 m01, float_mt4 m02) r0,
        (float_mt4 m10, float_mt4 m11, float_mt4 m12) r1,
        (float_mt4 m20, float_mt4 m21, float_mt4 m22) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float3x3_mt4((
        (float_mt4 m00, float_mt4 m01, float_mt4 m02) r0,
        (float_mt4 m10, float_mt4 m11, float_mt4 m12) r1,
        (float_mt4 m20, float_mt4 m21, float_mt4 m22) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x3_mt4(float_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float3x3_mt4(float value) => (float_mt4)(value);

    [MethodImpl(256 | 512)]
    public float3x3_mt4(float_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x3_mt4(float3_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public float3x3_mt4(float3_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out float3_mt4 c0, out float3_mt4 c1, out float3_mt4 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out float_mt4 m00, out float_mt4 m01, out float_mt4 m02,
        out float_mt4 m10, out float_mt4 m11, out float_mt4 m12,
        out float_mt4 m20, out float_mt4 m21, out float_mt4 m22
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
    }

    #endregion // Deconstruct

    #region Index

    public float3_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public float_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static float3x3_mt4 operator~(float3x3_mt4 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static float3x3_mt4 operator|(float3x3_mt4 a, float3x3_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static float3x3_mt4 operator&(float3x3_mt4 a, float3x3_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static float3x3_mt4 operator^(float3x3_mt4 a, float3x3_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"float3x3_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // float3x3_mt4

#region float3x3_mt8

[CpuOnly]
public partial struct float3x3_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => float_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 9; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 3); 
    }

    public static float3x3_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0f, default, default,
            default, 1.0f, default,
            default, default, 1.0f
        ); 
    }

    #endregion

    #region Fields

    public float3_mt8 c0;
    public float3_mt8 c1;
    public float3_mt8 c2;

    #endregion

    #region Properties

    public float_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public float_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public float_mt8 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public float_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public float_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public float_mt8 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public float_mt8 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public float_mt8 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public float_mt8 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly float3x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, float3x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public float3x3_mt8(float3_mt8 c0, float3_mt8 c1, float3_mt8 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public float3x3_mt8((float3_mt8 c0, float3_mt8 c1, float3_mt8 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x3_mt8((float3_mt8 c0, float3_mt8 c1, float3_mt8 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float3x3_mt8(
        float_mt8 m00, float_mt8 m01, float_mt8 m02,
        float_mt8 m10, float_mt8 m11, float_mt8 m12,
        float_mt8 m20, float_mt8 m21, float_mt8 m22
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x3_mt8((
        float_mt8 m00, float_mt8 m01, float_mt8 m02,
        float_mt8 m10, float_mt8 m11, float_mt8 m12,
        float_mt8 m20, float_mt8 m21, float_mt8 m22
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float3x3_mt8((
        float_mt8 m00, float_mt8 m01, float_mt8 m02,
        float_mt8 m10, float_mt8 m11, float_mt8 m12,
        float_mt8 m20, float_mt8 m21, float_mt8 m22
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x3_mt8((
        (float_mt8 m00, float_mt8 m01, float_mt8 m02) r0,
        (float_mt8 m10, float_mt8 m11, float_mt8 m12) r1,
        (float_mt8 m20, float_mt8 m21, float_mt8 m22) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float3x3_mt8((
        (float_mt8 m00, float_mt8 m01, float_mt8 m02) r0,
        (float_mt8 m10, float_mt8 m11, float_mt8 m12) r1,
        (float_mt8 m20, float_mt8 m21, float_mt8 m22) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x3_mt8(float_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float3x3_mt8(float value) => (float_mt8)(value);

    [MethodImpl(256 | 512)]
    public float3x3_mt8(float_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x3_mt8(float3_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public float3x3_mt8(float3_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out float3_mt8 c0, out float3_mt8 c1, out float3_mt8 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out float_mt8 m00, out float_mt8 m01, out float_mt8 m02,
        out float_mt8 m10, out float_mt8 m11, out float_mt8 m12,
        out float_mt8 m20, out float_mt8 m21, out float_mt8 m22
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
    }

    #endregion // Deconstruct

    #region Index

    public float3_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public float_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static float3x3_mt8 operator~(float3x3_mt8 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static float3x3_mt8 operator|(float3x3_mt8 a, float3x3_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static float3x3_mt8 operator&(float3x3_mt8 a, float3x3_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static float3x3_mt8 operator^(float3x3_mt8 a, float3x3_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"float3x3_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // float3x3_mt8

#region float3x3_mt16

[CpuOnly]
public partial struct float3x3_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => float_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 9; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 3); 
    }

    public static float3x3_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0f, default, default,
            default, 1.0f, default,
            default, default, 1.0f
        ); 
    }

    #endregion

    #region Fields

    public float3_mt16 c0;
    public float3_mt16 c1;
    public float3_mt16 c2;

    #endregion

    #region Properties

    public float_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public float_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public float_mt16 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public float_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public float_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public float_mt16 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public float_mt16 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public float_mt16 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public float_mt16 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly float3x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, float3x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public float3x3_mt16(float3_mt16 c0, float3_mt16 c1, float3_mt16 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public float3x3_mt16((float3_mt16 c0, float3_mt16 c1, float3_mt16 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x3_mt16((float3_mt16 c0, float3_mt16 c1, float3_mt16 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float3x3_mt16(
        float_mt16 m00, float_mt16 m01, float_mt16 m02,
        float_mt16 m10, float_mt16 m11, float_mt16 m12,
        float_mt16 m20, float_mt16 m21, float_mt16 m22
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x3_mt16((
        float_mt16 m00, float_mt16 m01, float_mt16 m02,
        float_mt16 m10, float_mt16 m11, float_mt16 m12,
        float_mt16 m20, float_mt16 m21, float_mt16 m22
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float3x3_mt16((
        float_mt16 m00, float_mt16 m01, float_mt16 m02,
        float_mt16 m10, float_mt16 m11, float_mt16 m12,
        float_mt16 m20, float_mt16 m21, float_mt16 m22
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x3_mt16((
        (float_mt16 m00, float_mt16 m01, float_mt16 m02) r0,
        (float_mt16 m10, float_mt16 m11, float_mt16 m12) r1,
        (float_mt16 m20, float_mt16 m21, float_mt16 m22) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float3x3_mt16((
        (float_mt16 m00, float_mt16 m01, float_mt16 m02) r0,
        (float_mt16 m10, float_mt16 m11, float_mt16 m12) r1,
        (float_mt16 m20, float_mt16 m21, float_mt16 m22) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x3_mt16(float_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float3x3_mt16(float value) => (float_mt16)(value);

    [MethodImpl(256 | 512)]
    public float3x3_mt16(float_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x3_mt16(float3_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public float3x3_mt16(float3_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out float3_mt16 c0, out float3_mt16 c1, out float3_mt16 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out float_mt16 m00, out float_mt16 m01, out float_mt16 m02,
        out float_mt16 m10, out float_mt16 m11, out float_mt16 m12,
        out float_mt16 m20, out float_mt16 m21, out float_mt16 m22
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
    }

    #endregion // Deconstruct

    #region Index

    public float3_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public float_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static float3x3_mt16 operator~(float3x3_mt16 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static float3x3_mt16 operator|(float3x3_mt16 a, float3x3_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static float3x3_mt16 operator&(float3x3_mt16 a, float3x3_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static float3x3_mt16 operator^(float3x3_mt16 a, float3x3_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"float3x3_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // float3x3_mt16

#region float3x4_mt4

[CpuOnly]
public partial struct float3x4_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => float_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 4); 
    }

    public static float3x4_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0f, default, default, default,
            default, 1.0f, default, default,
            default, default, 1.0f, default
        ); 
    }

    #endregion

    #region Fields

    public float3_mt4 c0;
    public float3_mt4 c1;
    public float3_mt4 c2;
    public float3_mt4 c3;

    #endregion

    #region Properties

    public float_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public float_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public float_mt4 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public float_mt4 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public float_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public float_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public float_mt4 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public float_mt4 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public float_mt4 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public float_mt4 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public float_mt4 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public float_mt4 m23
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly float3x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, float3x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public float3x4_mt4(float3_mt4 c0, float3_mt4 c1, float3_mt4 c2, float3_mt4 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public float3x4_mt4((float3_mt4 c0, float3_mt4 c1, float3_mt4 c2, float3_mt4 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x4_mt4((float3_mt4 c0, float3_mt4 c1, float3_mt4 c2, float3_mt4 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float3x4_mt4(
        float_mt4 m00, float_mt4 m01, float_mt4 m02, float_mt4 m03,
        float_mt4 m10, float_mt4 m11, float_mt4 m12, float_mt4 m13,
        float_mt4 m20, float_mt4 m21, float_mt4 m22, float_mt4 m23
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
        this.c3 = new(m03, m13, m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x4_mt4((
        float_mt4 m00, float_mt4 m01, float_mt4 m02, float_mt4 m03,
        float_mt4 m10, float_mt4 m11, float_mt4 m12, float_mt4 m13,
        float_mt4 m20, float_mt4 m21, float_mt4 m22, float_mt4 m23
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float3x4_mt4((
        float_mt4 m00, float_mt4 m01, float_mt4 m02, float_mt4 m03,
        float_mt4 m10, float_mt4 m11, float_mt4 m12, float_mt4 m13,
        float_mt4 m20, float_mt4 m21, float_mt4 m22, float_mt4 m23
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x4_mt4((
        (float_mt4 m00, float_mt4 m01, float_mt4 m02, float_mt4 m03) r0,
        (float_mt4 m10, float_mt4 m11, float_mt4 m12, float_mt4 m13) r1,
        (float_mt4 m20, float_mt4 m21, float_mt4 m22, float_mt4 m23) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float3x4_mt4((
        (float_mt4 m00, float_mt4 m01, float_mt4 m02, float_mt4 m03) r0,
        (float_mt4 m10, float_mt4 m11, float_mt4 m12, float_mt4 m13) r1,
        (float_mt4 m20, float_mt4 m21, float_mt4 m22, float_mt4 m23) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x4_mt4(float_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float3x4_mt4(float value) => (float_mt4)(value);

    [MethodImpl(256 | 512)]
    public float3x4_mt4(float_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x4_mt4(float3_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public float3x4_mt4(float3_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out float3_mt4 c0, out float3_mt4 c1, out float3_mt4 c2, out float3_mt4 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out float_mt4 m00, out float_mt4 m01, out float_mt4 m02, out float_mt4 m03,
        out float_mt4 m10, out float_mt4 m11, out float_mt4 m12, out float_mt4 m13,
        out float_mt4 m20, out float_mt4 m21, out float_mt4 m22, out float_mt4 m23
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
        this.c3.Deconstruct(out m03, out m13, out m23);
    }

    #endregion // Deconstruct

    #region Index

    public float3_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public float_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static float3x4_mt4 operator~(float3x4_mt4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static float3x4_mt4 operator|(float3x4_mt4 a, float3x4_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static float3x4_mt4 operator&(float3x4_mt4 a, float3x4_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static float3x4_mt4 operator^(float3x4_mt4 a, float3x4_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"float3x4_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // float3x4_mt4

#region float3x4_mt8

[CpuOnly]
public partial struct float3x4_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => float_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 4); 
    }

    public static float3x4_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0f, default, default, default,
            default, 1.0f, default, default,
            default, default, 1.0f, default
        ); 
    }

    #endregion

    #region Fields

    public float3_mt8 c0;
    public float3_mt8 c1;
    public float3_mt8 c2;
    public float3_mt8 c3;

    #endregion

    #region Properties

    public float_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public float_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public float_mt8 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public float_mt8 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public float_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public float_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public float_mt8 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public float_mt8 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public float_mt8 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public float_mt8 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public float_mt8 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public float_mt8 m23
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly float3x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, float3x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public float3x4_mt8(float3_mt8 c0, float3_mt8 c1, float3_mt8 c2, float3_mt8 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public float3x4_mt8((float3_mt8 c0, float3_mt8 c1, float3_mt8 c2, float3_mt8 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x4_mt8((float3_mt8 c0, float3_mt8 c1, float3_mt8 c2, float3_mt8 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float3x4_mt8(
        float_mt8 m00, float_mt8 m01, float_mt8 m02, float_mt8 m03,
        float_mt8 m10, float_mt8 m11, float_mt8 m12, float_mt8 m13,
        float_mt8 m20, float_mt8 m21, float_mt8 m22, float_mt8 m23
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
        this.c3 = new(m03, m13, m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x4_mt8((
        float_mt8 m00, float_mt8 m01, float_mt8 m02, float_mt8 m03,
        float_mt8 m10, float_mt8 m11, float_mt8 m12, float_mt8 m13,
        float_mt8 m20, float_mt8 m21, float_mt8 m22, float_mt8 m23
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float3x4_mt8((
        float_mt8 m00, float_mt8 m01, float_mt8 m02, float_mt8 m03,
        float_mt8 m10, float_mt8 m11, float_mt8 m12, float_mt8 m13,
        float_mt8 m20, float_mt8 m21, float_mt8 m22, float_mt8 m23
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x4_mt8((
        (float_mt8 m00, float_mt8 m01, float_mt8 m02, float_mt8 m03) r0,
        (float_mt8 m10, float_mt8 m11, float_mt8 m12, float_mt8 m13) r1,
        (float_mt8 m20, float_mt8 m21, float_mt8 m22, float_mt8 m23) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float3x4_mt8((
        (float_mt8 m00, float_mt8 m01, float_mt8 m02, float_mt8 m03) r0,
        (float_mt8 m10, float_mt8 m11, float_mt8 m12, float_mt8 m13) r1,
        (float_mt8 m20, float_mt8 m21, float_mt8 m22, float_mt8 m23) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x4_mt8(float_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float3x4_mt8(float value) => (float_mt8)(value);

    [MethodImpl(256 | 512)]
    public float3x4_mt8(float_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x4_mt8(float3_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public float3x4_mt8(float3_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out float3_mt8 c0, out float3_mt8 c1, out float3_mt8 c2, out float3_mt8 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out float_mt8 m00, out float_mt8 m01, out float_mt8 m02, out float_mt8 m03,
        out float_mt8 m10, out float_mt8 m11, out float_mt8 m12, out float_mt8 m13,
        out float_mt8 m20, out float_mt8 m21, out float_mt8 m22, out float_mt8 m23
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
        this.c3.Deconstruct(out m03, out m13, out m23);
    }

    #endregion // Deconstruct

    #region Index

    public float3_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public float_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static float3x4_mt8 operator~(float3x4_mt8 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static float3x4_mt8 operator|(float3x4_mt8 a, float3x4_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static float3x4_mt8 operator&(float3x4_mt8 a, float3x4_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static float3x4_mt8 operator^(float3x4_mt8 a, float3x4_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"float3x4_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // float3x4_mt8

#region float3x4_mt16

[CpuOnly]
public partial struct float3x4_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => float_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 4); 
    }

    public static float3x4_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0f, default, default, default,
            default, 1.0f, default, default,
            default, default, 1.0f, default
        ); 
    }

    #endregion

    #region Fields

    public float3_mt16 c0;
    public float3_mt16 c1;
    public float3_mt16 c2;
    public float3_mt16 c3;

    #endregion

    #region Properties

    public float_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public float_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public float_mt16 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public float_mt16 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public float_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public float_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public float_mt16 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public float_mt16 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public float_mt16 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public float_mt16 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public float_mt16 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public float_mt16 m23
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly float3x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, float3x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public float3x4_mt16(float3_mt16 c0, float3_mt16 c1, float3_mt16 c2, float3_mt16 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public float3x4_mt16((float3_mt16 c0, float3_mt16 c1, float3_mt16 c2, float3_mt16 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x4_mt16((float3_mt16 c0, float3_mt16 c1, float3_mt16 c2, float3_mt16 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float3x4_mt16(
        float_mt16 m00, float_mt16 m01, float_mt16 m02, float_mt16 m03,
        float_mt16 m10, float_mt16 m11, float_mt16 m12, float_mt16 m13,
        float_mt16 m20, float_mt16 m21, float_mt16 m22, float_mt16 m23
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
        this.c3 = new(m03, m13, m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x4_mt16((
        float_mt16 m00, float_mt16 m01, float_mt16 m02, float_mt16 m03,
        float_mt16 m10, float_mt16 m11, float_mt16 m12, float_mt16 m13,
        float_mt16 m20, float_mt16 m21, float_mt16 m22, float_mt16 m23
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float3x4_mt16((
        float_mt16 m00, float_mt16 m01, float_mt16 m02, float_mt16 m03,
        float_mt16 m10, float_mt16 m11, float_mt16 m12, float_mt16 m13,
        float_mt16 m20, float_mt16 m21, float_mt16 m22, float_mt16 m23
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x4_mt16((
        (float_mt16 m00, float_mt16 m01, float_mt16 m02, float_mt16 m03) r0,
        (float_mt16 m10, float_mt16 m11, float_mt16 m12, float_mt16 m13) r1,
        (float_mt16 m20, float_mt16 m21, float_mt16 m22, float_mt16 m23) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float3x4_mt16((
        (float_mt16 m00, float_mt16 m01, float_mt16 m02, float_mt16 m03) r0,
        (float_mt16 m10, float_mt16 m11, float_mt16 m12, float_mt16 m13) r1,
        (float_mt16 m20, float_mt16 m21, float_mt16 m22, float_mt16 m23) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x4_mt16(float_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float3x4_mt16(float value) => (float_mt16)(value);

    [MethodImpl(256 | 512)]
    public float3x4_mt16(float_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float3x4_mt16(float3_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public float3x4_mt16(float3_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out float3_mt16 c0, out float3_mt16 c1, out float3_mt16 c2, out float3_mt16 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out float_mt16 m00, out float_mt16 m01, out float_mt16 m02, out float_mt16 m03,
        out float_mt16 m10, out float_mt16 m11, out float_mt16 m12, out float_mt16 m13,
        out float_mt16 m20, out float_mt16 m21, out float_mt16 m22, out float_mt16 m23
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
        this.c3.Deconstruct(out m03, out m13, out m23);
    }

    #endregion // Deconstruct

    #region Index

    public float3_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public float_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static float3x4_mt16 operator~(float3x4_mt16 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static float3x4_mt16 operator|(float3x4_mt16 a, float3x4_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static float3x4_mt16 operator&(float3x4_mt16 a, float3x4_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static float3x4_mt16 operator^(float3x4_mt16 a, float3x4_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"float3x4_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // float3x4_mt16

#region float4x2_mt4

[CpuOnly]
public partial struct float4x2_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => float_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 2); 
    }

    public static float4x2_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0f, default,
            default, 1.0f,
            default, default,
            default, default
        ); 
    }

    #endregion

    #region Fields

    public float4_mt4 c0;
    public float4_mt4 c1;

    #endregion

    #region Properties

    public float_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public float_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public float_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public float_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public float_mt4 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public float_mt4 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public float_mt4 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public float_mt4 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly float4x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, float4x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public float4x2_mt4(float4_mt4 c0, float4_mt4 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public float4x2_mt4((float4_mt4 c0, float4_mt4 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x2_mt4((float4_mt4 c0, float4_mt4 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float4x2_mt4(
        float_mt4 m00, float_mt4 m01,
        float_mt4 m10, float_mt4 m11,
        float_mt4 m20, float_mt4 m21,
        float_mt4 m30, float_mt4 m31
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x2_mt4((
        float_mt4 m00, float_mt4 m01,
        float_mt4 m10, float_mt4 m11,
        float_mt4 m20, float_mt4 m21,
        float_mt4 m30, float_mt4 m31
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float4x2_mt4((
        float_mt4 m00, float_mt4 m01,
        float_mt4 m10, float_mt4 m11,
        float_mt4 m20, float_mt4 m21,
        float_mt4 m30, float_mt4 m31
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x2_mt4((
        (float_mt4 m00, float_mt4 m01) r0,
        (float_mt4 m10, float_mt4 m11) r1,
        (float_mt4 m20, float_mt4 m21) r2,
        (float_mt4 m30, float_mt4 m31) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float4x2_mt4((
        (float_mt4 m00, float_mt4 m01) r0,
        (float_mt4 m10, float_mt4 m11) r1,
        (float_mt4 m20, float_mt4 m21) r2,
        (float_mt4 m30, float_mt4 m31) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x2_mt4(float_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float4x2_mt4(float value) => (float_mt4)(value);

    [MethodImpl(256 | 512)]
    public float4x2_mt4(float_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x2_mt4(float4_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public float4x2_mt4(float4_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out float4_mt4 c0, out float4_mt4 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out float_mt4 m00, out float_mt4 m01,
        out float_mt4 m10, out float_mt4 m11,
        out float_mt4 m20, out float_mt4 m21,
        out float_mt4 m30, out float_mt4 m31
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
    }

    #endregion // Deconstruct

    #region Index

    public float4_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public float_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static float4x2_mt4 operator~(float4x2_mt4 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static float4x2_mt4 operator|(float4x2_mt4 a, float4x2_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static float4x2_mt4 operator&(float4x2_mt4 a, float4x2_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static float4x2_mt4 operator^(float4x2_mt4 a, float4x2_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"float4x2_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // float4x2_mt4

#region float4x2_mt8

[CpuOnly]
public partial struct float4x2_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => float_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 2); 
    }

    public static float4x2_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0f, default,
            default, 1.0f,
            default, default,
            default, default
        ); 
    }

    #endregion

    #region Fields

    public float4_mt8 c0;
    public float4_mt8 c1;

    #endregion

    #region Properties

    public float_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public float_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public float_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public float_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public float_mt8 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public float_mt8 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public float_mt8 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public float_mt8 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly float4x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, float4x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public float4x2_mt8(float4_mt8 c0, float4_mt8 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public float4x2_mt8((float4_mt8 c0, float4_mt8 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x2_mt8((float4_mt8 c0, float4_mt8 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float4x2_mt8(
        float_mt8 m00, float_mt8 m01,
        float_mt8 m10, float_mt8 m11,
        float_mt8 m20, float_mt8 m21,
        float_mt8 m30, float_mt8 m31
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x2_mt8((
        float_mt8 m00, float_mt8 m01,
        float_mt8 m10, float_mt8 m11,
        float_mt8 m20, float_mt8 m21,
        float_mt8 m30, float_mt8 m31
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float4x2_mt8((
        float_mt8 m00, float_mt8 m01,
        float_mt8 m10, float_mt8 m11,
        float_mt8 m20, float_mt8 m21,
        float_mt8 m30, float_mt8 m31
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x2_mt8((
        (float_mt8 m00, float_mt8 m01) r0,
        (float_mt8 m10, float_mt8 m11) r1,
        (float_mt8 m20, float_mt8 m21) r2,
        (float_mt8 m30, float_mt8 m31) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float4x2_mt8((
        (float_mt8 m00, float_mt8 m01) r0,
        (float_mt8 m10, float_mt8 m11) r1,
        (float_mt8 m20, float_mt8 m21) r2,
        (float_mt8 m30, float_mt8 m31) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x2_mt8(float_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float4x2_mt8(float value) => (float_mt8)(value);

    [MethodImpl(256 | 512)]
    public float4x2_mt8(float_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x2_mt8(float4_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public float4x2_mt8(float4_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out float4_mt8 c0, out float4_mt8 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out float_mt8 m00, out float_mt8 m01,
        out float_mt8 m10, out float_mt8 m11,
        out float_mt8 m20, out float_mt8 m21,
        out float_mt8 m30, out float_mt8 m31
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
    }

    #endregion // Deconstruct

    #region Index

    public float4_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public float_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static float4x2_mt8 operator~(float4x2_mt8 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static float4x2_mt8 operator|(float4x2_mt8 a, float4x2_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static float4x2_mt8 operator&(float4x2_mt8 a, float4x2_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static float4x2_mt8 operator^(float4x2_mt8 a, float4x2_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"float4x2_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // float4x2_mt8

#region float4x2_mt16

[CpuOnly]
public partial struct float4x2_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => float_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 2); 
    }

    public static float4x2_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0f, default,
            default, 1.0f,
            default, default,
            default, default
        ); 
    }

    #endregion

    #region Fields

    public float4_mt16 c0;
    public float4_mt16 c1;

    #endregion

    #region Properties

    public float_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public float_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public float_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public float_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public float_mt16 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public float_mt16 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public float_mt16 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public float_mt16 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly float4x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, float4x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public float4x2_mt16(float4_mt16 c0, float4_mt16 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public float4x2_mt16((float4_mt16 c0, float4_mt16 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x2_mt16((float4_mt16 c0, float4_mt16 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float4x2_mt16(
        float_mt16 m00, float_mt16 m01,
        float_mt16 m10, float_mt16 m11,
        float_mt16 m20, float_mt16 m21,
        float_mt16 m30, float_mt16 m31
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x2_mt16((
        float_mt16 m00, float_mt16 m01,
        float_mt16 m10, float_mt16 m11,
        float_mt16 m20, float_mt16 m21,
        float_mt16 m30, float_mt16 m31
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float4x2_mt16((
        float_mt16 m00, float_mt16 m01,
        float_mt16 m10, float_mt16 m11,
        float_mt16 m20, float_mt16 m21,
        float_mt16 m30, float_mt16 m31
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x2_mt16((
        (float_mt16 m00, float_mt16 m01) r0,
        (float_mt16 m10, float_mt16 m11) r1,
        (float_mt16 m20, float_mt16 m21) r2,
        (float_mt16 m30, float_mt16 m31) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float4x2_mt16((
        (float_mt16 m00, float_mt16 m01) r0,
        (float_mt16 m10, float_mt16 m11) r1,
        (float_mt16 m20, float_mt16 m21) r2,
        (float_mt16 m30, float_mt16 m31) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x2_mt16(float_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float4x2_mt16(float value) => (float_mt16)(value);

    [MethodImpl(256 | 512)]
    public float4x2_mt16(float_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x2_mt16(float4_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public float4x2_mt16(float4_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out float4_mt16 c0, out float4_mt16 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out float_mt16 m00, out float_mt16 m01,
        out float_mt16 m10, out float_mt16 m11,
        out float_mt16 m20, out float_mt16 m21,
        out float_mt16 m30, out float_mt16 m31
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
    }

    #endregion // Deconstruct

    #region Index

    public float4_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public float_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static float4x2_mt16 operator~(float4x2_mt16 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static float4x2_mt16 operator|(float4x2_mt16 a, float4x2_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static float4x2_mt16 operator&(float4x2_mt16 a, float4x2_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static float4x2_mt16 operator^(float4x2_mt16 a, float4x2_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"float4x2_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // float4x2_mt16

#region float4x3_mt4

[CpuOnly]
public partial struct float4x3_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => float_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 3); 
    }

    public static float4x3_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0f, default, default,
            default, 1.0f, default,
            default, default, 1.0f,
            default, default, default
        ); 
    }

    #endregion

    #region Fields

    public float4_mt4 c0;
    public float4_mt4 c1;
    public float4_mt4 c2;

    #endregion

    #region Properties

    public float_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public float_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public float_mt4 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public float_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public float_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public float_mt4 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public float_mt4 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public float_mt4 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public float_mt4 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public float_mt4 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public float_mt4 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public float_mt4 m32
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly float4x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, float4x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public float4x3_mt4(float4_mt4 c0, float4_mt4 c1, float4_mt4 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public float4x3_mt4((float4_mt4 c0, float4_mt4 c1, float4_mt4 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x3_mt4((float4_mt4 c0, float4_mt4 c1, float4_mt4 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float4x3_mt4(
        float_mt4 m00, float_mt4 m01, float_mt4 m02,
        float_mt4 m10, float_mt4 m11, float_mt4 m12,
        float_mt4 m20, float_mt4 m21, float_mt4 m22,
        float_mt4 m30, float_mt4 m31, float_mt4 m32
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x3_mt4((
        float_mt4 m00, float_mt4 m01, float_mt4 m02,
        float_mt4 m10, float_mt4 m11, float_mt4 m12,
        float_mt4 m20, float_mt4 m21, float_mt4 m22,
        float_mt4 m30, float_mt4 m31, float_mt4 m32
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float4x3_mt4((
        float_mt4 m00, float_mt4 m01, float_mt4 m02,
        float_mt4 m10, float_mt4 m11, float_mt4 m12,
        float_mt4 m20, float_mt4 m21, float_mt4 m22,
        float_mt4 m30, float_mt4 m31, float_mt4 m32
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x3_mt4((
        (float_mt4 m00, float_mt4 m01, float_mt4 m02) r0,
        (float_mt4 m10, float_mt4 m11, float_mt4 m12) r1,
        (float_mt4 m20, float_mt4 m21, float_mt4 m22) r2,
        (float_mt4 m30, float_mt4 m31, float_mt4 m32) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float4x3_mt4((
        (float_mt4 m00, float_mt4 m01, float_mt4 m02) r0,
        (float_mt4 m10, float_mt4 m11, float_mt4 m12) r1,
        (float_mt4 m20, float_mt4 m21, float_mt4 m22) r2,
        (float_mt4 m30, float_mt4 m31, float_mt4 m32) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x3_mt4(float_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float4x3_mt4(float value) => (float_mt4)(value);

    [MethodImpl(256 | 512)]
    public float4x3_mt4(float_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x3_mt4(float4_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public float4x3_mt4(float4_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out float4_mt4 c0, out float4_mt4 c1, out float4_mt4 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out float_mt4 m00, out float_mt4 m01, out float_mt4 m02,
        out float_mt4 m10, out float_mt4 m11, out float_mt4 m12,
        out float_mt4 m20, out float_mt4 m21, out float_mt4 m22,
        out float_mt4 m30, out float_mt4 m31, out float_mt4 m32
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
    }

    #endregion // Deconstruct

    #region Index

    public float4_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public float_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static float4x3_mt4 operator~(float4x3_mt4 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static float4x3_mt4 operator|(float4x3_mt4 a, float4x3_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static float4x3_mt4 operator&(float4x3_mt4 a, float4x3_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static float4x3_mt4 operator^(float4x3_mt4 a, float4x3_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"float4x3_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // float4x3_mt4

#region float4x3_mt8

[CpuOnly]
public partial struct float4x3_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => float_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 3); 
    }

    public static float4x3_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0f, default, default,
            default, 1.0f, default,
            default, default, 1.0f,
            default, default, default
        ); 
    }

    #endregion

    #region Fields

    public float4_mt8 c0;
    public float4_mt8 c1;
    public float4_mt8 c2;

    #endregion

    #region Properties

    public float_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public float_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public float_mt8 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public float_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public float_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public float_mt8 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public float_mt8 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public float_mt8 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public float_mt8 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public float_mt8 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public float_mt8 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public float_mt8 m32
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly float4x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, float4x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public float4x3_mt8(float4_mt8 c0, float4_mt8 c1, float4_mt8 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public float4x3_mt8((float4_mt8 c0, float4_mt8 c1, float4_mt8 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x3_mt8((float4_mt8 c0, float4_mt8 c1, float4_mt8 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float4x3_mt8(
        float_mt8 m00, float_mt8 m01, float_mt8 m02,
        float_mt8 m10, float_mt8 m11, float_mt8 m12,
        float_mt8 m20, float_mt8 m21, float_mt8 m22,
        float_mt8 m30, float_mt8 m31, float_mt8 m32
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x3_mt8((
        float_mt8 m00, float_mt8 m01, float_mt8 m02,
        float_mt8 m10, float_mt8 m11, float_mt8 m12,
        float_mt8 m20, float_mt8 m21, float_mt8 m22,
        float_mt8 m30, float_mt8 m31, float_mt8 m32
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float4x3_mt8((
        float_mt8 m00, float_mt8 m01, float_mt8 m02,
        float_mt8 m10, float_mt8 m11, float_mt8 m12,
        float_mt8 m20, float_mt8 m21, float_mt8 m22,
        float_mt8 m30, float_mt8 m31, float_mt8 m32
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x3_mt8((
        (float_mt8 m00, float_mt8 m01, float_mt8 m02) r0,
        (float_mt8 m10, float_mt8 m11, float_mt8 m12) r1,
        (float_mt8 m20, float_mt8 m21, float_mt8 m22) r2,
        (float_mt8 m30, float_mt8 m31, float_mt8 m32) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float4x3_mt8((
        (float_mt8 m00, float_mt8 m01, float_mt8 m02) r0,
        (float_mt8 m10, float_mt8 m11, float_mt8 m12) r1,
        (float_mt8 m20, float_mt8 m21, float_mt8 m22) r2,
        (float_mt8 m30, float_mt8 m31, float_mt8 m32) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x3_mt8(float_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float4x3_mt8(float value) => (float_mt8)(value);

    [MethodImpl(256 | 512)]
    public float4x3_mt8(float_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x3_mt8(float4_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public float4x3_mt8(float4_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out float4_mt8 c0, out float4_mt8 c1, out float4_mt8 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out float_mt8 m00, out float_mt8 m01, out float_mt8 m02,
        out float_mt8 m10, out float_mt8 m11, out float_mt8 m12,
        out float_mt8 m20, out float_mt8 m21, out float_mt8 m22,
        out float_mt8 m30, out float_mt8 m31, out float_mt8 m32
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
    }

    #endregion // Deconstruct

    #region Index

    public float4_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public float_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static float4x3_mt8 operator~(float4x3_mt8 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static float4x3_mt8 operator|(float4x3_mt8 a, float4x3_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static float4x3_mt8 operator&(float4x3_mt8 a, float4x3_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static float4x3_mt8 operator^(float4x3_mt8 a, float4x3_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"float4x3_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // float4x3_mt8

#region float4x3_mt16

[CpuOnly]
public partial struct float4x3_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => float_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 3); 
    }

    public static float4x3_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0f, default, default,
            default, 1.0f, default,
            default, default, 1.0f,
            default, default, default
        ); 
    }

    #endregion

    #region Fields

    public float4_mt16 c0;
    public float4_mt16 c1;
    public float4_mt16 c2;

    #endregion

    #region Properties

    public float_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public float_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public float_mt16 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public float_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public float_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public float_mt16 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public float_mt16 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public float_mt16 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public float_mt16 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public float_mt16 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public float_mt16 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public float_mt16 m32
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly float4x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, float4x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public float4x3_mt16(float4_mt16 c0, float4_mt16 c1, float4_mt16 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public float4x3_mt16((float4_mt16 c0, float4_mt16 c1, float4_mt16 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x3_mt16((float4_mt16 c0, float4_mt16 c1, float4_mt16 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float4x3_mt16(
        float_mt16 m00, float_mt16 m01, float_mt16 m02,
        float_mt16 m10, float_mt16 m11, float_mt16 m12,
        float_mt16 m20, float_mt16 m21, float_mt16 m22,
        float_mt16 m30, float_mt16 m31, float_mt16 m32
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x3_mt16((
        float_mt16 m00, float_mt16 m01, float_mt16 m02,
        float_mt16 m10, float_mt16 m11, float_mt16 m12,
        float_mt16 m20, float_mt16 m21, float_mt16 m22,
        float_mt16 m30, float_mt16 m31, float_mt16 m32
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float4x3_mt16((
        float_mt16 m00, float_mt16 m01, float_mt16 m02,
        float_mt16 m10, float_mt16 m11, float_mt16 m12,
        float_mt16 m20, float_mt16 m21, float_mt16 m22,
        float_mt16 m30, float_mt16 m31, float_mt16 m32
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x3_mt16((
        (float_mt16 m00, float_mt16 m01, float_mt16 m02) r0,
        (float_mt16 m10, float_mt16 m11, float_mt16 m12) r1,
        (float_mt16 m20, float_mt16 m21, float_mt16 m22) r2,
        (float_mt16 m30, float_mt16 m31, float_mt16 m32) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float4x3_mt16((
        (float_mt16 m00, float_mt16 m01, float_mt16 m02) r0,
        (float_mt16 m10, float_mt16 m11, float_mt16 m12) r1,
        (float_mt16 m20, float_mt16 m21, float_mt16 m22) r2,
        (float_mt16 m30, float_mt16 m31, float_mt16 m32) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x3_mt16(float_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float4x3_mt16(float value) => (float_mt16)(value);

    [MethodImpl(256 | 512)]
    public float4x3_mt16(float_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x3_mt16(float4_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public float4x3_mt16(float4_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out float4_mt16 c0, out float4_mt16 c1, out float4_mt16 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out float_mt16 m00, out float_mt16 m01, out float_mt16 m02,
        out float_mt16 m10, out float_mt16 m11, out float_mt16 m12,
        out float_mt16 m20, out float_mt16 m21, out float_mt16 m22,
        out float_mt16 m30, out float_mt16 m31, out float_mt16 m32
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
    }

    #endregion // Deconstruct

    #region Index

    public float4_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public float_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static float4x3_mt16 operator~(float4x3_mt16 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static float4x3_mt16 operator|(float4x3_mt16 a, float4x3_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static float4x3_mt16 operator&(float4x3_mt16 a, float4x3_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static float4x3_mt16 operator^(float4x3_mt16 a, float4x3_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"float4x3_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // float4x3_mt16

#region float4x4_mt4

[CpuOnly]
public partial struct float4x4_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => float_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 4); 
    }

    public static float4x4_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0f, default, default, default,
            default, 1.0f, default, default,
            default, default, 1.0f, default,
            default, default, default, 1.0f
        ); 
    }

    #endregion

    #region Fields

    public float4_mt4 c0;
    public float4_mt4 c1;
    public float4_mt4 c2;
    public float4_mt4 c3;

    #endregion

    #region Properties

    public float_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public float_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public float_mt4 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public float_mt4 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public float_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public float_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public float_mt4 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public float_mt4 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public float_mt4 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public float_mt4 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public float_mt4 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public float_mt4 m23
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }
    public float_mt4 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public float_mt4 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public float_mt4 m32
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }
    public float_mt4 m33
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.w;
        [MethodImpl(256 | 512)]
        set => c3.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly float4x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, float4x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public float4x4_mt4(float4_mt4 c0, float4_mt4 c1, float4_mt4 c2, float4_mt4 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public float4x4_mt4((float4_mt4 c0, float4_mt4 c1, float4_mt4 c2, float4_mt4 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x4_mt4((float4_mt4 c0, float4_mt4 c1, float4_mt4 c2, float4_mt4 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float4x4_mt4(
        float_mt4 m00, float_mt4 m01, float_mt4 m02, float_mt4 m03,
        float_mt4 m10, float_mt4 m11, float_mt4 m12, float_mt4 m13,
        float_mt4 m20, float_mt4 m21, float_mt4 m22, float_mt4 m23,
        float_mt4 m30, float_mt4 m31, float_mt4 m32, float_mt4 m33
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
        this.c3 = new(m03, m13, m23, m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x4_mt4((
        float_mt4 m00, float_mt4 m01, float_mt4 m02, float_mt4 m03,
        float_mt4 m10, float_mt4 m11, float_mt4 m12, float_mt4 m13,
        float_mt4 m20, float_mt4 m21, float_mt4 m22, float_mt4 m23,
        float_mt4 m30, float_mt4 m31, float_mt4 m32, float_mt4 m33
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float4x4_mt4((
        float_mt4 m00, float_mt4 m01, float_mt4 m02, float_mt4 m03,
        float_mt4 m10, float_mt4 m11, float_mt4 m12, float_mt4 m13,
        float_mt4 m20, float_mt4 m21, float_mt4 m22, float_mt4 m23,
        float_mt4 m30, float_mt4 m31, float_mt4 m32, float_mt4 m33
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23, tuple.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x4_mt4((
        (float_mt4 m00, float_mt4 m01, float_mt4 m02, float_mt4 m03) r0,
        (float_mt4 m10, float_mt4 m11, float_mt4 m12, float_mt4 m13) r1,
        (float_mt4 m20, float_mt4 m21, float_mt4 m22, float_mt4 m23) r2,
        (float_mt4 m30, float_mt4 m31, float_mt4 m32, float_mt4 m33) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float4x4_mt4((
        (float_mt4 m00, float_mt4 m01, float_mt4 m02, float_mt4 m03) r0,
        (float_mt4 m10, float_mt4 m11, float_mt4 m12, float_mt4 m13) r1,
        (float_mt4 m20, float_mt4 m21, float_mt4 m22, float_mt4 m23) r2,
        (float_mt4 m30, float_mt4 m31, float_mt4 m32, float_mt4 m33) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23, tuple.r3.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x4_mt4(float_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float4x4_mt4(float value) => (float_mt4)(value);

    [MethodImpl(256 | 512)]
    public float4x4_mt4(float_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x4_mt4(float4_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public float4x4_mt4(float4_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out float4_mt4 c0, out float4_mt4 c1, out float4_mt4 c2, out float4_mt4 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out float_mt4 m00, out float_mt4 m01, out float_mt4 m02, out float_mt4 m03,
        out float_mt4 m10, out float_mt4 m11, out float_mt4 m12, out float_mt4 m13,
        out float_mt4 m20, out float_mt4 m21, out float_mt4 m22, out float_mt4 m23,
        out float_mt4 m30, out float_mt4 m31, out float_mt4 m32, out float_mt4 m33
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
        this.c3.Deconstruct(out m03, out m13, out m23, out m33);
    }

    #endregion // Deconstruct

    #region Index

    public float4_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public float_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static float4x4_mt4 operator~(float4x4_mt4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static float4x4_mt4 operator|(float4x4_mt4 a, float4x4_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static float4x4_mt4 operator&(float4x4_mt4 a, float4x4_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static float4x4_mt4 operator^(float4x4_mt4 a, float4x4_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"float4x4_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // float4x4_mt4

#region float4x4_mt8

[CpuOnly]
public partial struct float4x4_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => float_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 4); 
    }

    public static float4x4_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0f, default, default, default,
            default, 1.0f, default, default,
            default, default, 1.0f, default,
            default, default, default, 1.0f
        ); 
    }

    #endregion

    #region Fields

    public float4_mt8 c0;
    public float4_mt8 c1;
    public float4_mt8 c2;
    public float4_mt8 c3;

    #endregion

    #region Properties

    public float_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public float_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public float_mt8 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public float_mt8 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public float_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public float_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public float_mt8 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public float_mt8 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public float_mt8 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public float_mt8 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public float_mt8 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public float_mt8 m23
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }
    public float_mt8 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public float_mt8 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public float_mt8 m32
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }
    public float_mt8 m33
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.w;
        [MethodImpl(256 | 512)]
        set => c3.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly float4x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, float4x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public float4x4_mt8(float4_mt8 c0, float4_mt8 c1, float4_mt8 c2, float4_mt8 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public float4x4_mt8((float4_mt8 c0, float4_mt8 c1, float4_mt8 c2, float4_mt8 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x4_mt8((float4_mt8 c0, float4_mt8 c1, float4_mt8 c2, float4_mt8 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float4x4_mt8(
        float_mt8 m00, float_mt8 m01, float_mt8 m02, float_mt8 m03,
        float_mt8 m10, float_mt8 m11, float_mt8 m12, float_mt8 m13,
        float_mt8 m20, float_mt8 m21, float_mt8 m22, float_mt8 m23,
        float_mt8 m30, float_mt8 m31, float_mt8 m32, float_mt8 m33
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
        this.c3 = new(m03, m13, m23, m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x4_mt8((
        float_mt8 m00, float_mt8 m01, float_mt8 m02, float_mt8 m03,
        float_mt8 m10, float_mt8 m11, float_mt8 m12, float_mt8 m13,
        float_mt8 m20, float_mt8 m21, float_mt8 m22, float_mt8 m23,
        float_mt8 m30, float_mt8 m31, float_mt8 m32, float_mt8 m33
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float4x4_mt8((
        float_mt8 m00, float_mt8 m01, float_mt8 m02, float_mt8 m03,
        float_mt8 m10, float_mt8 m11, float_mt8 m12, float_mt8 m13,
        float_mt8 m20, float_mt8 m21, float_mt8 m22, float_mt8 m23,
        float_mt8 m30, float_mt8 m31, float_mt8 m32, float_mt8 m33
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23, tuple.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x4_mt8((
        (float_mt8 m00, float_mt8 m01, float_mt8 m02, float_mt8 m03) r0,
        (float_mt8 m10, float_mt8 m11, float_mt8 m12, float_mt8 m13) r1,
        (float_mt8 m20, float_mt8 m21, float_mt8 m22, float_mt8 m23) r2,
        (float_mt8 m30, float_mt8 m31, float_mt8 m32, float_mt8 m33) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float4x4_mt8((
        (float_mt8 m00, float_mt8 m01, float_mt8 m02, float_mt8 m03) r0,
        (float_mt8 m10, float_mt8 m11, float_mt8 m12, float_mt8 m13) r1,
        (float_mt8 m20, float_mt8 m21, float_mt8 m22, float_mt8 m23) r2,
        (float_mt8 m30, float_mt8 m31, float_mt8 m32, float_mt8 m33) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23, tuple.r3.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x4_mt8(float_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float4x4_mt8(float value) => (float_mt8)(value);

    [MethodImpl(256 | 512)]
    public float4x4_mt8(float_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x4_mt8(float4_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public float4x4_mt8(float4_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out float4_mt8 c0, out float4_mt8 c1, out float4_mt8 c2, out float4_mt8 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out float_mt8 m00, out float_mt8 m01, out float_mt8 m02, out float_mt8 m03,
        out float_mt8 m10, out float_mt8 m11, out float_mt8 m12, out float_mt8 m13,
        out float_mt8 m20, out float_mt8 m21, out float_mt8 m22, out float_mt8 m23,
        out float_mt8 m30, out float_mt8 m31, out float_mt8 m32, out float_mt8 m33
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
        this.c3.Deconstruct(out m03, out m13, out m23, out m33);
    }

    #endregion // Deconstruct

    #region Index

    public float4_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public float_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static float4x4_mt8 operator~(float4x4_mt8 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static float4x4_mt8 operator|(float4x4_mt8 a, float4x4_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static float4x4_mt8 operator&(float4x4_mt8 a, float4x4_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static float4x4_mt8 operator^(float4x4_mt8 a, float4x4_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"float4x4_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // float4x4_mt8

#region float4x4_mt16

[CpuOnly]
public partial struct float4x4_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => float_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 4); 
    }

    public static float4x4_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0f, default, default, default,
            default, 1.0f, default, default,
            default, default, 1.0f, default,
            default, default, default, 1.0f
        ); 
    }

    #endregion

    #region Fields

    public float4_mt16 c0;
    public float4_mt16 c1;
    public float4_mt16 c2;
    public float4_mt16 c3;

    #endregion

    #region Properties

    public float_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public float_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public float_mt16 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public float_mt16 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public float_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public float_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public float_mt16 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public float_mt16 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public float_mt16 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public float_mt16 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public float_mt16 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public float_mt16 m23
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }
    public float_mt16 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public float_mt16 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public float_mt16 m32
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }
    public float_mt16 m33
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.w;
        [MethodImpl(256 | 512)]
        set => c3.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly float4x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, float4x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public float4x4_mt16(float4_mt16 c0, float4_mt16 c1, float4_mt16 c2, float4_mt16 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public float4x4_mt16((float4_mt16 c0, float4_mt16 c1, float4_mt16 c2, float4_mt16 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x4_mt16((float4_mt16 c0, float4_mt16 c1, float4_mt16 c2, float4_mt16 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float4x4_mt16(
        float_mt16 m00, float_mt16 m01, float_mt16 m02, float_mt16 m03,
        float_mt16 m10, float_mt16 m11, float_mt16 m12, float_mt16 m13,
        float_mt16 m20, float_mt16 m21, float_mt16 m22, float_mt16 m23,
        float_mt16 m30, float_mt16 m31, float_mt16 m32, float_mt16 m33
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
        this.c3 = new(m03, m13, m23, m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x4_mt16((
        float_mt16 m00, float_mt16 m01, float_mt16 m02, float_mt16 m03,
        float_mt16 m10, float_mt16 m11, float_mt16 m12, float_mt16 m13,
        float_mt16 m20, float_mt16 m21, float_mt16 m22, float_mt16 m23,
        float_mt16 m30, float_mt16 m31, float_mt16 m32, float_mt16 m33
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float4x4_mt16((
        float_mt16 m00, float_mt16 m01, float_mt16 m02, float_mt16 m03,
        float_mt16 m10, float_mt16 m11, float_mt16 m12, float_mt16 m13,
        float_mt16 m20, float_mt16 m21, float_mt16 m22, float_mt16 m23,
        float_mt16 m30, float_mt16 m31, float_mt16 m32, float_mt16 m33
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23, tuple.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x4_mt16((
        (float_mt16 m00, float_mt16 m01, float_mt16 m02, float_mt16 m03) r0,
        (float_mt16 m10, float_mt16 m11, float_mt16 m12, float_mt16 m13) r1,
        (float_mt16 m20, float_mt16 m21, float_mt16 m22, float_mt16 m23) r2,
        (float_mt16 m30, float_mt16 m31, float_mt16 m32, float_mt16 m33) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public float4x4_mt16((
        (float_mt16 m00, float_mt16 m01, float_mt16 m02, float_mt16 m03) r0,
        (float_mt16 m10, float_mt16 m11, float_mt16 m12, float_mt16 m13) r1,
        (float_mt16 m20, float_mt16 m21, float_mt16 m22, float_mt16 m23) r2,
        (float_mt16 m30, float_mt16 m31, float_mt16 m32, float_mt16 m33) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23, tuple.r3.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x4_mt16(float_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator float4x4_mt16(float value) => (float_mt16)(value);

    [MethodImpl(256 | 512)]
    public float4x4_mt16(float_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator float4x4_mt16(float4_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public float4x4_mt16(float4_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out float4_mt16 c0, out float4_mt16 c1, out float4_mt16 c2, out float4_mt16 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out float_mt16 m00, out float_mt16 m01, out float_mt16 m02, out float_mt16 m03,
        out float_mt16 m10, out float_mt16 m11, out float_mt16 m12, out float_mt16 m13,
        out float_mt16 m20, out float_mt16 m21, out float_mt16 m22, out float_mt16 m23,
        out float_mt16 m30, out float_mt16 m31, out float_mt16 m32, out float_mt16 m33
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
        this.c3.Deconstruct(out m03, out m13, out m23, out m33);
    }

    #endregion // Deconstruct

    #region Index

    public float4_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public float_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static float4x4_mt16 operator~(float4x4_mt16 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static float4x4_mt16 operator|(float4x4_mt16 a, float4x4_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static float4x4_mt16 operator&(float4x4_mt16 a, float4x4_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static float4x4_mt16 operator^(float4x4_mt16 a, float4x4_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"float4x4_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // float4x4_mt16

#region double2x2_mt4

[CpuOnly]
public partial struct double2x2_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => double_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 2); 
    }

    public static double2x2_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0, default,
            default, 1.0
        ); 
    }

    #endregion

    #region Fields

    public double2_mt4 c0;
    public double2_mt4 c1;

    #endregion

    #region Properties

    public double_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public double_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public double_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public double_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly double2x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, double2x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public double2x2_mt4(double2_mt4 c0, double2_mt4 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public double2x2_mt4((double2_mt4 c0, double2_mt4 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x2_mt4((double2_mt4 c0, double2_mt4 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double2x2_mt4(
        double_mt4 m00, double_mt4 m01,
        double_mt4 m10, double_mt4 m11
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x2_mt4((
        double_mt4 m00, double_mt4 m01,
        double_mt4 m10, double_mt4 m11
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double2x2_mt4((
        double_mt4 m00, double_mt4 m01,
        double_mt4 m10, double_mt4 m11
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x2_mt4((
        (double_mt4 m00, double_mt4 m01) r0,
        (double_mt4 m10, double_mt4 m11) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double2x2_mt4((
        (double_mt4 m00, double_mt4 m01) r0,
        (double_mt4 m10, double_mt4 m11) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x2_mt4(double_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double2x2_mt4(double value) => (double_mt4)(value);

    [MethodImpl(256 | 512)]
    public double2x2_mt4(double_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x2_mt4(double2_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public double2x2_mt4(double2_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out double2_mt4 c0, out double2_mt4 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out double_mt4 m00, out double_mt4 m01,
        out double_mt4 m10, out double_mt4 m11
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
    }

    #endregion // Deconstruct

    #region Index

    public double2_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public double_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static double2x2_mt4 operator~(double2x2_mt4 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static double2x2_mt4 operator|(double2x2_mt4 a, double2x2_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static double2x2_mt4 operator&(double2x2_mt4 a, double2x2_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static double2x2_mt4 operator^(double2x2_mt4 a, double2x2_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"double2x2_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // double2x2_mt4

#region double2x2_mt8

[CpuOnly]
public partial struct double2x2_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => double_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 2); 
    }

    public static double2x2_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0, default,
            default, 1.0
        ); 
    }

    #endregion

    #region Fields

    public double2_mt8 c0;
    public double2_mt8 c1;

    #endregion

    #region Properties

    public double_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public double_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public double_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public double_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly double2x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, double2x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public double2x2_mt8(double2_mt8 c0, double2_mt8 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public double2x2_mt8((double2_mt8 c0, double2_mt8 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x2_mt8((double2_mt8 c0, double2_mt8 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double2x2_mt8(
        double_mt8 m00, double_mt8 m01,
        double_mt8 m10, double_mt8 m11
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x2_mt8((
        double_mt8 m00, double_mt8 m01,
        double_mt8 m10, double_mt8 m11
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double2x2_mt8((
        double_mt8 m00, double_mt8 m01,
        double_mt8 m10, double_mt8 m11
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x2_mt8((
        (double_mt8 m00, double_mt8 m01) r0,
        (double_mt8 m10, double_mt8 m11) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double2x2_mt8((
        (double_mt8 m00, double_mt8 m01) r0,
        (double_mt8 m10, double_mt8 m11) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x2_mt8(double_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double2x2_mt8(double value) => (double_mt8)(value);

    [MethodImpl(256 | 512)]
    public double2x2_mt8(double_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x2_mt8(double2_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public double2x2_mt8(double2_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out double2_mt8 c0, out double2_mt8 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out double_mt8 m00, out double_mt8 m01,
        out double_mt8 m10, out double_mt8 m11
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
    }

    #endregion // Deconstruct

    #region Index

    public double2_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public double_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static double2x2_mt8 operator~(double2x2_mt8 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static double2x2_mt8 operator|(double2x2_mt8 a, double2x2_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static double2x2_mt8 operator&(double2x2_mt8 a, double2x2_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static double2x2_mt8 operator^(double2x2_mt8 a, double2x2_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"double2x2_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // double2x2_mt8

#region double2x2_mt16

[CpuOnly]
public partial struct double2x2_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => double_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 2); 
    }

    public static double2x2_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0, default,
            default, 1.0
        ); 
    }

    #endregion

    #region Fields

    public double2_mt16 c0;
    public double2_mt16 c1;

    #endregion

    #region Properties

    public double_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public double_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public double_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public double_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly double2x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, double2x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public double2x2_mt16(double2_mt16 c0, double2_mt16 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public double2x2_mt16((double2_mt16 c0, double2_mt16 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x2_mt16((double2_mt16 c0, double2_mt16 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double2x2_mt16(
        double_mt16 m00, double_mt16 m01,
        double_mt16 m10, double_mt16 m11
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x2_mt16((
        double_mt16 m00, double_mt16 m01,
        double_mt16 m10, double_mt16 m11
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double2x2_mt16((
        double_mt16 m00, double_mt16 m01,
        double_mt16 m10, double_mt16 m11
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x2_mt16((
        (double_mt16 m00, double_mt16 m01) r0,
        (double_mt16 m10, double_mt16 m11) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double2x2_mt16((
        (double_mt16 m00, double_mt16 m01) r0,
        (double_mt16 m10, double_mt16 m11) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x2_mt16(double_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double2x2_mt16(double value) => (double_mt16)(value);

    [MethodImpl(256 | 512)]
    public double2x2_mt16(double_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x2_mt16(double2_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public double2x2_mt16(double2_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out double2_mt16 c0, out double2_mt16 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out double_mt16 m00, out double_mt16 m01,
        out double_mt16 m10, out double_mt16 m11
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
    }

    #endregion // Deconstruct

    #region Index

    public double2_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public double_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static double2x2_mt16 operator~(double2x2_mt16 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static double2x2_mt16 operator|(double2x2_mt16 a, double2x2_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static double2x2_mt16 operator&(double2x2_mt16 a, double2x2_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static double2x2_mt16 operator^(double2x2_mt16 a, double2x2_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"double2x2_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // double2x2_mt16

#region double2x3_mt4

[CpuOnly]
public partial struct double2x3_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => double_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 3); 
    }

    public static double2x3_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0, default, default,
            default, 1.0, default
        ); 
    }

    #endregion

    #region Fields

    public double2_mt4 c0;
    public double2_mt4 c1;
    public double2_mt4 c2;

    #endregion

    #region Properties

    public double_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public double_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public double_mt4 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public double_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public double_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public double_mt4 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly double2x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, double2x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public double2x3_mt4(double2_mt4 c0, double2_mt4 c1, double2_mt4 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public double2x3_mt4((double2_mt4 c0, double2_mt4 c1, double2_mt4 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x3_mt4((double2_mt4 c0, double2_mt4 c1, double2_mt4 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double2x3_mt4(
        double_mt4 m00, double_mt4 m01, double_mt4 m02,
        double_mt4 m10, double_mt4 m11, double_mt4 m12
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x3_mt4((
        double_mt4 m00, double_mt4 m01, double_mt4 m02,
        double_mt4 m10, double_mt4 m11, double_mt4 m12
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double2x3_mt4((
        double_mt4 m00, double_mt4 m01, double_mt4 m02,
        double_mt4 m10, double_mt4 m11, double_mt4 m12
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x3_mt4((
        (double_mt4 m00, double_mt4 m01, double_mt4 m02) r0,
        (double_mt4 m10, double_mt4 m11, double_mt4 m12) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double2x3_mt4((
        (double_mt4 m00, double_mt4 m01, double_mt4 m02) r0,
        (double_mt4 m10, double_mt4 m11, double_mt4 m12) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x3_mt4(double_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double2x3_mt4(double value) => (double_mt4)(value);

    [MethodImpl(256 | 512)]
    public double2x3_mt4(double_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x3_mt4(double2_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public double2x3_mt4(double2_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out double2_mt4 c0, out double2_mt4 c1, out double2_mt4 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out double_mt4 m00, out double_mt4 m01, out double_mt4 m02,
        out double_mt4 m10, out double_mt4 m11, out double_mt4 m12
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
    }

    #endregion // Deconstruct

    #region Index

    public double2_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public double_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static double2x3_mt4 operator~(double2x3_mt4 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static double2x3_mt4 operator|(double2x3_mt4 a, double2x3_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static double2x3_mt4 operator&(double2x3_mt4 a, double2x3_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static double2x3_mt4 operator^(double2x3_mt4 a, double2x3_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"double2x3_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // double2x3_mt4

#region double2x3_mt8

[CpuOnly]
public partial struct double2x3_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => double_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 3); 
    }

    public static double2x3_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0, default, default,
            default, 1.0, default
        ); 
    }

    #endregion

    #region Fields

    public double2_mt8 c0;
    public double2_mt8 c1;
    public double2_mt8 c2;

    #endregion

    #region Properties

    public double_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public double_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public double_mt8 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public double_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public double_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public double_mt8 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly double2x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, double2x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public double2x3_mt8(double2_mt8 c0, double2_mt8 c1, double2_mt8 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public double2x3_mt8((double2_mt8 c0, double2_mt8 c1, double2_mt8 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x3_mt8((double2_mt8 c0, double2_mt8 c1, double2_mt8 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double2x3_mt8(
        double_mt8 m00, double_mt8 m01, double_mt8 m02,
        double_mt8 m10, double_mt8 m11, double_mt8 m12
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x3_mt8((
        double_mt8 m00, double_mt8 m01, double_mt8 m02,
        double_mt8 m10, double_mt8 m11, double_mt8 m12
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double2x3_mt8((
        double_mt8 m00, double_mt8 m01, double_mt8 m02,
        double_mt8 m10, double_mt8 m11, double_mt8 m12
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x3_mt8((
        (double_mt8 m00, double_mt8 m01, double_mt8 m02) r0,
        (double_mt8 m10, double_mt8 m11, double_mt8 m12) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double2x3_mt8((
        (double_mt8 m00, double_mt8 m01, double_mt8 m02) r0,
        (double_mt8 m10, double_mt8 m11, double_mt8 m12) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x3_mt8(double_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double2x3_mt8(double value) => (double_mt8)(value);

    [MethodImpl(256 | 512)]
    public double2x3_mt8(double_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x3_mt8(double2_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public double2x3_mt8(double2_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out double2_mt8 c0, out double2_mt8 c1, out double2_mt8 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out double_mt8 m00, out double_mt8 m01, out double_mt8 m02,
        out double_mt8 m10, out double_mt8 m11, out double_mt8 m12
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
    }

    #endregion // Deconstruct

    #region Index

    public double2_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public double_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static double2x3_mt8 operator~(double2x3_mt8 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static double2x3_mt8 operator|(double2x3_mt8 a, double2x3_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static double2x3_mt8 operator&(double2x3_mt8 a, double2x3_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static double2x3_mt8 operator^(double2x3_mt8 a, double2x3_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"double2x3_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // double2x3_mt8

#region double2x3_mt16

[CpuOnly]
public partial struct double2x3_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => double_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 3); 
    }

    public static double2x3_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0, default, default,
            default, 1.0, default
        ); 
    }

    #endregion

    #region Fields

    public double2_mt16 c0;
    public double2_mt16 c1;
    public double2_mt16 c2;

    #endregion

    #region Properties

    public double_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public double_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public double_mt16 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public double_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public double_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public double_mt16 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly double2x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, double2x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public double2x3_mt16(double2_mt16 c0, double2_mt16 c1, double2_mt16 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public double2x3_mt16((double2_mt16 c0, double2_mt16 c1, double2_mt16 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x3_mt16((double2_mt16 c0, double2_mt16 c1, double2_mt16 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double2x3_mt16(
        double_mt16 m00, double_mt16 m01, double_mt16 m02,
        double_mt16 m10, double_mt16 m11, double_mt16 m12
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x3_mt16((
        double_mt16 m00, double_mt16 m01, double_mt16 m02,
        double_mt16 m10, double_mt16 m11, double_mt16 m12
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double2x3_mt16((
        double_mt16 m00, double_mt16 m01, double_mt16 m02,
        double_mt16 m10, double_mt16 m11, double_mt16 m12
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x3_mt16((
        (double_mt16 m00, double_mt16 m01, double_mt16 m02) r0,
        (double_mt16 m10, double_mt16 m11, double_mt16 m12) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double2x3_mt16((
        (double_mt16 m00, double_mt16 m01, double_mt16 m02) r0,
        (double_mt16 m10, double_mt16 m11, double_mt16 m12) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x3_mt16(double_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double2x3_mt16(double value) => (double_mt16)(value);

    [MethodImpl(256 | 512)]
    public double2x3_mt16(double_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x3_mt16(double2_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public double2x3_mt16(double2_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out double2_mt16 c0, out double2_mt16 c1, out double2_mt16 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out double_mt16 m00, out double_mt16 m01, out double_mt16 m02,
        out double_mt16 m10, out double_mt16 m11, out double_mt16 m12
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
    }

    #endregion // Deconstruct

    #region Index

    public double2_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public double_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static double2x3_mt16 operator~(double2x3_mt16 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static double2x3_mt16 operator|(double2x3_mt16 a, double2x3_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static double2x3_mt16 operator&(double2x3_mt16 a, double2x3_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static double2x3_mt16 operator^(double2x3_mt16 a, double2x3_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"double2x3_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // double2x3_mt16

#region double2x4_mt4

[CpuOnly]
public partial struct double2x4_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => double_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 4); 
    }

    public static double2x4_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0, default, default, default,
            default, 1.0, default, default
        ); 
    }

    #endregion

    #region Fields

    public double2_mt4 c0;
    public double2_mt4 c1;
    public double2_mt4 c2;
    public double2_mt4 c3;

    #endregion

    #region Properties

    public double_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public double_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public double_mt4 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public double_mt4 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public double_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public double_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public double_mt4 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public double_mt4 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly double2x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, double2x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public double2x4_mt4(double2_mt4 c0, double2_mt4 c1, double2_mt4 c2, double2_mt4 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public double2x4_mt4((double2_mt4 c0, double2_mt4 c1, double2_mt4 c2, double2_mt4 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x4_mt4((double2_mt4 c0, double2_mt4 c1, double2_mt4 c2, double2_mt4 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double2x4_mt4(
        double_mt4 m00, double_mt4 m01, double_mt4 m02, double_mt4 m03,
        double_mt4 m10, double_mt4 m11, double_mt4 m12, double_mt4 m13
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
        this.c3 = new(m03, m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x4_mt4((
        double_mt4 m00, double_mt4 m01, double_mt4 m02, double_mt4 m03,
        double_mt4 m10, double_mt4 m11, double_mt4 m12, double_mt4 m13
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double2x4_mt4((
        double_mt4 m00, double_mt4 m01, double_mt4 m02, double_mt4 m03,
        double_mt4 m10, double_mt4 m11, double_mt4 m12, double_mt4 m13
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
        this.c3 = new(tuple.m03, tuple.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x4_mt4((
        (double_mt4 m00, double_mt4 m01, double_mt4 m02, double_mt4 m03) r0,
        (double_mt4 m10, double_mt4 m11, double_mt4 m12, double_mt4 m13) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double2x4_mt4((
        (double_mt4 m00, double_mt4 m01, double_mt4 m02, double_mt4 m03) r0,
        (double_mt4 m10, double_mt4 m11, double_mt4 m12, double_mt4 m13) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x4_mt4(double_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double2x4_mt4(double value) => (double_mt4)(value);

    [MethodImpl(256 | 512)]
    public double2x4_mt4(double_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x4_mt4(double2_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public double2x4_mt4(double2_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out double2_mt4 c0, out double2_mt4 c1, out double2_mt4 c2, out double2_mt4 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out double_mt4 m00, out double_mt4 m01, out double_mt4 m02, out double_mt4 m03,
        out double_mt4 m10, out double_mt4 m11, out double_mt4 m12, out double_mt4 m13
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
        this.c3.Deconstruct(out m03, out m13);
    }

    #endregion // Deconstruct

    #region Index

    public double2_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public double_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static double2x4_mt4 operator~(double2x4_mt4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static double2x4_mt4 operator|(double2x4_mt4 a, double2x4_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static double2x4_mt4 operator&(double2x4_mt4 a, double2x4_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static double2x4_mt4 operator^(double2x4_mt4 a, double2x4_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"double2x4_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // double2x4_mt4

#region double2x4_mt8

[CpuOnly]
public partial struct double2x4_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => double_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 4); 
    }

    public static double2x4_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0, default, default, default,
            default, 1.0, default, default
        ); 
    }

    #endregion

    #region Fields

    public double2_mt8 c0;
    public double2_mt8 c1;
    public double2_mt8 c2;
    public double2_mt8 c3;

    #endregion

    #region Properties

    public double_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public double_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public double_mt8 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public double_mt8 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public double_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public double_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public double_mt8 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public double_mt8 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly double2x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, double2x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public double2x4_mt8(double2_mt8 c0, double2_mt8 c1, double2_mt8 c2, double2_mt8 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public double2x4_mt8((double2_mt8 c0, double2_mt8 c1, double2_mt8 c2, double2_mt8 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x4_mt8((double2_mt8 c0, double2_mt8 c1, double2_mt8 c2, double2_mt8 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double2x4_mt8(
        double_mt8 m00, double_mt8 m01, double_mt8 m02, double_mt8 m03,
        double_mt8 m10, double_mt8 m11, double_mt8 m12, double_mt8 m13
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
        this.c3 = new(m03, m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x4_mt8((
        double_mt8 m00, double_mt8 m01, double_mt8 m02, double_mt8 m03,
        double_mt8 m10, double_mt8 m11, double_mt8 m12, double_mt8 m13
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double2x4_mt8((
        double_mt8 m00, double_mt8 m01, double_mt8 m02, double_mt8 m03,
        double_mt8 m10, double_mt8 m11, double_mt8 m12, double_mt8 m13
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
        this.c3 = new(tuple.m03, tuple.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x4_mt8((
        (double_mt8 m00, double_mt8 m01, double_mt8 m02, double_mt8 m03) r0,
        (double_mt8 m10, double_mt8 m11, double_mt8 m12, double_mt8 m13) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double2x4_mt8((
        (double_mt8 m00, double_mt8 m01, double_mt8 m02, double_mt8 m03) r0,
        (double_mt8 m10, double_mt8 m11, double_mt8 m12, double_mt8 m13) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x4_mt8(double_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double2x4_mt8(double value) => (double_mt8)(value);

    [MethodImpl(256 | 512)]
    public double2x4_mt8(double_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x4_mt8(double2_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public double2x4_mt8(double2_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out double2_mt8 c0, out double2_mt8 c1, out double2_mt8 c2, out double2_mt8 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out double_mt8 m00, out double_mt8 m01, out double_mt8 m02, out double_mt8 m03,
        out double_mt8 m10, out double_mt8 m11, out double_mt8 m12, out double_mt8 m13
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
        this.c3.Deconstruct(out m03, out m13);
    }

    #endregion // Deconstruct

    #region Index

    public double2_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public double_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static double2x4_mt8 operator~(double2x4_mt8 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static double2x4_mt8 operator|(double2x4_mt8 a, double2x4_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static double2x4_mt8 operator&(double2x4_mt8 a, double2x4_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static double2x4_mt8 operator^(double2x4_mt8 a, double2x4_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"double2x4_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // double2x4_mt8

#region double2x4_mt16

[CpuOnly]
public partial struct double2x4_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => double_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 4); 
    }

    public static double2x4_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0, default, default, default,
            default, 1.0, default, default
        ); 
    }

    #endregion

    #region Fields

    public double2_mt16 c0;
    public double2_mt16 c1;
    public double2_mt16 c2;
    public double2_mt16 c3;

    #endregion

    #region Properties

    public double_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public double_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public double_mt16 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public double_mt16 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public double_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public double_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public double_mt16 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public double_mt16 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly double2x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, double2x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public double2x4_mt16(double2_mt16 c0, double2_mt16 c1, double2_mt16 c2, double2_mt16 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public double2x4_mt16((double2_mt16 c0, double2_mt16 c1, double2_mt16 c2, double2_mt16 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x4_mt16((double2_mt16 c0, double2_mt16 c1, double2_mt16 c2, double2_mt16 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double2x4_mt16(
        double_mt16 m00, double_mt16 m01, double_mt16 m02, double_mt16 m03,
        double_mt16 m10, double_mt16 m11, double_mt16 m12, double_mt16 m13
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
        this.c3 = new(m03, m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x4_mt16((
        double_mt16 m00, double_mt16 m01, double_mt16 m02, double_mt16 m03,
        double_mt16 m10, double_mt16 m11, double_mt16 m12, double_mt16 m13
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double2x4_mt16((
        double_mt16 m00, double_mt16 m01, double_mt16 m02, double_mt16 m03,
        double_mt16 m10, double_mt16 m11, double_mt16 m12, double_mt16 m13
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
        this.c3 = new(tuple.m03, tuple.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x4_mt16((
        (double_mt16 m00, double_mt16 m01, double_mt16 m02, double_mt16 m03) r0,
        (double_mt16 m10, double_mt16 m11, double_mt16 m12, double_mt16 m13) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double2x4_mt16((
        (double_mt16 m00, double_mt16 m01, double_mt16 m02, double_mt16 m03) r0,
        (double_mt16 m10, double_mt16 m11, double_mt16 m12, double_mt16 m13) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x4_mt16(double_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double2x4_mt16(double value) => (double_mt16)(value);

    [MethodImpl(256 | 512)]
    public double2x4_mt16(double_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double2x4_mt16(double2_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public double2x4_mt16(double2_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out double2_mt16 c0, out double2_mt16 c1, out double2_mt16 c2, out double2_mt16 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out double_mt16 m00, out double_mt16 m01, out double_mt16 m02, out double_mt16 m03,
        out double_mt16 m10, out double_mt16 m11, out double_mt16 m12, out double_mt16 m13
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
        this.c3.Deconstruct(out m03, out m13);
    }

    #endregion // Deconstruct

    #region Index

    public double2_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public double_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static double2x4_mt16 operator~(double2x4_mt16 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static double2x4_mt16 operator|(double2x4_mt16 a, double2x4_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static double2x4_mt16 operator&(double2x4_mt16 a, double2x4_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static double2x4_mt16 operator^(double2x4_mt16 a, double2x4_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"double2x4_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // double2x4_mt16

#region double3x2_mt4

[CpuOnly]
public partial struct double3x2_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => double_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 2); 
    }

    public static double3x2_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0, default,
            default, 1.0,
            default, default
        ); 
    }

    #endregion

    #region Fields

    public double3_mt4 c0;
    public double3_mt4 c1;

    #endregion

    #region Properties

    public double_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public double_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public double_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public double_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public double_mt4 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public double_mt4 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly double3x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, double3x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public double3x2_mt4(double3_mt4 c0, double3_mt4 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public double3x2_mt4((double3_mt4 c0, double3_mt4 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x2_mt4((double3_mt4 c0, double3_mt4 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double3x2_mt4(
        double_mt4 m00, double_mt4 m01,
        double_mt4 m10, double_mt4 m11,
        double_mt4 m20, double_mt4 m21
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x2_mt4((
        double_mt4 m00, double_mt4 m01,
        double_mt4 m10, double_mt4 m11,
        double_mt4 m20, double_mt4 m21
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double3x2_mt4((
        double_mt4 m00, double_mt4 m01,
        double_mt4 m10, double_mt4 m11,
        double_mt4 m20, double_mt4 m21
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x2_mt4((
        (double_mt4 m00, double_mt4 m01) r0,
        (double_mt4 m10, double_mt4 m11) r1,
        (double_mt4 m20, double_mt4 m21) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double3x2_mt4((
        (double_mt4 m00, double_mt4 m01) r0,
        (double_mt4 m10, double_mt4 m11) r1,
        (double_mt4 m20, double_mt4 m21) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x2_mt4(double_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double3x2_mt4(double value) => (double_mt4)(value);

    [MethodImpl(256 | 512)]
    public double3x2_mt4(double_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x2_mt4(double3_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public double3x2_mt4(double3_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out double3_mt4 c0, out double3_mt4 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out double_mt4 m00, out double_mt4 m01,
        out double_mt4 m10, out double_mt4 m11,
        out double_mt4 m20, out double_mt4 m21
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
    }

    #endregion // Deconstruct

    #region Index

    public double3_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public double_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static double3x2_mt4 operator~(double3x2_mt4 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static double3x2_mt4 operator|(double3x2_mt4 a, double3x2_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static double3x2_mt4 operator&(double3x2_mt4 a, double3x2_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static double3x2_mt4 operator^(double3x2_mt4 a, double3x2_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"double3x2_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // double3x2_mt4

#region double3x2_mt8

[CpuOnly]
public partial struct double3x2_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => double_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 2); 
    }

    public static double3x2_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0, default,
            default, 1.0,
            default, default
        ); 
    }

    #endregion

    #region Fields

    public double3_mt8 c0;
    public double3_mt8 c1;

    #endregion

    #region Properties

    public double_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public double_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public double_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public double_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public double_mt8 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public double_mt8 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly double3x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, double3x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public double3x2_mt8(double3_mt8 c0, double3_mt8 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public double3x2_mt8((double3_mt8 c0, double3_mt8 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x2_mt8((double3_mt8 c0, double3_mt8 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double3x2_mt8(
        double_mt8 m00, double_mt8 m01,
        double_mt8 m10, double_mt8 m11,
        double_mt8 m20, double_mt8 m21
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x2_mt8((
        double_mt8 m00, double_mt8 m01,
        double_mt8 m10, double_mt8 m11,
        double_mt8 m20, double_mt8 m21
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double3x2_mt8((
        double_mt8 m00, double_mt8 m01,
        double_mt8 m10, double_mt8 m11,
        double_mt8 m20, double_mt8 m21
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x2_mt8((
        (double_mt8 m00, double_mt8 m01) r0,
        (double_mt8 m10, double_mt8 m11) r1,
        (double_mt8 m20, double_mt8 m21) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double3x2_mt8((
        (double_mt8 m00, double_mt8 m01) r0,
        (double_mt8 m10, double_mt8 m11) r1,
        (double_mt8 m20, double_mt8 m21) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x2_mt8(double_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double3x2_mt8(double value) => (double_mt8)(value);

    [MethodImpl(256 | 512)]
    public double3x2_mt8(double_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x2_mt8(double3_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public double3x2_mt8(double3_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out double3_mt8 c0, out double3_mt8 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out double_mt8 m00, out double_mt8 m01,
        out double_mt8 m10, out double_mt8 m11,
        out double_mt8 m20, out double_mt8 m21
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
    }

    #endregion // Deconstruct

    #region Index

    public double3_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public double_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static double3x2_mt8 operator~(double3x2_mt8 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static double3x2_mt8 operator|(double3x2_mt8 a, double3x2_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static double3x2_mt8 operator&(double3x2_mt8 a, double3x2_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static double3x2_mt8 operator^(double3x2_mt8 a, double3x2_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"double3x2_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // double3x2_mt8

#region double3x2_mt16

[CpuOnly]
public partial struct double3x2_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => double_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 2); 
    }

    public static double3x2_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0, default,
            default, 1.0,
            default, default
        ); 
    }

    #endregion

    #region Fields

    public double3_mt16 c0;
    public double3_mt16 c1;

    #endregion

    #region Properties

    public double_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public double_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public double_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public double_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public double_mt16 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public double_mt16 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly double3x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, double3x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public double3x2_mt16(double3_mt16 c0, double3_mt16 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public double3x2_mt16((double3_mt16 c0, double3_mt16 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x2_mt16((double3_mt16 c0, double3_mt16 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double3x2_mt16(
        double_mt16 m00, double_mt16 m01,
        double_mt16 m10, double_mt16 m11,
        double_mt16 m20, double_mt16 m21
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x2_mt16((
        double_mt16 m00, double_mt16 m01,
        double_mt16 m10, double_mt16 m11,
        double_mt16 m20, double_mt16 m21
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double3x2_mt16((
        double_mt16 m00, double_mt16 m01,
        double_mt16 m10, double_mt16 m11,
        double_mt16 m20, double_mt16 m21
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x2_mt16((
        (double_mt16 m00, double_mt16 m01) r0,
        (double_mt16 m10, double_mt16 m11) r1,
        (double_mt16 m20, double_mt16 m21) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double3x2_mt16((
        (double_mt16 m00, double_mt16 m01) r0,
        (double_mt16 m10, double_mt16 m11) r1,
        (double_mt16 m20, double_mt16 m21) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x2_mt16(double_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double3x2_mt16(double value) => (double_mt16)(value);

    [MethodImpl(256 | 512)]
    public double3x2_mt16(double_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x2_mt16(double3_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public double3x2_mt16(double3_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out double3_mt16 c0, out double3_mt16 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out double_mt16 m00, out double_mt16 m01,
        out double_mt16 m10, out double_mt16 m11,
        out double_mt16 m20, out double_mt16 m21
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
    }

    #endregion // Deconstruct

    #region Index

    public double3_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public double_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static double3x2_mt16 operator~(double3x2_mt16 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static double3x2_mt16 operator|(double3x2_mt16 a, double3x2_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static double3x2_mt16 operator&(double3x2_mt16 a, double3x2_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static double3x2_mt16 operator^(double3x2_mt16 a, double3x2_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"double3x2_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // double3x2_mt16

#region double3x3_mt4

[CpuOnly]
public partial struct double3x3_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => double_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 9; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 3); 
    }

    public static double3x3_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0, default, default,
            default, 1.0, default,
            default, default, 1.0
        ); 
    }

    #endregion

    #region Fields

    public double3_mt4 c0;
    public double3_mt4 c1;
    public double3_mt4 c2;

    #endregion

    #region Properties

    public double_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public double_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public double_mt4 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public double_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public double_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public double_mt4 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public double_mt4 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public double_mt4 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public double_mt4 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly double3x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, double3x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public double3x3_mt4(double3_mt4 c0, double3_mt4 c1, double3_mt4 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public double3x3_mt4((double3_mt4 c0, double3_mt4 c1, double3_mt4 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x3_mt4((double3_mt4 c0, double3_mt4 c1, double3_mt4 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double3x3_mt4(
        double_mt4 m00, double_mt4 m01, double_mt4 m02,
        double_mt4 m10, double_mt4 m11, double_mt4 m12,
        double_mt4 m20, double_mt4 m21, double_mt4 m22
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x3_mt4((
        double_mt4 m00, double_mt4 m01, double_mt4 m02,
        double_mt4 m10, double_mt4 m11, double_mt4 m12,
        double_mt4 m20, double_mt4 m21, double_mt4 m22
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double3x3_mt4((
        double_mt4 m00, double_mt4 m01, double_mt4 m02,
        double_mt4 m10, double_mt4 m11, double_mt4 m12,
        double_mt4 m20, double_mt4 m21, double_mt4 m22
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x3_mt4((
        (double_mt4 m00, double_mt4 m01, double_mt4 m02) r0,
        (double_mt4 m10, double_mt4 m11, double_mt4 m12) r1,
        (double_mt4 m20, double_mt4 m21, double_mt4 m22) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double3x3_mt4((
        (double_mt4 m00, double_mt4 m01, double_mt4 m02) r0,
        (double_mt4 m10, double_mt4 m11, double_mt4 m12) r1,
        (double_mt4 m20, double_mt4 m21, double_mt4 m22) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x3_mt4(double_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double3x3_mt4(double value) => (double_mt4)(value);

    [MethodImpl(256 | 512)]
    public double3x3_mt4(double_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x3_mt4(double3_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public double3x3_mt4(double3_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out double3_mt4 c0, out double3_mt4 c1, out double3_mt4 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out double_mt4 m00, out double_mt4 m01, out double_mt4 m02,
        out double_mt4 m10, out double_mt4 m11, out double_mt4 m12,
        out double_mt4 m20, out double_mt4 m21, out double_mt4 m22
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
    }

    #endregion // Deconstruct

    #region Index

    public double3_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public double_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static double3x3_mt4 operator~(double3x3_mt4 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static double3x3_mt4 operator|(double3x3_mt4 a, double3x3_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static double3x3_mt4 operator&(double3x3_mt4 a, double3x3_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static double3x3_mt4 operator^(double3x3_mt4 a, double3x3_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"double3x3_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // double3x3_mt4

#region double3x3_mt8

[CpuOnly]
public partial struct double3x3_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => double_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 9; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 3); 
    }

    public static double3x3_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0, default, default,
            default, 1.0, default,
            default, default, 1.0
        ); 
    }

    #endregion

    #region Fields

    public double3_mt8 c0;
    public double3_mt8 c1;
    public double3_mt8 c2;

    #endregion

    #region Properties

    public double_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public double_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public double_mt8 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public double_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public double_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public double_mt8 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public double_mt8 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public double_mt8 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public double_mt8 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly double3x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, double3x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public double3x3_mt8(double3_mt8 c0, double3_mt8 c1, double3_mt8 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public double3x3_mt8((double3_mt8 c0, double3_mt8 c1, double3_mt8 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x3_mt8((double3_mt8 c0, double3_mt8 c1, double3_mt8 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double3x3_mt8(
        double_mt8 m00, double_mt8 m01, double_mt8 m02,
        double_mt8 m10, double_mt8 m11, double_mt8 m12,
        double_mt8 m20, double_mt8 m21, double_mt8 m22
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x3_mt8((
        double_mt8 m00, double_mt8 m01, double_mt8 m02,
        double_mt8 m10, double_mt8 m11, double_mt8 m12,
        double_mt8 m20, double_mt8 m21, double_mt8 m22
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double3x3_mt8((
        double_mt8 m00, double_mt8 m01, double_mt8 m02,
        double_mt8 m10, double_mt8 m11, double_mt8 m12,
        double_mt8 m20, double_mt8 m21, double_mt8 m22
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x3_mt8((
        (double_mt8 m00, double_mt8 m01, double_mt8 m02) r0,
        (double_mt8 m10, double_mt8 m11, double_mt8 m12) r1,
        (double_mt8 m20, double_mt8 m21, double_mt8 m22) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double3x3_mt8((
        (double_mt8 m00, double_mt8 m01, double_mt8 m02) r0,
        (double_mt8 m10, double_mt8 m11, double_mt8 m12) r1,
        (double_mt8 m20, double_mt8 m21, double_mt8 m22) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x3_mt8(double_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double3x3_mt8(double value) => (double_mt8)(value);

    [MethodImpl(256 | 512)]
    public double3x3_mt8(double_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x3_mt8(double3_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public double3x3_mt8(double3_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out double3_mt8 c0, out double3_mt8 c1, out double3_mt8 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out double_mt8 m00, out double_mt8 m01, out double_mt8 m02,
        out double_mt8 m10, out double_mt8 m11, out double_mt8 m12,
        out double_mt8 m20, out double_mt8 m21, out double_mt8 m22
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
    }

    #endregion // Deconstruct

    #region Index

    public double3_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public double_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static double3x3_mt8 operator~(double3x3_mt8 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static double3x3_mt8 operator|(double3x3_mt8 a, double3x3_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static double3x3_mt8 operator&(double3x3_mt8 a, double3x3_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static double3x3_mt8 operator^(double3x3_mt8 a, double3x3_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"double3x3_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // double3x3_mt8

#region double3x3_mt16

[CpuOnly]
public partial struct double3x3_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => double_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 9; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 3); 
    }

    public static double3x3_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0, default, default,
            default, 1.0, default,
            default, default, 1.0
        ); 
    }

    #endregion

    #region Fields

    public double3_mt16 c0;
    public double3_mt16 c1;
    public double3_mt16 c2;

    #endregion

    #region Properties

    public double_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public double_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public double_mt16 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public double_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public double_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public double_mt16 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public double_mt16 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public double_mt16 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public double_mt16 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly double3x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, double3x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public double3x3_mt16(double3_mt16 c0, double3_mt16 c1, double3_mt16 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public double3x3_mt16((double3_mt16 c0, double3_mt16 c1, double3_mt16 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x3_mt16((double3_mt16 c0, double3_mt16 c1, double3_mt16 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double3x3_mt16(
        double_mt16 m00, double_mt16 m01, double_mt16 m02,
        double_mt16 m10, double_mt16 m11, double_mt16 m12,
        double_mt16 m20, double_mt16 m21, double_mt16 m22
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x3_mt16((
        double_mt16 m00, double_mt16 m01, double_mt16 m02,
        double_mt16 m10, double_mt16 m11, double_mt16 m12,
        double_mt16 m20, double_mt16 m21, double_mt16 m22
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double3x3_mt16((
        double_mt16 m00, double_mt16 m01, double_mt16 m02,
        double_mt16 m10, double_mt16 m11, double_mt16 m12,
        double_mt16 m20, double_mt16 m21, double_mt16 m22
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x3_mt16((
        (double_mt16 m00, double_mt16 m01, double_mt16 m02) r0,
        (double_mt16 m10, double_mt16 m11, double_mt16 m12) r1,
        (double_mt16 m20, double_mt16 m21, double_mt16 m22) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double3x3_mt16((
        (double_mt16 m00, double_mt16 m01, double_mt16 m02) r0,
        (double_mt16 m10, double_mt16 m11, double_mt16 m12) r1,
        (double_mt16 m20, double_mt16 m21, double_mt16 m22) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x3_mt16(double_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double3x3_mt16(double value) => (double_mt16)(value);

    [MethodImpl(256 | 512)]
    public double3x3_mt16(double_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x3_mt16(double3_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public double3x3_mt16(double3_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out double3_mt16 c0, out double3_mt16 c1, out double3_mt16 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out double_mt16 m00, out double_mt16 m01, out double_mt16 m02,
        out double_mt16 m10, out double_mt16 m11, out double_mt16 m12,
        out double_mt16 m20, out double_mt16 m21, out double_mt16 m22
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
    }

    #endregion // Deconstruct

    #region Index

    public double3_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public double_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static double3x3_mt16 operator~(double3x3_mt16 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static double3x3_mt16 operator|(double3x3_mt16 a, double3x3_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static double3x3_mt16 operator&(double3x3_mt16 a, double3x3_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static double3x3_mt16 operator^(double3x3_mt16 a, double3x3_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"double3x3_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // double3x3_mt16

#region double3x4_mt4

[CpuOnly]
public partial struct double3x4_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => double_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 4); 
    }

    public static double3x4_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0, default, default, default,
            default, 1.0, default, default,
            default, default, 1.0, default
        ); 
    }

    #endregion

    #region Fields

    public double3_mt4 c0;
    public double3_mt4 c1;
    public double3_mt4 c2;
    public double3_mt4 c3;

    #endregion

    #region Properties

    public double_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public double_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public double_mt4 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public double_mt4 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public double_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public double_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public double_mt4 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public double_mt4 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public double_mt4 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public double_mt4 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public double_mt4 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public double_mt4 m23
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly double3x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, double3x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public double3x4_mt4(double3_mt4 c0, double3_mt4 c1, double3_mt4 c2, double3_mt4 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public double3x4_mt4((double3_mt4 c0, double3_mt4 c1, double3_mt4 c2, double3_mt4 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x4_mt4((double3_mt4 c0, double3_mt4 c1, double3_mt4 c2, double3_mt4 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double3x4_mt4(
        double_mt4 m00, double_mt4 m01, double_mt4 m02, double_mt4 m03,
        double_mt4 m10, double_mt4 m11, double_mt4 m12, double_mt4 m13,
        double_mt4 m20, double_mt4 m21, double_mt4 m22, double_mt4 m23
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
        this.c3 = new(m03, m13, m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x4_mt4((
        double_mt4 m00, double_mt4 m01, double_mt4 m02, double_mt4 m03,
        double_mt4 m10, double_mt4 m11, double_mt4 m12, double_mt4 m13,
        double_mt4 m20, double_mt4 m21, double_mt4 m22, double_mt4 m23
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double3x4_mt4((
        double_mt4 m00, double_mt4 m01, double_mt4 m02, double_mt4 m03,
        double_mt4 m10, double_mt4 m11, double_mt4 m12, double_mt4 m13,
        double_mt4 m20, double_mt4 m21, double_mt4 m22, double_mt4 m23
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x4_mt4((
        (double_mt4 m00, double_mt4 m01, double_mt4 m02, double_mt4 m03) r0,
        (double_mt4 m10, double_mt4 m11, double_mt4 m12, double_mt4 m13) r1,
        (double_mt4 m20, double_mt4 m21, double_mt4 m22, double_mt4 m23) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double3x4_mt4((
        (double_mt4 m00, double_mt4 m01, double_mt4 m02, double_mt4 m03) r0,
        (double_mt4 m10, double_mt4 m11, double_mt4 m12, double_mt4 m13) r1,
        (double_mt4 m20, double_mt4 m21, double_mt4 m22, double_mt4 m23) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x4_mt4(double_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double3x4_mt4(double value) => (double_mt4)(value);

    [MethodImpl(256 | 512)]
    public double3x4_mt4(double_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x4_mt4(double3_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public double3x4_mt4(double3_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out double3_mt4 c0, out double3_mt4 c1, out double3_mt4 c2, out double3_mt4 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out double_mt4 m00, out double_mt4 m01, out double_mt4 m02, out double_mt4 m03,
        out double_mt4 m10, out double_mt4 m11, out double_mt4 m12, out double_mt4 m13,
        out double_mt4 m20, out double_mt4 m21, out double_mt4 m22, out double_mt4 m23
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
        this.c3.Deconstruct(out m03, out m13, out m23);
    }

    #endregion // Deconstruct

    #region Index

    public double3_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public double_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static double3x4_mt4 operator~(double3x4_mt4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static double3x4_mt4 operator|(double3x4_mt4 a, double3x4_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static double3x4_mt4 operator&(double3x4_mt4 a, double3x4_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static double3x4_mt4 operator^(double3x4_mt4 a, double3x4_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"double3x4_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // double3x4_mt4

#region double3x4_mt8

[CpuOnly]
public partial struct double3x4_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => double_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 4); 
    }

    public static double3x4_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0, default, default, default,
            default, 1.0, default, default,
            default, default, 1.0, default
        ); 
    }

    #endregion

    #region Fields

    public double3_mt8 c0;
    public double3_mt8 c1;
    public double3_mt8 c2;
    public double3_mt8 c3;

    #endregion

    #region Properties

    public double_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public double_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public double_mt8 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public double_mt8 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public double_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public double_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public double_mt8 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public double_mt8 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public double_mt8 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public double_mt8 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public double_mt8 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public double_mt8 m23
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly double3x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, double3x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public double3x4_mt8(double3_mt8 c0, double3_mt8 c1, double3_mt8 c2, double3_mt8 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public double3x4_mt8((double3_mt8 c0, double3_mt8 c1, double3_mt8 c2, double3_mt8 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x4_mt8((double3_mt8 c0, double3_mt8 c1, double3_mt8 c2, double3_mt8 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double3x4_mt8(
        double_mt8 m00, double_mt8 m01, double_mt8 m02, double_mt8 m03,
        double_mt8 m10, double_mt8 m11, double_mt8 m12, double_mt8 m13,
        double_mt8 m20, double_mt8 m21, double_mt8 m22, double_mt8 m23
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
        this.c3 = new(m03, m13, m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x4_mt8((
        double_mt8 m00, double_mt8 m01, double_mt8 m02, double_mt8 m03,
        double_mt8 m10, double_mt8 m11, double_mt8 m12, double_mt8 m13,
        double_mt8 m20, double_mt8 m21, double_mt8 m22, double_mt8 m23
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double3x4_mt8((
        double_mt8 m00, double_mt8 m01, double_mt8 m02, double_mt8 m03,
        double_mt8 m10, double_mt8 m11, double_mt8 m12, double_mt8 m13,
        double_mt8 m20, double_mt8 m21, double_mt8 m22, double_mt8 m23
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x4_mt8((
        (double_mt8 m00, double_mt8 m01, double_mt8 m02, double_mt8 m03) r0,
        (double_mt8 m10, double_mt8 m11, double_mt8 m12, double_mt8 m13) r1,
        (double_mt8 m20, double_mt8 m21, double_mt8 m22, double_mt8 m23) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double3x4_mt8((
        (double_mt8 m00, double_mt8 m01, double_mt8 m02, double_mt8 m03) r0,
        (double_mt8 m10, double_mt8 m11, double_mt8 m12, double_mt8 m13) r1,
        (double_mt8 m20, double_mt8 m21, double_mt8 m22, double_mt8 m23) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x4_mt8(double_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double3x4_mt8(double value) => (double_mt8)(value);

    [MethodImpl(256 | 512)]
    public double3x4_mt8(double_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x4_mt8(double3_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public double3x4_mt8(double3_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out double3_mt8 c0, out double3_mt8 c1, out double3_mt8 c2, out double3_mt8 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out double_mt8 m00, out double_mt8 m01, out double_mt8 m02, out double_mt8 m03,
        out double_mt8 m10, out double_mt8 m11, out double_mt8 m12, out double_mt8 m13,
        out double_mt8 m20, out double_mt8 m21, out double_mt8 m22, out double_mt8 m23
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
        this.c3.Deconstruct(out m03, out m13, out m23);
    }

    #endregion // Deconstruct

    #region Index

    public double3_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public double_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static double3x4_mt8 operator~(double3x4_mt8 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static double3x4_mt8 operator|(double3x4_mt8 a, double3x4_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static double3x4_mt8 operator&(double3x4_mt8 a, double3x4_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static double3x4_mt8 operator^(double3x4_mt8 a, double3x4_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"double3x4_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // double3x4_mt8

#region double3x4_mt16

[CpuOnly]
public partial struct double3x4_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => double_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 4); 
    }

    public static double3x4_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0, default, default, default,
            default, 1.0, default, default,
            default, default, 1.0, default
        ); 
    }

    #endregion

    #region Fields

    public double3_mt16 c0;
    public double3_mt16 c1;
    public double3_mt16 c2;
    public double3_mt16 c3;

    #endregion

    #region Properties

    public double_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public double_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public double_mt16 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public double_mt16 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public double_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public double_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public double_mt16 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public double_mt16 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public double_mt16 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public double_mt16 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public double_mt16 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public double_mt16 m23
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly double3x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, double3x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public double3x4_mt16(double3_mt16 c0, double3_mt16 c1, double3_mt16 c2, double3_mt16 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public double3x4_mt16((double3_mt16 c0, double3_mt16 c1, double3_mt16 c2, double3_mt16 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x4_mt16((double3_mt16 c0, double3_mt16 c1, double3_mt16 c2, double3_mt16 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double3x4_mt16(
        double_mt16 m00, double_mt16 m01, double_mt16 m02, double_mt16 m03,
        double_mt16 m10, double_mt16 m11, double_mt16 m12, double_mt16 m13,
        double_mt16 m20, double_mt16 m21, double_mt16 m22, double_mt16 m23
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
        this.c3 = new(m03, m13, m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x4_mt16((
        double_mt16 m00, double_mt16 m01, double_mt16 m02, double_mt16 m03,
        double_mt16 m10, double_mt16 m11, double_mt16 m12, double_mt16 m13,
        double_mt16 m20, double_mt16 m21, double_mt16 m22, double_mt16 m23
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double3x4_mt16((
        double_mt16 m00, double_mt16 m01, double_mt16 m02, double_mt16 m03,
        double_mt16 m10, double_mt16 m11, double_mt16 m12, double_mt16 m13,
        double_mt16 m20, double_mt16 m21, double_mt16 m22, double_mt16 m23
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x4_mt16((
        (double_mt16 m00, double_mt16 m01, double_mt16 m02, double_mt16 m03) r0,
        (double_mt16 m10, double_mt16 m11, double_mt16 m12, double_mt16 m13) r1,
        (double_mt16 m20, double_mt16 m21, double_mt16 m22, double_mt16 m23) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double3x4_mt16((
        (double_mt16 m00, double_mt16 m01, double_mt16 m02, double_mt16 m03) r0,
        (double_mt16 m10, double_mt16 m11, double_mt16 m12, double_mt16 m13) r1,
        (double_mt16 m20, double_mt16 m21, double_mt16 m22, double_mt16 m23) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x4_mt16(double_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double3x4_mt16(double value) => (double_mt16)(value);

    [MethodImpl(256 | 512)]
    public double3x4_mt16(double_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double3x4_mt16(double3_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public double3x4_mt16(double3_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out double3_mt16 c0, out double3_mt16 c1, out double3_mt16 c2, out double3_mt16 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out double_mt16 m00, out double_mt16 m01, out double_mt16 m02, out double_mt16 m03,
        out double_mt16 m10, out double_mt16 m11, out double_mt16 m12, out double_mt16 m13,
        out double_mt16 m20, out double_mt16 m21, out double_mt16 m22, out double_mt16 m23
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
        this.c3.Deconstruct(out m03, out m13, out m23);
    }

    #endregion // Deconstruct

    #region Index

    public double3_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public double_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static double3x4_mt16 operator~(double3x4_mt16 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static double3x4_mt16 operator|(double3x4_mt16 a, double3x4_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static double3x4_mt16 operator&(double3x4_mt16 a, double3x4_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static double3x4_mt16 operator^(double3x4_mt16 a, double3x4_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"double3x4_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // double3x4_mt16

#region double4x2_mt4

[CpuOnly]
public partial struct double4x2_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => double_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 2); 
    }

    public static double4x2_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0, default,
            default, 1.0,
            default, default,
            default, default
        ); 
    }

    #endregion

    #region Fields

    public double4_mt4 c0;
    public double4_mt4 c1;

    #endregion

    #region Properties

    public double_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public double_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public double_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public double_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public double_mt4 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public double_mt4 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public double_mt4 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public double_mt4 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly double4x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, double4x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public double4x2_mt4(double4_mt4 c0, double4_mt4 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public double4x2_mt4((double4_mt4 c0, double4_mt4 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x2_mt4((double4_mt4 c0, double4_mt4 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double4x2_mt4(
        double_mt4 m00, double_mt4 m01,
        double_mt4 m10, double_mt4 m11,
        double_mt4 m20, double_mt4 m21,
        double_mt4 m30, double_mt4 m31
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x2_mt4((
        double_mt4 m00, double_mt4 m01,
        double_mt4 m10, double_mt4 m11,
        double_mt4 m20, double_mt4 m21,
        double_mt4 m30, double_mt4 m31
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double4x2_mt4((
        double_mt4 m00, double_mt4 m01,
        double_mt4 m10, double_mt4 m11,
        double_mt4 m20, double_mt4 m21,
        double_mt4 m30, double_mt4 m31
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x2_mt4((
        (double_mt4 m00, double_mt4 m01) r0,
        (double_mt4 m10, double_mt4 m11) r1,
        (double_mt4 m20, double_mt4 m21) r2,
        (double_mt4 m30, double_mt4 m31) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double4x2_mt4((
        (double_mt4 m00, double_mt4 m01) r0,
        (double_mt4 m10, double_mt4 m11) r1,
        (double_mt4 m20, double_mt4 m21) r2,
        (double_mt4 m30, double_mt4 m31) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x2_mt4(double_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double4x2_mt4(double value) => (double_mt4)(value);

    [MethodImpl(256 | 512)]
    public double4x2_mt4(double_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x2_mt4(double4_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public double4x2_mt4(double4_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out double4_mt4 c0, out double4_mt4 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out double_mt4 m00, out double_mt4 m01,
        out double_mt4 m10, out double_mt4 m11,
        out double_mt4 m20, out double_mt4 m21,
        out double_mt4 m30, out double_mt4 m31
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
    }

    #endregion // Deconstruct

    #region Index

    public double4_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public double_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static double4x2_mt4 operator~(double4x2_mt4 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static double4x2_mt4 operator|(double4x2_mt4 a, double4x2_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static double4x2_mt4 operator&(double4x2_mt4 a, double4x2_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static double4x2_mt4 operator^(double4x2_mt4 a, double4x2_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"double4x2_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // double4x2_mt4

#region double4x2_mt8

[CpuOnly]
public partial struct double4x2_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => double_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 2); 
    }

    public static double4x2_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0, default,
            default, 1.0,
            default, default,
            default, default
        ); 
    }

    #endregion

    #region Fields

    public double4_mt8 c0;
    public double4_mt8 c1;

    #endregion

    #region Properties

    public double_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public double_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public double_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public double_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public double_mt8 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public double_mt8 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public double_mt8 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public double_mt8 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly double4x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, double4x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public double4x2_mt8(double4_mt8 c0, double4_mt8 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public double4x2_mt8((double4_mt8 c0, double4_mt8 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x2_mt8((double4_mt8 c0, double4_mt8 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double4x2_mt8(
        double_mt8 m00, double_mt8 m01,
        double_mt8 m10, double_mt8 m11,
        double_mt8 m20, double_mt8 m21,
        double_mt8 m30, double_mt8 m31
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x2_mt8((
        double_mt8 m00, double_mt8 m01,
        double_mt8 m10, double_mt8 m11,
        double_mt8 m20, double_mt8 m21,
        double_mt8 m30, double_mt8 m31
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double4x2_mt8((
        double_mt8 m00, double_mt8 m01,
        double_mt8 m10, double_mt8 m11,
        double_mt8 m20, double_mt8 m21,
        double_mt8 m30, double_mt8 m31
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x2_mt8((
        (double_mt8 m00, double_mt8 m01) r0,
        (double_mt8 m10, double_mt8 m11) r1,
        (double_mt8 m20, double_mt8 m21) r2,
        (double_mt8 m30, double_mt8 m31) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double4x2_mt8((
        (double_mt8 m00, double_mt8 m01) r0,
        (double_mt8 m10, double_mt8 m11) r1,
        (double_mt8 m20, double_mt8 m21) r2,
        (double_mt8 m30, double_mt8 m31) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x2_mt8(double_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double4x2_mt8(double value) => (double_mt8)(value);

    [MethodImpl(256 | 512)]
    public double4x2_mt8(double_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x2_mt8(double4_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public double4x2_mt8(double4_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out double4_mt8 c0, out double4_mt8 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out double_mt8 m00, out double_mt8 m01,
        out double_mt8 m10, out double_mt8 m11,
        out double_mt8 m20, out double_mt8 m21,
        out double_mt8 m30, out double_mt8 m31
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
    }

    #endregion // Deconstruct

    #region Index

    public double4_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public double_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static double4x2_mt8 operator~(double4x2_mt8 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static double4x2_mt8 operator|(double4x2_mt8 a, double4x2_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static double4x2_mt8 operator&(double4x2_mt8 a, double4x2_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static double4x2_mt8 operator^(double4x2_mt8 a, double4x2_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"double4x2_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // double4x2_mt8

#region double4x2_mt16

[CpuOnly]
public partial struct double4x2_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => double_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 2); 
    }

    public static double4x2_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0, default,
            default, 1.0,
            default, default,
            default, default
        ); 
    }

    #endregion

    #region Fields

    public double4_mt16 c0;
    public double4_mt16 c1;

    #endregion

    #region Properties

    public double_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public double_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public double_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public double_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public double_mt16 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public double_mt16 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public double_mt16 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public double_mt16 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly double4x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, double4x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public double4x2_mt16(double4_mt16 c0, double4_mt16 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public double4x2_mt16((double4_mt16 c0, double4_mt16 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x2_mt16((double4_mt16 c0, double4_mt16 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double4x2_mt16(
        double_mt16 m00, double_mt16 m01,
        double_mt16 m10, double_mt16 m11,
        double_mt16 m20, double_mt16 m21,
        double_mt16 m30, double_mt16 m31
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x2_mt16((
        double_mt16 m00, double_mt16 m01,
        double_mt16 m10, double_mt16 m11,
        double_mt16 m20, double_mt16 m21,
        double_mt16 m30, double_mt16 m31
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double4x2_mt16((
        double_mt16 m00, double_mt16 m01,
        double_mt16 m10, double_mt16 m11,
        double_mt16 m20, double_mt16 m21,
        double_mt16 m30, double_mt16 m31
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x2_mt16((
        (double_mt16 m00, double_mt16 m01) r0,
        (double_mt16 m10, double_mt16 m11) r1,
        (double_mt16 m20, double_mt16 m21) r2,
        (double_mt16 m30, double_mt16 m31) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double4x2_mt16((
        (double_mt16 m00, double_mt16 m01) r0,
        (double_mt16 m10, double_mt16 m11) r1,
        (double_mt16 m20, double_mt16 m21) r2,
        (double_mt16 m30, double_mt16 m31) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x2_mt16(double_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double4x2_mt16(double value) => (double_mt16)(value);

    [MethodImpl(256 | 512)]
    public double4x2_mt16(double_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x2_mt16(double4_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public double4x2_mt16(double4_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out double4_mt16 c0, out double4_mt16 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out double_mt16 m00, out double_mt16 m01,
        out double_mt16 m10, out double_mt16 m11,
        out double_mt16 m20, out double_mt16 m21,
        out double_mt16 m30, out double_mt16 m31
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
    }

    #endregion // Deconstruct

    #region Index

    public double4_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public double_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static double4x2_mt16 operator~(double4x2_mt16 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static double4x2_mt16 operator|(double4x2_mt16 a, double4x2_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static double4x2_mt16 operator&(double4x2_mt16 a, double4x2_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static double4x2_mt16 operator^(double4x2_mt16 a, double4x2_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"double4x2_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // double4x2_mt16

#region double4x3_mt4

[CpuOnly]
public partial struct double4x3_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => double_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 3); 
    }

    public static double4x3_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0, default, default,
            default, 1.0, default,
            default, default, 1.0,
            default, default, default
        ); 
    }

    #endregion

    #region Fields

    public double4_mt4 c0;
    public double4_mt4 c1;
    public double4_mt4 c2;

    #endregion

    #region Properties

    public double_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public double_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public double_mt4 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public double_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public double_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public double_mt4 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public double_mt4 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public double_mt4 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public double_mt4 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public double_mt4 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public double_mt4 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public double_mt4 m32
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly double4x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, double4x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public double4x3_mt4(double4_mt4 c0, double4_mt4 c1, double4_mt4 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public double4x3_mt4((double4_mt4 c0, double4_mt4 c1, double4_mt4 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x3_mt4((double4_mt4 c0, double4_mt4 c1, double4_mt4 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double4x3_mt4(
        double_mt4 m00, double_mt4 m01, double_mt4 m02,
        double_mt4 m10, double_mt4 m11, double_mt4 m12,
        double_mt4 m20, double_mt4 m21, double_mt4 m22,
        double_mt4 m30, double_mt4 m31, double_mt4 m32
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x3_mt4((
        double_mt4 m00, double_mt4 m01, double_mt4 m02,
        double_mt4 m10, double_mt4 m11, double_mt4 m12,
        double_mt4 m20, double_mt4 m21, double_mt4 m22,
        double_mt4 m30, double_mt4 m31, double_mt4 m32
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double4x3_mt4((
        double_mt4 m00, double_mt4 m01, double_mt4 m02,
        double_mt4 m10, double_mt4 m11, double_mt4 m12,
        double_mt4 m20, double_mt4 m21, double_mt4 m22,
        double_mt4 m30, double_mt4 m31, double_mt4 m32
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x3_mt4((
        (double_mt4 m00, double_mt4 m01, double_mt4 m02) r0,
        (double_mt4 m10, double_mt4 m11, double_mt4 m12) r1,
        (double_mt4 m20, double_mt4 m21, double_mt4 m22) r2,
        (double_mt4 m30, double_mt4 m31, double_mt4 m32) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double4x3_mt4((
        (double_mt4 m00, double_mt4 m01, double_mt4 m02) r0,
        (double_mt4 m10, double_mt4 m11, double_mt4 m12) r1,
        (double_mt4 m20, double_mt4 m21, double_mt4 m22) r2,
        (double_mt4 m30, double_mt4 m31, double_mt4 m32) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x3_mt4(double_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double4x3_mt4(double value) => (double_mt4)(value);

    [MethodImpl(256 | 512)]
    public double4x3_mt4(double_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x3_mt4(double4_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public double4x3_mt4(double4_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out double4_mt4 c0, out double4_mt4 c1, out double4_mt4 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out double_mt4 m00, out double_mt4 m01, out double_mt4 m02,
        out double_mt4 m10, out double_mt4 m11, out double_mt4 m12,
        out double_mt4 m20, out double_mt4 m21, out double_mt4 m22,
        out double_mt4 m30, out double_mt4 m31, out double_mt4 m32
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
    }

    #endregion // Deconstruct

    #region Index

    public double4_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public double_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static double4x3_mt4 operator~(double4x3_mt4 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static double4x3_mt4 operator|(double4x3_mt4 a, double4x3_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static double4x3_mt4 operator&(double4x3_mt4 a, double4x3_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static double4x3_mt4 operator^(double4x3_mt4 a, double4x3_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"double4x3_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // double4x3_mt4

#region double4x3_mt8

[CpuOnly]
public partial struct double4x3_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => double_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 3); 
    }

    public static double4x3_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0, default, default,
            default, 1.0, default,
            default, default, 1.0,
            default, default, default
        ); 
    }

    #endregion

    #region Fields

    public double4_mt8 c0;
    public double4_mt8 c1;
    public double4_mt8 c2;

    #endregion

    #region Properties

    public double_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public double_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public double_mt8 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public double_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public double_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public double_mt8 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public double_mt8 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public double_mt8 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public double_mt8 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public double_mt8 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public double_mt8 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public double_mt8 m32
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly double4x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, double4x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public double4x3_mt8(double4_mt8 c0, double4_mt8 c1, double4_mt8 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public double4x3_mt8((double4_mt8 c0, double4_mt8 c1, double4_mt8 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x3_mt8((double4_mt8 c0, double4_mt8 c1, double4_mt8 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double4x3_mt8(
        double_mt8 m00, double_mt8 m01, double_mt8 m02,
        double_mt8 m10, double_mt8 m11, double_mt8 m12,
        double_mt8 m20, double_mt8 m21, double_mt8 m22,
        double_mt8 m30, double_mt8 m31, double_mt8 m32
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x3_mt8((
        double_mt8 m00, double_mt8 m01, double_mt8 m02,
        double_mt8 m10, double_mt8 m11, double_mt8 m12,
        double_mt8 m20, double_mt8 m21, double_mt8 m22,
        double_mt8 m30, double_mt8 m31, double_mt8 m32
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double4x3_mt8((
        double_mt8 m00, double_mt8 m01, double_mt8 m02,
        double_mt8 m10, double_mt8 m11, double_mt8 m12,
        double_mt8 m20, double_mt8 m21, double_mt8 m22,
        double_mt8 m30, double_mt8 m31, double_mt8 m32
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x3_mt8((
        (double_mt8 m00, double_mt8 m01, double_mt8 m02) r0,
        (double_mt8 m10, double_mt8 m11, double_mt8 m12) r1,
        (double_mt8 m20, double_mt8 m21, double_mt8 m22) r2,
        (double_mt8 m30, double_mt8 m31, double_mt8 m32) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double4x3_mt8((
        (double_mt8 m00, double_mt8 m01, double_mt8 m02) r0,
        (double_mt8 m10, double_mt8 m11, double_mt8 m12) r1,
        (double_mt8 m20, double_mt8 m21, double_mt8 m22) r2,
        (double_mt8 m30, double_mt8 m31, double_mt8 m32) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x3_mt8(double_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double4x3_mt8(double value) => (double_mt8)(value);

    [MethodImpl(256 | 512)]
    public double4x3_mt8(double_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x3_mt8(double4_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public double4x3_mt8(double4_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out double4_mt8 c0, out double4_mt8 c1, out double4_mt8 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out double_mt8 m00, out double_mt8 m01, out double_mt8 m02,
        out double_mt8 m10, out double_mt8 m11, out double_mt8 m12,
        out double_mt8 m20, out double_mt8 m21, out double_mt8 m22,
        out double_mt8 m30, out double_mt8 m31, out double_mt8 m32
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
    }

    #endregion // Deconstruct

    #region Index

    public double4_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public double_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static double4x3_mt8 operator~(double4x3_mt8 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static double4x3_mt8 operator|(double4x3_mt8 a, double4x3_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static double4x3_mt8 operator&(double4x3_mt8 a, double4x3_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static double4x3_mt8 operator^(double4x3_mt8 a, double4x3_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"double4x3_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // double4x3_mt8

#region double4x3_mt16

[CpuOnly]
public partial struct double4x3_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => double_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 3); 
    }

    public static double4x3_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0, default, default,
            default, 1.0, default,
            default, default, 1.0,
            default, default, default
        ); 
    }

    #endregion

    #region Fields

    public double4_mt16 c0;
    public double4_mt16 c1;
    public double4_mt16 c2;

    #endregion

    #region Properties

    public double_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public double_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public double_mt16 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public double_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public double_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public double_mt16 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public double_mt16 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public double_mt16 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public double_mt16 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public double_mt16 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public double_mt16 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public double_mt16 m32
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly double4x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, double4x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public double4x3_mt16(double4_mt16 c0, double4_mt16 c1, double4_mt16 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public double4x3_mt16((double4_mt16 c0, double4_mt16 c1, double4_mt16 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x3_mt16((double4_mt16 c0, double4_mt16 c1, double4_mt16 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double4x3_mt16(
        double_mt16 m00, double_mt16 m01, double_mt16 m02,
        double_mt16 m10, double_mt16 m11, double_mt16 m12,
        double_mt16 m20, double_mt16 m21, double_mt16 m22,
        double_mt16 m30, double_mt16 m31, double_mt16 m32
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x3_mt16((
        double_mt16 m00, double_mt16 m01, double_mt16 m02,
        double_mt16 m10, double_mt16 m11, double_mt16 m12,
        double_mt16 m20, double_mt16 m21, double_mt16 m22,
        double_mt16 m30, double_mt16 m31, double_mt16 m32
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double4x3_mt16((
        double_mt16 m00, double_mt16 m01, double_mt16 m02,
        double_mt16 m10, double_mt16 m11, double_mt16 m12,
        double_mt16 m20, double_mt16 m21, double_mt16 m22,
        double_mt16 m30, double_mt16 m31, double_mt16 m32
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x3_mt16((
        (double_mt16 m00, double_mt16 m01, double_mt16 m02) r0,
        (double_mt16 m10, double_mt16 m11, double_mt16 m12) r1,
        (double_mt16 m20, double_mt16 m21, double_mt16 m22) r2,
        (double_mt16 m30, double_mt16 m31, double_mt16 m32) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double4x3_mt16((
        (double_mt16 m00, double_mt16 m01, double_mt16 m02) r0,
        (double_mt16 m10, double_mt16 m11, double_mt16 m12) r1,
        (double_mt16 m20, double_mt16 m21, double_mt16 m22) r2,
        (double_mt16 m30, double_mt16 m31, double_mt16 m32) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x3_mt16(double_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double4x3_mt16(double value) => (double_mt16)(value);

    [MethodImpl(256 | 512)]
    public double4x3_mt16(double_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x3_mt16(double4_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public double4x3_mt16(double4_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out double4_mt16 c0, out double4_mt16 c1, out double4_mt16 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out double_mt16 m00, out double_mt16 m01, out double_mt16 m02,
        out double_mt16 m10, out double_mt16 m11, out double_mt16 m12,
        out double_mt16 m20, out double_mt16 m21, out double_mt16 m22,
        out double_mt16 m30, out double_mt16 m31, out double_mt16 m32
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
    }

    #endregion // Deconstruct

    #region Index

    public double4_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public double_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static double4x3_mt16 operator~(double4x3_mt16 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static double4x3_mt16 operator|(double4x3_mt16 a, double4x3_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static double4x3_mt16 operator&(double4x3_mt16 a, double4x3_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static double4x3_mt16 operator^(double4x3_mt16 a, double4x3_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"double4x3_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // double4x3_mt16

#region double4x4_mt4

[CpuOnly]
public partial struct double4x4_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => double_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 4); 
    }

    public static double4x4_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0, default, default, default,
            default, 1.0, default, default,
            default, default, 1.0, default,
            default, default, default, 1.0
        ); 
    }

    #endregion

    #region Fields

    public double4_mt4 c0;
    public double4_mt4 c1;
    public double4_mt4 c2;
    public double4_mt4 c3;

    #endregion

    #region Properties

    public double_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public double_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public double_mt4 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public double_mt4 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public double_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public double_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public double_mt4 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public double_mt4 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public double_mt4 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public double_mt4 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public double_mt4 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public double_mt4 m23
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }
    public double_mt4 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public double_mt4 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public double_mt4 m32
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }
    public double_mt4 m33
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.w;
        [MethodImpl(256 | 512)]
        set => c3.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly double4x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, double4x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public double4x4_mt4(double4_mt4 c0, double4_mt4 c1, double4_mt4 c2, double4_mt4 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public double4x4_mt4((double4_mt4 c0, double4_mt4 c1, double4_mt4 c2, double4_mt4 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x4_mt4((double4_mt4 c0, double4_mt4 c1, double4_mt4 c2, double4_mt4 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double4x4_mt4(
        double_mt4 m00, double_mt4 m01, double_mt4 m02, double_mt4 m03,
        double_mt4 m10, double_mt4 m11, double_mt4 m12, double_mt4 m13,
        double_mt4 m20, double_mt4 m21, double_mt4 m22, double_mt4 m23,
        double_mt4 m30, double_mt4 m31, double_mt4 m32, double_mt4 m33
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
        this.c3 = new(m03, m13, m23, m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x4_mt4((
        double_mt4 m00, double_mt4 m01, double_mt4 m02, double_mt4 m03,
        double_mt4 m10, double_mt4 m11, double_mt4 m12, double_mt4 m13,
        double_mt4 m20, double_mt4 m21, double_mt4 m22, double_mt4 m23,
        double_mt4 m30, double_mt4 m31, double_mt4 m32, double_mt4 m33
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double4x4_mt4((
        double_mt4 m00, double_mt4 m01, double_mt4 m02, double_mt4 m03,
        double_mt4 m10, double_mt4 m11, double_mt4 m12, double_mt4 m13,
        double_mt4 m20, double_mt4 m21, double_mt4 m22, double_mt4 m23,
        double_mt4 m30, double_mt4 m31, double_mt4 m32, double_mt4 m33
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23, tuple.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x4_mt4((
        (double_mt4 m00, double_mt4 m01, double_mt4 m02, double_mt4 m03) r0,
        (double_mt4 m10, double_mt4 m11, double_mt4 m12, double_mt4 m13) r1,
        (double_mt4 m20, double_mt4 m21, double_mt4 m22, double_mt4 m23) r2,
        (double_mt4 m30, double_mt4 m31, double_mt4 m32, double_mt4 m33) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double4x4_mt4((
        (double_mt4 m00, double_mt4 m01, double_mt4 m02, double_mt4 m03) r0,
        (double_mt4 m10, double_mt4 m11, double_mt4 m12, double_mt4 m13) r1,
        (double_mt4 m20, double_mt4 m21, double_mt4 m22, double_mt4 m23) r2,
        (double_mt4 m30, double_mt4 m31, double_mt4 m32, double_mt4 m33) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23, tuple.r3.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x4_mt4(double_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double4x4_mt4(double value) => (double_mt4)(value);

    [MethodImpl(256 | 512)]
    public double4x4_mt4(double_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x4_mt4(double4_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public double4x4_mt4(double4_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out double4_mt4 c0, out double4_mt4 c1, out double4_mt4 c2, out double4_mt4 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out double_mt4 m00, out double_mt4 m01, out double_mt4 m02, out double_mt4 m03,
        out double_mt4 m10, out double_mt4 m11, out double_mt4 m12, out double_mt4 m13,
        out double_mt4 m20, out double_mt4 m21, out double_mt4 m22, out double_mt4 m23,
        out double_mt4 m30, out double_mt4 m31, out double_mt4 m32, out double_mt4 m33
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
        this.c3.Deconstruct(out m03, out m13, out m23, out m33);
    }

    #endregion // Deconstruct

    #region Index

    public double4_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public double_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static double4x4_mt4 operator~(double4x4_mt4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static double4x4_mt4 operator|(double4x4_mt4 a, double4x4_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static double4x4_mt4 operator&(double4x4_mt4 a, double4x4_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static double4x4_mt4 operator^(double4x4_mt4 a, double4x4_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"double4x4_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // double4x4_mt4

#region double4x4_mt8

[CpuOnly]
public partial struct double4x4_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => double_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 4); 
    }

    public static double4x4_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0, default, default, default,
            default, 1.0, default, default,
            default, default, 1.0, default,
            default, default, default, 1.0
        ); 
    }

    #endregion

    #region Fields

    public double4_mt8 c0;
    public double4_mt8 c1;
    public double4_mt8 c2;
    public double4_mt8 c3;

    #endregion

    #region Properties

    public double_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public double_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public double_mt8 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public double_mt8 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public double_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public double_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public double_mt8 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public double_mt8 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public double_mt8 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public double_mt8 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public double_mt8 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public double_mt8 m23
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }
    public double_mt8 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public double_mt8 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public double_mt8 m32
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }
    public double_mt8 m33
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.w;
        [MethodImpl(256 | 512)]
        set => c3.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly double4x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, double4x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public double4x4_mt8(double4_mt8 c0, double4_mt8 c1, double4_mt8 c2, double4_mt8 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public double4x4_mt8((double4_mt8 c0, double4_mt8 c1, double4_mt8 c2, double4_mt8 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x4_mt8((double4_mt8 c0, double4_mt8 c1, double4_mt8 c2, double4_mt8 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double4x4_mt8(
        double_mt8 m00, double_mt8 m01, double_mt8 m02, double_mt8 m03,
        double_mt8 m10, double_mt8 m11, double_mt8 m12, double_mt8 m13,
        double_mt8 m20, double_mt8 m21, double_mt8 m22, double_mt8 m23,
        double_mt8 m30, double_mt8 m31, double_mt8 m32, double_mt8 m33
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
        this.c3 = new(m03, m13, m23, m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x4_mt8((
        double_mt8 m00, double_mt8 m01, double_mt8 m02, double_mt8 m03,
        double_mt8 m10, double_mt8 m11, double_mt8 m12, double_mt8 m13,
        double_mt8 m20, double_mt8 m21, double_mt8 m22, double_mt8 m23,
        double_mt8 m30, double_mt8 m31, double_mt8 m32, double_mt8 m33
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double4x4_mt8((
        double_mt8 m00, double_mt8 m01, double_mt8 m02, double_mt8 m03,
        double_mt8 m10, double_mt8 m11, double_mt8 m12, double_mt8 m13,
        double_mt8 m20, double_mt8 m21, double_mt8 m22, double_mt8 m23,
        double_mt8 m30, double_mt8 m31, double_mt8 m32, double_mt8 m33
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23, tuple.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x4_mt8((
        (double_mt8 m00, double_mt8 m01, double_mt8 m02, double_mt8 m03) r0,
        (double_mt8 m10, double_mt8 m11, double_mt8 m12, double_mt8 m13) r1,
        (double_mt8 m20, double_mt8 m21, double_mt8 m22, double_mt8 m23) r2,
        (double_mt8 m30, double_mt8 m31, double_mt8 m32, double_mt8 m33) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double4x4_mt8((
        (double_mt8 m00, double_mt8 m01, double_mt8 m02, double_mt8 m03) r0,
        (double_mt8 m10, double_mt8 m11, double_mt8 m12, double_mt8 m13) r1,
        (double_mt8 m20, double_mt8 m21, double_mt8 m22, double_mt8 m23) r2,
        (double_mt8 m30, double_mt8 m31, double_mt8 m32, double_mt8 m33) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23, tuple.r3.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x4_mt8(double_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double4x4_mt8(double value) => (double_mt8)(value);

    [MethodImpl(256 | 512)]
    public double4x4_mt8(double_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x4_mt8(double4_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public double4x4_mt8(double4_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out double4_mt8 c0, out double4_mt8 c1, out double4_mt8 c2, out double4_mt8 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out double_mt8 m00, out double_mt8 m01, out double_mt8 m02, out double_mt8 m03,
        out double_mt8 m10, out double_mt8 m11, out double_mt8 m12, out double_mt8 m13,
        out double_mt8 m20, out double_mt8 m21, out double_mt8 m22, out double_mt8 m23,
        out double_mt8 m30, out double_mt8 m31, out double_mt8 m32, out double_mt8 m33
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
        this.c3.Deconstruct(out m03, out m13, out m23, out m33);
    }

    #endregion // Deconstruct

    #region Index

    public double4_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public double_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static double4x4_mt8 operator~(double4x4_mt8 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static double4x4_mt8 operator|(double4x4_mt8 a, double4x4_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static double4x4_mt8 operator&(double4x4_mt8 a, double4x4_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static double4x4_mt8 operator^(double4x4_mt8 a, double4x4_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"double4x4_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // double4x4_mt8

#region double4x4_mt16

[CpuOnly]
public partial struct double4x4_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => double_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 4); 
    }

    public static double4x4_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1.0, default, default, default,
            default, 1.0, default, default,
            default, default, 1.0, default,
            default, default, default, 1.0
        ); 
    }

    #endregion

    #region Fields

    public double4_mt16 c0;
    public double4_mt16 c1;
    public double4_mt16 c2;
    public double4_mt16 c3;

    #endregion

    #region Properties

    public double_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public double_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public double_mt16 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public double_mt16 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public double_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public double_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public double_mt16 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public double_mt16 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public double_mt16 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public double_mt16 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public double_mt16 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public double_mt16 m23
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }
    public double_mt16 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public double_mt16 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public double_mt16 m32
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }
    public double_mt16 m33
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.w;
        [MethodImpl(256 | 512)]
        set => c3.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly double4x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, double4x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public double4x4_mt16(double4_mt16 c0, double4_mt16 c1, double4_mt16 c2, double4_mt16 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public double4x4_mt16((double4_mt16 c0, double4_mt16 c1, double4_mt16 c2, double4_mt16 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x4_mt16((double4_mt16 c0, double4_mt16 c1, double4_mt16 c2, double4_mt16 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double4x4_mt16(
        double_mt16 m00, double_mt16 m01, double_mt16 m02, double_mt16 m03,
        double_mt16 m10, double_mt16 m11, double_mt16 m12, double_mt16 m13,
        double_mt16 m20, double_mt16 m21, double_mt16 m22, double_mt16 m23,
        double_mt16 m30, double_mt16 m31, double_mt16 m32, double_mt16 m33
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
        this.c3 = new(m03, m13, m23, m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x4_mt16((
        double_mt16 m00, double_mt16 m01, double_mt16 m02, double_mt16 m03,
        double_mt16 m10, double_mt16 m11, double_mt16 m12, double_mt16 m13,
        double_mt16 m20, double_mt16 m21, double_mt16 m22, double_mt16 m23,
        double_mt16 m30, double_mt16 m31, double_mt16 m32, double_mt16 m33
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double4x4_mt16((
        double_mt16 m00, double_mt16 m01, double_mt16 m02, double_mt16 m03,
        double_mt16 m10, double_mt16 m11, double_mt16 m12, double_mt16 m13,
        double_mt16 m20, double_mt16 m21, double_mt16 m22, double_mt16 m23,
        double_mt16 m30, double_mt16 m31, double_mt16 m32, double_mt16 m33
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23, tuple.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x4_mt16((
        (double_mt16 m00, double_mt16 m01, double_mt16 m02, double_mt16 m03) r0,
        (double_mt16 m10, double_mt16 m11, double_mt16 m12, double_mt16 m13) r1,
        (double_mt16 m20, double_mt16 m21, double_mt16 m22, double_mt16 m23) r2,
        (double_mt16 m30, double_mt16 m31, double_mt16 m32, double_mt16 m33) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public double4x4_mt16((
        (double_mt16 m00, double_mt16 m01, double_mt16 m02, double_mt16 m03) r0,
        (double_mt16 m10, double_mt16 m11, double_mt16 m12, double_mt16 m13) r1,
        (double_mt16 m20, double_mt16 m21, double_mt16 m22, double_mt16 m23) r2,
        (double_mt16 m30, double_mt16 m31, double_mt16 m32, double_mt16 m33) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23, tuple.r3.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x4_mt16(double_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator double4x4_mt16(double value) => (double_mt16)(value);

    [MethodImpl(256 | 512)]
    public double4x4_mt16(double_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator double4x4_mt16(double4_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public double4x4_mt16(double4_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out double4_mt16 c0, out double4_mt16 c1, out double4_mt16 c2, out double4_mt16 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out double_mt16 m00, out double_mt16 m01, out double_mt16 m02, out double_mt16 m03,
        out double_mt16 m10, out double_mt16 m11, out double_mt16 m12, out double_mt16 m13,
        out double_mt16 m20, out double_mt16 m21, out double_mt16 m22, out double_mt16 m23,
        out double_mt16 m30, out double_mt16 m31, out double_mt16 m32, out double_mt16 m33
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
        this.c3.Deconstruct(out m03, out m13, out m23, out m33);
    }

    #endregion // Deconstruct

    #region Index

    public double4_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public double_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static double4x4_mt16 operator~(double4x4_mt16 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static double4x4_mt16 operator|(double4x4_mt16 a, double4x4_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static double4x4_mt16 operator&(double4x4_mt16 a, double4x4_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static double4x4_mt16 operator^(double4x4_mt16 a, double4x4_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"double4x4_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // double4x4_mt16

#region int2x2_mt4

[CpuOnly]
public partial struct int2x2_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => int_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 2); 
    }

    public static int2x2_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1, default,
            default, 1
        ); 
    }

    #endregion

    #region Fields

    public int2_mt4 c0;
    public int2_mt4 c1;

    #endregion

    #region Properties

    public int_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public int_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public int_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public int_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly int2x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, int2x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public int2x2_mt4(int2_mt4 c0, int2_mt4 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public int2x2_mt4((int2_mt4 c0, int2_mt4 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x2_mt4((int2_mt4 c0, int2_mt4 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int2x2_mt4(
        int_mt4 m00, int_mt4 m01,
        int_mt4 m10, int_mt4 m11
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x2_mt4((
        int_mt4 m00, int_mt4 m01,
        int_mt4 m10, int_mt4 m11
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int2x2_mt4((
        int_mt4 m00, int_mt4 m01,
        int_mt4 m10, int_mt4 m11
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x2_mt4((
        (int_mt4 m00, int_mt4 m01) r0,
        (int_mt4 m10, int_mt4 m11) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int2x2_mt4((
        (int_mt4 m00, int_mt4 m01) r0,
        (int_mt4 m10, int_mt4 m11) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x2_mt4(int_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int2x2_mt4(int value) => (int_mt4)(value);

    [MethodImpl(256 | 512)]
    public int2x2_mt4(int_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x2_mt4(int2_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public int2x2_mt4(int2_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out int2_mt4 c0, out int2_mt4 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out int_mt4 m00, out int_mt4 m01,
        out int_mt4 m10, out int_mt4 m11
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
    }

    #endregion // Deconstruct

    #region Index

    public int2_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public int_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static int2x2_mt4 operator~(int2x2_mt4 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static int2x2_mt4 operator|(int2x2_mt4 a, int2x2_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static int2x2_mt4 operator&(int2x2_mt4 a, int2x2_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static int2x2_mt4 operator^(int2x2_mt4 a, int2x2_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"int2x2_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // int2x2_mt4

#region int2x2_mt8

[CpuOnly]
public partial struct int2x2_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => int_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 2); 
    }

    public static int2x2_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1, default,
            default, 1
        ); 
    }

    #endregion

    #region Fields

    public int2_mt8 c0;
    public int2_mt8 c1;

    #endregion

    #region Properties

    public int_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public int_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public int_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public int_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly int2x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, int2x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public int2x2_mt8(int2_mt8 c0, int2_mt8 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public int2x2_mt8((int2_mt8 c0, int2_mt8 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x2_mt8((int2_mt8 c0, int2_mt8 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int2x2_mt8(
        int_mt8 m00, int_mt8 m01,
        int_mt8 m10, int_mt8 m11
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x2_mt8((
        int_mt8 m00, int_mt8 m01,
        int_mt8 m10, int_mt8 m11
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int2x2_mt8((
        int_mt8 m00, int_mt8 m01,
        int_mt8 m10, int_mt8 m11
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x2_mt8((
        (int_mt8 m00, int_mt8 m01) r0,
        (int_mt8 m10, int_mt8 m11) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int2x2_mt8((
        (int_mt8 m00, int_mt8 m01) r0,
        (int_mt8 m10, int_mt8 m11) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x2_mt8(int_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int2x2_mt8(int value) => (int_mt8)(value);

    [MethodImpl(256 | 512)]
    public int2x2_mt8(int_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x2_mt8(int2_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public int2x2_mt8(int2_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out int2_mt8 c0, out int2_mt8 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out int_mt8 m00, out int_mt8 m01,
        out int_mt8 m10, out int_mt8 m11
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
    }

    #endregion // Deconstruct

    #region Index

    public int2_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public int_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static int2x2_mt8 operator~(int2x2_mt8 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static int2x2_mt8 operator|(int2x2_mt8 a, int2x2_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static int2x2_mt8 operator&(int2x2_mt8 a, int2x2_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static int2x2_mt8 operator^(int2x2_mt8 a, int2x2_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"int2x2_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // int2x2_mt8

#region int2x2_mt16

[CpuOnly]
public partial struct int2x2_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => int_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 2); 
    }

    public static int2x2_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1, default,
            default, 1
        ); 
    }

    #endregion

    #region Fields

    public int2_mt16 c0;
    public int2_mt16 c1;

    #endregion

    #region Properties

    public int_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public int_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public int_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public int_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly int2x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, int2x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public int2x2_mt16(int2_mt16 c0, int2_mt16 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public int2x2_mt16((int2_mt16 c0, int2_mt16 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x2_mt16((int2_mt16 c0, int2_mt16 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int2x2_mt16(
        int_mt16 m00, int_mt16 m01,
        int_mt16 m10, int_mt16 m11
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x2_mt16((
        int_mt16 m00, int_mt16 m01,
        int_mt16 m10, int_mt16 m11
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int2x2_mt16((
        int_mt16 m00, int_mt16 m01,
        int_mt16 m10, int_mt16 m11
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x2_mt16((
        (int_mt16 m00, int_mt16 m01) r0,
        (int_mt16 m10, int_mt16 m11) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int2x2_mt16((
        (int_mt16 m00, int_mt16 m01) r0,
        (int_mt16 m10, int_mt16 m11) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x2_mt16(int_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int2x2_mt16(int value) => (int_mt16)(value);

    [MethodImpl(256 | 512)]
    public int2x2_mt16(int_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x2_mt16(int2_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public int2x2_mt16(int2_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out int2_mt16 c0, out int2_mt16 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out int_mt16 m00, out int_mt16 m01,
        out int_mt16 m10, out int_mt16 m11
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
    }

    #endregion // Deconstruct

    #region Index

    public int2_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public int_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static int2x2_mt16 operator~(int2x2_mt16 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static int2x2_mt16 operator|(int2x2_mt16 a, int2x2_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static int2x2_mt16 operator&(int2x2_mt16 a, int2x2_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static int2x2_mt16 operator^(int2x2_mt16 a, int2x2_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"int2x2_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // int2x2_mt16

#region int2x3_mt4

[CpuOnly]
public partial struct int2x3_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => int_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 3); 
    }

    public static int2x3_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1, default, default,
            default, 1, default
        ); 
    }

    #endregion

    #region Fields

    public int2_mt4 c0;
    public int2_mt4 c1;
    public int2_mt4 c2;

    #endregion

    #region Properties

    public int_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public int_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public int_mt4 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public int_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public int_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public int_mt4 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly int2x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, int2x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public int2x3_mt4(int2_mt4 c0, int2_mt4 c1, int2_mt4 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public int2x3_mt4((int2_mt4 c0, int2_mt4 c1, int2_mt4 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x3_mt4((int2_mt4 c0, int2_mt4 c1, int2_mt4 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int2x3_mt4(
        int_mt4 m00, int_mt4 m01, int_mt4 m02,
        int_mt4 m10, int_mt4 m11, int_mt4 m12
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x3_mt4((
        int_mt4 m00, int_mt4 m01, int_mt4 m02,
        int_mt4 m10, int_mt4 m11, int_mt4 m12
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int2x3_mt4((
        int_mt4 m00, int_mt4 m01, int_mt4 m02,
        int_mt4 m10, int_mt4 m11, int_mt4 m12
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x3_mt4((
        (int_mt4 m00, int_mt4 m01, int_mt4 m02) r0,
        (int_mt4 m10, int_mt4 m11, int_mt4 m12) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int2x3_mt4((
        (int_mt4 m00, int_mt4 m01, int_mt4 m02) r0,
        (int_mt4 m10, int_mt4 m11, int_mt4 m12) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x3_mt4(int_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int2x3_mt4(int value) => (int_mt4)(value);

    [MethodImpl(256 | 512)]
    public int2x3_mt4(int_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x3_mt4(int2_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public int2x3_mt4(int2_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out int2_mt4 c0, out int2_mt4 c1, out int2_mt4 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out int_mt4 m00, out int_mt4 m01, out int_mt4 m02,
        out int_mt4 m10, out int_mt4 m11, out int_mt4 m12
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
    }

    #endregion // Deconstruct

    #region Index

    public int2_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public int_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static int2x3_mt4 operator~(int2x3_mt4 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static int2x3_mt4 operator|(int2x3_mt4 a, int2x3_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static int2x3_mt4 operator&(int2x3_mt4 a, int2x3_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static int2x3_mt4 operator^(int2x3_mt4 a, int2x3_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"int2x3_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // int2x3_mt4

#region int2x3_mt8

[CpuOnly]
public partial struct int2x3_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => int_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 3); 
    }

    public static int2x3_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1, default, default,
            default, 1, default
        ); 
    }

    #endregion

    #region Fields

    public int2_mt8 c0;
    public int2_mt8 c1;
    public int2_mt8 c2;

    #endregion

    #region Properties

    public int_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public int_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public int_mt8 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public int_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public int_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public int_mt8 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly int2x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, int2x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public int2x3_mt8(int2_mt8 c0, int2_mt8 c1, int2_mt8 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public int2x3_mt8((int2_mt8 c0, int2_mt8 c1, int2_mt8 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x3_mt8((int2_mt8 c0, int2_mt8 c1, int2_mt8 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int2x3_mt8(
        int_mt8 m00, int_mt8 m01, int_mt8 m02,
        int_mt8 m10, int_mt8 m11, int_mt8 m12
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x3_mt8((
        int_mt8 m00, int_mt8 m01, int_mt8 m02,
        int_mt8 m10, int_mt8 m11, int_mt8 m12
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int2x3_mt8((
        int_mt8 m00, int_mt8 m01, int_mt8 m02,
        int_mt8 m10, int_mt8 m11, int_mt8 m12
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x3_mt8((
        (int_mt8 m00, int_mt8 m01, int_mt8 m02) r0,
        (int_mt8 m10, int_mt8 m11, int_mt8 m12) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int2x3_mt8((
        (int_mt8 m00, int_mt8 m01, int_mt8 m02) r0,
        (int_mt8 m10, int_mt8 m11, int_mt8 m12) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x3_mt8(int_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int2x3_mt8(int value) => (int_mt8)(value);

    [MethodImpl(256 | 512)]
    public int2x3_mt8(int_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x3_mt8(int2_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public int2x3_mt8(int2_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out int2_mt8 c0, out int2_mt8 c1, out int2_mt8 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out int_mt8 m00, out int_mt8 m01, out int_mt8 m02,
        out int_mt8 m10, out int_mt8 m11, out int_mt8 m12
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
    }

    #endregion // Deconstruct

    #region Index

    public int2_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public int_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static int2x3_mt8 operator~(int2x3_mt8 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static int2x3_mt8 operator|(int2x3_mt8 a, int2x3_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static int2x3_mt8 operator&(int2x3_mt8 a, int2x3_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static int2x3_mt8 operator^(int2x3_mt8 a, int2x3_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"int2x3_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // int2x3_mt8

#region int2x3_mt16

[CpuOnly]
public partial struct int2x3_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => int_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 3); 
    }

    public static int2x3_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1, default, default,
            default, 1, default
        ); 
    }

    #endregion

    #region Fields

    public int2_mt16 c0;
    public int2_mt16 c1;
    public int2_mt16 c2;

    #endregion

    #region Properties

    public int_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public int_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public int_mt16 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public int_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public int_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public int_mt16 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly int2x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, int2x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public int2x3_mt16(int2_mt16 c0, int2_mt16 c1, int2_mt16 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public int2x3_mt16((int2_mt16 c0, int2_mt16 c1, int2_mt16 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x3_mt16((int2_mt16 c0, int2_mt16 c1, int2_mt16 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int2x3_mt16(
        int_mt16 m00, int_mt16 m01, int_mt16 m02,
        int_mt16 m10, int_mt16 m11, int_mt16 m12
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x3_mt16((
        int_mt16 m00, int_mt16 m01, int_mt16 m02,
        int_mt16 m10, int_mt16 m11, int_mt16 m12
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int2x3_mt16((
        int_mt16 m00, int_mt16 m01, int_mt16 m02,
        int_mt16 m10, int_mt16 m11, int_mt16 m12
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x3_mt16((
        (int_mt16 m00, int_mt16 m01, int_mt16 m02) r0,
        (int_mt16 m10, int_mt16 m11, int_mt16 m12) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int2x3_mt16((
        (int_mt16 m00, int_mt16 m01, int_mt16 m02) r0,
        (int_mt16 m10, int_mt16 m11, int_mt16 m12) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x3_mt16(int_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int2x3_mt16(int value) => (int_mt16)(value);

    [MethodImpl(256 | 512)]
    public int2x3_mt16(int_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x3_mt16(int2_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public int2x3_mt16(int2_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out int2_mt16 c0, out int2_mt16 c1, out int2_mt16 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out int_mt16 m00, out int_mt16 m01, out int_mt16 m02,
        out int_mt16 m10, out int_mt16 m11, out int_mt16 m12
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
    }

    #endregion // Deconstruct

    #region Index

    public int2_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public int_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static int2x3_mt16 operator~(int2x3_mt16 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static int2x3_mt16 operator|(int2x3_mt16 a, int2x3_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static int2x3_mt16 operator&(int2x3_mt16 a, int2x3_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static int2x3_mt16 operator^(int2x3_mt16 a, int2x3_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"int2x3_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // int2x3_mt16

#region int2x4_mt4

[CpuOnly]
public partial struct int2x4_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => int_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 4); 
    }

    public static int2x4_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1, default, default, default,
            default, 1, default, default
        ); 
    }

    #endregion

    #region Fields

    public int2_mt4 c0;
    public int2_mt4 c1;
    public int2_mt4 c2;
    public int2_mt4 c3;

    #endregion

    #region Properties

    public int_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public int_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public int_mt4 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public int_mt4 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public int_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public int_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public int_mt4 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public int_mt4 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly int2x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, int2x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public int2x4_mt4(int2_mt4 c0, int2_mt4 c1, int2_mt4 c2, int2_mt4 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public int2x4_mt4((int2_mt4 c0, int2_mt4 c1, int2_mt4 c2, int2_mt4 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x4_mt4((int2_mt4 c0, int2_mt4 c1, int2_mt4 c2, int2_mt4 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int2x4_mt4(
        int_mt4 m00, int_mt4 m01, int_mt4 m02, int_mt4 m03,
        int_mt4 m10, int_mt4 m11, int_mt4 m12, int_mt4 m13
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
        this.c3 = new(m03, m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x4_mt4((
        int_mt4 m00, int_mt4 m01, int_mt4 m02, int_mt4 m03,
        int_mt4 m10, int_mt4 m11, int_mt4 m12, int_mt4 m13
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int2x4_mt4((
        int_mt4 m00, int_mt4 m01, int_mt4 m02, int_mt4 m03,
        int_mt4 m10, int_mt4 m11, int_mt4 m12, int_mt4 m13
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
        this.c3 = new(tuple.m03, tuple.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x4_mt4((
        (int_mt4 m00, int_mt4 m01, int_mt4 m02, int_mt4 m03) r0,
        (int_mt4 m10, int_mt4 m11, int_mt4 m12, int_mt4 m13) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int2x4_mt4((
        (int_mt4 m00, int_mt4 m01, int_mt4 m02, int_mt4 m03) r0,
        (int_mt4 m10, int_mt4 m11, int_mt4 m12, int_mt4 m13) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x4_mt4(int_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int2x4_mt4(int value) => (int_mt4)(value);

    [MethodImpl(256 | 512)]
    public int2x4_mt4(int_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x4_mt4(int2_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public int2x4_mt4(int2_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out int2_mt4 c0, out int2_mt4 c1, out int2_mt4 c2, out int2_mt4 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out int_mt4 m00, out int_mt4 m01, out int_mt4 m02, out int_mt4 m03,
        out int_mt4 m10, out int_mt4 m11, out int_mt4 m12, out int_mt4 m13
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
        this.c3.Deconstruct(out m03, out m13);
    }

    #endregion // Deconstruct

    #region Index

    public int2_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public int_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static int2x4_mt4 operator~(int2x4_mt4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static int2x4_mt4 operator|(int2x4_mt4 a, int2x4_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static int2x4_mt4 operator&(int2x4_mt4 a, int2x4_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static int2x4_mt4 operator^(int2x4_mt4 a, int2x4_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"int2x4_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // int2x4_mt4

#region int2x4_mt8

[CpuOnly]
public partial struct int2x4_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => int_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 4); 
    }

    public static int2x4_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1, default, default, default,
            default, 1, default, default
        ); 
    }

    #endregion

    #region Fields

    public int2_mt8 c0;
    public int2_mt8 c1;
    public int2_mt8 c2;
    public int2_mt8 c3;

    #endregion

    #region Properties

    public int_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public int_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public int_mt8 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public int_mt8 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public int_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public int_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public int_mt8 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public int_mt8 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly int2x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, int2x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public int2x4_mt8(int2_mt8 c0, int2_mt8 c1, int2_mt8 c2, int2_mt8 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public int2x4_mt8((int2_mt8 c0, int2_mt8 c1, int2_mt8 c2, int2_mt8 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x4_mt8((int2_mt8 c0, int2_mt8 c1, int2_mt8 c2, int2_mt8 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int2x4_mt8(
        int_mt8 m00, int_mt8 m01, int_mt8 m02, int_mt8 m03,
        int_mt8 m10, int_mt8 m11, int_mt8 m12, int_mt8 m13
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
        this.c3 = new(m03, m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x4_mt8((
        int_mt8 m00, int_mt8 m01, int_mt8 m02, int_mt8 m03,
        int_mt8 m10, int_mt8 m11, int_mt8 m12, int_mt8 m13
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int2x4_mt8((
        int_mt8 m00, int_mt8 m01, int_mt8 m02, int_mt8 m03,
        int_mt8 m10, int_mt8 m11, int_mt8 m12, int_mt8 m13
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
        this.c3 = new(tuple.m03, tuple.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x4_mt8((
        (int_mt8 m00, int_mt8 m01, int_mt8 m02, int_mt8 m03) r0,
        (int_mt8 m10, int_mt8 m11, int_mt8 m12, int_mt8 m13) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int2x4_mt8((
        (int_mt8 m00, int_mt8 m01, int_mt8 m02, int_mt8 m03) r0,
        (int_mt8 m10, int_mt8 m11, int_mt8 m12, int_mt8 m13) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x4_mt8(int_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int2x4_mt8(int value) => (int_mt8)(value);

    [MethodImpl(256 | 512)]
    public int2x4_mt8(int_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x4_mt8(int2_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public int2x4_mt8(int2_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out int2_mt8 c0, out int2_mt8 c1, out int2_mt8 c2, out int2_mt8 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out int_mt8 m00, out int_mt8 m01, out int_mt8 m02, out int_mt8 m03,
        out int_mt8 m10, out int_mt8 m11, out int_mt8 m12, out int_mt8 m13
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
        this.c3.Deconstruct(out m03, out m13);
    }

    #endregion // Deconstruct

    #region Index

    public int2_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public int_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static int2x4_mt8 operator~(int2x4_mt8 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static int2x4_mt8 operator|(int2x4_mt8 a, int2x4_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static int2x4_mt8 operator&(int2x4_mt8 a, int2x4_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static int2x4_mt8 operator^(int2x4_mt8 a, int2x4_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"int2x4_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // int2x4_mt8

#region int2x4_mt16

[CpuOnly]
public partial struct int2x4_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => int_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 4); 
    }

    public static int2x4_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1, default, default, default,
            default, 1, default, default
        ); 
    }

    #endregion

    #region Fields

    public int2_mt16 c0;
    public int2_mt16 c1;
    public int2_mt16 c2;
    public int2_mt16 c3;

    #endregion

    #region Properties

    public int_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public int_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public int_mt16 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public int_mt16 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public int_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public int_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public int_mt16 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public int_mt16 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly int2x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, int2x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public int2x4_mt16(int2_mt16 c0, int2_mt16 c1, int2_mt16 c2, int2_mt16 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public int2x4_mt16((int2_mt16 c0, int2_mt16 c1, int2_mt16 c2, int2_mt16 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x4_mt16((int2_mt16 c0, int2_mt16 c1, int2_mt16 c2, int2_mt16 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int2x4_mt16(
        int_mt16 m00, int_mt16 m01, int_mt16 m02, int_mt16 m03,
        int_mt16 m10, int_mt16 m11, int_mt16 m12, int_mt16 m13
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
        this.c3 = new(m03, m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x4_mt16((
        int_mt16 m00, int_mt16 m01, int_mt16 m02, int_mt16 m03,
        int_mt16 m10, int_mt16 m11, int_mt16 m12, int_mt16 m13
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int2x4_mt16((
        int_mt16 m00, int_mt16 m01, int_mt16 m02, int_mt16 m03,
        int_mt16 m10, int_mt16 m11, int_mt16 m12, int_mt16 m13
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
        this.c3 = new(tuple.m03, tuple.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x4_mt16((
        (int_mt16 m00, int_mt16 m01, int_mt16 m02, int_mt16 m03) r0,
        (int_mt16 m10, int_mt16 m11, int_mt16 m12, int_mt16 m13) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int2x4_mt16((
        (int_mt16 m00, int_mt16 m01, int_mt16 m02, int_mt16 m03) r0,
        (int_mt16 m10, int_mt16 m11, int_mt16 m12, int_mt16 m13) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x4_mt16(int_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int2x4_mt16(int value) => (int_mt16)(value);

    [MethodImpl(256 | 512)]
    public int2x4_mt16(int_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int2x4_mt16(int2_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public int2x4_mt16(int2_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out int2_mt16 c0, out int2_mt16 c1, out int2_mt16 c2, out int2_mt16 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out int_mt16 m00, out int_mt16 m01, out int_mt16 m02, out int_mt16 m03,
        out int_mt16 m10, out int_mt16 m11, out int_mt16 m12, out int_mt16 m13
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
        this.c3.Deconstruct(out m03, out m13);
    }

    #endregion // Deconstruct

    #region Index

    public int2_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public int_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static int2x4_mt16 operator~(int2x4_mt16 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static int2x4_mt16 operator|(int2x4_mt16 a, int2x4_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static int2x4_mt16 operator&(int2x4_mt16 a, int2x4_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static int2x4_mt16 operator^(int2x4_mt16 a, int2x4_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"int2x4_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // int2x4_mt16

#region int3x2_mt4

[CpuOnly]
public partial struct int3x2_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => int_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 2); 
    }

    public static int3x2_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1, default,
            default, 1,
            default, default
        ); 
    }

    #endregion

    #region Fields

    public int3_mt4 c0;
    public int3_mt4 c1;

    #endregion

    #region Properties

    public int_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public int_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public int_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public int_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public int_mt4 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public int_mt4 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly int3x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, int3x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public int3x2_mt4(int3_mt4 c0, int3_mt4 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public int3x2_mt4((int3_mt4 c0, int3_mt4 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x2_mt4((int3_mt4 c0, int3_mt4 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int3x2_mt4(
        int_mt4 m00, int_mt4 m01,
        int_mt4 m10, int_mt4 m11,
        int_mt4 m20, int_mt4 m21
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x2_mt4((
        int_mt4 m00, int_mt4 m01,
        int_mt4 m10, int_mt4 m11,
        int_mt4 m20, int_mt4 m21
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int3x2_mt4((
        int_mt4 m00, int_mt4 m01,
        int_mt4 m10, int_mt4 m11,
        int_mt4 m20, int_mt4 m21
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x2_mt4((
        (int_mt4 m00, int_mt4 m01) r0,
        (int_mt4 m10, int_mt4 m11) r1,
        (int_mt4 m20, int_mt4 m21) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int3x2_mt4((
        (int_mt4 m00, int_mt4 m01) r0,
        (int_mt4 m10, int_mt4 m11) r1,
        (int_mt4 m20, int_mt4 m21) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x2_mt4(int_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int3x2_mt4(int value) => (int_mt4)(value);

    [MethodImpl(256 | 512)]
    public int3x2_mt4(int_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x2_mt4(int3_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public int3x2_mt4(int3_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out int3_mt4 c0, out int3_mt4 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out int_mt4 m00, out int_mt4 m01,
        out int_mt4 m10, out int_mt4 m11,
        out int_mt4 m20, out int_mt4 m21
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
    }

    #endregion // Deconstruct

    #region Index

    public int3_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public int_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static int3x2_mt4 operator~(int3x2_mt4 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static int3x2_mt4 operator|(int3x2_mt4 a, int3x2_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static int3x2_mt4 operator&(int3x2_mt4 a, int3x2_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static int3x2_mt4 operator^(int3x2_mt4 a, int3x2_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"int3x2_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // int3x2_mt4

#region int3x2_mt8

[CpuOnly]
public partial struct int3x2_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => int_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 2); 
    }

    public static int3x2_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1, default,
            default, 1,
            default, default
        ); 
    }

    #endregion

    #region Fields

    public int3_mt8 c0;
    public int3_mt8 c1;

    #endregion

    #region Properties

    public int_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public int_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public int_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public int_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public int_mt8 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public int_mt8 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly int3x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, int3x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public int3x2_mt8(int3_mt8 c0, int3_mt8 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public int3x2_mt8((int3_mt8 c0, int3_mt8 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x2_mt8((int3_mt8 c0, int3_mt8 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int3x2_mt8(
        int_mt8 m00, int_mt8 m01,
        int_mt8 m10, int_mt8 m11,
        int_mt8 m20, int_mt8 m21
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x2_mt8((
        int_mt8 m00, int_mt8 m01,
        int_mt8 m10, int_mt8 m11,
        int_mt8 m20, int_mt8 m21
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int3x2_mt8((
        int_mt8 m00, int_mt8 m01,
        int_mt8 m10, int_mt8 m11,
        int_mt8 m20, int_mt8 m21
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x2_mt8((
        (int_mt8 m00, int_mt8 m01) r0,
        (int_mt8 m10, int_mt8 m11) r1,
        (int_mt8 m20, int_mt8 m21) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int3x2_mt8((
        (int_mt8 m00, int_mt8 m01) r0,
        (int_mt8 m10, int_mt8 m11) r1,
        (int_mt8 m20, int_mt8 m21) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x2_mt8(int_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int3x2_mt8(int value) => (int_mt8)(value);

    [MethodImpl(256 | 512)]
    public int3x2_mt8(int_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x2_mt8(int3_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public int3x2_mt8(int3_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out int3_mt8 c0, out int3_mt8 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out int_mt8 m00, out int_mt8 m01,
        out int_mt8 m10, out int_mt8 m11,
        out int_mt8 m20, out int_mt8 m21
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
    }

    #endregion // Deconstruct

    #region Index

    public int3_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public int_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static int3x2_mt8 operator~(int3x2_mt8 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static int3x2_mt8 operator|(int3x2_mt8 a, int3x2_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static int3x2_mt8 operator&(int3x2_mt8 a, int3x2_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static int3x2_mt8 operator^(int3x2_mt8 a, int3x2_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"int3x2_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // int3x2_mt8

#region int3x2_mt16

[CpuOnly]
public partial struct int3x2_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => int_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 2); 
    }

    public static int3x2_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1, default,
            default, 1,
            default, default
        ); 
    }

    #endregion

    #region Fields

    public int3_mt16 c0;
    public int3_mt16 c1;

    #endregion

    #region Properties

    public int_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public int_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public int_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public int_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public int_mt16 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public int_mt16 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly int3x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, int3x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public int3x2_mt16(int3_mt16 c0, int3_mt16 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public int3x2_mt16((int3_mt16 c0, int3_mt16 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x2_mt16((int3_mt16 c0, int3_mt16 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int3x2_mt16(
        int_mt16 m00, int_mt16 m01,
        int_mt16 m10, int_mt16 m11,
        int_mt16 m20, int_mt16 m21
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x2_mt16((
        int_mt16 m00, int_mt16 m01,
        int_mt16 m10, int_mt16 m11,
        int_mt16 m20, int_mt16 m21
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int3x2_mt16((
        int_mt16 m00, int_mt16 m01,
        int_mt16 m10, int_mt16 m11,
        int_mt16 m20, int_mt16 m21
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x2_mt16((
        (int_mt16 m00, int_mt16 m01) r0,
        (int_mt16 m10, int_mt16 m11) r1,
        (int_mt16 m20, int_mt16 m21) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int3x2_mt16((
        (int_mt16 m00, int_mt16 m01) r0,
        (int_mt16 m10, int_mt16 m11) r1,
        (int_mt16 m20, int_mt16 m21) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x2_mt16(int_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int3x2_mt16(int value) => (int_mt16)(value);

    [MethodImpl(256 | 512)]
    public int3x2_mt16(int_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x2_mt16(int3_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public int3x2_mt16(int3_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out int3_mt16 c0, out int3_mt16 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out int_mt16 m00, out int_mt16 m01,
        out int_mt16 m10, out int_mt16 m11,
        out int_mt16 m20, out int_mt16 m21
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
    }

    #endregion // Deconstruct

    #region Index

    public int3_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public int_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static int3x2_mt16 operator~(int3x2_mt16 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static int3x2_mt16 operator|(int3x2_mt16 a, int3x2_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static int3x2_mt16 operator&(int3x2_mt16 a, int3x2_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static int3x2_mt16 operator^(int3x2_mt16 a, int3x2_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"int3x2_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // int3x2_mt16

#region int3x3_mt4

[CpuOnly]
public partial struct int3x3_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => int_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 9; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 3); 
    }

    public static int3x3_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1, default, default,
            default, 1, default,
            default, default, 1
        ); 
    }

    #endregion

    #region Fields

    public int3_mt4 c0;
    public int3_mt4 c1;
    public int3_mt4 c2;

    #endregion

    #region Properties

    public int_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public int_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public int_mt4 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public int_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public int_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public int_mt4 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public int_mt4 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public int_mt4 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public int_mt4 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly int3x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, int3x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public int3x3_mt4(int3_mt4 c0, int3_mt4 c1, int3_mt4 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public int3x3_mt4((int3_mt4 c0, int3_mt4 c1, int3_mt4 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x3_mt4((int3_mt4 c0, int3_mt4 c1, int3_mt4 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int3x3_mt4(
        int_mt4 m00, int_mt4 m01, int_mt4 m02,
        int_mt4 m10, int_mt4 m11, int_mt4 m12,
        int_mt4 m20, int_mt4 m21, int_mt4 m22
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x3_mt4((
        int_mt4 m00, int_mt4 m01, int_mt4 m02,
        int_mt4 m10, int_mt4 m11, int_mt4 m12,
        int_mt4 m20, int_mt4 m21, int_mt4 m22
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int3x3_mt4((
        int_mt4 m00, int_mt4 m01, int_mt4 m02,
        int_mt4 m10, int_mt4 m11, int_mt4 m12,
        int_mt4 m20, int_mt4 m21, int_mt4 m22
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x3_mt4((
        (int_mt4 m00, int_mt4 m01, int_mt4 m02) r0,
        (int_mt4 m10, int_mt4 m11, int_mt4 m12) r1,
        (int_mt4 m20, int_mt4 m21, int_mt4 m22) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int3x3_mt4((
        (int_mt4 m00, int_mt4 m01, int_mt4 m02) r0,
        (int_mt4 m10, int_mt4 m11, int_mt4 m12) r1,
        (int_mt4 m20, int_mt4 m21, int_mt4 m22) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x3_mt4(int_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int3x3_mt4(int value) => (int_mt4)(value);

    [MethodImpl(256 | 512)]
    public int3x3_mt4(int_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x3_mt4(int3_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public int3x3_mt4(int3_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out int3_mt4 c0, out int3_mt4 c1, out int3_mt4 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out int_mt4 m00, out int_mt4 m01, out int_mt4 m02,
        out int_mt4 m10, out int_mt4 m11, out int_mt4 m12,
        out int_mt4 m20, out int_mt4 m21, out int_mt4 m22
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
    }

    #endregion // Deconstruct

    #region Index

    public int3_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public int_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static int3x3_mt4 operator~(int3x3_mt4 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static int3x3_mt4 operator|(int3x3_mt4 a, int3x3_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static int3x3_mt4 operator&(int3x3_mt4 a, int3x3_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static int3x3_mt4 operator^(int3x3_mt4 a, int3x3_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"int3x3_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // int3x3_mt4

#region int3x3_mt8

[CpuOnly]
public partial struct int3x3_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => int_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 9; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 3); 
    }

    public static int3x3_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1, default, default,
            default, 1, default,
            default, default, 1
        ); 
    }

    #endregion

    #region Fields

    public int3_mt8 c0;
    public int3_mt8 c1;
    public int3_mt8 c2;

    #endregion

    #region Properties

    public int_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public int_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public int_mt8 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public int_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public int_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public int_mt8 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public int_mt8 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public int_mt8 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public int_mt8 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly int3x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, int3x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public int3x3_mt8(int3_mt8 c0, int3_mt8 c1, int3_mt8 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public int3x3_mt8((int3_mt8 c0, int3_mt8 c1, int3_mt8 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x3_mt8((int3_mt8 c0, int3_mt8 c1, int3_mt8 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int3x3_mt8(
        int_mt8 m00, int_mt8 m01, int_mt8 m02,
        int_mt8 m10, int_mt8 m11, int_mt8 m12,
        int_mt8 m20, int_mt8 m21, int_mt8 m22
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x3_mt8((
        int_mt8 m00, int_mt8 m01, int_mt8 m02,
        int_mt8 m10, int_mt8 m11, int_mt8 m12,
        int_mt8 m20, int_mt8 m21, int_mt8 m22
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int3x3_mt8((
        int_mt8 m00, int_mt8 m01, int_mt8 m02,
        int_mt8 m10, int_mt8 m11, int_mt8 m12,
        int_mt8 m20, int_mt8 m21, int_mt8 m22
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x3_mt8((
        (int_mt8 m00, int_mt8 m01, int_mt8 m02) r0,
        (int_mt8 m10, int_mt8 m11, int_mt8 m12) r1,
        (int_mt8 m20, int_mt8 m21, int_mt8 m22) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int3x3_mt8((
        (int_mt8 m00, int_mt8 m01, int_mt8 m02) r0,
        (int_mt8 m10, int_mt8 m11, int_mt8 m12) r1,
        (int_mt8 m20, int_mt8 m21, int_mt8 m22) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x3_mt8(int_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int3x3_mt8(int value) => (int_mt8)(value);

    [MethodImpl(256 | 512)]
    public int3x3_mt8(int_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x3_mt8(int3_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public int3x3_mt8(int3_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out int3_mt8 c0, out int3_mt8 c1, out int3_mt8 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out int_mt8 m00, out int_mt8 m01, out int_mt8 m02,
        out int_mt8 m10, out int_mt8 m11, out int_mt8 m12,
        out int_mt8 m20, out int_mt8 m21, out int_mt8 m22
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
    }

    #endregion // Deconstruct

    #region Index

    public int3_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public int_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static int3x3_mt8 operator~(int3x3_mt8 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static int3x3_mt8 operator|(int3x3_mt8 a, int3x3_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static int3x3_mt8 operator&(int3x3_mt8 a, int3x3_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static int3x3_mt8 operator^(int3x3_mt8 a, int3x3_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"int3x3_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // int3x3_mt8

#region int3x3_mt16

[CpuOnly]
public partial struct int3x3_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => int_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 9; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 3); 
    }

    public static int3x3_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1, default, default,
            default, 1, default,
            default, default, 1
        ); 
    }

    #endregion

    #region Fields

    public int3_mt16 c0;
    public int3_mt16 c1;
    public int3_mt16 c2;

    #endregion

    #region Properties

    public int_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public int_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public int_mt16 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public int_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public int_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public int_mt16 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public int_mt16 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public int_mt16 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public int_mt16 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly int3x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, int3x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public int3x3_mt16(int3_mt16 c0, int3_mt16 c1, int3_mt16 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public int3x3_mt16((int3_mt16 c0, int3_mt16 c1, int3_mt16 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x3_mt16((int3_mt16 c0, int3_mt16 c1, int3_mt16 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int3x3_mt16(
        int_mt16 m00, int_mt16 m01, int_mt16 m02,
        int_mt16 m10, int_mt16 m11, int_mt16 m12,
        int_mt16 m20, int_mt16 m21, int_mt16 m22
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x3_mt16((
        int_mt16 m00, int_mt16 m01, int_mt16 m02,
        int_mt16 m10, int_mt16 m11, int_mt16 m12,
        int_mt16 m20, int_mt16 m21, int_mt16 m22
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int3x3_mt16((
        int_mt16 m00, int_mt16 m01, int_mt16 m02,
        int_mt16 m10, int_mt16 m11, int_mt16 m12,
        int_mt16 m20, int_mt16 m21, int_mt16 m22
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x3_mt16((
        (int_mt16 m00, int_mt16 m01, int_mt16 m02) r0,
        (int_mt16 m10, int_mt16 m11, int_mt16 m12) r1,
        (int_mt16 m20, int_mt16 m21, int_mt16 m22) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int3x3_mt16((
        (int_mt16 m00, int_mt16 m01, int_mt16 m02) r0,
        (int_mt16 m10, int_mt16 m11, int_mt16 m12) r1,
        (int_mt16 m20, int_mt16 m21, int_mt16 m22) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x3_mt16(int_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int3x3_mt16(int value) => (int_mt16)(value);

    [MethodImpl(256 | 512)]
    public int3x3_mt16(int_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x3_mt16(int3_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public int3x3_mt16(int3_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out int3_mt16 c0, out int3_mt16 c1, out int3_mt16 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out int_mt16 m00, out int_mt16 m01, out int_mt16 m02,
        out int_mt16 m10, out int_mt16 m11, out int_mt16 m12,
        out int_mt16 m20, out int_mt16 m21, out int_mt16 m22
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
    }

    #endregion // Deconstruct

    #region Index

    public int3_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public int_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static int3x3_mt16 operator~(int3x3_mt16 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static int3x3_mt16 operator|(int3x3_mt16 a, int3x3_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static int3x3_mt16 operator&(int3x3_mt16 a, int3x3_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static int3x3_mt16 operator^(int3x3_mt16 a, int3x3_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"int3x3_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // int3x3_mt16

#region int3x4_mt4

[CpuOnly]
public partial struct int3x4_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => int_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 4); 
    }

    public static int3x4_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1, default, default, default,
            default, 1, default, default,
            default, default, 1, default
        ); 
    }

    #endregion

    #region Fields

    public int3_mt4 c0;
    public int3_mt4 c1;
    public int3_mt4 c2;
    public int3_mt4 c3;

    #endregion

    #region Properties

    public int_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public int_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public int_mt4 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public int_mt4 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public int_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public int_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public int_mt4 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public int_mt4 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public int_mt4 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public int_mt4 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public int_mt4 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public int_mt4 m23
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly int3x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, int3x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public int3x4_mt4(int3_mt4 c0, int3_mt4 c1, int3_mt4 c2, int3_mt4 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public int3x4_mt4((int3_mt4 c0, int3_mt4 c1, int3_mt4 c2, int3_mt4 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x4_mt4((int3_mt4 c0, int3_mt4 c1, int3_mt4 c2, int3_mt4 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int3x4_mt4(
        int_mt4 m00, int_mt4 m01, int_mt4 m02, int_mt4 m03,
        int_mt4 m10, int_mt4 m11, int_mt4 m12, int_mt4 m13,
        int_mt4 m20, int_mt4 m21, int_mt4 m22, int_mt4 m23
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
        this.c3 = new(m03, m13, m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x4_mt4((
        int_mt4 m00, int_mt4 m01, int_mt4 m02, int_mt4 m03,
        int_mt4 m10, int_mt4 m11, int_mt4 m12, int_mt4 m13,
        int_mt4 m20, int_mt4 m21, int_mt4 m22, int_mt4 m23
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int3x4_mt4((
        int_mt4 m00, int_mt4 m01, int_mt4 m02, int_mt4 m03,
        int_mt4 m10, int_mt4 m11, int_mt4 m12, int_mt4 m13,
        int_mt4 m20, int_mt4 m21, int_mt4 m22, int_mt4 m23
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x4_mt4((
        (int_mt4 m00, int_mt4 m01, int_mt4 m02, int_mt4 m03) r0,
        (int_mt4 m10, int_mt4 m11, int_mt4 m12, int_mt4 m13) r1,
        (int_mt4 m20, int_mt4 m21, int_mt4 m22, int_mt4 m23) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int3x4_mt4((
        (int_mt4 m00, int_mt4 m01, int_mt4 m02, int_mt4 m03) r0,
        (int_mt4 m10, int_mt4 m11, int_mt4 m12, int_mt4 m13) r1,
        (int_mt4 m20, int_mt4 m21, int_mt4 m22, int_mt4 m23) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x4_mt4(int_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int3x4_mt4(int value) => (int_mt4)(value);

    [MethodImpl(256 | 512)]
    public int3x4_mt4(int_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x4_mt4(int3_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public int3x4_mt4(int3_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out int3_mt4 c0, out int3_mt4 c1, out int3_mt4 c2, out int3_mt4 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out int_mt4 m00, out int_mt4 m01, out int_mt4 m02, out int_mt4 m03,
        out int_mt4 m10, out int_mt4 m11, out int_mt4 m12, out int_mt4 m13,
        out int_mt4 m20, out int_mt4 m21, out int_mt4 m22, out int_mt4 m23
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
        this.c3.Deconstruct(out m03, out m13, out m23);
    }

    #endregion // Deconstruct

    #region Index

    public int3_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public int_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static int3x4_mt4 operator~(int3x4_mt4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static int3x4_mt4 operator|(int3x4_mt4 a, int3x4_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static int3x4_mt4 operator&(int3x4_mt4 a, int3x4_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static int3x4_mt4 operator^(int3x4_mt4 a, int3x4_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"int3x4_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // int3x4_mt4

#region int3x4_mt8

[CpuOnly]
public partial struct int3x4_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => int_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 4); 
    }

    public static int3x4_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1, default, default, default,
            default, 1, default, default,
            default, default, 1, default
        ); 
    }

    #endregion

    #region Fields

    public int3_mt8 c0;
    public int3_mt8 c1;
    public int3_mt8 c2;
    public int3_mt8 c3;

    #endregion

    #region Properties

    public int_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public int_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public int_mt8 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public int_mt8 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public int_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public int_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public int_mt8 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public int_mt8 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public int_mt8 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public int_mt8 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public int_mt8 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public int_mt8 m23
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly int3x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, int3x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public int3x4_mt8(int3_mt8 c0, int3_mt8 c1, int3_mt8 c2, int3_mt8 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public int3x4_mt8((int3_mt8 c0, int3_mt8 c1, int3_mt8 c2, int3_mt8 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x4_mt8((int3_mt8 c0, int3_mt8 c1, int3_mt8 c2, int3_mt8 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int3x4_mt8(
        int_mt8 m00, int_mt8 m01, int_mt8 m02, int_mt8 m03,
        int_mt8 m10, int_mt8 m11, int_mt8 m12, int_mt8 m13,
        int_mt8 m20, int_mt8 m21, int_mt8 m22, int_mt8 m23
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
        this.c3 = new(m03, m13, m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x4_mt8((
        int_mt8 m00, int_mt8 m01, int_mt8 m02, int_mt8 m03,
        int_mt8 m10, int_mt8 m11, int_mt8 m12, int_mt8 m13,
        int_mt8 m20, int_mt8 m21, int_mt8 m22, int_mt8 m23
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int3x4_mt8((
        int_mt8 m00, int_mt8 m01, int_mt8 m02, int_mt8 m03,
        int_mt8 m10, int_mt8 m11, int_mt8 m12, int_mt8 m13,
        int_mt8 m20, int_mt8 m21, int_mt8 m22, int_mt8 m23
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x4_mt8((
        (int_mt8 m00, int_mt8 m01, int_mt8 m02, int_mt8 m03) r0,
        (int_mt8 m10, int_mt8 m11, int_mt8 m12, int_mt8 m13) r1,
        (int_mt8 m20, int_mt8 m21, int_mt8 m22, int_mt8 m23) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int3x4_mt8((
        (int_mt8 m00, int_mt8 m01, int_mt8 m02, int_mt8 m03) r0,
        (int_mt8 m10, int_mt8 m11, int_mt8 m12, int_mt8 m13) r1,
        (int_mt8 m20, int_mt8 m21, int_mt8 m22, int_mt8 m23) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x4_mt8(int_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int3x4_mt8(int value) => (int_mt8)(value);

    [MethodImpl(256 | 512)]
    public int3x4_mt8(int_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x4_mt8(int3_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public int3x4_mt8(int3_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out int3_mt8 c0, out int3_mt8 c1, out int3_mt8 c2, out int3_mt8 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out int_mt8 m00, out int_mt8 m01, out int_mt8 m02, out int_mt8 m03,
        out int_mt8 m10, out int_mt8 m11, out int_mt8 m12, out int_mt8 m13,
        out int_mt8 m20, out int_mt8 m21, out int_mt8 m22, out int_mt8 m23
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
        this.c3.Deconstruct(out m03, out m13, out m23);
    }

    #endregion // Deconstruct

    #region Index

    public int3_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public int_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static int3x4_mt8 operator~(int3x4_mt8 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static int3x4_mt8 operator|(int3x4_mt8 a, int3x4_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static int3x4_mt8 operator&(int3x4_mt8 a, int3x4_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static int3x4_mt8 operator^(int3x4_mt8 a, int3x4_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"int3x4_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // int3x4_mt8

#region int3x4_mt16

[CpuOnly]
public partial struct int3x4_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => int_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 4); 
    }

    public static int3x4_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1, default, default, default,
            default, 1, default, default,
            default, default, 1, default
        ); 
    }

    #endregion

    #region Fields

    public int3_mt16 c0;
    public int3_mt16 c1;
    public int3_mt16 c2;
    public int3_mt16 c3;

    #endregion

    #region Properties

    public int_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public int_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public int_mt16 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public int_mt16 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public int_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public int_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public int_mt16 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public int_mt16 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public int_mt16 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public int_mt16 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public int_mt16 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public int_mt16 m23
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly int3x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, int3x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public int3x4_mt16(int3_mt16 c0, int3_mt16 c1, int3_mt16 c2, int3_mt16 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public int3x4_mt16((int3_mt16 c0, int3_mt16 c1, int3_mt16 c2, int3_mt16 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x4_mt16((int3_mt16 c0, int3_mt16 c1, int3_mt16 c2, int3_mt16 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int3x4_mt16(
        int_mt16 m00, int_mt16 m01, int_mt16 m02, int_mt16 m03,
        int_mt16 m10, int_mt16 m11, int_mt16 m12, int_mt16 m13,
        int_mt16 m20, int_mt16 m21, int_mt16 m22, int_mt16 m23
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
        this.c3 = new(m03, m13, m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x4_mt16((
        int_mt16 m00, int_mt16 m01, int_mt16 m02, int_mt16 m03,
        int_mt16 m10, int_mt16 m11, int_mt16 m12, int_mt16 m13,
        int_mt16 m20, int_mt16 m21, int_mt16 m22, int_mt16 m23
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int3x4_mt16((
        int_mt16 m00, int_mt16 m01, int_mt16 m02, int_mt16 m03,
        int_mt16 m10, int_mt16 m11, int_mt16 m12, int_mt16 m13,
        int_mt16 m20, int_mt16 m21, int_mt16 m22, int_mt16 m23
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x4_mt16((
        (int_mt16 m00, int_mt16 m01, int_mt16 m02, int_mt16 m03) r0,
        (int_mt16 m10, int_mt16 m11, int_mt16 m12, int_mt16 m13) r1,
        (int_mt16 m20, int_mt16 m21, int_mt16 m22, int_mt16 m23) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int3x4_mt16((
        (int_mt16 m00, int_mt16 m01, int_mt16 m02, int_mt16 m03) r0,
        (int_mt16 m10, int_mt16 m11, int_mt16 m12, int_mt16 m13) r1,
        (int_mt16 m20, int_mt16 m21, int_mt16 m22, int_mt16 m23) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x4_mt16(int_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int3x4_mt16(int value) => (int_mt16)(value);

    [MethodImpl(256 | 512)]
    public int3x4_mt16(int_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int3x4_mt16(int3_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public int3x4_mt16(int3_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out int3_mt16 c0, out int3_mt16 c1, out int3_mt16 c2, out int3_mt16 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out int_mt16 m00, out int_mt16 m01, out int_mt16 m02, out int_mt16 m03,
        out int_mt16 m10, out int_mt16 m11, out int_mt16 m12, out int_mt16 m13,
        out int_mt16 m20, out int_mt16 m21, out int_mt16 m22, out int_mt16 m23
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
        this.c3.Deconstruct(out m03, out m13, out m23);
    }

    #endregion // Deconstruct

    #region Index

    public int3_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public int_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static int3x4_mt16 operator~(int3x4_mt16 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static int3x4_mt16 operator|(int3x4_mt16 a, int3x4_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static int3x4_mt16 operator&(int3x4_mt16 a, int3x4_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static int3x4_mt16 operator^(int3x4_mt16 a, int3x4_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"int3x4_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // int3x4_mt16

#region int4x2_mt4

[CpuOnly]
public partial struct int4x2_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => int_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 2); 
    }

    public static int4x2_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1, default,
            default, 1,
            default, default,
            default, default
        ); 
    }

    #endregion

    #region Fields

    public int4_mt4 c0;
    public int4_mt4 c1;

    #endregion

    #region Properties

    public int_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public int_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public int_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public int_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public int_mt4 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public int_mt4 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public int_mt4 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public int_mt4 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly int4x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, int4x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public int4x2_mt4(int4_mt4 c0, int4_mt4 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public int4x2_mt4((int4_mt4 c0, int4_mt4 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x2_mt4((int4_mt4 c0, int4_mt4 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int4x2_mt4(
        int_mt4 m00, int_mt4 m01,
        int_mt4 m10, int_mt4 m11,
        int_mt4 m20, int_mt4 m21,
        int_mt4 m30, int_mt4 m31
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x2_mt4((
        int_mt4 m00, int_mt4 m01,
        int_mt4 m10, int_mt4 m11,
        int_mt4 m20, int_mt4 m21,
        int_mt4 m30, int_mt4 m31
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int4x2_mt4((
        int_mt4 m00, int_mt4 m01,
        int_mt4 m10, int_mt4 m11,
        int_mt4 m20, int_mt4 m21,
        int_mt4 m30, int_mt4 m31
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x2_mt4((
        (int_mt4 m00, int_mt4 m01) r0,
        (int_mt4 m10, int_mt4 m11) r1,
        (int_mt4 m20, int_mt4 m21) r2,
        (int_mt4 m30, int_mt4 m31) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int4x2_mt4((
        (int_mt4 m00, int_mt4 m01) r0,
        (int_mt4 m10, int_mt4 m11) r1,
        (int_mt4 m20, int_mt4 m21) r2,
        (int_mt4 m30, int_mt4 m31) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x2_mt4(int_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int4x2_mt4(int value) => (int_mt4)(value);

    [MethodImpl(256 | 512)]
    public int4x2_mt4(int_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x2_mt4(int4_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public int4x2_mt4(int4_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out int4_mt4 c0, out int4_mt4 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out int_mt4 m00, out int_mt4 m01,
        out int_mt4 m10, out int_mt4 m11,
        out int_mt4 m20, out int_mt4 m21,
        out int_mt4 m30, out int_mt4 m31
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
    }

    #endregion // Deconstruct

    #region Index

    public int4_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public int_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static int4x2_mt4 operator~(int4x2_mt4 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static int4x2_mt4 operator|(int4x2_mt4 a, int4x2_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static int4x2_mt4 operator&(int4x2_mt4 a, int4x2_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static int4x2_mt4 operator^(int4x2_mt4 a, int4x2_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"int4x2_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // int4x2_mt4

#region int4x2_mt8

[CpuOnly]
public partial struct int4x2_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => int_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 2); 
    }

    public static int4x2_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1, default,
            default, 1,
            default, default,
            default, default
        ); 
    }

    #endregion

    #region Fields

    public int4_mt8 c0;
    public int4_mt8 c1;

    #endregion

    #region Properties

    public int_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public int_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public int_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public int_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public int_mt8 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public int_mt8 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public int_mt8 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public int_mt8 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly int4x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, int4x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public int4x2_mt8(int4_mt8 c0, int4_mt8 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public int4x2_mt8((int4_mt8 c0, int4_mt8 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x2_mt8((int4_mt8 c0, int4_mt8 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int4x2_mt8(
        int_mt8 m00, int_mt8 m01,
        int_mt8 m10, int_mt8 m11,
        int_mt8 m20, int_mt8 m21,
        int_mt8 m30, int_mt8 m31
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x2_mt8((
        int_mt8 m00, int_mt8 m01,
        int_mt8 m10, int_mt8 m11,
        int_mt8 m20, int_mt8 m21,
        int_mt8 m30, int_mt8 m31
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int4x2_mt8((
        int_mt8 m00, int_mt8 m01,
        int_mt8 m10, int_mt8 m11,
        int_mt8 m20, int_mt8 m21,
        int_mt8 m30, int_mt8 m31
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x2_mt8((
        (int_mt8 m00, int_mt8 m01) r0,
        (int_mt8 m10, int_mt8 m11) r1,
        (int_mt8 m20, int_mt8 m21) r2,
        (int_mt8 m30, int_mt8 m31) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int4x2_mt8((
        (int_mt8 m00, int_mt8 m01) r0,
        (int_mt8 m10, int_mt8 m11) r1,
        (int_mt8 m20, int_mt8 m21) r2,
        (int_mt8 m30, int_mt8 m31) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x2_mt8(int_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int4x2_mt8(int value) => (int_mt8)(value);

    [MethodImpl(256 | 512)]
    public int4x2_mt8(int_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x2_mt8(int4_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public int4x2_mt8(int4_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out int4_mt8 c0, out int4_mt8 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out int_mt8 m00, out int_mt8 m01,
        out int_mt8 m10, out int_mt8 m11,
        out int_mt8 m20, out int_mt8 m21,
        out int_mt8 m30, out int_mt8 m31
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
    }

    #endregion // Deconstruct

    #region Index

    public int4_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public int_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static int4x2_mt8 operator~(int4x2_mt8 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static int4x2_mt8 operator|(int4x2_mt8 a, int4x2_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static int4x2_mt8 operator&(int4x2_mt8 a, int4x2_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static int4x2_mt8 operator^(int4x2_mt8 a, int4x2_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"int4x2_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // int4x2_mt8

#region int4x2_mt16

[CpuOnly]
public partial struct int4x2_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => int_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 2); 
    }

    public static int4x2_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1, default,
            default, 1,
            default, default,
            default, default
        ); 
    }

    #endregion

    #region Fields

    public int4_mt16 c0;
    public int4_mt16 c1;

    #endregion

    #region Properties

    public int_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public int_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public int_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public int_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public int_mt16 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public int_mt16 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public int_mt16 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public int_mt16 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly int4x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, int4x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public int4x2_mt16(int4_mt16 c0, int4_mt16 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public int4x2_mt16((int4_mt16 c0, int4_mt16 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x2_mt16((int4_mt16 c0, int4_mt16 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int4x2_mt16(
        int_mt16 m00, int_mt16 m01,
        int_mt16 m10, int_mt16 m11,
        int_mt16 m20, int_mt16 m21,
        int_mt16 m30, int_mt16 m31
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x2_mt16((
        int_mt16 m00, int_mt16 m01,
        int_mt16 m10, int_mt16 m11,
        int_mt16 m20, int_mt16 m21,
        int_mt16 m30, int_mt16 m31
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int4x2_mt16((
        int_mt16 m00, int_mt16 m01,
        int_mt16 m10, int_mt16 m11,
        int_mt16 m20, int_mt16 m21,
        int_mt16 m30, int_mt16 m31
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x2_mt16((
        (int_mt16 m00, int_mt16 m01) r0,
        (int_mt16 m10, int_mt16 m11) r1,
        (int_mt16 m20, int_mt16 m21) r2,
        (int_mt16 m30, int_mt16 m31) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int4x2_mt16((
        (int_mt16 m00, int_mt16 m01) r0,
        (int_mt16 m10, int_mt16 m11) r1,
        (int_mt16 m20, int_mt16 m21) r2,
        (int_mt16 m30, int_mt16 m31) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x2_mt16(int_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int4x2_mt16(int value) => (int_mt16)(value);

    [MethodImpl(256 | 512)]
    public int4x2_mt16(int_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x2_mt16(int4_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public int4x2_mt16(int4_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out int4_mt16 c0, out int4_mt16 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out int_mt16 m00, out int_mt16 m01,
        out int_mt16 m10, out int_mt16 m11,
        out int_mt16 m20, out int_mt16 m21,
        out int_mt16 m30, out int_mt16 m31
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
    }

    #endregion // Deconstruct

    #region Index

    public int4_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public int_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static int4x2_mt16 operator~(int4x2_mt16 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static int4x2_mt16 operator|(int4x2_mt16 a, int4x2_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static int4x2_mt16 operator&(int4x2_mt16 a, int4x2_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static int4x2_mt16 operator^(int4x2_mt16 a, int4x2_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"int4x2_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // int4x2_mt16

#region int4x3_mt4

[CpuOnly]
public partial struct int4x3_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => int_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 3); 
    }

    public static int4x3_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1, default, default,
            default, 1, default,
            default, default, 1,
            default, default, default
        ); 
    }

    #endregion

    #region Fields

    public int4_mt4 c0;
    public int4_mt4 c1;
    public int4_mt4 c2;

    #endregion

    #region Properties

    public int_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public int_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public int_mt4 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public int_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public int_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public int_mt4 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public int_mt4 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public int_mt4 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public int_mt4 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public int_mt4 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public int_mt4 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public int_mt4 m32
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly int4x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, int4x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public int4x3_mt4(int4_mt4 c0, int4_mt4 c1, int4_mt4 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public int4x3_mt4((int4_mt4 c0, int4_mt4 c1, int4_mt4 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x3_mt4((int4_mt4 c0, int4_mt4 c1, int4_mt4 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int4x3_mt4(
        int_mt4 m00, int_mt4 m01, int_mt4 m02,
        int_mt4 m10, int_mt4 m11, int_mt4 m12,
        int_mt4 m20, int_mt4 m21, int_mt4 m22,
        int_mt4 m30, int_mt4 m31, int_mt4 m32
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x3_mt4((
        int_mt4 m00, int_mt4 m01, int_mt4 m02,
        int_mt4 m10, int_mt4 m11, int_mt4 m12,
        int_mt4 m20, int_mt4 m21, int_mt4 m22,
        int_mt4 m30, int_mt4 m31, int_mt4 m32
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int4x3_mt4((
        int_mt4 m00, int_mt4 m01, int_mt4 m02,
        int_mt4 m10, int_mt4 m11, int_mt4 m12,
        int_mt4 m20, int_mt4 m21, int_mt4 m22,
        int_mt4 m30, int_mt4 m31, int_mt4 m32
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x3_mt4((
        (int_mt4 m00, int_mt4 m01, int_mt4 m02) r0,
        (int_mt4 m10, int_mt4 m11, int_mt4 m12) r1,
        (int_mt4 m20, int_mt4 m21, int_mt4 m22) r2,
        (int_mt4 m30, int_mt4 m31, int_mt4 m32) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int4x3_mt4((
        (int_mt4 m00, int_mt4 m01, int_mt4 m02) r0,
        (int_mt4 m10, int_mt4 m11, int_mt4 m12) r1,
        (int_mt4 m20, int_mt4 m21, int_mt4 m22) r2,
        (int_mt4 m30, int_mt4 m31, int_mt4 m32) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x3_mt4(int_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int4x3_mt4(int value) => (int_mt4)(value);

    [MethodImpl(256 | 512)]
    public int4x3_mt4(int_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x3_mt4(int4_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public int4x3_mt4(int4_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out int4_mt4 c0, out int4_mt4 c1, out int4_mt4 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out int_mt4 m00, out int_mt4 m01, out int_mt4 m02,
        out int_mt4 m10, out int_mt4 m11, out int_mt4 m12,
        out int_mt4 m20, out int_mt4 m21, out int_mt4 m22,
        out int_mt4 m30, out int_mt4 m31, out int_mt4 m32
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
    }

    #endregion // Deconstruct

    #region Index

    public int4_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public int_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static int4x3_mt4 operator~(int4x3_mt4 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static int4x3_mt4 operator|(int4x3_mt4 a, int4x3_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static int4x3_mt4 operator&(int4x3_mt4 a, int4x3_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static int4x3_mt4 operator^(int4x3_mt4 a, int4x3_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"int4x3_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // int4x3_mt4

#region int4x3_mt8

[CpuOnly]
public partial struct int4x3_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => int_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 3); 
    }

    public static int4x3_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1, default, default,
            default, 1, default,
            default, default, 1,
            default, default, default
        ); 
    }

    #endregion

    #region Fields

    public int4_mt8 c0;
    public int4_mt8 c1;
    public int4_mt8 c2;

    #endregion

    #region Properties

    public int_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public int_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public int_mt8 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public int_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public int_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public int_mt8 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public int_mt8 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public int_mt8 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public int_mt8 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public int_mt8 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public int_mt8 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public int_mt8 m32
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly int4x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, int4x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public int4x3_mt8(int4_mt8 c0, int4_mt8 c1, int4_mt8 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public int4x3_mt8((int4_mt8 c0, int4_mt8 c1, int4_mt8 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x3_mt8((int4_mt8 c0, int4_mt8 c1, int4_mt8 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int4x3_mt8(
        int_mt8 m00, int_mt8 m01, int_mt8 m02,
        int_mt8 m10, int_mt8 m11, int_mt8 m12,
        int_mt8 m20, int_mt8 m21, int_mt8 m22,
        int_mt8 m30, int_mt8 m31, int_mt8 m32
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x3_mt8((
        int_mt8 m00, int_mt8 m01, int_mt8 m02,
        int_mt8 m10, int_mt8 m11, int_mt8 m12,
        int_mt8 m20, int_mt8 m21, int_mt8 m22,
        int_mt8 m30, int_mt8 m31, int_mt8 m32
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int4x3_mt8((
        int_mt8 m00, int_mt8 m01, int_mt8 m02,
        int_mt8 m10, int_mt8 m11, int_mt8 m12,
        int_mt8 m20, int_mt8 m21, int_mt8 m22,
        int_mt8 m30, int_mt8 m31, int_mt8 m32
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x3_mt8((
        (int_mt8 m00, int_mt8 m01, int_mt8 m02) r0,
        (int_mt8 m10, int_mt8 m11, int_mt8 m12) r1,
        (int_mt8 m20, int_mt8 m21, int_mt8 m22) r2,
        (int_mt8 m30, int_mt8 m31, int_mt8 m32) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int4x3_mt8((
        (int_mt8 m00, int_mt8 m01, int_mt8 m02) r0,
        (int_mt8 m10, int_mt8 m11, int_mt8 m12) r1,
        (int_mt8 m20, int_mt8 m21, int_mt8 m22) r2,
        (int_mt8 m30, int_mt8 m31, int_mt8 m32) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x3_mt8(int_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int4x3_mt8(int value) => (int_mt8)(value);

    [MethodImpl(256 | 512)]
    public int4x3_mt8(int_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x3_mt8(int4_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public int4x3_mt8(int4_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out int4_mt8 c0, out int4_mt8 c1, out int4_mt8 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out int_mt8 m00, out int_mt8 m01, out int_mt8 m02,
        out int_mt8 m10, out int_mt8 m11, out int_mt8 m12,
        out int_mt8 m20, out int_mt8 m21, out int_mt8 m22,
        out int_mt8 m30, out int_mt8 m31, out int_mt8 m32
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
    }

    #endregion // Deconstruct

    #region Index

    public int4_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public int_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static int4x3_mt8 operator~(int4x3_mt8 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static int4x3_mt8 operator|(int4x3_mt8 a, int4x3_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static int4x3_mt8 operator&(int4x3_mt8 a, int4x3_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static int4x3_mt8 operator^(int4x3_mt8 a, int4x3_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"int4x3_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // int4x3_mt8

#region int4x3_mt16

[CpuOnly]
public partial struct int4x3_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => int_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 3); 
    }

    public static int4x3_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1, default, default,
            default, 1, default,
            default, default, 1,
            default, default, default
        ); 
    }

    #endregion

    #region Fields

    public int4_mt16 c0;
    public int4_mt16 c1;
    public int4_mt16 c2;

    #endregion

    #region Properties

    public int_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public int_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public int_mt16 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public int_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public int_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public int_mt16 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public int_mt16 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public int_mt16 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public int_mt16 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public int_mt16 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public int_mt16 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public int_mt16 m32
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly int4x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, int4x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public int4x3_mt16(int4_mt16 c0, int4_mt16 c1, int4_mt16 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public int4x3_mt16((int4_mt16 c0, int4_mt16 c1, int4_mt16 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x3_mt16((int4_mt16 c0, int4_mt16 c1, int4_mt16 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int4x3_mt16(
        int_mt16 m00, int_mt16 m01, int_mt16 m02,
        int_mt16 m10, int_mt16 m11, int_mt16 m12,
        int_mt16 m20, int_mt16 m21, int_mt16 m22,
        int_mt16 m30, int_mt16 m31, int_mt16 m32
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x3_mt16((
        int_mt16 m00, int_mt16 m01, int_mt16 m02,
        int_mt16 m10, int_mt16 m11, int_mt16 m12,
        int_mt16 m20, int_mt16 m21, int_mt16 m22,
        int_mt16 m30, int_mt16 m31, int_mt16 m32
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int4x3_mt16((
        int_mt16 m00, int_mt16 m01, int_mt16 m02,
        int_mt16 m10, int_mt16 m11, int_mt16 m12,
        int_mt16 m20, int_mt16 m21, int_mt16 m22,
        int_mt16 m30, int_mt16 m31, int_mt16 m32
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x3_mt16((
        (int_mt16 m00, int_mt16 m01, int_mt16 m02) r0,
        (int_mt16 m10, int_mt16 m11, int_mt16 m12) r1,
        (int_mt16 m20, int_mt16 m21, int_mt16 m22) r2,
        (int_mt16 m30, int_mt16 m31, int_mt16 m32) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int4x3_mt16((
        (int_mt16 m00, int_mt16 m01, int_mt16 m02) r0,
        (int_mt16 m10, int_mt16 m11, int_mt16 m12) r1,
        (int_mt16 m20, int_mt16 m21, int_mt16 m22) r2,
        (int_mt16 m30, int_mt16 m31, int_mt16 m32) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x3_mt16(int_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int4x3_mt16(int value) => (int_mt16)(value);

    [MethodImpl(256 | 512)]
    public int4x3_mt16(int_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x3_mt16(int4_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public int4x3_mt16(int4_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out int4_mt16 c0, out int4_mt16 c1, out int4_mt16 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out int_mt16 m00, out int_mt16 m01, out int_mt16 m02,
        out int_mt16 m10, out int_mt16 m11, out int_mt16 m12,
        out int_mt16 m20, out int_mt16 m21, out int_mt16 m22,
        out int_mt16 m30, out int_mt16 m31, out int_mt16 m32
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
    }

    #endregion // Deconstruct

    #region Index

    public int4_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public int_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static int4x3_mt16 operator~(int4x3_mt16 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static int4x3_mt16 operator|(int4x3_mt16 a, int4x3_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static int4x3_mt16 operator&(int4x3_mt16 a, int4x3_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static int4x3_mt16 operator^(int4x3_mt16 a, int4x3_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"int4x3_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // int4x3_mt16

#region int4x4_mt4

[CpuOnly]
public partial struct int4x4_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => int_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 4); 
    }

    public static int4x4_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1, default, default, default,
            default, 1, default, default,
            default, default, 1, default,
            default, default, default, 1
        ); 
    }

    #endregion

    #region Fields

    public int4_mt4 c0;
    public int4_mt4 c1;
    public int4_mt4 c2;
    public int4_mt4 c3;

    #endregion

    #region Properties

    public int_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public int_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public int_mt4 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public int_mt4 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public int_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public int_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public int_mt4 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public int_mt4 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public int_mt4 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public int_mt4 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public int_mt4 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public int_mt4 m23
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }
    public int_mt4 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public int_mt4 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public int_mt4 m32
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }
    public int_mt4 m33
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.w;
        [MethodImpl(256 | 512)]
        set => c3.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly int4x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, int4x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public int4x4_mt4(int4_mt4 c0, int4_mt4 c1, int4_mt4 c2, int4_mt4 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public int4x4_mt4((int4_mt4 c0, int4_mt4 c1, int4_mt4 c2, int4_mt4 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x4_mt4((int4_mt4 c0, int4_mt4 c1, int4_mt4 c2, int4_mt4 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int4x4_mt4(
        int_mt4 m00, int_mt4 m01, int_mt4 m02, int_mt4 m03,
        int_mt4 m10, int_mt4 m11, int_mt4 m12, int_mt4 m13,
        int_mt4 m20, int_mt4 m21, int_mt4 m22, int_mt4 m23,
        int_mt4 m30, int_mt4 m31, int_mt4 m32, int_mt4 m33
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
        this.c3 = new(m03, m13, m23, m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x4_mt4((
        int_mt4 m00, int_mt4 m01, int_mt4 m02, int_mt4 m03,
        int_mt4 m10, int_mt4 m11, int_mt4 m12, int_mt4 m13,
        int_mt4 m20, int_mt4 m21, int_mt4 m22, int_mt4 m23,
        int_mt4 m30, int_mt4 m31, int_mt4 m32, int_mt4 m33
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int4x4_mt4((
        int_mt4 m00, int_mt4 m01, int_mt4 m02, int_mt4 m03,
        int_mt4 m10, int_mt4 m11, int_mt4 m12, int_mt4 m13,
        int_mt4 m20, int_mt4 m21, int_mt4 m22, int_mt4 m23,
        int_mt4 m30, int_mt4 m31, int_mt4 m32, int_mt4 m33
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23, tuple.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x4_mt4((
        (int_mt4 m00, int_mt4 m01, int_mt4 m02, int_mt4 m03) r0,
        (int_mt4 m10, int_mt4 m11, int_mt4 m12, int_mt4 m13) r1,
        (int_mt4 m20, int_mt4 m21, int_mt4 m22, int_mt4 m23) r2,
        (int_mt4 m30, int_mt4 m31, int_mt4 m32, int_mt4 m33) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int4x4_mt4((
        (int_mt4 m00, int_mt4 m01, int_mt4 m02, int_mt4 m03) r0,
        (int_mt4 m10, int_mt4 m11, int_mt4 m12, int_mt4 m13) r1,
        (int_mt4 m20, int_mt4 m21, int_mt4 m22, int_mt4 m23) r2,
        (int_mt4 m30, int_mt4 m31, int_mt4 m32, int_mt4 m33) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23, tuple.r3.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x4_mt4(int_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int4x4_mt4(int value) => (int_mt4)(value);

    [MethodImpl(256 | 512)]
    public int4x4_mt4(int_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x4_mt4(int4_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public int4x4_mt4(int4_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out int4_mt4 c0, out int4_mt4 c1, out int4_mt4 c2, out int4_mt4 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out int_mt4 m00, out int_mt4 m01, out int_mt4 m02, out int_mt4 m03,
        out int_mt4 m10, out int_mt4 m11, out int_mt4 m12, out int_mt4 m13,
        out int_mt4 m20, out int_mt4 m21, out int_mt4 m22, out int_mt4 m23,
        out int_mt4 m30, out int_mt4 m31, out int_mt4 m32, out int_mt4 m33
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
        this.c3.Deconstruct(out m03, out m13, out m23, out m33);
    }

    #endregion // Deconstruct

    #region Index

    public int4_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public int_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static int4x4_mt4 operator~(int4x4_mt4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static int4x4_mt4 operator|(int4x4_mt4 a, int4x4_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static int4x4_mt4 operator&(int4x4_mt4 a, int4x4_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static int4x4_mt4 operator^(int4x4_mt4 a, int4x4_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"int4x4_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // int4x4_mt4

#region int4x4_mt8

[CpuOnly]
public partial struct int4x4_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => int_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 4); 
    }

    public static int4x4_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1, default, default, default,
            default, 1, default, default,
            default, default, 1, default,
            default, default, default, 1
        ); 
    }

    #endregion

    #region Fields

    public int4_mt8 c0;
    public int4_mt8 c1;
    public int4_mt8 c2;
    public int4_mt8 c3;

    #endregion

    #region Properties

    public int_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public int_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public int_mt8 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public int_mt8 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public int_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public int_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public int_mt8 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public int_mt8 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public int_mt8 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public int_mt8 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public int_mt8 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public int_mt8 m23
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }
    public int_mt8 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public int_mt8 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public int_mt8 m32
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }
    public int_mt8 m33
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.w;
        [MethodImpl(256 | 512)]
        set => c3.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly int4x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, int4x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public int4x4_mt8(int4_mt8 c0, int4_mt8 c1, int4_mt8 c2, int4_mt8 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public int4x4_mt8((int4_mt8 c0, int4_mt8 c1, int4_mt8 c2, int4_mt8 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x4_mt8((int4_mt8 c0, int4_mt8 c1, int4_mt8 c2, int4_mt8 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int4x4_mt8(
        int_mt8 m00, int_mt8 m01, int_mt8 m02, int_mt8 m03,
        int_mt8 m10, int_mt8 m11, int_mt8 m12, int_mt8 m13,
        int_mt8 m20, int_mt8 m21, int_mt8 m22, int_mt8 m23,
        int_mt8 m30, int_mt8 m31, int_mt8 m32, int_mt8 m33
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
        this.c3 = new(m03, m13, m23, m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x4_mt8((
        int_mt8 m00, int_mt8 m01, int_mt8 m02, int_mt8 m03,
        int_mt8 m10, int_mt8 m11, int_mt8 m12, int_mt8 m13,
        int_mt8 m20, int_mt8 m21, int_mt8 m22, int_mt8 m23,
        int_mt8 m30, int_mt8 m31, int_mt8 m32, int_mt8 m33
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int4x4_mt8((
        int_mt8 m00, int_mt8 m01, int_mt8 m02, int_mt8 m03,
        int_mt8 m10, int_mt8 m11, int_mt8 m12, int_mt8 m13,
        int_mt8 m20, int_mt8 m21, int_mt8 m22, int_mt8 m23,
        int_mt8 m30, int_mt8 m31, int_mt8 m32, int_mt8 m33
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23, tuple.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x4_mt8((
        (int_mt8 m00, int_mt8 m01, int_mt8 m02, int_mt8 m03) r0,
        (int_mt8 m10, int_mt8 m11, int_mt8 m12, int_mt8 m13) r1,
        (int_mt8 m20, int_mt8 m21, int_mt8 m22, int_mt8 m23) r2,
        (int_mt8 m30, int_mt8 m31, int_mt8 m32, int_mt8 m33) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int4x4_mt8((
        (int_mt8 m00, int_mt8 m01, int_mt8 m02, int_mt8 m03) r0,
        (int_mt8 m10, int_mt8 m11, int_mt8 m12, int_mt8 m13) r1,
        (int_mt8 m20, int_mt8 m21, int_mt8 m22, int_mt8 m23) r2,
        (int_mt8 m30, int_mt8 m31, int_mt8 m32, int_mt8 m33) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23, tuple.r3.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x4_mt8(int_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int4x4_mt8(int value) => (int_mt8)(value);

    [MethodImpl(256 | 512)]
    public int4x4_mt8(int_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x4_mt8(int4_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public int4x4_mt8(int4_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out int4_mt8 c0, out int4_mt8 c1, out int4_mt8 c2, out int4_mt8 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out int_mt8 m00, out int_mt8 m01, out int_mt8 m02, out int_mt8 m03,
        out int_mt8 m10, out int_mt8 m11, out int_mt8 m12, out int_mt8 m13,
        out int_mt8 m20, out int_mt8 m21, out int_mt8 m22, out int_mt8 m23,
        out int_mt8 m30, out int_mt8 m31, out int_mt8 m32, out int_mt8 m33
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
        this.c3.Deconstruct(out m03, out m13, out m23, out m33);
    }

    #endregion // Deconstruct

    #region Index

    public int4_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public int_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static int4x4_mt8 operator~(int4x4_mt8 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static int4x4_mt8 operator|(int4x4_mt8 a, int4x4_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static int4x4_mt8 operator&(int4x4_mt8 a, int4x4_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static int4x4_mt8 operator^(int4x4_mt8 a, int4x4_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"int4x4_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // int4x4_mt8

#region int4x4_mt16

[CpuOnly]
public partial struct int4x4_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => int_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 4); 
    }

    public static int4x4_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1, default, default, default,
            default, 1, default, default,
            default, default, 1, default,
            default, default, default, 1
        ); 
    }

    #endregion

    #region Fields

    public int4_mt16 c0;
    public int4_mt16 c1;
    public int4_mt16 c2;
    public int4_mt16 c3;

    #endregion

    #region Properties

    public int_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public int_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public int_mt16 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public int_mt16 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public int_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public int_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public int_mt16 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public int_mt16 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public int_mt16 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public int_mt16 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public int_mt16 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public int_mt16 m23
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }
    public int_mt16 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public int_mt16 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public int_mt16 m32
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }
    public int_mt16 m33
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.w;
        [MethodImpl(256 | 512)]
        set => c3.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly int4x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, int4x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public int4x4_mt16(int4_mt16 c0, int4_mt16 c1, int4_mt16 c2, int4_mt16 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public int4x4_mt16((int4_mt16 c0, int4_mt16 c1, int4_mt16 c2, int4_mt16 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x4_mt16((int4_mt16 c0, int4_mt16 c1, int4_mt16 c2, int4_mt16 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int4x4_mt16(
        int_mt16 m00, int_mt16 m01, int_mt16 m02, int_mt16 m03,
        int_mt16 m10, int_mt16 m11, int_mt16 m12, int_mt16 m13,
        int_mt16 m20, int_mt16 m21, int_mt16 m22, int_mt16 m23,
        int_mt16 m30, int_mt16 m31, int_mt16 m32, int_mt16 m33
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
        this.c3 = new(m03, m13, m23, m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x4_mt16((
        int_mt16 m00, int_mt16 m01, int_mt16 m02, int_mt16 m03,
        int_mt16 m10, int_mt16 m11, int_mt16 m12, int_mt16 m13,
        int_mt16 m20, int_mt16 m21, int_mt16 m22, int_mt16 m23,
        int_mt16 m30, int_mt16 m31, int_mt16 m32, int_mt16 m33
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int4x4_mt16((
        int_mt16 m00, int_mt16 m01, int_mt16 m02, int_mt16 m03,
        int_mt16 m10, int_mt16 m11, int_mt16 m12, int_mt16 m13,
        int_mt16 m20, int_mt16 m21, int_mt16 m22, int_mt16 m23,
        int_mt16 m30, int_mt16 m31, int_mt16 m32, int_mt16 m33
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23, tuple.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x4_mt16((
        (int_mt16 m00, int_mt16 m01, int_mt16 m02, int_mt16 m03) r0,
        (int_mt16 m10, int_mt16 m11, int_mt16 m12, int_mt16 m13) r1,
        (int_mt16 m20, int_mt16 m21, int_mt16 m22, int_mt16 m23) r2,
        (int_mt16 m30, int_mt16 m31, int_mt16 m32, int_mt16 m33) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public int4x4_mt16((
        (int_mt16 m00, int_mt16 m01, int_mt16 m02, int_mt16 m03) r0,
        (int_mt16 m10, int_mt16 m11, int_mt16 m12, int_mt16 m13) r1,
        (int_mt16 m20, int_mt16 m21, int_mt16 m22, int_mt16 m23) r2,
        (int_mt16 m30, int_mt16 m31, int_mt16 m32, int_mt16 m33) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23, tuple.r3.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x4_mt16(int_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator int4x4_mt16(int value) => (int_mt16)(value);

    [MethodImpl(256 | 512)]
    public int4x4_mt16(int_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator int4x4_mt16(int4_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public int4x4_mt16(int4_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out int4_mt16 c0, out int4_mt16 c1, out int4_mt16 c2, out int4_mt16 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out int_mt16 m00, out int_mt16 m01, out int_mt16 m02, out int_mt16 m03,
        out int_mt16 m10, out int_mt16 m11, out int_mt16 m12, out int_mt16 m13,
        out int_mt16 m20, out int_mt16 m21, out int_mt16 m22, out int_mt16 m23,
        out int_mt16 m30, out int_mt16 m31, out int_mt16 m32, out int_mt16 m33
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
        this.c3.Deconstruct(out m03, out m13, out m23, out m33);
    }

    #endregion // Deconstruct

    #region Index

    public int4_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public int_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static int4x4_mt16 operator~(int4x4_mt16 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static int4x4_mt16 operator|(int4x4_mt16 a, int4x4_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static int4x4_mt16 operator&(int4x4_mt16 a, int4x4_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static int4x4_mt16 operator^(int4x4_mt16 a, int4x4_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"int4x4_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // int4x4_mt16

#region uint2x2_mt4

[CpuOnly]
public partial struct uint2x2_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => uint_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 2); 
    }

    public static uint2x2_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1u, default,
            default, 1u
        ); 
    }

    #endregion

    #region Fields

    public uint2_mt4 c0;
    public uint2_mt4 c1;

    #endregion

    #region Properties

    public uint_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public uint_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public uint_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public uint_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly uint2x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, uint2x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public uint2x2_mt4(uint2_mt4 c0, uint2_mt4 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public uint2x2_mt4((uint2_mt4 c0, uint2_mt4 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x2_mt4((uint2_mt4 c0, uint2_mt4 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint2x2_mt4(
        uint_mt4 m00, uint_mt4 m01,
        uint_mt4 m10, uint_mt4 m11
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x2_mt4((
        uint_mt4 m00, uint_mt4 m01,
        uint_mt4 m10, uint_mt4 m11
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint2x2_mt4((
        uint_mt4 m00, uint_mt4 m01,
        uint_mt4 m10, uint_mt4 m11
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x2_mt4((
        (uint_mt4 m00, uint_mt4 m01) r0,
        (uint_mt4 m10, uint_mt4 m11) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint2x2_mt4((
        (uint_mt4 m00, uint_mt4 m01) r0,
        (uint_mt4 m10, uint_mt4 m11) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x2_mt4(uint_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x2_mt4(uint value) => (uint_mt4)(value);

    [MethodImpl(256 | 512)]
    public uint2x2_mt4(uint_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x2_mt4(uint2_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public uint2x2_mt4(uint2_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out uint2_mt4 c0, out uint2_mt4 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out uint_mt4 m00, out uint_mt4 m01,
        out uint_mt4 m10, out uint_mt4 m11
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
    }

    #endregion // Deconstruct

    #region Index

    public uint2_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public uint_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static uint2x2_mt4 operator~(uint2x2_mt4 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static uint2x2_mt4 operator|(uint2x2_mt4 a, uint2x2_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static uint2x2_mt4 operator&(uint2x2_mt4 a, uint2x2_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static uint2x2_mt4 operator^(uint2x2_mt4 a, uint2x2_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"uint2x2_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // uint2x2_mt4

#region uint2x2_mt8

[CpuOnly]
public partial struct uint2x2_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => uint_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 2); 
    }

    public static uint2x2_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1u, default,
            default, 1u
        ); 
    }

    #endregion

    #region Fields

    public uint2_mt8 c0;
    public uint2_mt8 c1;

    #endregion

    #region Properties

    public uint_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public uint_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public uint_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public uint_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly uint2x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, uint2x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public uint2x2_mt8(uint2_mt8 c0, uint2_mt8 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public uint2x2_mt8((uint2_mt8 c0, uint2_mt8 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x2_mt8((uint2_mt8 c0, uint2_mt8 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint2x2_mt8(
        uint_mt8 m00, uint_mt8 m01,
        uint_mt8 m10, uint_mt8 m11
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x2_mt8((
        uint_mt8 m00, uint_mt8 m01,
        uint_mt8 m10, uint_mt8 m11
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint2x2_mt8((
        uint_mt8 m00, uint_mt8 m01,
        uint_mt8 m10, uint_mt8 m11
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x2_mt8((
        (uint_mt8 m00, uint_mt8 m01) r0,
        (uint_mt8 m10, uint_mt8 m11) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint2x2_mt8((
        (uint_mt8 m00, uint_mt8 m01) r0,
        (uint_mt8 m10, uint_mt8 m11) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x2_mt8(uint_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x2_mt8(uint value) => (uint_mt8)(value);

    [MethodImpl(256 | 512)]
    public uint2x2_mt8(uint_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x2_mt8(uint2_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public uint2x2_mt8(uint2_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out uint2_mt8 c0, out uint2_mt8 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out uint_mt8 m00, out uint_mt8 m01,
        out uint_mt8 m10, out uint_mt8 m11
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
    }

    #endregion // Deconstruct

    #region Index

    public uint2_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public uint_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static uint2x2_mt8 operator~(uint2x2_mt8 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static uint2x2_mt8 operator|(uint2x2_mt8 a, uint2x2_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static uint2x2_mt8 operator&(uint2x2_mt8 a, uint2x2_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static uint2x2_mt8 operator^(uint2x2_mt8 a, uint2x2_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"uint2x2_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // uint2x2_mt8

#region uint2x2_mt16

[CpuOnly]
public partial struct uint2x2_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => uint_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 2); 
    }

    public static uint2x2_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1u, default,
            default, 1u
        ); 
    }

    #endregion

    #region Fields

    public uint2_mt16 c0;
    public uint2_mt16 c1;

    #endregion

    #region Properties

    public uint_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public uint_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public uint_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public uint_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly uint2x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, uint2x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public uint2x2_mt16(uint2_mt16 c0, uint2_mt16 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public uint2x2_mt16((uint2_mt16 c0, uint2_mt16 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x2_mt16((uint2_mt16 c0, uint2_mt16 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint2x2_mt16(
        uint_mt16 m00, uint_mt16 m01,
        uint_mt16 m10, uint_mt16 m11
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x2_mt16((
        uint_mt16 m00, uint_mt16 m01,
        uint_mt16 m10, uint_mt16 m11
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint2x2_mt16((
        uint_mt16 m00, uint_mt16 m01,
        uint_mt16 m10, uint_mt16 m11
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x2_mt16((
        (uint_mt16 m00, uint_mt16 m01) r0,
        (uint_mt16 m10, uint_mt16 m11) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint2x2_mt16((
        (uint_mt16 m00, uint_mt16 m01) r0,
        (uint_mt16 m10, uint_mt16 m11) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x2_mt16(uint_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x2_mt16(uint value) => (uint_mt16)(value);

    [MethodImpl(256 | 512)]
    public uint2x2_mt16(uint_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x2_mt16(uint2_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public uint2x2_mt16(uint2_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out uint2_mt16 c0, out uint2_mt16 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out uint_mt16 m00, out uint_mt16 m01,
        out uint_mt16 m10, out uint_mt16 m11
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
    }

    #endregion // Deconstruct

    #region Index

    public uint2_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public uint_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static uint2x2_mt16 operator~(uint2x2_mt16 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static uint2x2_mt16 operator|(uint2x2_mt16 a, uint2x2_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static uint2x2_mt16 operator&(uint2x2_mt16 a, uint2x2_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static uint2x2_mt16 operator^(uint2x2_mt16 a, uint2x2_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"uint2x2_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // uint2x2_mt16

#region uint2x3_mt4

[CpuOnly]
public partial struct uint2x3_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => uint_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 3); 
    }

    public static uint2x3_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1u, default, default,
            default, 1u, default
        ); 
    }

    #endregion

    #region Fields

    public uint2_mt4 c0;
    public uint2_mt4 c1;
    public uint2_mt4 c2;

    #endregion

    #region Properties

    public uint_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public uint_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public uint_mt4 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public uint_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public uint_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public uint_mt4 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly uint2x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, uint2x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public uint2x3_mt4(uint2_mt4 c0, uint2_mt4 c1, uint2_mt4 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public uint2x3_mt4((uint2_mt4 c0, uint2_mt4 c1, uint2_mt4 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x3_mt4((uint2_mt4 c0, uint2_mt4 c1, uint2_mt4 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint2x3_mt4(
        uint_mt4 m00, uint_mt4 m01, uint_mt4 m02,
        uint_mt4 m10, uint_mt4 m11, uint_mt4 m12
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x3_mt4((
        uint_mt4 m00, uint_mt4 m01, uint_mt4 m02,
        uint_mt4 m10, uint_mt4 m11, uint_mt4 m12
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint2x3_mt4((
        uint_mt4 m00, uint_mt4 m01, uint_mt4 m02,
        uint_mt4 m10, uint_mt4 m11, uint_mt4 m12
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x3_mt4((
        (uint_mt4 m00, uint_mt4 m01, uint_mt4 m02) r0,
        (uint_mt4 m10, uint_mt4 m11, uint_mt4 m12) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint2x3_mt4((
        (uint_mt4 m00, uint_mt4 m01, uint_mt4 m02) r0,
        (uint_mt4 m10, uint_mt4 m11, uint_mt4 m12) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x3_mt4(uint_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x3_mt4(uint value) => (uint_mt4)(value);

    [MethodImpl(256 | 512)]
    public uint2x3_mt4(uint_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x3_mt4(uint2_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public uint2x3_mt4(uint2_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out uint2_mt4 c0, out uint2_mt4 c1, out uint2_mt4 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out uint_mt4 m00, out uint_mt4 m01, out uint_mt4 m02,
        out uint_mt4 m10, out uint_mt4 m11, out uint_mt4 m12
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
    }

    #endregion // Deconstruct

    #region Index

    public uint2_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public uint_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static uint2x3_mt4 operator~(uint2x3_mt4 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static uint2x3_mt4 operator|(uint2x3_mt4 a, uint2x3_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static uint2x3_mt4 operator&(uint2x3_mt4 a, uint2x3_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static uint2x3_mt4 operator^(uint2x3_mt4 a, uint2x3_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"uint2x3_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // uint2x3_mt4

#region uint2x3_mt8

[CpuOnly]
public partial struct uint2x3_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => uint_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 3); 
    }

    public static uint2x3_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1u, default, default,
            default, 1u, default
        ); 
    }

    #endregion

    #region Fields

    public uint2_mt8 c0;
    public uint2_mt8 c1;
    public uint2_mt8 c2;

    #endregion

    #region Properties

    public uint_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public uint_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public uint_mt8 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public uint_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public uint_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public uint_mt8 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly uint2x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, uint2x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public uint2x3_mt8(uint2_mt8 c0, uint2_mt8 c1, uint2_mt8 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public uint2x3_mt8((uint2_mt8 c0, uint2_mt8 c1, uint2_mt8 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x3_mt8((uint2_mt8 c0, uint2_mt8 c1, uint2_mt8 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint2x3_mt8(
        uint_mt8 m00, uint_mt8 m01, uint_mt8 m02,
        uint_mt8 m10, uint_mt8 m11, uint_mt8 m12
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x3_mt8((
        uint_mt8 m00, uint_mt8 m01, uint_mt8 m02,
        uint_mt8 m10, uint_mt8 m11, uint_mt8 m12
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint2x3_mt8((
        uint_mt8 m00, uint_mt8 m01, uint_mt8 m02,
        uint_mt8 m10, uint_mt8 m11, uint_mt8 m12
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x3_mt8((
        (uint_mt8 m00, uint_mt8 m01, uint_mt8 m02) r0,
        (uint_mt8 m10, uint_mt8 m11, uint_mt8 m12) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint2x3_mt8((
        (uint_mt8 m00, uint_mt8 m01, uint_mt8 m02) r0,
        (uint_mt8 m10, uint_mt8 m11, uint_mt8 m12) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x3_mt8(uint_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x3_mt8(uint value) => (uint_mt8)(value);

    [MethodImpl(256 | 512)]
    public uint2x3_mt8(uint_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x3_mt8(uint2_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public uint2x3_mt8(uint2_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out uint2_mt8 c0, out uint2_mt8 c1, out uint2_mt8 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out uint_mt8 m00, out uint_mt8 m01, out uint_mt8 m02,
        out uint_mt8 m10, out uint_mt8 m11, out uint_mt8 m12
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
    }

    #endregion // Deconstruct

    #region Index

    public uint2_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public uint_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static uint2x3_mt8 operator~(uint2x3_mt8 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static uint2x3_mt8 operator|(uint2x3_mt8 a, uint2x3_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static uint2x3_mt8 operator&(uint2x3_mt8 a, uint2x3_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static uint2x3_mt8 operator^(uint2x3_mt8 a, uint2x3_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"uint2x3_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // uint2x3_mt8

#region uint2x3_mt16

[CpuOnly]
public partial struct uint2x3_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => uint_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 3); 
    }

    public static uint2x3_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1u, default, default,
            default, 1u, default
        ); 
    }

    #endregion

    #region Fields

    public uint2_mt16 c0;
    public uint2_mt16 c1;
    public uint2_mt16 c2;

    #endregion

    #region Properties

    public uint_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public uint_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public uint_mt16 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public uint_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public uint_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public uint_mt16 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly uint2x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, uint2x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public uint2x3_mt16(uint2_mt16 c0, uint2_mt16 c1, uint2_mt16 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public uint2x3_mt16((uint2_mt16 c0, uint2_mt16 c1, uint2_mt16 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x3_mt16((uint2_mt16 c0, uint2_mt16 c1, uint2_mt16 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint2x3_mt16(
        uint_mt16 m00, uint_mt16 m01, uint_mt16 m02,
        uint_mt16 m10, uint_mt16 m11, uint_mt16 m12
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x3_mt16((
        uint_mt16 m00, uint_mt16 m01, uint_mt16 m02,
        uint_mt16 m10, uint_mt16 m11, uint_mt16 m12
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint2x3_mt16((
        uint_mt16 m00, uint_mt16 m01, uint_mt16 m02,
        uint_mt16 m10, uint_mt16 m11, uint_mt16 m12
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x3_mt16((
        (uint_mt16 m00, uint_mt16 m01, uint_mt16 m02) r0,
        (uint_mt16 m10, uint_mt16 m11, uint_mt16 m12) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint2x3_mt16((
        (uint_mt16 m00, uint_mt16 m01, uint_mt16 m02) r0,
        (uint_mt16 m10, uint_mt16 m11, uint_mt16 m12) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x3_mt16(uint_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x3_mt16(uint value) => (uint_mt16)(value);

    [MethodImpl(256 | 512)]
    public uint2x3_mt16(uint_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x3_mt16(uint2_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public uint2x3_mt16(uint2_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out uint2_mt16 c0, out uint2_mt16 c1, out uint2_mt16 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out uint_mt16 m00, out uint_mt16 m01, out uint_mt16 m02,
        out uint_mt16 m10, out uint_mt16 m11, out uint_mt16 m12
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
    }

    #endregion // Deconstruct

    #region Index

    public uint2_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public uint_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static uint2x3_mt16 operator~(uint2x3_mt16 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static uint2x3_mt16 operator|(uint2x3_mt16 a, uint2x3_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static uint2x3_mt16 operator&(uint2x3_mt16 a, uint2x3_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static uint2x3_mt16 operator^(uint2x3_mt16 a, uint2x3_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"uint2x3_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // uint2x3_mt16

#region uint2x4_mt4

[CpuOnly]
public partial struct uint2x4_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => uint_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 4); 
    }

    public static uint2x4_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1u, default, default, default,
            default, 1u, default, default
        ); 
    }

    #endregion

    #region Fields

    public uint2_mt4 c0;
    public uint2_mt4 c1;
    public uint2_mt4 c2;
    public uint2_mt4 c3;

    #endregion

    #region Properties

    public uint_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public uint_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public uint_mt4 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public uint_mt4 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public uint_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public uint_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public uint_mt4 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public uint_mt4 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly uint2x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, uint2x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public uint2x4_mt4(uint2_mt4 c0, uint2_mt4 c1, uint2_mt4 c2, uint2_mt4 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public uint2x4_mt4((uint2_mt4 c0, uint2_mt4 c1, uint2_mt4 c2, uint2_mt4 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x4_mt4((uint2_mt4 c0, uint2_mt4 c1, uint2_mt4 c2, uint2_mt4 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint2x4_mt4(
        uint_mt4 m00, uint_mt4 m01, uint_mt4 m02, uint_mt4 m03,
        uint_mt4 m10, uint_mt4 m11, uint_mt4 m12, uint_mt4 m13
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
        this.c3 = new(m03, m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x4_mt4((
        uint_mt4 m00, uint_mt4 m01, uint_mt4 m02, uint_mt4 m03,
        uint_mt4 m10, uint_mt4 m11, uint_mt4 m12, uint_mt4 m13
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint2x4_mt4((
        uint_mt4 m00, uint_mt4 m01, uint_mt4 m02, uint_mt4 m03,
        uint_mt4 m10, uint_mt4 m11, uint_mt4 m12, uint_mt4 m13
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
        this.c3 = new(tuple.m03, tuple.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x4_mt4((
        (uint_mt4 m00, uint_mt4 m01, uint_mt4 m02, uint_mt4 m03) r0,
        (uint_mt4 m10, uint_mt4 m11, uint_mt4 m12, uint_mt4 m13) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint2x4_mt4((
        (uint_mt4 m00, uint_mt4 m01, uint_mt4 m02, uint_mt4 m03) r0,
        (uint_mt4 m10, uint_mt4 m11, uint_mt4 m12, uint_mt4 m13) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x4_mt4(uint_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x4_mt4(uint value) => (uint_mt4)(value);

    [MethodImpl(256 | 512)]
    public uint2x4_mt4(uint_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x4_mt4(uint2_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public uint2x4_mt4(uint2_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out uint2_mt4 c0, out uint2_mt4 c1, out uint2_mt4 c2, out uint2_mt4 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out uint_mt4 m00, out uint_mt4 m01, out uint_mt4 m02, out uint_mt4 m03,
        out uint_mt4 m10, out uint_mt4 m11, out uint_mt4 m12, out uint_mt4 m13
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
        this.c3.Deconstruct(out m03, out m13);
    }

    #endregion // Deconstruct

    #region Index

    public uint2_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public uint_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static uint2x4_mt4 operator~(uint2x4_mt4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static uint2x4_mt4 operator|(uint2x4_mt4 a, uint2x4_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static uint2x4_mt4 operator&(uint2x4_mt4 a, uint2x4_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static uint2x4_mt4 operator^(uint2x4_mt4 a, uint2x4_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"uint2x4_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // uint2x4_mt4

#region uint2x4_mt8

[CpuOnly]
public partial struct uint2x4_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => uint_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 4); 
    }

    public static uint2x4_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1u, default, default, default,
            default, 1u, default, default
        ); 
    }

    #endregion

    #region Fields

    public uint2_mt8 c0;
    public uint2_mt8 c1;
    public uint2_mt8 c2;
    public uint2_mt8 c3;

    #endregion

    #region Properties

    public uint_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public uint_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public uint_mt8 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public uint_mt8 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public uint_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public uint_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public uint_mt8 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public uint_mt8 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly uint2x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, uint2x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public uint2x4_mt8(uint2_mt8 c0, uint2_mt8 c1, uint2_mt8 c2, uint2_mt8 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public uint2x4_mt8((uint2_mt8 c0, uint2_mt8 c1, uint2_mt8 c2, uint2_mt8 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x4_mt8((uint2_mt8 c0, uint2_mt8 c1, uint2_mt8 c2, uint2_mt8 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint2x4_mt8(
        uint_mt8 m00, uint_mt8 m01, uint_mt8 m02, uint_mt8 m03,
        uint_mt8 m10, uint_mt8 m11, uint_mt8 m12, uint_mt8 m13
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
        this.c3 = new(m03, m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x4_mt8((
        uint_mt8 m00, uint_mt8 m01, uint_mt8 m02, uint_mt8 m03,
        uint_mt8 m10, uint_mt8 m11, uint_mt8 m12, uint_mt8 m13
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint2x4_mt8((
        uint_mt8 m00, uint_mt8 m01, uint_mt8 m02, uint_mt8 m03,
        uint_mt8 m10, uint_mt8 m11, uint_mt8 m12, uint_mt8 m13
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
        this.c3 = new(tuple.m03, tuple.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x4_mt8((
        (uint_mt8 m00, uint_mt8 m01, uint_mt8 m02, uint_mt8 m03) r0,
        (uint_mt8 m10, uint_mt8 m11, uint_mt8 m12, uint_mt8 m13) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint2x4_mt8((
        (uint_mt8 m00, uint_mt8 m01, uint_mt8 m02, uint_mt8 m03) r0,
        (uint_mt8 m10, uint_mt8 m11, uint_mt8 m12, uint_mt8 m13) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x4_mt8(uint_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x4_mt8(uint value) => (uint_mt8)(value);

    [MethodImpl(256 | 512)]
    public uint2x4_mt8(uint_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x4_mt8(uint2_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public uint2x4_mt8(uint2_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out uint2_mt8 c0, out uint2_mt8 c1, out uint2_mt8 c2, out uint2_mt8 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out uint_mt8 m00, out uint_mt8 m01, out uint_mt8 m02, out uint_mt8 m03,
        out uint_mt8 m10, out uint_mt8 m11, out uint_mt8 m12, out uint_mt8 m13
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
        this.c3.Deconstruct(out m03, out m13);
    }

    #endregion // Deconstruct

    #region Index

    public uint2_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public uint_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static uint2x4_mt8 operator~(uint2x4_mt8 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static uint2x4_mt8 operator|(uint2x4_mt8 a, uint2x4_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static uint2x4_mt8 operator&(uint2x4_mt8 a, uint2x4_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static uint2x4_mt8 operator^(uint2x4_mt8 a, uint2x4_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"uint2x4_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // uint2x4_mt8

#region uint2x4_mt16

[CpuOnly]
public partial struct uint2x4_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => uint_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 4); 
    }

    public static uint2x4_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1u, default, default, default,
            default, 1u, default, default
        ); 
    }

    #endregion

    #region Fields

    public uint2_mt16 c0;
    public uint2_mt16 c1;
    public uint2_mt16 c2;
    public uint2_mt16 c3;

    #endregion

    #region Properties

    public uint_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public uint_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public uint_mt16 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public uint_mt16 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public uint_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public uint_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public uint_mt16 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public uint_mt16 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly uint2x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, uint2x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public uint2x4_mt16(uint2_mt16 c0, uint2_mt16 c1, uint2_mt16 c2, uint2_mt16 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public uint2x4_mt16((uint2_mt16 c0, uint2_mt16 c1, uint2_mt16 c2, uint2_mt16 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x4_mt16((uint2_mt16 c0, uint2_mt16 c1, uint2_mt16 c2, uint2_mt16 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint2x4_mt16(
        uint_mt16 m00, uint_mt16 m01, uint_mt16 m02, uint_mt16 m03,
        uint_mt16 m10, uint_mt16 m11, uint_mt16 m12, uint_mt16 m13
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
        this.c3 = new(m03, m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x4_mt16((
        uint_mt16 m00, uint_mt16 m01, uint_mt16 m02, uint_mt16 m03,
        uint_mt16 m10, uint_mt16 m11, uint_mt16 m12, uint_mt16 m13
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint2x4_mt16((
        uint_mt16 m00, uint_mt16 m01, uint_mt16 m02, uint_mt16 m03,
        uint_mt16 m10, uint_mt16 m11, uint_mt16 m12, uint_mt16 m13
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
        this.c3 = new(tuple.m03, tuple.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x4_mt16((
        (uint_mt16 m00, uint_mt16 m01, uint_mt16 m02, uint_mt16 m03) r0,
        (uint_mt16 m10, uint_mt16 m11, uint_mt16 m12, uint_mt16 m13) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint2x4_mt16((
        (uint_mt16 m00, uint_mt16 m01, uint_mt16 m02, uint_mt16 m03) r0,
        (uint_mt16 m10, uint_mt16 m11, uint_mt16 m12, uint_mt16 m13) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x4_mt16(uint_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x4_mt16(uint value) => (uint_mt16)(value);

    [MethodImpl(256 | 512)]
    public uint2x4_mt16(uint_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint2x4_mt16(uint2_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public uint2x4_mt16(uint2_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out uint2_mt16 c0, out uint2_mt16 c1, out uint2_mt16 c2, out uint2_mt16 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out uint_mt16 m00, out uint_mt16 m01, out uint_mt16 m02, out uint_mt16 m03,
        out uint_mt16 m10, out uint_mt16 m11, out uint_mt16 m12, out uint_mt16 m13
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
        this.c3.Deconstruct(out m03, out m13);
    }

    #endregion // Deconstruct

    #region Index

    public uint2_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public uint_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static uint2x4_mt16 operator~(uint2x4_mt16 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static uint2x4_mt16 operator|(uint2x4_mt16 a, uint2x4_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static uint2x4_mt16 operator&(uint2x4_mt16 a, uint2x4_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static uint2x4_mt16 operator^(uint2x4_mt16 a, uint2x4_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"uint2x4_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // uint2x4_mt16

#region uint3x2_mt4

[CpuOnly]
public partial struct uint3x2_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => uint_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 2); 
    }

    public static uint3x2_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1u, default,
            default, 1u,
            default, default
        ); 
    }

    #endregion

    #region Fields

    public uint3_mt4 c0;
    public uint3_mt4 c1;

    #endregion

    #region Properties

    public uint_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public uint_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public uint_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public uint_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public uint_mt4 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public uint_mt4 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly uint3x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, uint3x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public uint3x2_mt4(uint3_mt4 c0, uint3_mt4 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public uint3x2_mt4((uint3_mt4 c0, uint3_mt4 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x2_mt4((uint3_mt4 c0, uint3_mt4 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint3x2_mt4(
        uint_mt4 m00, uint_mt4 m01,
        uint_mt4 m10, uint_mt4 m11,
        uint_mt4 m20, uint_mt4 m21
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x2_mt4((
        uint_mt4 m00, uint_mt4 m01,
        uint_mt4 m10, uint_mt4 m11,
        uint_mt4 m20, uint_mt4 m21
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint3x2_mt4((
        uint_mt4 m00, uint_mt4 m01,
        uint_mt4 m10, uint_mt4 m11,
        uint_mt4 m20, uint_mt4 m21
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x2_mt4((
        (uint_mt4 m00, uint_mt4 m01) r0,
        (uint_mt4 m10, uint_mt4 m11) r1,
        (uint_mt4 m20, uint_mt4 m21) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint3x2_mt4((
        (uint_mt4 m00, uint_mt4 m01) r0,
        (uint_mt4 m10, uint_mt4 m11) r1,
        (uint_mt4 m20, uint_mt4 m21) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x2_mt4(uint_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x2_mt4(uint value) => (uint_mt4)(value);

    [MethodImpl(256 | 512)]
    public uint3x2_mt4(uint_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x2_mt4(uint3_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public uint3x2_mt4(uint3_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out uint3_mt4 c0, out uint3_mt4 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out uint_mt4 m00, out uint_mt4 m01,
        out uint_mt4 m10, out uint_mt4 m11,
        out uint_mt4 m20, out uint_mt4 m21
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
    }

    #endregion // Deconstruct

    #region Index

    public uint3_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public uint_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static uint3x2_mt4 operator~(uint3x2_mt4 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static uint3x2_mt4 operator|(uint3x2_mt4 a, uint3x2_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static uint3x2_mt4 operator&(uint3x2_mt4 a, uint3x2_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static uint3x2_mt4 operator^(uint3x2_mt4 a, uint3x2_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"uint3x2_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // uint3x2_mt4

#region uint3x2_mt8

[CpuOnly]
public partial struct uint3x2_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => uint_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 2); 
    }

    public static uint3x2_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1u, default,
            default, 1u,
            default, default
        ); 
    }

    #endregion

    #region Fields

    public uint3_mt8 c0;
    public uint3_mt8 c1;

    #endregion

    #region Properties

    public uint_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public uint_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public uint_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public uint_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public uint_mt8 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public uint_mt8 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly uint3x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, uint3x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public uint3x2_mt8(uint3_mt8 c0, uint3_mt8 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public uint3x2_mt8((uint3_mt8 c0, uint3_mt8 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x2_mt8((uint3_mt8 c0, uint3_mt8 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint3x2_mt8(
        uint_mt8 m00, uint_mt8 m01,
        uint_mt8 m10, uint_mt8 m11,
        uint_mt8 m20, uint_mt8 m21
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x2_mt8((
        uint_mt8 m00, uint_mt8 m01,
        uint_mt8 m10, uint_mt8 m11,
        uint_mt8 m20, uint_mt8 m21
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint3x2_mt8((
        uint_mt8 m00, uint_mt8 m01,
        uint_mt8 m10, uint_mt8 m11,
        uint_mt8 m20, uint_mt8 m21
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x2_mt8((
        (uint_mt8 m00, uint_mt8 m01) r0,
        (uint_mt8 m10, uint_mt8 m11) r1,
        (uint_mt8 m20, uint_mt8 m21) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint3x2_mt8((
        (uint_mt8 m00, uint_mt8 m01) r0,
        (uint_mt8 m10, uint_mt8 m11) r1,
        (uint_mt8 m20, uint_mt8 m21) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x2_mt8(uint_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x2_mt8(uint value) => (uint_mt8)(value);

    [MethodImpl(256 | 512)]
    public uint3x2_mt8(uint_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x2_mt8(uint3_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public uint3x2_mt8(uint3_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out uint3_mt8 c0, out uint3_mt8 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out uint_mt8 m00, out uint_mt8 m01,
        out uint_mt8 m10, out uint_mt8 m11,
        out uint_mt8 m20, out uint_mt8 m21
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
    }

    #endregion // Deconstruct

    #region Index

    public uint3_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public uint_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static uint3x2_mt8 operator~(uint3x2_mt8 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static uint3x2_mt8 operator|(uint3x2_mt8 a, uint3x2_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static uint3x2_mt8 operator&(uint3x2_mt8 a, uint3x2_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static uint3x2_mt8 operator^(uint3x2_mt8 a, uint3x2_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"uint3x2_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // uint3x2_mt8

#region uint3x2_mt16

[CpuOnly]
public partial struct uint3x2_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => uint_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 2); 
    }

    public static uint3x2_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1u, default,
            default, 1u,
            default, default
        ); 
    }

    #endregion

    #region Fields

    public uint3_mt16 c0;
    public uint3_mt16 c1;

    #endregion

    #region Properties

    public uint_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public uint_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public uint_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public uint_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public uint_mt16 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public uint_mt16 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly uint3x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, uint3x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public uint3x2_mt16(uint3_mt16 c0, uint3_mt16 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public uint3x2_mt16((uint3_mt16 c0, uint3_mt16 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x2_mt16((uint3_mt16 c0, uint3_mt16 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint3x2_mt16(
        uint_mt16 m00, uint_mt16 m01,
        uint_mt16 m10, uint_mt16 m11,
        uint_mt16 m20, uint_mt16 m21
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x2_mt16((
        uint_mt16 m00, uint_mt16 m01,
        uint_mt16 m10, uint_mt16 m11,
        uint_mt16 m20, uint_mt16 m21
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint3x2_mt16((
        uint_mt16 m00, uint_mt16 m01,
        uint_mt16 m10, uint_mt16 m11,
        uint_mt16 m20, uint_mt16 m21
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x2_mt16((
        (uint_mt16 m00, uint_mt16 m01) r0,
        (uint_mt16 m10, uint_mt16 m11) r1,
        (uint_mt16 m20, uint_mt16 m21) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint3x2_mt16((
        (uint_mt16 m00, uint_mt16 m01) r0,
        (uint_mt16 m10, uint_mt16 m11) r1,
        (uint_mt16 m20, uint_mt16 m21) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x2_mt16(uint_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x2_mt16(uint value) => (uint_mt16)(value);

    [MethodImpl(256 | 512)]
    public uint3x2_mt16(uint_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x2_mt16(uint3_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public uint3x2_mt16(uint3_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out uint3_mt16 c0, out uint3_mt16 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out uint_mt16 m00, out uint_mt16 m01,
        out uint_mt16 m10, out uint_mt16 m11,
        out uint_mt16 m20, out uint_mt16 m21
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
    }

    #endregion // Deconstruct

    #region Index

    public uint3_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public uint_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static uint3x2_mt16 operator~(uint3x2_mt16 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static uint3x2_mt16 operator|(uint3x2_mt16 a, uint3x2_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static uint3x2_mt16 operator&(uint3x2_mt16 a, uint3x2_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static uint3x2_mt16 operator^(uint3x2_mt16 a, uint3x2_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"uint3x2_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // uint3x2_mt16

#region uint3x3_mt4

[CpuOnly]
public partial struct uint3x3_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => uint_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 9; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 3); 
    }

    public static uint3x3_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1u, default, default,
            default, 1u, default,
            default, default, 1u
        ); 
    }

    #endregion

    #region Fields

    public uint3_mt4 c0;
    public uint3_mt4 c1;
    public uint3_mt4 c2;

    #endregion

    #region Properties

    public uint_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public uint_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public uint_mt4 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public uint_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public uint_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public uint_mt4 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public uint_mt4 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public uint_mt4 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public uint_mt4 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly uint3x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, uint3x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public uint3x3_mt4(uint3_mt4 c0, uint3_mt4 c1, uint3_mt4 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public uint3x3_mt4((uint3_mt4 c0, uint3_mt4 c1, uint3_mt4 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x3_mt4((uint3_mt4 c0, uint3_mt4 c1, uint3_mt4 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint3x3_mt4(
        uint_mt4 m00, uint_mt4 m01, uint_mt4 m02,
        uint_mt4 m10, uint_mt4 m11, uint_mt4 m12,
        uint_mt4 m20, uint_mt4 m21, uint_mt4 m22
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x3_mt4((
        uint_mt4 m00, uint_mt4 m01, uint_mt4 m02,
        uint_mt4 m10, uint_mt4 m11, uint_mt4 m12,
        uint_mt4 m20, uint_mt4 m21, uint_mt4 m22
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint3x3_mt4((
        uint_mt4 m00, uint_mt4 m01, uint_mt4 m02,
        uint_mt4 m10, uint_mt4 m11, uint_mt4 m12,
        uint_mt4 m20, uint_mt4 m21, uint_mt4 m22
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x3_mt4((
        (uint_mt4 m00, uint_mt4 m01, uint_mt4 m02) r0,
        (uint_mt4 m10, uint_mt4 m11, uint_mt4 m12) r1,
        (uint_mt4 m20, uint_mt4 m21, uint_mt4 m22) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint3x3_mt4((
        (uint_mt4 m00, uint_mt4 m01, uint_mt4 m02) r0,
        (uint_mt4 m10, uint_mt4 m11, uint_mt4 m12) r1,
        (uint_mt4 m20, uint_mt4 m21, uint_mt4 m22) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x3_mt4(uint_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x3_mt4(uint value) => (uint_mt4)(value);

    [MethodImpl(256 | 512)]
    public uint3x3_mt4(uint_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x3_mt4(uint3_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public uint3x3_mt4(uint3_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out uint3_mt4 c0, out uint3_mt4 c1, out uint3_mt4 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out uint_mt4 m00, out uint_mt4 m01, out uint_mt4 m02,
        out uint_mt4 m10, out uint_mt4 m11, out uint_mt4 m12,
        out uint_mt4 m20, out uint_mt4 m21, out uint_mt4 m22
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
    }

    #endregion // Deconstruct

    #region Index

    public uint3_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public uint_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static uint3x3_mt4 operator~(uint3x3_mt4 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static uint3x3_mt4 operator|(uint3x3_mt4 a, uint3x3_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static uint3x3_mt4 operator&(uint3x3_mt4 a, uint3x3_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static uint3x3_mt4 operator^(uint3x3_mt4 a, uint3x3_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"uint3x3_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // uint3x3_mt4

#region uint3x3_mt8

[CpuOnly]
public partial struct uint3x3_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => uint_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 9; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 3); 
    }

    public static uint3x3_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1u, default, default,
            default, 1u, default,
            default, default, 1u
        ); 
    }

    #endregion

    #region Fields

    public uint3_mt8 c0;
    public uint3_mt8 c1;
    public uint3_mt8 c2;

    #endregion

    #region Properties

    public uint_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public uint_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public uint_mt8 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public uint_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public uint_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public uint_mt8 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public uint_mt8 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public uint_mt8 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public uint_mt8 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly uint3x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, uint3x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public uint3x3_mt8(uint3_mt8 c0, uint3_mt8 c1, uint3_mt8 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public uint3x3_mt8((uint3_mt8 c0, uint3_mt8 c1, uint3_mt8 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x3_mt8((uint3_mt8 c0, uint3_mt8 c1, uint3_mt8 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint3x3_mt8(
        uint_mt8 m00, uint_mt8 m01, uint_mt8 m02,
        uint_mt8 m10, uint_mt8 m11, uint_mt8 m12,
        uint_mt8 m20, uint_mt8 m21, uint_mt8 m22
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x3_mt8((
        uint_mt8 m00, uint_mt8 m01, uint_mt8 m02,
        uint_mt8 m10, uint_mt8 m11, uint_mt8 m12,
        uint_mt8 m20, uint_mt8 m21, uint_mt8 m22
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint3x3_mt8((
        uint_mt8 m00, uint_mt8 m01, uint_mt8 m02,
        uint_mt8 m10, uint_mt8 m11, uint_mt8 m12,
        uint_mt8 m20, uint_mt8 m21, uint_mt8 m22
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x3_mt8((
        (uint_mt8 m00, uint_mt8 m01, uint_mt8 m02) r0,
        (uint_mt8 m10, uint_mt8 m11, uint_mt8 m12) r1,
        (uint_mt8 m20, uint_mt8 m21, uint_mt8 m22) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint3x3_mt8((
        (uint_mt8 m00, uint_mt8 m01, uint_mt8 m02) r0,
        (uint_mt8 m10, uint_mt8 m11, uint_mt8 m12) r1,
        (uint_mt8 m20, uint_mt8 m21, uint_mt8 m22) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x3_mt8(uint_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x3_mt8(uint value) => (uint_mt8)(value);

    [MethodImpl(256 | 512)]
    public uint3x3_mt8(uint_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x3_mt8(uint3_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public uint3x3_mt8(uint3_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out uint3_mt8 c0, out uint3_mt8 c1, out uint3_mt8 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out uint_mt8 m00, out uint_mt8 m01, out uint_mt8 m02,
        out uint_mt8 m10, out uint_mt8 m11, out uint_mt8 m12,
        out uint_mt8 m20, out uint_mt8 m21, out uint_mt8 m22
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
    }

    #endregion // Deconstruct

    #region Index

    public uint3_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public uint_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static uint3x3_mt8 operator~(uint3x3_mt8 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static uint3x3_mt8 operator|(uint3x3_mt8 a, uint3x3_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static uint3x3_mt8 operator&(uint3x3_mt8 a, uint3x3_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static uint3x3_mt8 operator^(uint3x3_mt8 a, uint3x3_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"uint3x3_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // uint3x3_mt8

#region uint3x3_mt16

[CpuOnly]
public partial struct uint3x3_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => uint_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 9; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 3); 
    }

    public static uint3x3_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1u, default, default,
            default, 1u, default,
            default, default, 1u
        ); 
    }

    #endregion

    #region Fields

    public uint3_mt16 c0;
    public uint3_mt16 c1;
    public uint3_mt16 c2;

    #endregion

    #region Properties

    public uint_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public uint_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public uint_mt16 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public uint_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public uint_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public uint_mt16 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public uint_mt16 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public uint_mt16 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public uint_mt16 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly uint3x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, uint3x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public uint3x3_mt16(uint3_mt16 c0, uint3_mt16 c1, uint3_mt16 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public uint3x3_mt16((uint3_mt16 c0, uint3_mt16 c1, uint3_mt16 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x3_mt16((uint3_mt16 c0, uint3_mt16 c1, uint3_mt16 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint3x3_mt16(
        uint_mt16 m00, uint_mt16 m01, uint_mt16 m02,
        uint_mt16 m10, uint_mt16 m11, uint_mt16 m12,
        uint_mt16 m20, uint_mt16 m21, uint_mt16 m22
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x3_mt16((
        uint_mt16 m00, uint_mt16 m01, uint_mt16 m02,
        uint_mt16 m10, uint_mt16 m11, uint_mt16 m12,
        uint_mt16 m20, uint_mt16 m21, uint_mt16 m22
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint3x3_mt16((
        uint_mt16 m00, uint_mt16 m01, uint_mt16 m02,
        uint_mt16 m10, uint_mt16 m11, uint_mt16 m12,
        uint_mt16 m20, uint_mt16 m21, uint_mt16 m22
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x3_mt16((
        (uint_mt16 m00, uint_mt16 m01, uint_mt16 m02) r0,
        (uint_mt16 m10, uint_mt16 m11, uint_mt16 m12) r1,
        (uint_mt16 m20, uint_mt16 m21, uint_mt16 m22) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint3x3_mt16((
        (uint_mt16 m00, uint_mt16 m01, uint_mt16 m02) r0,
        (uint_mt16 m10, uint_mt16 m11, uint_mt16 m12) r1,
        (uint_mt16 m20, uint_mt16 m21, uint_mt16 m22) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x3_mt16(uint_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x3_mt16(uint value) => (uint_mt16)(value);

    [MethodImpl(256 | 512)]
    public uint3x3_mt16(uint_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x3_mt16(uint3_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public uint3x3_mt16(uint3_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out uint3_mt16 c0, out uint3_mt16 c1, out uint3_mt16 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out uint_mt16 m00, out uint_mt16 m01, out uint_mt16 m02,
        out uint_mt16 m10, out uint_mt16 m11, out uint_mt16 m12,
        out uint_mt16 m20, out uint_mt16 m21, out uint_mt16 m22
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
    }

    #endregion // Deconstruct

    #region Index

    public uint3_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public uint_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static uint3x3_mt16 operator~(uint3x3_mt16 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static uint3x3_mt16 operator|(uint3x3_mt16 a, uint3x3_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static uint3x3_mt16 operator&(uint3x3_mt16 a, uint3x3_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static uint3x3_mt16 operator^(uint3x3_mt16 a, uint3x3_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"uint3x3_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // uint3x3_mt16

#region uint3x4_mt4

[CpuOnly]
public partial struct uint3x4_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => uint_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 4); 
    }

    public static uint3x4_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1u, default, default, default,
            default, 1u, default, default,
            default, default, 1u, default
        ); 
    }

    #endregion

    #region Fields

    public uint3_mt4 c0;
    public uint3_mt4 c1;
    public uint3_mt4 c2;
    public uint3_mt4 c3;

    #endregion

    #region Properties

    public uint_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public uint_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public uint_mt4 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public uint_mt4 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public uint_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public uint_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public uint_mt4 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public uint_mt4 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public uint_mt4 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public uint_mt4 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public uint_mt4 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public uint_mt4 m23
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly uint3x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, uint3x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public uint3x4_mt4(uint3_mt4 c0, uint3_mt4 c1, uint3_mt4 c2, uint3_mt4 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public uint3x4_mt4((uint3_mt4 c0, uint3_mt4 c1, uint3_mt4 c2, uint3_mt4 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x4_mt4((uint3_mt4 c0, uint3_mt4 c1, uint3_mt4 c2, uint3_mt4 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint3x4_mt4(
        uint_mt4 m00, uint_mt4 m01, uint_mt4 m02, uint_mt4 m03,
        uint_mt4 m10, uint_mt4 m11, uint_mt4 m12, uint_mt4 m13,
        uint_mt4 m20, uint_mt4 m21, uint_mt4 m22, uint_mt4 m23
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
        this.c3 = new(m03, m13, m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x4_mt4((
        uint_mt4 m00, uint_mt4 m01, uint_mt4 m02, uint_mt4 m03,
        uint_mt4 m10, uint_mt4 m11, uint_mt4 m12, uint_mt4 m13,
        uint_mt4 m20, uint_mt4 m21, uint_mt4 m22, uint_mt4 m23
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint3x4_mt4((
        uint_mt4 m00, uint_mt4 m01, uint_mt4 m02, uint_mt4 m03,
        uint_mt4 m10, uint_mt4 m11, uint_mt4 m12, uint_mt4 m13,
        uint_mt4 m20, uint_mt4 m21, uint_mt4 m22, uint_mt4 m23
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x4_mt4((
        (uint_mt4 m00, uint_mt4 m01, uint_mt4 m02, uint_mt4 m03) r0,
        (uint_mt4 m10, uint_mt4 m11, uint_mt4 m12, uint_mt4 m13) r1,
        (uint_mt4 m20, uint_mt4 m21, uint_mt4 m22, uint_mt4 m23) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint3x4_mt4((
        (uint_mt4 m00, uint_mt4 m01, uint_mt4 m02, uint_mt4 m03) r0,
        (uint_mt4 m10, uint_mt4 m11, uint_mt4 m12, uint_mt4 m13) r1,
        (uint_mt4 m20, uint_mt4 m21, uint_mt4 m22, uint_mt4 m23) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x4_mt4(uint_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x4_mt4(uint value) => (uint_mt4)(value);

    [MethodImpl(256 | 512)]
    public uint3x4_mt4(uint_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x4_mt4(uint3_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public uint3x4_mt4(uint3_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out uint3_mt4 c0, out uint3_mt4 c1, out uint3_mt4 c2, out uint3_mt4 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out uint_mt4 m00, out uint_mt4 m01, out uint_mt4 m02, out uint_mt4 m03,
        out uint_mt4 m10, out uint_mt4 m11, out uint_mt4 m12, out uint_mt4 m13,
        out uint_mt4 m20, out uint_mt4 m21, out uint_mt4 m22, out uint_mt4 m23
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
        this.c3.Deconstruct(out m03, out m13, out m23);
    }

    #endregion // Deconstruct

    #region Index

    public uint3_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public uint_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static uint3x4_mt4 operator~(uint3x4_mt4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static uint3x4_mt4 operator|(uint3x4_mt4 a, uint3x4_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static uint3x4_mt4 operator&(uint3x4_mt4 a, uint3x4_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static uint3x4_mt4 operator^(uint3x4_mt4 a, uint3x4_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"uint3x4_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // uint3x4_mt4

#region uint3x4_mt8

[CpuOnly]
public partial struct uint3x4_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => uint_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 4); 
    }

    public static uint3x4_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1u, default, default, default,
            default, 1u, default, default,
            default, default, 1u, default
        ); 
    }

    #endregion

    #region Fields

    public uint3_mt8 c0;
    public uint3_mt8 c1;
    public uint3_mt8 c2;
    public uint3_mt8 c3;

    #endregion

    #region Properties

    public uint_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public uint_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public uint_mt8 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public uint_mt8 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public uint_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public uint_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public uint_mt8 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public uint_mt8 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public uint_mt8 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public uint_mt8 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public uint_mt8 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public uint_mt8 m23
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly uint3x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, uint3x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public uint3x4_mt8(uint3_mt8 c0, uint3_mt8 c1, uint3_mt8 c2, uint3_mt8 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public uint3x4_mt8((uint3_mt8 c0, uint3_mt8 c1, uint3_mt8 c2, uint3_mt8 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x4_mt8((uint3_mt8 c0, uint3_mt8 c1, uint3_mt8 c2, uint3_mt8 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint3x4_mt8(
        uint_mt8 m00, uint_mt8 m01, uint_mt8 m02, uint_mt8 m03,
        uint_mt8 m10, uint_mt8 m11, uint_mt8 m12, uint_mt8 m13,
        uint_mt8 m20, uint_mt8 m21, uint_mt8 m22, uint_mt8 m23
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
        this.c3 = new(m03, m13, m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x4_mt8((
        uint_mt8 m00, uint_mt8 m01, uint_mt8 m02, uint_mt8 m03,
        uint_mt8 m10, uint_mt8 m11, uint_mt8 m12, uint_mt8 m13,
        uint_mt8 m20, uint_mt8 m21, uint_mt8 m22, uint_mt8 m23
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint3x4_mt8((
        uint_mt8 m00, uint_mt8 m01, uint_mt8 m02, uint_mt8 m03,
        uint_mt8 m10, uint_mt8 m11, uint_mt8 m12, uint_mt8 m13,
        uint_mt8 m20, uint_mt8 m21, uint_mt8 m22, uint_mt8 m23
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x4_mt8((
        (uint_mt8 m00, uint_mt8 m01, uint_mt8 m02, uint_mt8 m03) r0,
        (uint_mt8 m10, uint_mt8 m11, uint_mt8 m12, uint_mt8 m13) r1,
        (uint_mt8 m20, uint_mt8 m21, uint_mt8 m22, uint_mt8 m23) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint3x4_mt8((
        (uint_mt8 m00, uint_mt8 m01, uint_mt8 m02, uint_mt8 m03) r0,
        (uint_mt8 m10, uint_mt8 m11, uint_mt8 m12, uint_mt8 m13) r1,
        (uint_mt8 m20, uint_mt8 m21, uint_mt8 m22, uint_mt8 m23) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x4_mt8(uint_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x4_mt8(uint value) => (uint_mt8)(value);

    [MethodImpl(256 | 512)]
    public uint3x4_mt8(uint_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x4_mt8(uint3_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public uint3x4_mt8(uint3_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out uint3_mt8 c0, out uint3_mt8 c1, out uint3_mt8 c2, out uint3_mt8 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out uint_mt8 m00, out uint_mt8 m01, out uint_mt8 m02, out uint_mt8 m03,
        out uint_mt8 m10, out uint_mt8 m11, out uint_mt8 m12, out uint_mt8 m13,
        out uint_mt8 m20, out uint_mt8 m21, out uint_mt8 m22, out uint_mt8 m23
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
        this.c3.Deconstruct(out m03, out m13, out m23);
    }

    #endregion // Deconstruct

    #region Index

    public uint3_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public uint_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static uint3x4_mt8 operator~(uint3x4_mt8 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static uint3x4_mt8 operator|(uint3x4_mt8 a, uint3x4_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static uint3x4_mt8 operator&(uint3x4_mt8 a, uint3x4_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static uint3x4_mt8 operator^(uint3x4_mt8 a, uint3x4_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"uint3x4_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // uint3x4_mt8

#region uint3x4_mt16

[CpuOnly]
public partial struct uint3x4_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => uint_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 4); 
    }

    public static uint3x4_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1u, default, default, default,
            default, 1u, default, default,
            default, default, 1u, default
        ); 
    }

    #endregion

    #region Fields

    public uint3_mt16 c0;
    public uint3_mt16 c1;
    public uint3_mt16 c2;
    public uint3_mt16 c3;

    #endregion

    #region Properties

    public uint_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public uint_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public uint_mt16 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public uint_mt16 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public uint_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public uint_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public uint_mt16 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public uint_mt16 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public uint_mt16 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public uint_mt16 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public uint_mt16 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public uint_mt16 m23
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly uint3x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, uint3x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public uint3x4_mt16(uint3_mt16 c0, uint3_mt16 c1, uint3_mt16 c2, uint3_mt16 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public uint3x4_mt16((uint3_mt16 c0, uint3_mt16 c1, uint3_mt16 c2, uint3_mt16 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x4_mt16((uint3_mt16 c0, uint3_mt16 c1, uint3_mt16 c2, uint3_mt16 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint3x4_mt16(
        uint_mt16 m00, uint_mt16 m01, uint_mt16 m02, uint_mt16 m03,
        uint_mt16 m10, uint_mt16 m11, uint_mt16 m12, uint_mt16 m13,
        uint_mt16 m20, uint_mt16 m21, uint_mt16 m22, uint_mt16 m23
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
        this.c3 = new(m03, m13, m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x4_mt16((
        uint_mt16 m00, uint_mt16 m01, uint_mt16 m02, uint_mt16 m03,
        uint_mt16 m10, uint_mt16 m11, uint_mt16 m12, uint_mt16 m13,
        uint_mt16 m20, uint_mt16 m21, uint_mt16 m22, uint_mt16 m23
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint3x4_mt16((
        uint_mt16 m00, uint_mt16 m01, uint_mt16 m02, uint_mt16 m03,
        uint_mt16 m10, uint_mt16 m11, uint_mt16 m12, uint_mt16 m13,
        uint_mt16 m20, uint_mt16 m21, uint_mt16 m22, uint_mt16 m23
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x4_mt16((
        (uint_mt16 m00, uint_mt16 m01, uint_mt16 m02, uint_mt16 m03) r0,
        (uint_mt16 m10, uint_mt16 m11, uint_mt16 m12, uint_mt16 m13) r1,
        (uint_mt16 m20, uint_mt16 m21, uint_mt16 m22, uint_mt16 m23) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint3x4_mt16((
        (uint_mt16 m00, uint_mt16 m01, uint_mt16 m02, uint_mt16 m03) r0,
        (uint_mt16 m10, uint_mt16 m11, uint_mt16 m12, uint_mt16 m13) r1,
        (uint_mt16 m20, uint_mt16 m21, uint_mt16 m22, uint_mt16 m23) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x4_mt16(uint_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x4_mt16(uint value) => (uint_mt16)(value);

    [MethodImpl(256 | 512)]
    public uint3x4_mt16(uint_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint3x4_mt16(uint3_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public uint3x4_mt16(uint3_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out uint3_mt16 c0, out uint3_mt16 c1, out uint3_mt16 c2, out uint3_mt16 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out uint_mt16 m00, out uint_mt16 m01, out uint_mt16 m02, out uint_mt16 m03,
        out uint_mt16 m10, out uint_mt16 m11, out uint_mt16 m12, out uint_mt16 m13,
        out uint_mt16 m20, out uint_mt16 m21, out uint_mt16 m22, out uint_mt16 m23
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
        this.c3.Deconstruct(out m03, out m13, out m23);
    }

    #endregion // Deconstruct

    #region Index

    public uint3_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public uint_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static uint3x4_mt16 operator~(uint3x4_mt16 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static uint3x4_mt16 operator|(uint3x4_mt16 a, uint3x4_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static uint3x4_mt16 operator&(uint3x4_mt16 a, uint3x4_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static uint3x4_mt16 operator^(uint3x4_mt16 a, uint3x4_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"uint3x4_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // uint3x4_mt16

#region uint4x2_mt4

[CpuOnly]
public partial struct uint4x2_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => uint_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 2); 
    }

    public static uint4x2_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1u, default,
            default, 1u,
            default, default,
            default, default
        ); 
    }

    #endregion

    #region Fields

    public uint4_mt4 c0;
    public uint4_mt4 c1;

    #endregion

    #region Properties

    public uint_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public uint_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public uint_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public uint_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public uint_mt4 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public uint_mt4 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public uint_mt4 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public uint_mt4 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly uint4x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, uint4x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public uint4x2_mt4(uint4_mt4 c0, uint4_mt4 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public uint4x2_mt4((uint4_mt4 c0, uint4_mt4 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x2_mt4((uint4_mt4 c0, uint4_mt4 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint4x2_mt4(
        uint_mt4 m00, uint_mt4 m01,
        uint_mt4 m10, uint_mt4 m11,
        uint_mt4 m20, uint_mt4 m21,
        uint_mt4 m30, uint_mt4 m31
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x2_mt4((
        uint_mt4 m00, uint_mt4 m01,
        uint_mt4 m10, uint_mt4 m11,
        uint_mt4 m20, uint_mt4 m21,
        uint_mt4 m30, uint_mt4 m31
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint4x2_mt4((
        uint_mt4 m00, uint_mt4 m01,
        uint_mt4 m10, uint_mt4 m11,
        uint_mt4 m20, uint_mt4 m21,
        uint_mt4 m30, uint_mt4 m31
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x2_mt4((
        (uint_mt4 m00, uint_mt4 m01) r0,
        (uint_mt4 m10, uint_mt4 m11) r1,
        (uint_mt4 m20, uint_mt4 m21) r2,
        (uint_mt4 m30, uint_mt4 m31) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint4x2_mt4((
        (uint_mt4 m00, uint_mt4 m01) r0,
        (uint_mt4 m10, uint_mt4 m11) r1,
        (uint_mt4 m20, uint_mt4 m21) r2,
        (uint_mt4 m30, uint_mt4 m31) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x2_mt4(uint_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x2_mt4(uint value) => (uint_mt4)(value);

    [MethodImpl(256 | 512)]
    public uint4x2_mt4(uint_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x2_mt4(uint4_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public uint4x2_mt4(uint4_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out uint4_mt4 c0, out uint4_mt4 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out uint_mt4 m00, out uint_mt4 m01,
        out uint_mt4 m10, out uint_mt4 m11,
        out uint_mt4 m20, out uint_mt4 m21,
        out uint_mt4 m30, out uint_mt4 m31
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
    }

    #endregion // Deconstruct

    #region Index

    public uint4_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public uint_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static uint4x2_mt4 operator~(uint4x2_mt4 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static uint4x2_mt4 operator|(uint4x2_mt4 a, uint4x2_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static uint4x2_mt4 operator&(uint4x2_mt4 a, uint4x2_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static uint4x2_mt4 operator^(uint4x2_mt4 a, uint4x2_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"uint4x2_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // uint4x2_mt4

#region uint4x2_mt8

[CpuOnly]
public partial struct uint4x2_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => uint_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 2); 
    }

    public static uint4x2_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1u, default,
            default, 1u,
            default, default,
            default, default
        ); 
    }

    #endregion

    #region Fields

    public uint4_mt8 c0;
    public uint4_mt8 c1;

    #endregion

    #region Properties

    public uint_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public uint_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public uint_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public uint_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public uint_mt8 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public uint_mt8 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public uint_mt8 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public uint_mt8 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly uint4x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, uint4x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public uint4x2_mt8(uint4_mt8 c0, uint4_mt8 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public uint4x2_mt8((uint4_mt8 c0, uint4_mt8 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x2_mt8((uint4_mt8 c0, uint4_mt8 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint4x2_mt8(
        uint_mt8 m00, uint_mt8 m01,
        uint_mt8 m10, uint_mt8 m11,
        uint_mt8 m20, uint_mt8 m21,
        uint_mt8 m30, uint_mt8 m31
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x2_mt8((
        uint_mt8 m00, uint_mt8 m01,
        uint_mt8 m10, uint_mt8 m11,
        uint_mt8 m20, uint_mt8 m21,
        uint_mt8 m30, uint_mt8 m31
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint4x2_mt8((
        uint_mt8 m00, uint_mt8 m01,
        uint_mt8 m10, uint_mt8 m11,
        uint_mt8 m20, uint_mt8 m21,
        uint_mt8 m30, uint_mt8 m31
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x2_mt8((
        (uint_mt8 m00, uint_mt8 m01) r0,
        (uint_mt8 m10, uint_mt8 m11) r1,
        (uint_mt8 m20, uint_mt8 m21) r2,
        (uint_mt8 m30, uint_mt8 m31) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint4x2_mt8((
        (uint_mt8 m00, uint_mt8 m01) r0,
        (uint_mt8 m10, uint_mt8 m11) r1,
        (uint_mt8 m20, uint_mt8 m21) r2,
        (uint_mt8 m30, uint_mt8 m31) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x2_mt8(uint_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x2_mt8(uint value) => (uint_mt8)(value);

    [MethodImpl(256 | 512)]
    public uint4x2_mt8(uint_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x2_mt8(uint4_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public uint4x2_mt8(uint4_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out uint4_mt8 c0, out uint4_mt8 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out uint_mt8 m00, out uint_mt8 m01,
        out uint_mt8 m10, out uint_mt8 m11,
        out uint_mt8 m20, out uint_mt8 m21,
        out uint_mt8 m30, out uint_mt8 m31
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
    }

    #endregion // Deconstruct

    #region Index

    public uint4_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public uint_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static uint4x2_mt8 operator~(uint4x2_mt8 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static uint4x2_mt8 operator|(uint4x2_mt8 a, uint4x2_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static uint4x2_mt8 operator&(uint4x2_mt8 a, uint4x2_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static uint4x2_mt8 operator^(uint4x2_mt8 a, uint4x2_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"uint4x2_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // uint4x2_mt8

#region uint4x2_mt16

[CpuOnly]
public partial struct uint4x2_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => uint_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 2); 
    }

    public static uint4x2_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1u, default,
            default, 1u,
            default, default,
            default, default
        ); 
    }

    #endregion

    #region Fields

    public uint4_mt16 c0;
    public uint4_mt16 c1;

    #endregion

    #region Properties

    public uint_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public uint_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public uint_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public uint_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public uint_mt16 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public uint_mt16 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public uint_mt16 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public uint_mt16 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly uint4x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, uint4x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public uint4x2_mt16(uint4_mt16 c0, uint4_mt16 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public uint4x2_mt16((uint4_mt16 c0, uint4_mt16 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x2_mt16((uint4_mt16 c0, uint4_mt16 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint4x2_mt16(
        uint_mt16 m00, uint_mt16 m01,
        uint_mt16 m10, uint_mt16 m11,
        uint_mt16 m20, uint_mt16 m21,
        uint_mt16 m30, uint_mt16 m31
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x2_mt16((
        uint_mt16 m00, uint_mt16 m01,
        uint_mt16 m10, uint_mt16 m11,
        uint_mt16 m20, uint_mt16 m21,
        uint_mt16 m30, uint_mt16 m31
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint4x2_mt16((
        uint_mt16 m00, uint_mt16 m01,
        uint_mt16 m10, uint_mt16 m11,
        uint_mt16 m20, uint_mt16 m21,
        uint_mt16 m30, uint_mt16 m31
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x2_mt16((
        (uint_mt16 m00, uint_mt16 m01) r0,
        (uint_mt16 m10, uint_mt16 m11) r1,
        (uint_mt16 m20, uint_mt16 m21) r2,
        (uint_mt16 m30, uint_mt16 m31) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint4x2_mt16((
        (uint_mt16 m00, uint_mt16 m01) r0,
        (uint_mt16 m10, uint_mt16 m11) r1,
        (uint_mt16 m20, uint_mt16 m21) r2,
        (uint_mt16 m30, uint_mt16 m31) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x2_mt16(uint_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x2_mt16(uint value) => (uint_mt16)(value);

    [MethodImpl(256 | 512)]
    public uint4x2_mt16(uint_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x2_mt16(uint4_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public uint4x2_mt16(uint4_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out uint4_mt16 c0, out uint4_mt16 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out uint_mt16 m00, out uint_mt16 m01,
        out uint_mt16 m10, out uint_mt16 m11,
        out uint_mt16 m20, out uint_mt16 m21,
        out uint_mt16 m30, out uint_mt16 m31
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
    }

    #endregion // Deconstruct

    #region Index

    public uint4_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public uint_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static uint4x2_mt16 operator~(uint4x2_mt16 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static uint4x2_mt16 operator|(uint4x2_mt16 a, uint4x2_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static uint4x2_mt16 operator&(uint4x2_mt16 a, uint4x2_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static uint4x2_mt16 operator^(uint4x2_mt16 a, uint4x2_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"uint4x2_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // uint4x2_mt16

#region uint4x3_mt4

[CpuOnly]
public partial struct uint4x3_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => uint_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 3); 
    }

    public static uint4x3_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1u, default, default,
            default, 1u, default,
            default, default, 1u,
            default, default, default
        ); 
    }

    #endregion

    #region Fields

    public uint4_mt4 c0;
    public uint4_mt4 c1;
    public uint4_mt4 c2;

    #endregion

    #region Properties

    public uint_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public uint_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public uint_mt4 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public uint_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public uint_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public uint_mt4 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public uint_mt4 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public uint_mt4 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public uint_mt4 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public uint_mt4 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public uint_mt4 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public uint_mt4 m32
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly uint4x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, uint4x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public uint4x3_mt4(uint4_mt4 c0, uint4_mt4 c1, uint4_mt4 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public uint4x3_mt4((uint4_mt4 c0, uint4_mt4 c1, uint4_mt4 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x3_mt4((uint4_mt4 c0, uint4_mt4 c1, uint4_mt4 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint4x3_mt4(
        uint_mt4 m00, uint_mt4 m01, uint_mt4 m02,
        uint_mt4 m10, uint_mt4 m11, uint_mt4 m12,
        uint_mt4 m20, uint_mt4 m21, uint_mt4 m22,
        uint_mt4 m30, uint_mt4 m31, uint_mt4 m32
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x3_mt4((
        uint_mt4 m00, uint_mt4 m01, uint_mt4 m02,
        uint_mt4 m10, uint_mt4 m11, uint_mt4 m12,
        uint_mt4 m20, uint_mt4 m21, uint_mt4 m22,
        uint_mt4 m30, uint_mt4 m31, uint_mt4 m32
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint4x3_mt4((
        uint_mt4 m00, uint_mt4 m01, uint_mt4 m02,
        uint_mt4 m10, uint_mt4 m11, uint_mt4 m12,
        uint_mt4 m20, uint_mt4 m21, uint_mt4 m22,
        uint_mt4 m30, uint_mt4 m31, uint_mt4 m32
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x3_mt4((
        (uint_mt4 m00, uint_mt4 m01, uint_mt4 m02) r0,
        (uint_mt4 m10, uint_mt4 m11, uint_mt4 m12) r1,
        (uint_mt4 m20, uint_mt4 m21, uint_mt4 m22) r2,
        (uint_mt4 m30, uint_mt4 m31, uint_mt4 m32) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint4x3_mt4((
        (uint_mt4 m00, uint_mt4 m01, uint_mt4 m02) r0,
        (uint_mt4 m10, uint_mt4 m11, uint_mt4 m12) r1,
        (uint_mt4 m20, uint_mt4 m21, uint_mt4 m22) r2,
        (uint_mt4 m30, uint_mt4 m31, uint_mt4 m32) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x3_mt4(uint_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x3_mt4(uint value) => (uint_mt4)(value);

    [MethodImpl(256 | 512)]
    public uint4x3_mt4(uint_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x3_mt4(uint4_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public uint4x3_mt4(uint4_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out uint4_mt4 c0, out uint4_mt4 c1, out uint4_mt4 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out uint_mt4 m00, out uint_mt4 m01, out uint_mt4 m02,
        out uint_mt4 m10, out uint_mt4 m11, out uint_mt4 m12,
        out uint_mt4 m20, out uint_mt4 m21, out uint_mt4 m22,
        out uint_mt4 m30, out uint_mt4 m31, out uint_mt4 m32
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
    }

    #endregion // Deconstruct

    #region Index

    public uint4_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public uint_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static uint4x3_mt4 operator~(uint4x3_mt4 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static uint4x3_mt4 operator|(uint4x3_mt4 a, uint4x3_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static uint4x3_mt4 operator&(uint4x3_mt4 a, uint4x3_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static uint4x3_mt4 operator^(uint4x3_mt4 a, uint4x3_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"uint4x3_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // uint4x3_mt4

#region uint4x3_mt8

[CpuOnly]
public partial struct uint4x3_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => uint_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 3); 
    }

    public static uint4x3_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1u, default, default,
            default, 1u, default,
            default, default, 1u,
            default, default, default
        ); 
    }

    #endregion

    #region Fields

    public uint4_mt8 c0;
    public uint4_mt8 c1;
    public uint4_mt8 c2;

    #endregion

    #region Properties

    public uint_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public uint_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public uint_mt8 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public uint_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public uint_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public uint_mt8 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public uint_mt8 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public uint_mt8 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public uint_mt8 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public uint_mt8 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public uint_mt8 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public uint_mt8 m32
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly uint4x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, uint4x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public uint4x3_mt8(uint4_mt8 c0, uint4_mt8 c1, uint4_mt8 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public uint4x3_mt8((uint4_mt8 c0, uint4_mt8 c1, uint4_mt8 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x3_mt8((uint4_mt8 c0, uint4_mt8 c1, uint4_mt8 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint4x3_mt8(
        uint_mt8 m00, uint_mt8 m01, uint_mt8 m02,
        uint_mt8 m10, uint_mt8 m11, uint_mt8 m12,
        uint_mt8 m20, uint_mt8 m21, uint_mt8 m22,
        uint_mt8 m30, uint_mt8 m31, uint_mt8 m32
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x3_mt8((
        uint_mt8 m00, uint_mt8 m01, uint_mt8 m02,
        uint_mt8 m10, uint_mt8 m11, uint_mt8 m12,
        uint_mt8 m20, uint_mt8 m21, uint_mt8 m22,
        uint_mt8 m30, uint_mt8 m31, uint_mt8 m32
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint4x3_mt8((
        uint_mt8 m00, uint_mt8 m01, uint_mt8 m02,
        uint_mt8 m10, uint_mt8 m11, uint_mt8 m12,
        uint_mt8 m20, uint_mt8 m21, uint_mt8 m22,
        uint_mt8 m30, uint_mt8 m31, uint_mt8 m32
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x3_mt8((
        (uint_mt8 m00, uint_mt8 m01, uint_mt8 m02) r0,
        (uint_mt8 m10, uint_mt8 m11, uint_mt8 m12) r1,
        (uint_mt8 m20, uint_mt8 m21, uint_mt8 m22) r2,
        (uint_mt8 m30, uint_mt8 m31, uint_mt8 m32) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint4x3_mt8((
        (uint_mt8 m00, uint_mt8 m01, uint_mt8 m02) r0,
        (uint_mt8 m10, uint_mt8 m11, uint_mt8 m12) r1,
        (uint_mt8 m20, uint_mt8 m21, uint_mt8 m22) r2,
        (uint_mt8 m30, uint_mt8 m31, uint_mt8 m32) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x3_mt8(uint_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x3_mt8(uint value) => (uint_mt8)(value);

    [MethodImpl(256 | 512)]
    public uint4x3_mt8(uint_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x3_mt8(uint4_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public uint4x3_mt8(uint4_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out uint4_mt8 c0, out uint4_mt8 c1, out uint4_mt8 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out uint_mt8 m00, out uint_mt8 m01, out uint_mt8 m02,
        out uint_mt8 m10, out uint_mt8 m11, out uint_mt8 m12,
        out uint_mt8 m20, out uint_mt8 m21, out uint_mt8 m22,
        out uint_mt8 m30, out uint_mt8 m31, out uint_mt8 m32
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
    }

    #endregion // Deconstruct

    #region Index

    public uint4_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public uint_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static uint4x3_mt8 operator~(uint4x3_mt8 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static uint4x3_mt8 operator|(uint4x3_mt8 a, uint4x3_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static uint4x3_mt8 operator&(uint4x3_mt8 a, uint4x3_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static uint4x3_mt8 operator^(uint4x3_mt8 a, uint4x3_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"uint4x3_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // uint4x3_mt8

#region uint4x3_mt16

[CpuOnly]
public partial struct uint4x3_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => uint_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 3); 
    }

    public static uint4x3_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1u, default, default,
            default, 1u, default,
            default, default, 1u,
            default, default, default
        ); 
    }

    #endregion

    #region Fields

    public uint4_mt16 c0;
    public uint4_mt16 c1;
    public uint4_mt16 c2;

    #endregion

    #region Properties

    public uint_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public uint_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public uint_mt16 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public uint_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public uint_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public uint_mt16 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public uint_mt16 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public uint_mt16 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public uint_mt16 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public uint_mt16 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public uint_mt16 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public uint_mt16 m32
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly uint4x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, uint4x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public uint4x3_mt16(uint4_mt16 c0, uint4_mt16 c1, uint4_mt16 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public uint4x3_mt16((uint4_mt16 c0, uint4_mt16 c1, uint4_mt16 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x3_mt16((uint4_mt16 c0, uint4_mt16 c1, uint4_mt16 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint4x3_mt16(
        uint_mt16 m00, uint_mt16 m01, uint_mt16 m02,
        uint_mt16 m10, uint_mt16 m11, uint_mt16 m12,
        uint_mt16 m20, uint_mt16 m21, uint_mt16 m22,
        uint_mt16 m30, uint_mt16 m31, uint_mt16 m32
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x3_mt16((
        uint_mt16 m00, uint_mt16 m01, uint_mt16 m02,
        uint_mt16 m10, uint_mt16 m11, uint_mt16 m12,
        uint_mt16 m20, uint_mt16 m21, uint_mt16 m22,
        uint_mt16 m30, uint_mt16 m31, uint_mt16 m32
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint4x3_mt16((
        uint_mt16 m00, uint_mt16 m01, uint_mt16 m02,
        uint_mt16 m10, uint_mt16 m11, uint_mt16 m12,
        uint_mt16 m20, uint_mt16 m21, uint_mt16 m22,
        uint_mt16 m30, uint_mt16 m31, uint_mt16 m32
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x3_mt16((
        (uint_mt16 m00, uint_mt16 m01, uint_mt16 m02) r0,
        (uint_mt16 m10, uint_mt16 m11, uint_mt16 m12) r1,
        (uint_mt16 m20, uint_mt16 m21, uint_mt16 m22) r2,
        (uint_mt16 m30, uint_mt16 m31, uint_mt16 m32) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint4x3_mt16((
        (uint_mt16 m00, uint_mt16 m01, uint_mt16 m02) r0,
        (uint_mt16 m10, uint_mt16 m11, uint_mt16 m12) r1,
        (uint_mt16 m20, uint_mt16 m21, uint_mt16 m22) r2,
        (uint_mt16 m30, uint_mt16 m31, uint_mt16 m32) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x3_mt16(uint_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x3_mt16(uint value) => (uint_mt16)(value);

    [MethodImpl(256 | 512)]
    public uint4x3_mt16(uint_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x3_mt16(uint4_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public uint4x3_mt16(uint4_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out uint4_mt16 c0, out uint4_mt16 c1, out uint4_mt16 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out uint_mt16 m00, out uint_mt16 m01, out uint_mt16 m02,
        out uint_mt16 m10, out uint_mt16 m11, out uint_mt16 m12,
        out uint_mt16 m20, out uint_mt16 m21, out uint_mt16 m22,
        out uint_mt16 m30, out uint_mt16 m31, out uint_mt16 m32
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
    }

    #endregion // Deconstruct

    #region Index

    public uint4_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public uint_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static uint4x3_mt16 operator~(uint4x3_mt16 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static uint4x3_mt16 operator|(uint4x3_mt16 a, uint4x3_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static uint4x3_mt16 operator&(uint4x3_mt16 a, uint4x3_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static uint4x3_mt16 operator^(uint4x3_mt16 a, uint4x3_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"uint4x3_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // uint4x3_mt16

#region uint4x4_mt4

[CpuOnly]
public partial struct uint4x4_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => uint_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 4); 
    }

    public static uint4x4_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1u, default, default, default,
            default, 1u, default, default,
            default, default, 1u, default,
            default, default, default, 1u
        ); 
    }

    #endregion

    #region Fields

    public uint4_mt4 c0;
    public uint4_mt4 c1;
    public uint4_mt4 c2;
    public uint4_mt4 c3;

    #endregion

    #region Properties

    public uint_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public uint_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public uint_mt4 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public uint_mt4 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public uint_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public uint_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public uint_mt4 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public uint_mt4 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public uint_mt4 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public uint_mt4 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public uint_mt4 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public uint_mt4 m23
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }
    public uint_mt4 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public uint_mt4 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public uint_mt4 m32
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }
    public uint_mt4 m33
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.w;
        [MethodImpl(256 | 512)]
        set => c3.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly uint4x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, uint4x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public uint4x4_mt4(uint4_mt4 c0, uint4_mt4 c1, uint4_mt4 c2, uint4_mt4 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public uint4x4_mt4((uint4_mt4 c0, uint4_mt4 c1, uint4_mt4 c2, uint4_mt4 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x4_mt4((uint4_mt4 c0, uint4_mt4 c1, uint4_mt4 c2, uint4_mt4 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint4x4_mt4(
        uint_mt4 m00, uint_mt4 m01, uint_mt4 m02, uint_mt4 m03,
        uint_mt4 m10, uint_mt4 m11, uint_mt4 m12, uint_mt4 m13,
        uint_mt4 m20, uint_mt4 m21, uint_mt4 m22, uint_mt4 m23,
        uint_mt4 m30, uint_mt4 m31, uint_mt4 m32, uint_mt4 m33
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
        this.c3 = new(m03, m13, m23, m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x4_mt4((
        uint_mt4 m00, uint_mt4 m01, uint_mt4 m02, uint_mt4 m03,
        uint_mt4 m10, uint_mt4 m11, uint_mt4 m12, uint_mt4 m13,
        uint_mt4 m20, uint_mt4 m21, uint_mt4 m22, uint_mt4 m23,
        uint_mt4 m30, uint_mt4 m31, uint_mt4 m32, uint_mt4 m33
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint4x4_mt4((
        uint_mt4 m00, uint_mt4 m01, uint_mt4 m02, uint_mt4 m03,
        uint_mt4 m10, uint_mt4 m11, uint_mt4 m12, uint_mt4 m13,
        uint_mt4 m20, uint_mt4 m21, uint_mt4 m22, uint_mt4 m23,
        uint_mt4 m30, uint_mt4 m31, uint_mt4 m32, uint_mt4 m33
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23, tuple.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x4_mt4((
        (uint_mt4 m00, uint_mt4 m01, uint_mt4 m02, uint_mt4 m03) r0,
        (uint_mt4 m10, uint_mt4 m11, uint_mt4 m12, uint_mt4 m13) r1,
        (uint_mt4 m20, uint_mt4 m21, uint_mt4 m22, uint_mt4 m23) r2,
        (uint_mt4 m30, uint_mt4 m31, uint_mt4 m32, uint_mt4 m33) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint4x4_mt4((
        (uint_mt4 m00, uint_mt4 m01, uint_mt4 m02, uint_mt4 m03) r0,
        (uint_mt4 m10, uint_mt4 m11, uint_mt4 m12, uint_mt4 m13) r1,
        (uint_mt4 m20, uint_mt4 m21, uint_mt4 m22, uint_mt4 m23) r2,
        (uint_mt4 m30, uint_mt4 m31, uint_mt4 m32, uint_mt4 m33) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23, tuple.r3.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x4_mt4(uint_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x4_mt4(uint value) => (uint_mt4)(value);

    [MethodImpl(256 | 512)]
    public uint4x4_mt4(uint_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x4_mt4(uint4_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public uint4x4_mt4(uint4_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out uint4_mt4 c0, out uint4_mt4 c1, out uint4_mt4 c2, out uint4_mt4 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out uint_mt4 m00, out uint_mt4 m01, out uint_mt4 m02, out uint_mt4 m03,
        out uint_mt4 m10, out uint_mt4 m11, out uint_mt4 m12, out uint_mt4 m13,
        out uint_mt4 m20, out uint_mt4 m21, out uint_mt4 m22, out uint_mt4 m23,
        out uint_mt4 m30, out uint_mt4 m31, out uint_mt4 m32, out uint_mt4 m33
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
        this.c3.Deconstruct(out m03, out m13, out m23, out m33);
    }

    #endregion // Deconstruct

    #region Index

    public uint4_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public uint_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static uint4x4_mt4 operator~(uint4x4_mt4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static uint4x4_mt4 operator|(uint4x4_mt4 a, uint4x4_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static uint4x4_mt4 operator&(uint4x4_mt4 a, uint4x4_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static uint4x4_mt4 operator^(uint4x4_mt4 a, uint4x4_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"uint4x4_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // uint4x4_mt4

#region uint4x4_mt8

[CpuOnly]
public partial struct uint4x4_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => uint_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 4); 
    }

    public static uint4x4_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1u, default, default, default,
            default, 1u, default, default,
            default, default, 1u, default,
            default, default, default, 1u
        ); 
    }

    #endregion

    #region Fields

    public uint4_mt8 c0;
    public uint4_mt8 c1;
    public uint4_mt8 c2;
    public uint4_mt8 c3;

    #endregion

    #region Properties

    public uint_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public uint_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public uint_mt8 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public uint_mt8 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public uint_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public uint_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public uint_mt8 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public uint_mt8 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public uint_mt8 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public uint_mt8 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public uint_mt8 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public uint_mt8 m23
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }
    public uint_mt8 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public uint_mt8 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public uint_mt8 m32
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }
    public uint_mt8 m33
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.w;
        [MethodImpl(256 | 512)]
        set => c3.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly uint4x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, uint4x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public uint4x4_mt8(uint4_mt8 c0, uint4_mt8 c1, uint4_mt8 c2, uint4_mt8 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public uint4x4_mt8((uint4_mt8 c0, uint4_mt8 c1, uint4_mt8 c2, uint4_mt8 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x4_mt8((uint4_mt8 c0, uint4_mt8 c1, uint4_mt8 c2, uint4_mt8 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint4x4_mt8(
        uint_mt8 m00, uint_mt8 m01, uint_mt8 m02, uint_mt8 m03,
        uint_mt8 m10, uint_mt8 m11, uint_mt8 m12, uint_mt8 m13,
        uint_mt8 m20, uint_mt8 m21, uint_mt8 m22, uint_mt8 m23,
        uint_mt8 m30, uint_mt8 m31, uint_mt8 m32, uint_mt8 m33
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
        this.c3 = new(m03, m13, m23, m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x4_mt8((
        uint_mt8 m00, uint_mt8 m01, uint_mt8 m02, uint_mt8 m03,
        uint_mt8 m10, uint_mt8 m11, uint_mt8 m12, uint_mt8 m13,
        uint_mt8 m20, uint_mt8 m21, uint_mt8 m22, uint_mt8 m23,
        uint_mt8 m30, uint_mt8 m31, uint_mt8 m32, uint_mt8 m33
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint4x4_mt8((
        uint_mt8 m00, uint_mt8 m01, uint_mt8 m02, uint_mt8 m03,
        uint_mt8 m10, uint_mt8 m11, uint_mt8 m12, uint_mt8 m13,
        uint_mt8 m20, uint_mt8 m21, uint_mt8 m22, uint_mt8 m23,
        uint_mt8 m30, uint_mt8 m31, uint_mt8 m32, uint_mt8 m33
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23, tuple.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x4_mt8((
        (uint_mt8 m00, uint_mt8 m01, uint_mt8 m02, uint_mt8 m03) r0,
        (uint_mt8 m10, uint_mt8 m11, uint_mt8 m12, uint_mt8 m13) r1,
        (uint_mt8 m20, uint_mt8 m21, uint_mt8 m22, uint_mt8 m23) r2,
        (uint_mt8 m30, uint_mt8 m31, uint_mt8 m32, uint_mt8 m33) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint4x4_mt8((
        (uint_mt8 m00, uint_mt8 m01, uint_mt8 m02, uint_mt8 m03) r0,
        (uint_mt8 m10, uint_mt8 m11, uint_mt8 m12, uint_mt8 m13) r1,
        (uint_mt8 m20, uint_mt8 m21, uint_mt8 m22, uint_mt8 m23) r2,
        (uint_mt8 m30, uint_mt8 m31, uint_mt8 m32, uint_mt8 m33) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23, tuple.r3.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x4_mt8(uint_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x4_mt8(uint value) => (uint_mt8)(value);

    [MethodImpl(256 | 512)]
    public uint4x4_mt8(uint_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x4_mt8(uint4_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public uint4x4_mt8(uint4_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out uint4_mt8 c0, out uint4_mt8 c1, out uint4_mt8 c2, out uint4_mt8 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out uint_mt8 m00, out uint_mt8 m01, out uint_mt8 m02, out uint_mt8 m03,
        out uint_mt8 m10, out uint_mt8 m11, out uint_mt8 m12, out uint_mt8 m13,
        out uint_mt8 m20, out uint_mt8 m21, out uint_mt8 m22, out uint_mt8 m23,
        out uint_mt8 m30, out uint_mt8 m31, out uint_mt8 m32, out uint_mt8 m33
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
        this.c3.Deconstruct(out m03, out m13, out m23, out m33);
    }

    #endregion // Deconstruct

    #region Index

    public uint4_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public uint_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static uint4x4_mt8 operator~(uint4x4_mt8 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static uint4x4_mt8 operator|(uint4x4_mt8 a, uint4x4_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static uint4x4_mt8 operator&(uint4x4_mt8 a, uint4x4_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static uint4x4_mt8 operator^(uint4x4_mt8 a, uint4x4_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"uint4x4_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // uint4x4_mt8

#region uint4x4_mt16

[CpuOnly]
public partial struct uint4x4_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => uint_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 4); 
    }

    public static uint4x4_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1u, default, default, default,
            default, 1u, default, default,
            default, default, 1u, default,
            default, default, default, 1u
        ); 
    }

    #endregion

    #region Fields

    public uint4_mt16 c0;
    public uint4_mt16 c1;
    public uint4_mt16 c2;
    public uint4_mt16 c3;

    #endregion

    #region Properties

    public uint_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public uint_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public uint_mt16 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public uint_mt16 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public uint_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public uint_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public uint_mt16 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public uint_mt16 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public uint_mt16 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public uint_mt16 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public uint_mt16 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public uint_mt16 m23
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }
    public uint_mt16 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public uint_mt16 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public uint_mt16 m32
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }
    public uint_mt16 m33
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.w;
        [MethodImpl(256 | 512)]
        set => c3.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly uint4x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, uint4x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public uint4x4_mt16(uint4_mt16 c0, uint4_mt16 c1, uint4_mt16 c2, uint4_mt16 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public uint4x4_mt16((uint4_mt16 c0, uint4_mt16 c1, uint4_mt16 c2, uint4_mt16 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x4_mt16((uint4_mt16 c0, uint4_mt16 c1, uint4_mt16 c2, uint4_mt16 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint4x4_mt16(
        uint_mt16 m00, uint_mt16 m01, uint_mt16 m02, uint_mt16 m03,
        uint_mt16 m10, uint_mt16 m11, uint_mt16 m12, uint_mt16 m13,
        uint_mt16 m20, uint_mt16 m21, uint_mt16 m22, uint_mt16 m23,
        uint_mt16 m30, uint_mt16 m31, uint_mt16 m32, uint_mt16 m33
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
        this.c3 = new(m03, m13, m23, m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x4_mt16((
        uint_mt16 m00, uint_mt16 m01, uint_mt16 m02, uint_mt16 m03,
        uint_mt16 m10, uint_mt16 m11, uint_mt16 m12, uint_mt16 m13,
        uint_mt16 m20, uint_mt16 m21, uint_mt16 m22, uint_mt16 m23,
        uint_mt16 m30, uint_mt16 m31, uint_mt16 m32, uint_mt16 m33
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint4x4_mt16((
        uint_mt16 m00, uint_mt16 m01, uint_mt16 m02, uint_mt16 m03,
        uint_mt16 m10, uint_mt16 m11, uint_mt16 m12, uint_mt16 m13,
        uint_mt16 m20, uint_mt16 m21, uint_mt16 m22, uint_mt16 m23,
        uint_mt16 m30, uint_mt16 m31, uint_mt16 m32, uint_mt16 m33
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23, tuple.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x4_mt16((
        (uint_mt16 m00, uint_mt16 m01, uint_mt16 m02, uint_mt16 m03) r0,
        (uint_mt16 m10, uint_mt16 m11, uint_mt16 m12, uint_mt16 m13) r1,
        (uint_mt16 m20, uint_mt16 m21, uint_mt16 m22, uint_mt16 m23) r2,
        (uint_mt16 m30, uint_mt16 m31, uint_mt16 m32, uint_mt16 m33) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public uint4x4_mt16((
        (uint_mt16 m00, uint_mt16 m01, uint_mt16 m02, uint_mt16 m03) r0,
        (uint_mt16 m10, uint_mt16 m11, uint_mt16 m12, uint_mt16 m13) r1,
        (uint_mt16 m20, uint_mt16 m21, uint_mt16 m22, uint_mt16 m23) r2,
        (uint_mt16 m30, uint_mt16 m31, uint_mt16 m32, uint_mt16 m33) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23, tuple.r3.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x4_mt16(uint_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x4_mt16(uint value) => (uint_mt16)(value);

    [MethodImpl(256 | 512)]
    public uint4x4_mt16(uint_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator uint4x4_mt16(uint4_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public uint4x4_mt16(uint4_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out uint4_mt16 c0, out uint4_mt16 c1, out uint4_mt16 c2, out uint4_mt16 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out uint_mt16 m00, out uint_mt16 m01, out uint_mt16 m02, out uint_mt16 m03,
        out uint_mt16 m10, out uint_mt16 m11, out uint_mt16 m12, out uint_mt16 m13,
        out uint_mt16 m20, out uint_mt16 m21, out uint_mt16 m22, out uint_mt16 m23,
        out uint_mt16 m30, out uint_mt16 m31, out uint_mt16 m32, out uint_mt16 m33
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
        this.c3.Deconstruct(out m03, out m13, out m23, out m33);
    }

    #endregion // Deconstruct

    #region Index

    public uint4_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public uint_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static uint4x4_mt16 operator~(uint4x4_mt16 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static uint4x4_mt16 operator|(uint4x4_mt16 a, uint4x4_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static uint4x4_mt16 operator&(uint4x4_mt16 a, uint4x4_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static uint4x4_mt16 operator^(uint4x4_mt16 a, uint4x4_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"uint4x4_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // uint4x4_mt16

#region long2x2_mt4

[CpuOnly]
public partial struct long2x2_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => long_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 2); 
    }

    public static long2x2_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1L, default,
            default, 1L
        ); 
    }

    #endregion

    #region Fields

    public long2_mt4 c0;
    public long2_mt4 c1;

    #endregion

    #region Properties

    public long_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public long_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public long_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public long_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly long2x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, long2x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public long2x2_mt4(long2_mt4 c0, long2_mt4 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public long2x2_mt4((long2_mt4 c0, long2_mt4 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x2_mt4((long2_mt4 c0, long2_mt4 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long2x2_mt4(
        long_mt4 m00, long_mt4 m01,
        long_mt4 m10, long_mt4 m11
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x2_mt4((
        long_mt4 m00, long_mt4 m01,
        long_mt4 m10, long_mt4 m11
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long2x2_mt4((
        long_mt4 m00, long_mt4 m01,
        long_mt4 m10, long_mt4 m11
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x2_mt4((
        (long_mt4 m00, long_mt4 m01) r0,
        (long_mt4 m10, long_mt4 m11) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long2x2_mt4((
        (long_mt4 m00, long_mt4 m01) r0,
        (long_mt4 m10, long_mt4 m11) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x2_mt4(long_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long2x2_mt4(long value) => (long_mt4)(value);

    [MethodImpl(256 | 512)]
    public long2x2_mt4(long_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x2_mt4(long2_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public long2x2_mt4(long2_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out long2_mt4 c0, out long2_mt4 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out long_mt4 m00, out long_mt4 m01,
        out long_mt4 m10, out long_mt4 m11
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
    }

    #endregion // Deconstruct

    #region Index

    public long2_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public long_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static long2x2_mt4 operator~(long2x2_mt4 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static long2x2_mt4 operator|(long2x2_mt4 a, long2x2_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static long2x2_mt4 operator&(long2x2_mt4 a, long2x2_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static long2x2_mt4 operator^(long2x2_mt4 a, long2x2_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"long2x2_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // long2x2_mt4

#region long2x2_mt8

[CpuOnly]
public partial struct long2x2_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => long_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 2); 
    }

    public static long2x2_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1L, default,
            default, 1L
        ); 
    }

    #endregion

    #region Fields

    public long2_mt8 c0;
    public long2_mt8 c1;

    #endregion

    #region Properties

    public long_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public long_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public long_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public long_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly long2x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, long2x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public long2x2_mt8(long2_mt8 c0, long2_mt8 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public long2x2_mt8((long2_mt8 c0, long2_mt8 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x2_mt8((long2_mt8 c0, long2_mt8 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long2x2_mt8(
        long_mt8 m00, long_mt8 m01,
        long_mt8 m10, long_mt8 m11
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x2_mt8((
        long_mt8 m00, long_mt8 m01,
        long_mt8 m10, long_mt8 m11
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long2x2_mt8((
        long_mt8 m00, long_mt8 m01,
        long_mt8 m10, long_mt8 m11
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x2_mt8((
        (long_mt8 m00, long_mt8 m01) r0,
        (long_mt8 m10, long_mt8 m11) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long2x2_mt8((
        (long_mt8 m00, long_mt8 m01) r0,
        (long_mt8 m10, long_mt8 m11) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x2_mt8(long_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long2x2_mt8(long value) => (long_mt8)(value);

    [MethodImpl(256 | 512)]
    public long2x2_mt8(long_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x2_mt8(long2_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public long2x2_mt8(long2_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out long2_mt8 c0, out long2_mt8 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out long_mt8 m00, out long_mt8 m01,
        out long_mt8 m10, out long_mt8 m11
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
    }

    #endregion // Deconstruct

    #region Index

    public long2_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public long_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static long2x2_mt8 operator~(long2x2_mt8 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static long2x2_mt8 operator|(long2x2_mt8 a, long2x2_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static long2x2_mt8 operator&(long2x2_mt8 a, long2x2_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static long2x2_mt8 operator^(long2x2_mt8 a, long2x2_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"long2x2_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // long2x2_mt8

#region long2x2_mt16

[CpuOnly]
public partial struct long2x2_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => long_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 2); 
    }

    public static long2x2_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1L, default,
            default, 1L
        ); 
    }

    #endregion

    #region Fields

    public long2_mt16 c0;
    public long2_mt16 c1;

    #endregion

    #region Properties

    public long_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public long_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public long_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public long_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly long2x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, long2x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public long2x2_mt16(long2_mt16 c0, long2_mt16 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public long2x2_mt16((long2_mt16 c0, long2_mt16 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x2_mt16((long2_mt16 c0, long2_mt16 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long2x2_mt16(
        long_mt16 m00, long_mt16 m01,
        long_mt16 m10, long_mt16 m11
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x2_mt16((
        long_mt16 m00, long_mt16 m01,
        long_mt16 m10, long_mt16 m11
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long2x2_mt16((
        long_mt16 m00, long_mt16 m01,
        long_mt16 m10, long_mt16 m11
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x2_mt16((
        (long_mt16 m00, long_mt16 m01) r0,
        (long_mt16 m10, long_mt16 m11) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long2x2_mt16((
        (long_mt16 m00, long_mt16 m01) r0,
        (long_mt16 m10, long_mt16 m11) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x2_mt16(long_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long2x2_mt16(long value) => (long_mt16)(value);

    [MethodImpl(256 | 512)]
    public long2x2_mt16(long_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x2_mt16(long2_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public long2x2_mt16(long2_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out long2_mt16 c0, out long2_mt16 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out long_mt16 m00, out long_mt16 m01,
        out long_mt16 m10, out long_mt16 m11
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
    }

    #endregion // Deconstruct

    #region Index

    public long2_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public long_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static long2x2_mt16 operator~(long2x2_mt16 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static long2x2_mt16 operator|(long2x2_mt16 a, long2x2_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static long2x2_mt16 operator&(long2x2_mt16 a, long2x2_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static long2x2_mt16 operator^(long2x2_mt16 a, long2x2_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"long2x2_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // long2x2_mt16

#region long2x3_mt4

[CpuOnly]
public partial struct long2x3_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => long_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 3); 
    }

    public static long2x3_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1L, default, default,
            default, 1L, default
        ); 
    }

    #endregion

    #region Fields

    public long2_mt4 c0;
    public long2_mt4 c1;
    public long2_mt4 c2;

    #endregion

    #region Properties

    public long_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public long_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public long_mt4 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public long_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public long_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public long_mt4 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly long2x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, long2x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public long2x3_mt4(long2_mt4 c0, long2_mt4 c1, long2_mt4 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public long2x3_mt4((long2_mt4 c0, long2_mt4 c1, long2_mt4 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x3_mt4((long2_mt4 c0, long2_mt4 c1, long2_mt4 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long2x3_mt4(
        long_mt4 m00, long_mt4 m01, long_mt4 m02,
        long_mt4 m10, long_mt4 m11, long_mt4 m12
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x3_mt4((
        long_mt4 m00, long_mt4 m01, long_mt4 m02,
        long_mt4 m10, long_mt4 m11, long_mt4 m12
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long2x3_mt4((
        long_mt4 m00, long_mt4 m01, long_mt4 m02,
        long_mt4 m10, long_mt4 m11, long_mt4 m12
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x3_mt4((
        (long_mt4 m00, long_mt4 m01, long_mt4 m02) r0,
        (long_mt4 m10, long_mt4 m11, long_mt4 m12) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long2x3_mt4((
        (long_mt4 m00, long_mt4 m01, long_mt4 m02) r0,
        (long_mt4 m10, long_mt4 m11, long_mt4 m12) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x3_mt4(long_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long2x3_mt4(long value) => (long_mt4)(value);

    [MethodImpl(256 | 512)]
    public long2x3_mt4(long_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x3_mt4(long2_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public long2x3_mt4(long2_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out long2_mt4 c0, out long2_mt4 c1, out long2_mt4 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out long_mt4 m00, out long_mt4 m01, out long_mt4 m02,
        out long_mt4 m10, out long_mt4 m11, out long_mt4 m12
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
    }

    #endregion // Deconstruct

    #region Index

    public long2_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public long_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static long2x3_mt4 operator~(long2x3_mt4 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static long2x3_mt4 operator|(long2x3_mt4 a, long2x3_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static long2x3_mt4 operator&(long2x3_mt4 a, long2x3_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static long2x3_mt4 operator^(long2x3_mt4 a, long2x3_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"long2x3_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // long2x3_mt4

#region long2x3_mt8

[CpuOnly]
public partial struct long2x3_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => long_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 3); 
    }

    public static long2x3_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1L, default, default,
            default, 1L, default
        ); 
    }

    #endregion

    #region Fields

    public long2_mt8 c0;
    public long2_mt8 c1;
    public long2_mt8 c2;

    #endregion

    #region Properties

    public long_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public long_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public long_mt8 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public long_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public long_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public long_mt8 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly long2x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, long2x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public long2x3_mt8(long2_mt8 c0, long2_mt8 c1, long2_mt8 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public long2x3_mt8((long2_mt8 c0, long2_mt8 c1, long2_mt8 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x3_mt8((long2_mt8 c0, long2_mt8 c1, long2_mt8 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long2x3_mt8(
        long_mt8 m00, long_mt8 m01, long_mt8 m02,
        long_mt8 m10, long_mt8 m11, long_mt8 m12
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x3_mt8((
        long_mt8 m00, long_mt8 m01, long_mt8 m02,
        long_mt8 m10, long_mt8 m11, long_mt8 m12
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long2x3_mt8((
        long_mt8 m00, long_mt8 m01, long_mt8 m02,
        long_mt8 m10, long_mt8 m11, long_mt8 m12
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x3_mt8((
        (long_mt8 m00, long_mt8 m01, long_mt8 m02) r0,
        (long_mt8 m10, long_mt8 m11, long_mt8 m12) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long2x3_mt8((
        (long_mt8 m00, long_mt8 m01, long_mt8 m02) r0,
        (long_mt8 m10, long_mt8 m11, long_mt8 m12) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x3_mt8(long_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long2x3_mt8(long value) => (long_mt8)(value);

    [MethodImpl(256 | 512)]
    public long2x3_mt8(long_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x3_mt8(long2_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public long2x3_mt8(long2_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out long2_mt8 c0, out long2_mt8 c1, out long2_mt8 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out long_mt8 m00, out long_mt8 m01, out long_mt8 m02,
        out long_mt8 m10, out long_mt8 m11, out long_mt8 m12
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
    }

    #endregion // Deconstruct

    #region Index

    public long2_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public long_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static long2x3_mt8 operator~(long2x3_mt8 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static long2x3_mt8 operator|(long2x3_mt8 a, long2x3_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static long2x3_mt8 operator&(long2x3_mt8 a, long2x3_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static long2x3_mt8 operator^(long2x3_mt8 a, long2x3_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"long2x3_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // long2x3_mt8

#region long2x3_mt16

[CpuOnly]
public partial struct long2x3_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => long_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 3); 
    }

    public static long2x3_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1L, default, default,
            default, 1L, default
        ); 
    }

    #endregion

    #region Fields

    public long2_mt16 c0;
    public long2_mt16 c1;
    public long2_mt16 c2;

    #endregion

    #region Properties

    public long_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public long_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public long_mt16 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public long_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public long_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public long_mt16 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly long2x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, long2x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public long2x3_mt16(long2_mt16 c0, long2_mt16 c1, long2_mt16 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public long2x3_mt16((long2_mt16 c0, long2_mt16 c1, long2_mt16 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x3_mt16((long2_mt16 c0, long2_mt16 c1, long2_mt16 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long2x3_mt16(
        long_mt16 m00, long_mt16 m01, long_mt16 m02,
        long_mt16 m10, long_mt16 m11, long_mt16 m12
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x3_mt16((
        long_mt16 m00, long_mt16 m01, long_mt16 m02,
        long_mt16 m10, long_mt16 m11, long_mt16 m12
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long2x3_mt16((
        long_mt16 m00, long_mt16 m01, long_mt16 m02,
        long_mt16 m10, long_mt16 m11, long_mt16 m12
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x3_mt16((
        (long_mt16 m00, long_mt16 m01, long_mt16 m02) r0,
        (long_mt16 m10, long_mt16 m11, long_mt16 m12) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long2x3_mt16((
        (long_mt16 m00, long_mt16 m01, long_mt16 m02) r0,
        (long_mt16 m10, long_mt16 m11, long_mt16 m12) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x3_mt16(long_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long2x3_mt16(long value) => (long_mt16)(value);

    [MethodImpl(256 | 512)]
    public long2x3_mt16(long_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x3_mt16(long2_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public long2x3_mt16(long2_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out long2_mt16 c0, out long2_mt16 c1, out long2_mt16 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out long_mt16 m00, out long_mt16 m01, out long_mt16 m02,
        out long_mt16 m10, out long_mt16 m11, out long_mt16 m12
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
    }

    #endregion // Deconstruct

    #region Index

    public long2_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public long_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static long2x3_mt16 operator~(long2x3_mt16 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static long2x3_mt16 operator|(long2x3_mt16 a, long2x3_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static long2x3_mt16 operator&(long2x3_mt16 a, long2x3_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static long2x3_mt16 operator^(long2x3_mt16 a, long2x3_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"long2x3_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // long2x3_mt16

#region long2x4_mt4

[CpuOnly]
public partial struct long2x4_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => long_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 4); 
    }

    public static long2x4_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1L, default, default, default,
            default, 1L, default, default
        ); 
    }

    #endregion

    #region Fields

    public long2_mt4 c0;
    public long2_mt4 c1;
    public long2_mt4 c2;
    public long2_mt4 c3;

    #endregion

    #region Properties

    public long_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public long_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public long_mt4 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public long_mt4 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public long_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public long_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public long_mt4 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public long_mt4 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly long2x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, long2x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public long2x4_mt4(long2_mt4 c0, long2_mt4 c1, long2_mt4 c2, long2_mt4 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public long2x4_mt4((long2_mt4 c0, long2_mt4 c1, long2_mt4 c2, long2_mt4 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x4_mt4((long2_mt4 c0, long2_mt4 c1, long2_mt4 c2, long2_mt4 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long2x4_mt4(
        long_mt4 m00, long_mt4 m01, long_mt4 m02, long_mt4 m03,
        long_mt4 m10, long_mt4 m11, long_mt4 m12, long_mt4 m13
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
        this.c3 = new(m03, m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x4_mt4((
        long_mt4 m00, long_mt4 m01, long_mt4 m02, long_mt4 m03,
        long_mt4 m10, long_mt4 m11, long_mt4 m12, long_mt4 m13
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long2x4_mt4((
        long_mt4 m00, long_mt4 m01, long_mt4 m02, long_mt4 m03,
        long_mt4 m10, long_mt4 m11, long_mt4 m12, long_mt4 m13
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
        this.c3 = new(tuple.m03, tuple.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x4_mt4((
        (long_mt4 m00, long_mt4 m01, long_mt4 m02, long_mt4 m03) r0,
        (long_mt4 m10, long_mt4 m11, long_mt4 m12, long_mt4 m13) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long2x4_mt4((
        (long_mt4 m00, long_mt4 m01, long_mt4 m02, long_mt4 m03) r0,
        (long_mt4 m10, long_mt4 m11, long_mt4 m12, long_mt4 m13) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x4_mt4(long_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long2x4_mt4(long value) => (long_mt4)(value);

    [MethodImpl(256 | 512)]
    public long2x4_mt4(long_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x4_mt4(long2_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public long2x4_mt4(long2_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out long2_mt4 c0, out long2_mt4 c1, out long2_mt4 c2, out long2_mt4 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out long_mt4 m00, out long_mt4 m01, out long_mt4 m02, out long_mt4 m03,
        out long_mt4 m10, out long_mt4 m11, out long_mt4 m12, out long_mt4 m13
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
        this.c3.Deconstruct(out m03, out m13);
    }

    #endregion // Deconstruct

    #region Index

    public long2_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public long_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static long2x4_mt4 operator~(long2x4_mt4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static long2x4_mt4 operator|(long2x4_mt4 a, long2x4_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static long2x4_mt4 operator&(long2x4_mt4 a, long2x4_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static long2x4_mt4 operator^(long2x4_mt4 a, long2x4_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"long2x4_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // long2x4_mt4

#region long2x4_mt8

[CpuOnly]
public partial struct long2x4_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => long_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 4); 
    }

    public static long2x4_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1L, default, default, default,
            default, 1L, default, default
        ); 
    }

    #endregion

    #region Fields

    public long2_mt8 c0;
    public long2_mt8 c1;
    public long2_mt8 c2;
    public long2_mt8 c3;

    #endregion

    #region Properties

    public long_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public long_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public long_mt8 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public long_mt8 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public long_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public long_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public long_mt8 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public long_mt8 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly long2x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, long2x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public long2x4_mt8(long2_mt8 c0, long2_mt8 c1, long2_mt8 c2, long2_mt8 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public long2x4_mt8((long2_mt8 c0, long2_mt8 c1, long2_mt8 c2, long2_mt8 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x4_mt8((long2_mt8 c0, long2_mt8 c1, long2_mt8 c2, long2_mt8 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long2x4_mt8(
        long_mt8 m00, long_mt8 m01, long_mt8 m02, long_mt8 m03,
        long_mt8 m10, long_mt8 m11, long_mt8 m12, long_mt8 m13
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
        this.c3 = new(m03, m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x4_mt8((
        long_mt8 m00, long_mt8 m01, long_mt8 m02, long_mt8 m03,
        long_mt8 m10, long_mt8 m11, long_mt8 m12, long_mt8 m13
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long2x4_mt8((
        long_mt8 m00, long_mt8 m01, long_mt8 m02, long_mt8 m03,
        long_mt8 m10, long_mt8 m11, long_mt8 m12, long_mt8 m13
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
        this.c3 = new(tuple.m03, tuple.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x4_mt8((
        (long_mt8 m00, long_mt8 m01, long_mt8 m02, long_mt8 m03) r0,
        (long_mt8 m10, long_mt8 m11, long_mt8 m12, long_mt8 m13) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long2x4_mt8((
        (long_mt8 m00, long_mt8 m01, long_mt8 m02, long_mt8 m03) r0,
        (long_mt8 m10, long_mt8 m11, long_mt8 m12, long_mt8 m13) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x4_mt8(long_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long2x4_mt8(long value) => (long_mt8)(value);

    [MethodImpl(256 | 512)]
    public long2x4_mt8(long_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x4_mt8(long2_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public long2x4_mt8(long2_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out long2_mt8 c0, out long2_mt8 c1, out long2_mt8 c2, out long2_mt8 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out long_mt8 m00, out long_mt8 m01, out long_mt8 m02, out long_mt8 m03,
        out long_mt8 m10, out long_mt8 m11, out long_mt8 m12, out long_mt8 m13
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
        this.c3.Deconstruct(out m03, out m13);
    }

    #endregion // Deconstruct

    #region Index

    public long2_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public long_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static long2x4_mt8 operator~(long2x4_mt8 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static long2x4_mt8 operator|(long2x4_mt8 a, long2x4_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static long2x4_mt8 operator&(long2x4_mt8 a, long2x4_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static long2x4_mt8 operator^(long2x4_mt8 a, long2x4_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"long2x4_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // long2x4_mt8

#region long2x4_mt16

[CpuOnly]
public partial struct long2x4_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => long_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 4); 
    }

    public static long2x4_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1L, default, default, default,
            default, 1L, default, default
        ); 
    }

    #endregion

    #region Fields

    public long2_mt16 c0;
    public long2_mt16 c1;
    public long2_mt16 c2;
    public long2_mt16 c3;

    #endregion

    #region Properties

    public long_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public long_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public long_mt16 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public long_mt16 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public long_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public long_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public long_mt16 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public long_mt16 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly long2x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, long2x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public long2x4_mt16(long2_mt16 c0, long2_mt16 c1, long2_mt16 c2, long2_mt16 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public long2x4_mt16((long2_mt16 c0, long2_mt16 c1, long2_mt16 c2, long2_mt16 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x4_mt16((long2_mt16 c0, long2_mt16 c1, long2_mt16 c2, long2_mt16 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long2x4_mt16(
        long_mt16 m00, long_mt16 m01, long_mt16 m02, long_mt16 m03,
        long_mt16 m10, long_mt16 m11, long_mt16 m12, long_mt16 m13
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
        this.c3 = new(m03, m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x4_mt16((
        long_mt16 m00, long_mt16 m01, long_mt16 m02, long_mt16 m03,
        long_mt16 m10, long_mt16 m11, long_mt16 m12, long_mt16 m13
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long2x4_mt16((
        long_mt16 m00, long_mt16 m01, long_mt16 m02, long_mt16 m03,
        long_mt16 m10, long_mt16 m11, long_mt16 m12, long_mt16 m13
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
        this.c3 = new(tuple.m03, tuple.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x4_mt16((
        (long_mt16 m00, long_mt16 m01, long_mt16 m02, long_mt16 m03) r0,
        (long_mt16 m10, long_mt16 m11, long_mt16 m12, long_mt16 m13) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long2x4_mt16((
        (long_mt16 m00, long_mt16 m01, long_mt16 m02, long_mt16 m03) r0,
        (long_mt16 m10, long_mt16 m11, long_mt16 m12, long_mt16 m13) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x4_mt16(long_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long2x4_mt16(long value) => (long_mt16)(value);

    [MethodImpl(256 | 512)]
    public long2x4_mt16(long_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long2x4_mt16(long2_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public long2x4_mt16(long2_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out long2_mt16 c0, out long2_mt16 c1, out long2_mt16 c2, out long2_mt16 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out long_mt16 m00, out long_mt16 m01, out long_mt16 m02, out long_mt16 m03,
        out long_mt16 m10, out long_mt16 m11, out long_mt16 m12, out long_mt16 m13
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
        this.c3.Deconstruct(out m03, out m13);
    }

    #endregion // Deconstruct

    #region Index

    public long2_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public long_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static long2x4_mt16 operator~(long2x4_mt16 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static long2x4_mt16 operator|(long2x4_mt16 a, long2x4_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static long2x4_mt16 operator&(long2x4_mt16 a, long2x4_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static long2x4_mt16 operator^(long2x4_mt16 a, long2x4_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"long2x4_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // long2x4_mt16

#region long3x2_mt4

[CpuOnly]
public partial struct long3x2_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => long_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 2); 
    }

    public static long3x2_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1L, default,
            default, 1L,
            default, default
        ); 
    }

    #endregion

    #region Fields

    public long3_mt4 c0;
    public long3_mt4 c1;

    #endregion

    #region Properties

    public long_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public long_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public long_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public long_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public long_mt4 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public long_mt4 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly long3x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, long3x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public long3x2_mt4(long3_mt4 c0, long3_mt4 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public long3x2_mt4((long3_mt4 c0, long3_mt4 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x2_mt4((long3_mt4 c0, long3_mt4 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long3x2_mt4(
        long_mt4 m00, long_mt4 m01,
        long_mt4 m10, long_mt4 m11,
        long_mt4 m20, long_mt4 m21
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x2_mt4((
        long_mt4 m00, long_mt4 m01,
        long_mt4 m10, long_mt4 m11,
        long_mt4 m20, long_mt4 m21
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long3x2_mt4((
        long_mt4 m00, long_mt4 m01,
        long_mt4 m10, long_mt4 m11,
        long_mt4 m20, long_mt4 m21
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x2_mt4((
        (long_mt4 m00, long_mt4 m01) r0,
        (long_mt4 m10, long_mt4 m11) r1,
        (long_mt4 m20, long_mt4 m21) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long3x2_mt4((
        (long_mt4 m00, long_mt4 m01) r0,
        (long_mt4 m10, long_mt4 m11) r1,
        (long_mt4 m20, long_mt4 m21) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x2_mt4(long_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long3x2_mt4(long value) => (long_mt4)(value);

    [MethodImpl(256 | 512)]
    public long3x2_mt4(long_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x2_mt4(long3_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public long3x2_mt4(long3_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out long3_mt4 c0, out long3_mt4 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out long_mt4 m00, out long_mt4 m01,
        out long_mt4 m10, out long_mt4 m11,
        out long_mt4 m20, out long_mt4 m21
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
    }

    #endregion // Deconstruct

    #region Index

    public long3_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public long_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static long3x2_mt4 operator~(long3x2_mt4 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static long3x2_mt4 operator|(long3x2_mt4 a, long3x2_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static long3x2_mt4 operator&(long3x2_mt4 a, long3x2_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static long3x2_mt4 operator^(long3x2_mt4 a, long3x2_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"long3x2_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // long3x2_mt4

#region long3x2_mt8

[CpuOnly]
public partial struct long3x2_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => long_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 2); 
    }

    public static long3x2_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1L, default,
            default, 1L,
            default, default
        ); 
    }

    #endregion

    #region Fields

    public long3_mt8 c0;
    public long3_mt8 c1;

    #endregion

    #region Properties

    public long_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public long_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public long_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public long_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public long_mt8 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public long_mt8 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly long3x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, long3x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public long3x2_mt8(long3_mt8 c0, long3_mt8 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public long3x2_mt8((long3_mt8 c0, long3_mt8 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x2_mt8((long3_mt8 c0, long3_mt8 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long3x2_mt8(
        long_mt8 m00, long_mt8 m01,
        long_mt8 m10, long_mt8 m11,
        long_mt8 m20, long_mt8 m21
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x2_mt8((
        long_mt8 m00, long_mt8 m01,
        long_mt8 m10, long_mt8 m11,
        long_mt8 m20, long_mt8 m21
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long3x2_mt8((
        long_mt8 m00, long_mt8 m01,
        long_mt8 m10, long_mt8 m11,
        long_mt8 m20, long_mt8 m21
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x2_mt8((
        (long_mt8 m00, long_mt8 m01) r0,
        (long_mt8 m10, long_mt8 m11) r1,
        (long_mt8 m20, long_mt8 m21) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long3x2_mt8((
        (long_mt8 m00, long_mt8 m01) r0,
        (long_mt8 m10, long_mt8 m11) r1,
        (long_mt8 m20, long_mt8 m21) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x2_mt8(long_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long3x2_mt8(long value) => (long_mt8)(value);

    [MethodImpl(256 | 512)]
    public long3x2_mt8(long_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x2_mt8(long3_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public long3x2_mt8(long3_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out long3_mt8 c0, out long3_mt8 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out long_mt8 m00, out long_mt8 m01,
        out long_mt8 m10, out long_mt8 m11,
        out long_mt8 m20, out long_mt8 m21
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
    }

    #endregion // Deconstruct

    #region Index

    public long3_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public long_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static long3x2_mt8 operator~(long3x2_mt8 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static long3x2_mt8 operator|(long3x2_mt8 a, long3x2_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static long3x2_mt8 operator&(long3x2_mt8 a, long3x2_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static long3x2_mt8 operator^(long3x2_mt8 a, long3x2_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"long3x2_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // long3x2_mt8

#region long3x2_mt16

[CpuOnly]
public partial struct long3x2_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => long_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 2); 
    }

    public static long3x2_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1L, default,
            default, 1L,
            default, default
        ); 
    }

    #endregion

    #region Fields

    public long3_mt16 c0;
    public long3_mt16 c1;

    #endregion

    #region Properties

    public long_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public long_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public long_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public long_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public long_mt16 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public long_mt16 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly long3x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, long3x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public long3x2_mt16(long3_mt16 c0, long3_mt16 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public long3x2_mt16((long3_mt16 c0, long3_mt16 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x2_mt16((long3_mt16 c0, long3_mt16 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long3x2_mt16(
        long_mt16 m00, long_mt16 m01,
        long_mt16 m10, long_mt16 m11,
        long_mt16 m20, long_mt16 m21
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x2_mt16((
        long_mt16 m00, long_mt16 m01,
        long_mt16 m10, long_mt16 m11,
        long_mt16 m20, long_mt16 m21
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long3x2_mt16((
        long_mt16 m00, long_mt16 m01,
        long_mt16 m10, long_mt16 m11,
        long_mt16 m20, long_mt16 m21
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x2_mt16((
        (long_mt16 m00, long_mt16 m01) r0,
        (long_mt16 m10, long_mt16 m11) r1,
        (long_mt16 m20, long_mt16 m21) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long3x2_mt16((
        (long_mt16 m00, long_mt16 m01) r0,
        (long_mt16 m10, long_mt16 m11) r1,
        (long_mt16 m20, long_mt16 m21) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x2_mt16(long_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long3x2_mt16(long value) => (long_mt16)(value);

    [MethodImpl(256 | 512)]
    public long3x2_mt16(long_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x2_mt16(long3_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public long3x2_mt16(long3_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out long3_mt16 c0, out long3_mt16 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out long_mt16 m00, out long_mt16 m01,
        out long_mt16 m10, out long_mt16 m11,
        out long_mt16 m20, out long_mt16 m21
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
    }

    #endregion // Deconstruct

    #region Index

    public long3_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public long_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static long3x2_mt16 operator~(long3x2_mt16 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static long3x2_mt16 operator|(long3x2_mt16 a, long3x2_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static long3x2_mt16 operator&(long3x2_mt16 a, long3x2_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static long3x2_mt16 operator^(long3x2_mt16 a, long3x2_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"long3x2_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // long3x2_mt16

#region long3x3_mt4

[CpuOnly]
public partial struct long3x3_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => long_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 9; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 3); 
    }

    public static long3x3_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1L, default, default,
            default, 1L, default,
            default, default, 1L
        ); 
    }

    #endregion

    #region Fields

    public long3_mt4 c0;
    public long3_mt4 c1;
    public long3_mt4 c2;

    #endregion

    #region Properties

    public long_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public long_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public long_mt4 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public long_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public long_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public long_mt4 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public long_mt4 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public long_mt4 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public long_mt4 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly long3x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, long3x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public long3x3_mt4(long3_mt4 c0, long3_mt4 c1, long3_mt4 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public long3x3_mt4((long3_mt4 c0, long3_mt4 c1, long3_mt4 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x3_mt4((long3_mt4 c0, long3_mt4 c1, long3_mt4 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long3x3_mt4(
        long_mt4 m00, long_mt4 m01, long_mt4 m02,
        long_mt4 m10, long_mt4 m11, long_mt4 m12,
        long_mt4 m20, long_mt4 m21, long_mt4 m22
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x3_mt4((
        long_mt4 m00, long_mt4 m01, long_mt4 m02,
        long_mt4 m10, long_mt4 m11, long_mt4 m12,
        long_mt4 m20, long_mt4 m21, long_mt4 m22
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long3x3_mt4((
        long_mt4 m00, long_mt4 m01, long_mt4 m02,
        long_mt4 m10, long_mt4 m11, long_mt4 m12,
        long_mt4 m20, long_mt4 m21, long_mt4 m22
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x3_mt4((
        (long_mt4 m00, long_mt4 m01, long_mt4 m02) r0,
        (long_mt4 m10, long_mt4 m11, long_mt4 m12) r1,
        (long_mt4 m20, long_mt4 m21, long_mt4 m22) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long3x3_mt4((
        (long_mt4 m00, long_mt4 m01, long_mt4 m02) r0,
        (long_mt4 m10, long_mt4 m11, long_mt4 m12) r1,
        (long_mt4 m20, long_mt4 m21, long_mt4 m22) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x3_mt4(long_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long3x3_mt4(long value) => (long_mt4)(value);

    [MethodImpl(256 | 512)]
    public long3x3_mt4(long_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x3_mt4(long3_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public long3x3_mt4(long3_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out long3_mt4 c0, out long3_mt4 c1, out long3_mt4 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out long_mt4 m00, out long_mt4 m01, out long_mt4 m02,
        out long_mt4 m10, out long_mt4 m11, out long_mt4 m12,
        out long_mt4 m20, out long_mt4 m21, out long_mt4 m22
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
    }

    #endregion // Deconstruct

    #region Index

    public long3_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public long_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static long3x3_mt4 operator~(long3x3_mt4 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static long3x3_mt4 operator|(long3x3_mt4 a, long3x3_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static long3x3_mt4 operator&(long3x3_mt4 a, long3x3_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static long3x3_mt4 operator^(long3x3_mt4 a, long3x3_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"long3x3_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // long3x3_mt4

#region long3x3_mt8

[CpuOnly]
public partial struct long3x3_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => long_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 9; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 3); 
    }

    public static long3x3_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1L, default, default,
            default, 1L, default,
            default, default, 1L
        ); 
    }

    #endregion

    #region Fields

    public long3_mt8 c0;
    public long3_mt8 c1;
    public long3_mt8 c2;

    #endregion

    #region Properties

    public long_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public long_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public long_mt8 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public long_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public long_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public long_mt8 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public long_mt8 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public long_mt8 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public long_mt8 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly long3x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, long3x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public long3x3_mt8(long3_mt8 c0, long3_mt8 c1, long3_mt8 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public long3x3_mt8((long3_mt8 c0, long3_mt8 c1, long3_mt8 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x3_mt8((long3_mt8 c0, long3_mt8 c1, long3_mt8 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long3x3_mt8(
        long_mt8 m00, long_mt8 m01, long_mt8 m02,
        long_mt8 m10, long_mt8 m11, long_mt8 m12,
        long_mt8 m20, long_mt8 m21, long_mt8 m22
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x3_mt8((
        long_mt8 m00, long_mt8 m01, long_mt8 m02,
        long_mt8 m10, long_mt8 m11, long_mt8 m12,
        long_mt8 m20, long_mt8 m21, long_mt8 m22
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long3x3_mt8((
        long_mt8 m00, long_mt8 m01, long_mt8 m02,
        long_mt8 m10, long_mt8 m11, long_mt8 m12,
        long_mt8 m20, long_mt8 m21, long_mt8 m22
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x3_mt8((
        (long_mt8 m00, long_mt8 m01, long_mt8 m02) r0,
        (long_mt8 m10, long_mt8 m11, long_mt8 m12) r1,
        (long_mt8 m20, long_mt8 m21, long_mt8 m22) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long3x3_mt8((
        (long_mt8 m00, long_mt8 m01, long_mt8 m02) r0,
        (long_mt8 m10, long_mt8 m11, long_mt8 m12) r1,
        (long_mt8 m20, long_mt8 m21, long_mt8 m22) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x3_mt8(long_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long3x3_mt8(long value) => (long_mt8)(value);

    [MethodImpl(256 | 512)]
    public long3x3_mt8(long_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x3_mt8(long3_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public long3x3_mt8(long3_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out long3_mt8 c0, out long3_mt8 c1, out long3_mt8 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out long_mt8 m00, out long_mt8 m01, out long_mt8 m02,
        out long_mt8 m10, out long_mt8 m11, out long_mt8 m12,
        out long_mt8 m20, out long_mt8 m21, out long_mt8 m22
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
    }

    #endregion // Deconstruct

    #region Index

    public long3_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public long_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static long3x3_mt8 operator~(long3x3_mt8 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static long3x3_mt8 operator|(long3x3_mt8 a, long3x3_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static long3x3_mt8 operator&(long3x3_mt8 a, long3x3_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static long3x3_mt8 operator^(long3x3_mt8 a, long3x3_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"long3x3_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // long3x3_mt8

#region long3x3_mt16

[CpuOnly]
public partial struct long3x3_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => long_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 9; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 3); 
    }

    public static long3x3_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1L, default, default,
            default, 1L, default,
            default, default, 1L
        ); 
    }

    #endregion

    #region Fields

    public long3_mt16 c0;
    public long3_mt16 c1;
    public long3_mt16 c2;

    #endregion

    #region Properties

    public long_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public long_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public long_mt16 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public long_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public long_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public long_mt16 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public long_mt16 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public long_mt16 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public long_mt16 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly long3x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, long3x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public long3x3_mt16(long3_mt16 c0, long3_mt16 c1, long3_mt16 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public long3x3_mt16((long3_mt16 c0, long3_mt16 c1, long3_mt16 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x3_mt16((long3_mt16 c0, long3_mt16 c1, long3_mt16 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long3x3_mt16(
        long_mt16 m00, long_mt16 m01, long_mt16 m02,
        long_mt16 m10, long_mt16 m11, long_mt16 m12,
        long_mt16 m20, long_mt16 m21, long_mt16 m22
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x3_mt16((
        long_mt16 m00, long_mt16 m01, long_mt16 m02,
        long_mt16 m10, long_mt16 m11, long_mt16 m12,
        long_mt16 m20, long_mt16 m21, long_mt16 m22
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long3x3_mt16((
        long_mt16 m00, long_mt16 m01, long_mt16 m02,
        long_mt16 m10, long_mt16 m11, long_mt16 m12,
        long_mt16 m20, long_mt16 m21, long_mt16 m22
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x3_mt16((
        (long_mt16 m00, long_mt16 m01, long_mt16 m02) r0,
        (long_mt16 m10, long_mt16 m11, long_mt16 m12) r1,
        (long_mt16 m20, long_mt16 m21, long_mt16 m22) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long3x3_mt16((
        (long_mt16 m00, long_mt16 m01, long_mt16 m02) r0,
        (long_mt16 m10, long_mt16 m11, long_mt16 m12) r1,
        (long_mt16 m20, long_mt16 m21, long_mt16 m22) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x3_mt16(long_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long3x3_mt16(long value) => (long_mt16)(value);

    [MethodImpl(256 | 512)]
    public long3x3_mt16(long_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x3_mt16(long3_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public long3x3_mt16(long3_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out long3_mt16 c0, out long3_mt16 c1, out long3_mt16 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out long_mt16 m00, out long_mt16 m01, out long_mt16 m02,
        out long_mt16 m10, out long_mt16 m11, out long_mt16 m12,
        out long_mt16 m20, out long_mt16 m21, out long_mt16 m22
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
    }

    #endregion // Deconstruct

    #region Index

    public long3_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public long_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static long3x3_mt16 operator~(long3x3_mt16 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static long3x3_mt16 operator|(long3x3_mt16 a, long3x3_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static long3x3_mt16 operator&(long3x3_mt16 a, long3x3_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static long3x3_mt16 operator^(long3x3_mt16 a, long3x3_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"long3x3_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // long3x3_mt16

#region long3x4_mt4

[CpuOnly]
public partial struct long3x4_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => long_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 4); 
    }

    public static long3x4_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1L, default, default, default,
            default, 1L, default, default,
            default, default, 1L, default
        ); 
    }

    #endregion

    #region Fields

    public long3_mt4 c0;
    public long3_mt4 c1;
    public long3_mt4 c2;
    public long3_mt4 c3;

    #endregion

    #region Properties

    public long_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public long_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public long_mt4 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public long_mt4 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public long_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public long_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public long_mt4 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public long_mt4 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public long_mt4 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public long_mt4 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public long_mt4 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public long_mt4 m23
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly long3x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, long3x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public long3x4_mt4(long3_mt4 c0, long3_mt4 c1, long3_mt4 c2, long3_mt4 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public long3x4_mt4((long3_mt4 c0, long3_mt4 c1, long3_mt4 c2, long3_mt4 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x4_mt4((long3_mt4 c0, long3_mt4 c1, long3_mt4 c2, long3_mt4 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long3x4_mt4(
        long_mt4 m00, long_mt4 m01, long_mt4 m02, long_mt4 m03,
        long_mt4 m10, long_mt4 m11, long_mt4 m12, long_mt4 m13,
        long_mt4 m20, long_mt4 m21, long_mt4 m22, long_mt4 m23
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
        this.c3 = new(m03, m13, m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x4_mt4((
        long_mt4 m00, long_mt4 m01, long_mt4 m02, long_mt4 m03,
        long_mt4 m10, long_mt4 m11, long_mt4 m12, long_mt4 m13,
        long_mt4 m20, long_mt4 m21, long_mt4 m22, long_mt4 m23
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long3x4_mt4((
        long_mt4 m00, long_mt4 m01, long_mt4 m02, long_mt4 m03,
        long_mt4 m10, long_mt4 m11, long_mt4 m12, long_mt4 m13,
        long_mt4 m20, long_mt4 m21, long_mt4 m22, long_mt4 m23
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x4_mt4((
        (long_mt4 m00, long_mt4 m01, long_mt4 m02, long_mt4 m03) r0,
        (long_mt4 m10, long_mt4 m11, long_mt4 m12, long_mt4 m13) r1,
        (long_mt4 m20, long_mt4 m21, long_mt4 m22, long_mt4 m23) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long3x4_mt4((
        (long_mt4 m00, long_mt4 m01, long_mt4 m02, long_mt4 m03) r0,
        (long_mt4 m10, long_mt4 m11, long_mt4 m12, long_mt4 m13) r1,
        (long_mt4 m20, long_mt4 m21, long_mt4 m22, long_mt4 m23) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x4_mt4(long_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long3x4_mt4(long value) => (long_mt4)(value);

    [MethodImpl(256 | 512)]
    public long3x4_mt4(long_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x4_mt4(long3_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public long3x4_mt4(long3_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out long3_mt4 c0, out long3_mt4 c1, out long3_mt4 c2, out long3_mt4 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out long_mt4 m00, out long_mt4 m01, out long_mt4 m02, out long_mt4 m03,
        out long_mt4 m10, out long_mt4 m11, out long_mt4 m12, out long_mt4 m13,
        out long_mt4 m20, out long_mt4 m21, out long_mt4 m22, out long_mt4 m23
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
        this.c3.Deconstruct(out m03, out m13, out m23);
    }

    #endregion // Deconstruct

    #region Index

    public long3_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public long_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static long3x4_mt4 operator~(long3x4_mt4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static long3x4_mt4 operator|(long3x4_mt4 a, long3x4_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static long3x4_mt4 operator&(long3x4_mt4 a, long3x4_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static long3x4_mt4 operator^(long3x4_mt4 a, long3x4_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"long3x4_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // long3x4_mt4

#region long3x4_mt8

[CpuOnly]
public partial struct long3x4_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => long_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 4); 
    }

    public static long3x4_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1L, default, default, default,
            default, 1L, default, default,
            default, default, 1L, default
        ); 
    }

    #endregion

    #region Fields

    public long3_mt8 c0;
    public long3_mt8 c1;
    public long3_mt8 c2;
    public long3_mt8 c3;

    #endregion

    #region Properties

    public long_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public long_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public long_mt8 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public long_mt8 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public long_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public long_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public long_mt8 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public long_mt8 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public long_mt8 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public long_mt8 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public long_mt8 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public long_mt8 m23
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly long3x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, long3x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public long3x4_mt8(long3_mt8 c0, long3_mt8 c1, long3_mt8 c2, long3_mt8 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public long3x4_mt8((long3_mt8 c0, long3_mt8 c1, long3_mt8 c2, long3_mt8 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x4_mt8((long3_mt8 c0, long3_mt8 c1, long3_mt8 c2, long3_mt8 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long3x4_mt8(
        long_mt8 m00, long_mt8 m01, long_mt8 m02, long_mt8 m03,
        long_mt8 m10, long_mt8 m11, long_mt8 m12, long_mt8 m13,
        long_mt8 m20, long_mt8 m21, long_mt8 m22, long_mt8 m23
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
        this.c3 = new(m03, m13, m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x4_mt8((
        long_mt8 m00, long_mt8 m01, long_mt8 m02, long_mt8 m03,
        long_mt8 m10, long_mt8 m11, long_mt8 m12, long_mt8 m13,
        long_mt8 m20, long_mt8 m21, long_mt8 m22, long_mt8 m23
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long3x4_mt8((
        long_mt8 m00, long_mt8 m01, long_mt8 m02, long_mt8 m03,
        long_mt8 m10, long_mt8 m11, long_mt8 m12, long_mt8 m13,
        long_mt8 m20, long_mt8 m21, long_mt8 m22, long_mt8 m23
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x4_mt8((
        (long_mt8 m00, long_mt8 m01, long_mt8 m02, long_mt8 m03) r0,
        (long_mt8 m10, long_mt8 m11, long_mt8 m12, long_mt8 m13) r1,
        (long_mt8 m20, long_mt8 m21, long_mt8 m22, long_mt8 m23) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long3x4_mt8((
        (long_mt8 m00, long_mt8 m01, long_mt8 m02, long_mt8 m03) r0,
        (long_mt8 m10, long_mt8 m11, long_mt8 m12, long_mt8 m13) r1,
        (long_mt8 m20, long_mt8 m21, long_mt8 m22, long_mt8 m23) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x4_mt8(long_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long3x4_mt8(long value) => (long_mt8)(value);

    [MethodImpl(256 | 512)]
    public long3x4_mt8(long_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x4_mt8(long3_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public long3x4_mt8(long3_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out long3_mt8 c0, out long3_mt8 c1, out long3_mt8 c2, out long3_mt8 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out long_mt8 m00, out long_mt8 m01, out long_mt8 m02, out long_mt8 m03,
        out long_mt8 m10, out long_mt8 m11, out long_mt8 m12, out long_mt8 m13,
        out long_mt8 m20, out long_mt8 m21, out long_mt8 m22, out long_mt8 m23
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
        this.c3.Deconstruct(out m03, out m13, out m23);
    }

    #endregion // Deconstruct

    #region Index

    public long3_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public long_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static long3x4_mt8 operator~(long3x4_mt8 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static long3x4_mt8 operator|(long3x4_mt8 a, long3x4_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static long3x4_mt8 operator&(long3x4_mt8 a, long3x4_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static long3x4_mt8 operator^(long3x4_mt8 a, long3x4_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"long3x4_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // long3x4_mt8

#region long3x4_mt16

[CpuOnly]
public partial struct long3x4_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => long_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 4); 
    }

    public static long3x4_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1L, default, default, default,
            default, 1L, default, default,
            default, default, 1L, default
        ); 
    }

    #endregion

    #region Fields

    public long3_mt16 c0;
    public long3_mt16 c1;
    public long3_mt16 c2;
    public long3_mt16 c3;

    #endregion

    #region Properties

    public long_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public long_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public long_mt16 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public long_mt16 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public long_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public long_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public long_mt16 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public long_mt16 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public long_mt16 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public long_mt16 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public long_mt16 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public long_mt16 m23
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly long3x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, long3x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public long3x4_mt16(long3_mt16 c0, long3_mt16 c1, long3_mt16 c2, long3_mt16 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public long3x4_mt16((long3_mt16 c0, long3_mt16 c1, long3_mt16 c2, long3_mt16 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x4_mt16((long3_mt16 c0, long3_mt16 c1, long3_mt16 c2, long3_mt16 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long3x4_mt16(
        long_mt16 m00, long_mt16 m01, long_mt16 m02, long_mt16 m03,
        long_mt16 m10, long_mt16 m11, long_mt16 m12, long_mt16 m13,
        long_mt16 m20, long_mt16 m21, long_mt16 m22, long_mt16 m23
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
        this.c3 = new(m03, m13, m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x4_mt16((
        long_mt16 m00, long_mt16 m01, long_mt16 m02, long_mt16 m03,
        long_mt16 m10, long_mt16 m11, long_mt16 m12, long_mt16 m13,
        long_mt16 m20, long_mt16 m21, long_mt16 m22, long_mt16 m23
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long3x4_mt16((
        long_mt16 m00, long_mt16 m01, long_mt16 m02, long_mt16 m03,
        long_mt16 m10, long_mt16 m11, long_mt16 m12, long_mt16 m13,
        long_mt16 m20, long_mt16 m21, long_mt16 m22, long_mt16 m23
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x4_mt16((
        (long_mt16 m00, long_mt16 m01, long_mt16 m02, long_mt16 m03) r0,
        (long_mt16 m10, long_mt16 m11, long_mt16 m12, long_mt16 m13) r1,
        (long_mt16 m20, long_mt16 m21, long_mt16 m22, long_mt16 m23) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long3x4_mt16((
        (long_mt16 m00, long_mt16 m01, long_mt16 m02, long_mt16 m03) r0,
        (long_mt16 m10, long_mt16 m11, long_mt16 m12, long_mt16 m13) r1,
        (long_mt16 m20, long_mt16 m21, long_mt16 m22, long_mt16 m23) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x4_mt16(long_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long3x4_mt16(long value) => (long_mt16)(value);

    [MethodImpl(256 | 512)]
    public long3x4_mt16(long_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long3x4_mt16(long3_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public long3x4_mt16(long3_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out long3_mt16 c0, out long3_mt16 c1, out long3_mt16 c2, out long3_mt16 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out long_mt16 m00, out long_mt16 m01, out long_mt16 m02, out long_mt16 m03,
        out long_mt16 m10, out long_mt16 m11, out long_mt16 m12, out long_mt16 m13,
        out long_mt16 m20, out long_mt16 m21, out long_mt16 m22, out long_mt16 m23
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
        this.c3.Deconstruct(out m03, out m13, out m23);
    }

    #endregion // Deconstruct

    #region Index

    public long3_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public long_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static long3x4_mt16 operator~(long3x4_mt16 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static long3x4_mt16 operator|(long3x4_mt16 a, long3x4_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static long3x4_mt16 operator&(long3x4_mt16 a, long3x4_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static long3x4_mt16 operator^(long3x4_mt16 a, long3x4_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"long3x4_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // long3x4_mt16

#region long4x2_mt4

[CpuOnly]
public partial struct long4x2_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => long_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 2); 
    }

    public static long4x2_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1L, default,
            default, 1L,
            default, default,
            default, default
        ); 
    }

    #endregion

    #region Fields

    public long4_mt4 c0;
    public long4_mt4 c1;

    #endregion

    #region Properties

    public long_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public long_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public long_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public long_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public long_mt4 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public long_mt4 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public long_mt4 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public long_mt4 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly long4x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, long4x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public long4x2_mt4(long4_mt4 c0, long4_mt4 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public long4x2_mt4((long4_mt4 c0, long4_mt4 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x2_mt4((long4_mt4 c0, long4_mt4 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long4x2_mt4(
        long_mt4 m00, long_mt4 m01,
        long_mt4 m10, long_mt4 m11,
        long_mt4 m20, long_mt4 m21,
        long_mt4 m30, long_mt4 m31
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x2_mt4((
        long_mt4 m00, long_mt4 m01,
        long_mt4 m10, long_mt4 m11,
        long_mt4 m20, long_mt4 m21,
        long_mt4 m30, long_mt4 m31
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long4x2_mt4((
        long_mt4 m00, long_mt4 m01,
        long_mt4 m10, long_mt4 m11,
        long_mt4 m20, long_mt4 m21,
        long_mt4 m30, long_mt4 m31
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x2_mt4((
        (long_mt4 m00, long_mt4 m01) r0,
        (long_mt4 m10, long_mt4 m11) r1,
        (long_mt4 m20, long_mt4 m21) r2,
        (long_mt4 m30, long_mt4 m31) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long4x2_mt4((
        (long_mt4 m00, long_mt4 m01) r0,
        (long_mt4 m10, long_mt4 m11) r1,
        (long_mt4 m20, long_mt4 m21) r2,
        (long_mt4 m30, long_mt4 m31) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x2_mt4(long_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long4x2_mt4(long value) => (long_mt4)(value);

    [MethodImpl(256 | 512)]
    public long4x2_mt4(long_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x2_mt4(long4_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public long4x2_mt4(long4_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out long4_mt4 c0, out long4_mt4 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out long_mt4 m00, out long_mt4 m01,
        out long_mt4 m10, out long_mt4 m11,
        out long_mt4 m20, out long_mt4 m21,
        out long_mt4 m30, out long_mt4 m31
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
    }

    #endregion // Deconstruct

    #region Index

    public long4_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public long_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static long4x2_mt4 operator~(long4x2_mt4 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static long4x2_mt4 operator|(long4x2_mt4 a, long4x2_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static long4x2_mt4 operator&(long4x2_mt4 a, long4x2_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static long4x2_mt4 operator^(long4x2_mt4 a, long4x2_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"long4x2_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // long4x2_mt4

#region long4x2_mt8

[CpuOnly]
public partial struct long4x2_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => long_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 2); 
    }

    public static long4x2_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1L, default,
            default, 1L,
            default, default,
            default, default
        ); 
    }

    #endregion

    #region Fields

    public long4_mt8 c0;
    public long4_mt8 c1;

    #endregion

    #region Properties

    public long_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public long_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public long_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public long_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public long_mt8 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public long_mt8 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public long_mt8 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public long_mt8 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly long4x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, long4x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public long4x2_mt8(long4_mt8 c0, long4_mt8 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public long4x2_mt8((long4_mt8 c0, long4_mt8 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x2_mt8((long4_mt8 c0, long4_mt8 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long4x2_mt8(
        long_mt8 m00, long_mt8 m01,
        long_mt8 m10, long_mt8 m11,
        long_mt8 m20, long_mt8 m21,
        long_mt8 m30, long_mt8 m31
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x2_mt8((
        long_mt8 m00, long_mt8 m01,
        long_mt8 m10, long_mt8 m11,
        long_mt8 m20, long_mt8 m21,
        long_mt8 m30, long_mt8 m31
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long4x2_mt8((
        long_mt8 m00, long_mt8 m01,
        long_mt8 m10, long_mt8 m11,
        long_mt8 m20, long_mt8 m21,
        long_mt8 m30, long_mt8 m31
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x2_mt8((
        (long_mt8 m00, long_mt8 m01) r0,
        (long_mt8 m10, long_mt8 m11) r1,
        (long_mt8 m20, long_mt8 m21) r2,
        (long_mt8 m30, long_mt8 m31) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long4x2_mt8((
        (long_mt8 m00, long_mt8 m01) r0,
        (long_mt8 m10, long_mt8 m11) r1,
        (long_mt8 m20, long_mt8 m21) r2,
        (long_mt8 m30, long_mt8 m31) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x2_mt8(long_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long4x2_mt8(long value) => (long_mt8)(value);

    [MethodImpl(256 | 512)]
    public long4x2_mt8(long_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x2_mt8(long4_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public long4x2_mt8(long4_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out long4_mt8 c0, out long4_mt8 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out long_mt8 m00, out long_mt8 m01,
        out long_mt8 m10, out long_mt8 m11,
        out long_mt8 m20, out long_mt8 m21,
        out long_mt8 m30, out long_mt8 m31
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
    }

    #endregion // Deconstruct

    #region Index

    public long4_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public long_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static long4x2_mt8 operator~(long4x2_mt8 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static long4x2_mt8 operator|(long4x2_mt8 a, long4x2_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static long4x2_mt8 operator&(long4x2_mt8 a, long4x2_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static long4x2_mt8 operator^(long4x2_mt8 a, long4x2_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"long4x2_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // long4x2_mt8

#region long4x2_mt16

[CpuOnly]
public partial struct long4x2_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => long_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 2); 
    }

    public static long4x2_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1L, default,
            default, 1L,
            default, default,
            default, default
        ); 
    }

    #endregion

    #region Fields

    public long4_mt16 c0;
    public long4_mt16 c1;

    #endregion

    #region Properties

    public long_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public long_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public long_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public long_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public long_mt16 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public long_mt16 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public long_mt16 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public long_mt16 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly long4x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, long4x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public long4x2_mt16(long4_mt16 c0, long4_mt16 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public long4x2_mt16((long4_mt16 c0, long4_mt16 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x2_mt16((long4_mt16 c0, long4_mt16 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long4x2_mt16(
        long_mt16 m00, long_mt16 m01,
        long_mt16 m10, long_mt16 m11,
        long_mt16 m20, long_mt16 m21,
        long_mt16 m30, long_mt16 m31
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x2_mt16((
        long_mt16 m00, long_mt16 m01,
        long_mt16 m10, long_mt16 m11,
        long_mt16 m20, long_mt16 m21,
        long_mt16 m30, long_mt16 m31
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long4x2_mt16((
        long_mt16 m00, long_mt16 m01,
        long_mt16 m10, long_mt16 m11,
        long_mt16 m20, long_mt16 m21,
        long_mt16 m30, long_mt16 m31
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x2_mt16((
        (long_mt16 m00, long_mt16 m01) r0,
        (long_mt16 m10, long_mt16 m11) r1,
        (long_mt16 m20, long_mt16 m21) r2,
        (long_mt16 m30, long_mt16 m31) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long4x2_mt16((
        (long_mt16 m00, long_mt16 m01) r0,
        (long_mt16 m10, long_mt16 m11) r1,
        (long_mt16 m20, long_mt16 m21) r2,
        (long_mt16 m30, long_mt16 m31) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x2_mt16(long_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long4x2_mt16(long value) => (long_mt16)(value);

    [MethodImpl(256 | 512)]
    public long4x2_mt16(long_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x2_mt16(long4_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public long4x2_mt16(long4_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out long4_mt16 c0, out long4_mt16 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out long_mt16 m00, out long_mt16 m01,
        out long_mt16 m10, out long_mt16 m11,
        out long_mt16 m20, out long_mt16 m21,
        out long_mt16 m30, out long_mt16 m31
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
    }

    #endregion // Deconstruct

    #region Index

    public long4_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public long_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static long4x2_mt16 operator~(long4x2_mt16 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static long4x2_mt16 operator|(long4x2_mt16 a, long4x2_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static long4x2_mt16 operator&(long4x2_mt16 a, long4x2_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static long4x2_mt16 operator^(long4x2_mt16 a, long4x2_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"long4x2_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // long4x2_mt16

#region long4x3_mt4

[CpuOnly]
public partial struct long4x3_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => long_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 3); 
    }

    public static long4x3_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1L, default, default,
            default, 1L, default,
            default, default, 1L,
            default, default, default
        ); 
    }

    #endregion

    #region Fields

    public long4_mt4 c0;
    public long4_mt4 c1;
    public long4_mt4 c2;

    #endregion

    #region Properties

    public long_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public long_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public long_mt4 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public long_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public long_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public long_mt4 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public long_mt4 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public long_mt4 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public long_mt4 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public long_mt4 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public long_mt4 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public long_mt4 m32
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly long4x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, long4x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public long4x3_mt4(long4_mt4 c0, long4_mt4 c1, long4_mt4 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public long4x3_mt4((long4_mt4 c0, long4_mt4 c1, long4_mt4 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x3_mt4((long4_mt4 c0, long4_mt4 c1, long4_mt4 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long4x3_mt4(
        long_mt4 m00, long_mt4 m01, long_mt4 m02,
        long_mt4 m10, long_mt4 m11, long_mt4 m12,
        long_mt4 m20, long_mt4 m21, long_mt4 m22,
        long_mt4 m30, long_mt4 m31, long_mt4 m32
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x3_mt4((
        long_mt4 m00, long_mt4 m01, long_mt4 m02,
        long_mt4 m10, long_mt4 m11, long_mt4 m12,
        long_mt4 m20, long_mt4 m21, long_mt4 m22,
        long_mt4 m30, long_mt4 m31, long_mt4 m32
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long4x3_mt4((
        long_mt4 m00, long_mt4 m01, long_mt4 m02,
        long_mt4 m10, long_mt4 m11, long_mt4 m12,
        long_mt4 m20, long_mt4 m21, long_mt4 m22,
        long_mt4 m30, long_mt4 m31, long_mt4 m32
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x3_mt4((
        (long_mt4 m00, long_mt4 m01, long_mt4 m02) r0,
        (long_mt4 m10, long_mt4 m11, long_mt4 m12) r1,
        (long_mt4 m20, long_mt4 m21, long_mt4 m22) r2,
        (long_mt4 m30, long_mt4 m31, long_mt4 m32) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long4x3_mt4((
        (long_mt4 m00, long_mt4 m01, long_mt4 m02) r0,
        (long_mt4 m10, long_mt4 m11, long_mt4 m12) r1,
        (long_mt4 m20, long_mt4 m21, long_mt4 m22) r2,
        (long_mt4 m30, long_mt4 m31, long_mt4 m32) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x3_mt4(long_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long4x3_mt4(long value) => (long_mt4)(value);

    [MethodImpl(256 | 512)]
    public long4x3_mt4(long_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x3_mt4(long4_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public long4x3_mt4(long4_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out long4_mt4 c0, out long4_mt4 c1, out long4_mt4 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out long_mt4 m00, out long_mt4 m01, out long_mt4 m02,
        out long_mt4 m10, out long_mt4 m11, out long_mt4 m12,
        out long_mt4 m20, out long_mt4 m21, out long_mt4 m22,
        out long_mt4 m30, out long_mt4 m31, out long_mt4 m32
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
    }

    #endregion // Deconstruct

    #region Index

    public long4_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public long_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static long4x3_mt4 operator~(long4x3_mt4 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static long4x3_mt4 operator|(long4x3_mt4 a, long4x3_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static long4x3_mt4 operator&(long4x3_mt4 a, long4x3_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static long4x3_mt4 operator^(long4x3_mt4 a, long4x3_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"long4x3_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // long4x3_mt4

#region long4x3_mt8

[CpuOnly]
public partial struct long4x3_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => long_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 3); 
    }

    public static long4x3_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1L, default, default,
            default, 1L, default,
            default, default, 1L,
            default, default, default
        ); 
    }

    #endregion

    #region Fields

    public long4_mt8 c0;
    public long4_mt8 c1;
    public long4_mt8 c2;

    #endregion

    #region Properties

    public long_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public long_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public long_mt8 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public long_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public long_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public long_mt8 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public long_mt8 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public long_mt8 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public long_mt8 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public long_mt8 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public long_mt8 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public long_mt8 m32
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly long4x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, long4x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public long4x3_mt8(long4_mt8 c0, long4_mt8 c1, long4_mt8 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public long4x3_mt8((long4_mt8 c0, long4_mt8 c1, long4_mt8 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x3_mt8((long4_mt8 c0, long4_mt8 c1, long4_mt8 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long4x3_mt8(
        long_mt8 m00, long_mt8 m01, long_mt8 m02,
        long_mt8 m10, long_mt8 m11, long_mt8 m12,
        long_mt8 m20, long_mt8 m21, long_mt8 m22,
        long_mt8 m30, long_mt8 m31, long_mt8 m32
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x3_mt8((
        long_mt8 m00, long_mt8 m01, long_mt8 m02,
        long_mt8 m10, long_mt8 m11, long_mt8 m12,
        long_mt8 m20, long_mt8 m21, long_mt8 m22,
        long_mt8 m30, long_mt8 m31, long_mt8 m32
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long4x3_mt8((
        long_mt8 m00, long_mt8 m01, long_mt8 m02,
        long_mt8 m10, long_mt8 m11, long_mt8 m12,
        long_mt8 m20, long_mt8 m21, long_mt8 m22,
        long_mt8 m30, long_mt8 m31, long_mt8 m32
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x3_mt8((
        (long_mt8 m00, long_mt8 m01, long_mt8 m02) r0,
        (long_mt8 m10, long_mt8 m11, long_mt8 m12) r1,
        (long_mt8 m20, long_mt8 m21, long_mt8 m22) r2,
        (long_mt8 m30, long_mt8 m31, long_mt8 m32) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long4x3_mt8((
        (long_mt8 m00, long_mt8 m01, long_mt8 m02) r0,
        (long_mt8 m10, long_mt8 m11, long_mt8 m12) r1,
        (long_mt8 m20, long_mt8 m21, long_mt8 m22) r2,
        (long_mt8 m30, long_mt8 m31, long_mt8 m32) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x3_mt8(long_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long4x3_mt8(long value) => (long_mt8)(value);

    [MethodImpl(256 | 512)]
    public long4x3_mt8(long_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x3_mt8(long4_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public long4x3_mt8(long4_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out long4_mt8 c0, out long4_mt8 c1, out long4_mt8 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out long_mt8 m00, out long_mt8 m01, out long_mt8 m02,
        out long_mt8 m10, out long_mt8 m11, out long_mt8 m12,
        out long_mt8 m20, out long_mt8 m21, out long_mt8 m22,
        out long_mt8 m30, out long_mt8 m31, out long_mt8 m32
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
    }

    #endregion // Deconstruct

    #region Index

    public long4_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public long_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static long4x3_mt8 operator~(long4x3_mt8 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static long4x3_mt8 operator|(long4x3_mt8 a, long4x3_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static long4x3_mt8 operator&(long4x3_mt8 a, long4x3_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static long4x3_mt8 operator^(long4x3_mt8 a, long4x3_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"long4x3_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // long4x3_mt8

#region long4x3_mt16

[CpuOnly]
public partial struct long4x3_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => long_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 3); 
    }

    public static long4x3_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1L, default, default,
            default, 1L, default,
            default, default, 1L,
            default, default, default
        ); 
    }

    #endregion

    #region Fields

    public long4_mt16 c0;
    public long4_mt16 c1;
    public long4_mt16 c2;

    #endregion

    #region Properties

    public long_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public long_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public long_mt16 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public long_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public long_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public long_mt16 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public long_mt16 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public long_mt16 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public long_mt16 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public long_mt16 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public long_mt16 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public long_mt16 m32
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly long4x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, long4x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public long4x3_mt16(long4_mt16 c0, long4_mt16 c1, long4_mt16 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public long4x3_mt16((long4_mt16 c0, long4_mt16 c1, long4_mt16 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x3_mt16((long4_mt16 c0, long4_mt16 c1, long4_mt16 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long4x3_mt16(
        long_mt16 m00, long_mt16 m01, long_mt16 m02,
        long_mt16 m10, long_mt16 m11, long_mt16 m12,
        long_mt16 m20, long_mt16 m21, long_mt16 m22,
        long_mt16 m30, long_mt16 m31, long_mt16 m32
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x3_mt16((
        long_mt16 m00, long_mt16 m01, long_mt16 m02,
        long_mt16 m10, long_mt16 m11, long_mt16 m12,
        long_mt16 m20, long_mt16 m21, long_mt16 m22,
        long_mt16 m30, long_mt16 m31, long_mt16 m32
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long4x3_mt16((
        long_mt16 m00, long_mt16 m01, long_mt16 m02,
        long_mt16 m10, long_mt16 m11, long_mt16 m12,
        long_mt16 m20, long_mt16 m21, long_mt16 m22,
        long_mt16 m30, long_mt16 m31, long_mt16 m32
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x3_mt16((
        (long_mt16 m00, long_mt16 m01, long_mt16 m02) r0,
        (long_mt16 m10, long_mt16 m11, long_mt16 m12) r1,
        (long_mt16 m20, long_mt16 m21, long_mt16 m22) r2,
        (long_mt16 m30, long_mt16 m31, long_mt16 m32) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long4x3_mt16((
        (long_mt16 m00, long_mt16 m01, long_mt16 m02) r0,
        (long_mt16 m10, long_mt16 m11, long_mt16 m12) r1,
        (long_mt16 m20, long_mt16 m21, long_mt16 m22) r2,
        (long_mt16 m30, long_mt16 m31, long_mt16 m32) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x3_mt16(long_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long4x3_mt16(long value) => (long_mt16)(value);

    [MethodImpl(256 | 512)]
    public long4x3_mt16(long_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x3_mt16(long4_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public long4x3_mt16(long4_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out long4_mt16 c0, out long4_mt16 c1, out long4_mt16 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out long_mt16 m00, out long_mt16 m01, out long_mt16 m02,
        out long_mt16 m10, out long_mt16 m11, out long_mt16 m12,
        out long_mt16 m20, out long_mt16 m21, out long_mt16 m22,
        out long_mt16 m30, out long_mt16 m31, out long_mt16 m32
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
    }

    #endregion // Deconstruct

    #region Index

    public long4_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public long_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static long4x3_mt16 operator~(long4x3_mt16 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static long4x3_mt16 operator|(long4x3_mt16 a, long4x3_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static long4x3_mt16 operator&(long4x3_mt16 a, long4x3_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static long4x3_mt16 operator^(long4x3_mt16 a, long4x3_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"long4x3_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // long4x3_mt16

#region long4x4_mt4

[CpuOnly]
public partial struct long4x4_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => long_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 4); 
    }

    public static long4x4_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1L, default, default, default,
            default, 1L, default, default,
            default, default, 1L, default,
            default, default, default, 1L
        ); 
    }

    #endregion

    #region Fields

    public long4_mt4 c0;
    public long4_mt4 c1;
    public long4_mt4 c2;
    public long4_mt4 c3;

    #endregion

    #region Properties

    public long_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public long_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public long_mt4 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public long_mt4 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public long_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public long_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public long_mt4 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public long_mt4 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public long_mt4 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public long_mt4 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public long_mt4 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public long_mt4 m23
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }
    public long_mt4 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public long_mt4 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public long_mt4 m32
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }
    public long_mt4 m33
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.w;
        [MethodImpl(256 | 512)]
        set => c3.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly long4x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, long4x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public long4x4_mt4(long4_mt4 c0, long4_mt4 c1, long4_mt4 c2, long4_mt4 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public long4x4_mt4((long4_mt4 c0, long4_mt4 c1, long4_mt4 c2, long4_mt4 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x4_mt4((long4_mt4 c0, long4_mt4 c1, long4_mt4 c2, long4_mt4 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long4x4_mt4(
        long_mt4 m00, long_mt4 m01, long_mt4 m02, long_mt4 m03,
        long_mt4 m10, long_mt4 m11, long_mt4 m12, long_mt4 m13,
        long_mt4 m20, long_mt4 m21, long_mt4 m22, long_mt4 m23,
        long_mt4 m30, long_mt4 m31, long_mt4 m32, long_mt4 m33
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
        this.c3 = new(m03, m13, m23, m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x4_mt4((
        long_mt4 m00, long_mt4 m01, long_mt4 m02, long_mt4 m03,
        long_mt4 m10, long_mt4 m11, long_mt4 m12, long_mt4 m13,
        long_mt4 m20, long_mt4 m21, long_mt4 m22, long_mt4 m23,
        long_mt4 m30, long_mt4 m31, long_mt4 m32, long_mt4 m33
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long4x4_mt4((
        long_mt4 m00, long_mt4 m01, long_mt4 m02, long_mt4 m03,
        long_mt4 m10, long_mt4 m11, long_mt4 m12, long_mt4 m13,
        long_mt4 m20, long_mt4 m21, long_mt4 m22, long_mt4 m23,
        long_mt4 m30, long_mt4 m31, long_mt4 m32, long_mt4 m33
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23, tuple.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x4_mt4((
        (long_mt4 m00, long_mt4 m01, long_mt4 m02, long_mt4 m03) r0,
        (long_mt4 m10, long_mt4 m11, long_mt4 m12, long_mt4 m13) r1,
        (long_mt4 m20, long_mt4 m21, long_mt4 m22, long_mt4 m23) r2,
        (long_mt4 m30, long_mt4 m31, long_mt4 m32, long_mt4 m33) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long4x4_mt4((
        (long_mt4 m00, long_mt4 m01, long_mt4 m02, long_mt4 m03) r0,
        (long_mt4 m10, long_mt4 m11, long_mt4 m12, long_mt4 m13) r1,
        (long_mt4 m20, long_mt4 m21, long_mt4 m22, long_mt4 m23) r2,
        (long_mt4 m30, long_mt4 m31, long_mt4 m32, long_mt4 m33) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23, tuple.r3.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x4_mt4(long_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long4x4_mt4(long value) => (long_mt4)(value);

    [MethodImpl(256 | 512)]
    public long4x4_mt4(long_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x4_mt4(long4_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public long4x4_mt4(long4_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out long4_mt4 c0, out long4_mt4 c1, out long4_mt4 c2, out long4_mt4 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out long_mt4 m00, out long_mt4 m01, out long_mt4 m02, out long_mt4 m03,
        out long_mt4 m10, out long_mt4 m11, out long_mt4 m12, out long_mt4 m13,
        out long_mt4 m20, out long_mt4 m21, out long_mt4 m22, out long_mt4 m23,
        out long_mt4 m30, out long_mt4 m31, out long_mt4 m32, out long_mt4 m33
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
        this.c3.Deconstruct(out m03, out m13, out m23, out m33);
    }

    #endregion // Deconstruct

    #region Index

    public long4_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public long_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static long4x4_mt4 operator~(long4x4_mt4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static long4x4_mt4 operator|(long4x4_mt4 a, long4x4_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static long4x4_mt4 operator&(long4x4_mt4 a, long4x4_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static long4x4_mt4 operator^(long4x4_mt4 a, long4x4_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"long4x4_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // long4x4_mt4

#region long4x4_mt8

[CpuOnly]
public partial struct long4x4_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => long_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 4); 
    }

    public static long4x4_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1L, default, default, default,
            default, 1L, default, default,
            default, default, 1L, default,
            default, default, default, 1L
        ); 
    }

    #endregion

    #region Fields

    public long4_mt8 c0;
    public long4_mt8 c1;
    public long4_mt8 c2;
    public long4_mt8 c3;

    #endregion

    #region Properties

    public long_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public long_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public long_mt8 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public long_mt8 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public long_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public long_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public long_mt8 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public long_mt8 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public long_mt8 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public long_mt8 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public long_mt8 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public long_mt8 m23
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }
    public long_mt8 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public long_mt8 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public long_mt8 m32
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }
    public long_mt8 m33
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.w;
        [MethodImpl(256 | 512)]
        set => c3.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly long4x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, long4x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public long4x4_mt8(long4_mt8 c0, long4_mt8 c1, long4_mt8 c2, long4_mt8 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public long4x4_mt8((long4_mt8 c0, long4_mt8 c1, long4_mt8 c2, long4_mt8 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x4_mt8((long4_mt8 c0, long4_mt8 c1, long4_mt8 c2, long4_mt8 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long4x4_mt8(
        long_mt8 m00, long_mt8 m01, long_mt8 m02, long_mt8 m03,
        long_mt8 m10, long_mt8 m11, long_mt8 m12, long_mt8 m13,
        long_mt8 m20, long_mt8 m21, long_mt8 m22, long_mt8 m23,
        long_mt8 m30, long_mt8 m31, long_mt8 m32, long_mt8 m33
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
        this.c3 = new(m03, m13, m23, m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x4_mt8((
        long_mt8 m00, long_mt8 m01, long_mt8 m02, long_mt8 m03,
        long_mt8 m10, long_mt8 m11, long_mt8 m12, long_mt8 m13,
        long_mt8 m20, long_mt8 m21, long_mt8 m22, long_mt8 m23,
        long_mt8 m30, long_mt8 m31, long_mt8 m32, long_mt8 m33
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long4x4_mt8((
        long_mt8 m00, long_mt8 m01, long_mt8 m02, long_mt8 m03,
        long_mt8 m10, long_mt8 m11, long_mt8 m12, long_mt8 m13,
        long_mt8 m20, long_mt8 m21, long_mt8 m22, long_mt8 m23,
        long_mt8 m30, long_mt8 m31, long_mt8 m32, long_mt8 m33
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23, tuple.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x4_mt8((
        (long_mt8 m00, long_mt8 m01, long_mt8 m02, long_mt8 m03) r0,
        (long_mt8 m10, long_mt8 m11, long_mt8 m12, long_mt8 m13) r1,
        (long_mt8 m20, long_mt8 m21, long_mt8 m22, long_mt8 m23) r2,
        (long_mt8 m30, long_mt8 m31, long_mt8 m32, long_mt8 m33) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long4x4_mt8((
        (long_mt8 m00, long_mt8 m01, long_mt8 m02, long_mt8 m03) r0,
        (long_mt8 m10, long_mt8 m11, long_mt8 m12, long_mt8 m13) r1,
        (long_mt8 m20, long_mt8 m21, long_mt8 m22, long_mt8 m23) r2,
        (long_mt8 m30, long_mt8 m31, long_mt8 m32, long_mt8 m33) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23, tuple.r3.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x4_mt8(long_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long4x4_mt8(long value) => (long_mt8)(value);

    [MethodImpl(256 | 512)]
    public long4x4_mt8(long_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x4_mt8(long4_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public long4x4_mt8(long4_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out long4_mt8 c0, out long4_mt8 c1, out long4_mt8 c2, out long4_mt8 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out long_mt8 m00, out long_mt8 m01, out long_mt8 m02, out long_mt8 m03,
        out long_mt8 m10, out long_mt8 m11, out long_mt8 m12, out long_mt8 m13,
        out long_mt8 m20, out long_mt8 m21, out long_mt8 m22, out long_mt8 m23,
        out long_mt8 m30, out long_mt8 m31, out long_mt8 m32, out long_mt8 m33
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
        this.c3.Deconstruct(out m03, out m13, out m23, out m33);
    }

    #endregion // Deconstruct

    #region Index

    public long4_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public long_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static long4x4_mt8 operator~(long4x4_mt8 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static long4x4_mt8 operator|(long4x4_mt8 a, long4x4_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static long4x4_mt8 operator&(long4x4_mt8 a, long4x4_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static long4x4_mt8 operator^(long4x4_mt8 a, long4x4_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"long4x4_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // long4x4_mt8

#region long4x4_mt16

[CpuOnly]
public partial struct long4x4_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => long_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 4); 
    }

    public static long4x4_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1L, default, default, default,
            default, 1L, default, default,
            default, default, 1L, default,
            default, default, default, 1L
        ); 
    }

    #endregion

    #region Fields

    public long4_mt16 c0;
    public long4_mt16 c1;
    public long4_mt16 c2;
    public long4_mt16 c3;

    #endregion

    #region Properties

    public long_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public long_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public long_mt16 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public long_mt16 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public long_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public long_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public long_mt16 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public long_mt16 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public long_mt16 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public long_mt16 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public long_mt16 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public long_mt16 m23
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }
    public long_mt16 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public long_mt16 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public long_mt16 m32
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }
    public long_mt16 m33
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.w;
        [MethodImpl(256 | 512)]
        set => c3.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly long4x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, long4x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public long4x4_mt16(long4_mt16 c0, long4_mt16 c1, long4_mt16 c2, long4_mt16 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public long4x4_mt16((long4_mt16 c0, long4_mt16 c1, long4_mt16 c2, long4_mt16 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x4_mt16((long4_mt16 c0, long4_mt16 c1, long4_mt16 c2, long4_mt16 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long4x4_mt16(
        long_mt16 m00, long_mt16 m01, long_mt16 m02, long_mt16 m03,
        long_mt16 m10, long_mt16 m11, long_mt16 m12, long_mt16 m13,
        long_mt16 m20, long_mt16 m21, long_mt16 m22, long_mt16 m23,
        long_mt16 m30, long_mt16 m31, long_mt16 m32, long_mt16 m33
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
        this.c3 = new(m03, m13, m23, m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x4_mt16((
        long_mt16 m00, long_mt16 m01, long_mt16 m02, long_mt16 m03,
        long_mt16 m10, long_mt16 m11, long_mt16 m12, long_mt16 m13,
        long_mt16 m20, long_mt16 m21, long_mt16 m22, long_mt16 m23,
        long_mt16 m30, long_mt16 m31, long_mt16 m32, long_mt16 m33
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long4x4_mt16((
        long_mt16 m00, long_mt16 m01, long_mt16 m02, long_mt16 m03,
        long_mt16 m10, long_mt16 m11, long_mt16 m12, long_mt16 m13,
        long_mt16 m20, long_mt16 m21, long_mt16 m22, long_mt16 m23,
        long_mt16 m30, long_mt16 m31, long_mt16 m32, long_mt16 m33
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23, tuple.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x4_mt16((
        (long_mt16 m00, long_mt16 m01, long_mt16 m02, long_mt16 m03) r0,
        (long_mt16 m10, long_mt16 m11, long_mt16 m12, long_mt16 m13) r1,
        (long_mt16 m20, long_mt16 m21, long_mt16 m22, long_mt16 m23) r2,
        (long_mt16 m30, long_mt16 m31, long_mt16 m32, long_mt16 m33) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public long4x4_mt16((
        (long_mt16 m00, long_mt16 m01, long_mt16 m02, long_mt16 m03) r0,
        (long_mt16 m10, long_mt16 m11, long_mt16 m12, long_mt16 m13) r1,
        (long_mt16 m20, long_mt16 m21, long_mt16 m22, long_mt16 m23) r2,
        (long_mt16 m30, long_mt16 m31, long_mt16 m32, long_mt16 m33) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23, tuple.r3.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x4_mt16(long_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator long4x4_mt16(long value) => (long_mt16)(value);

    [MethodImpl(256 | 512)]
    public long4x4_mt16(long_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator long4x4_mt16(long4_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public long4x4_mt16(long4_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out long4_mt16 c0, out long4_mt16 c1, out long4_mt16 c2, out long4_mt16 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out long_mt16 m00, out long_mt16 m01, out long_mt16 m02, out long_mt16 m03,
        out long_mt16 m10, out long_mt16 m11, out long_mt16 m12, out long_mt16 m13,
        out long_mt16 m20, out long_mt16 m21, out long_mt16 m22, out long_mt16 m23,
        out long_mt16 m30, out long_mt16 m31, out long_mt16 m32, out long_mt16 m33
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
        this.c3.Deconstruct(out m03, out m13, out m23, out m33);
    }

    #endregion // Deconstruct

    #region Index

    public long4_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public long_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static long4x4_mt16 operator~(long4x4_mt16 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static long4x4_mt16 operator|(long4x4_mt16 a, long4x4_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static long4x4_mt16 operator&(long4x4_mt16 a, long4x4_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static long4x4_mt16 operator^(long4x4_mt16 a, long4x4_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"long4x4_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // long4x4_mt16

#region ulong2x2_mt4

[CpuOnly]
public partial struct ulong2x2_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => ulong_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 2); 
    }

    public static ulong2x2_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1UL, default,
            default, 1UL
        ); 
    }

    #endregion

    #region Fields

    public ulong2_mt4 c0;
    public ulong2_mt4 c1;

    #endregion

    #region Properties

    public ulong_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ulong_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ulong_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ulong_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly ulong2x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, ulong2x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public ulong2x2_mt4(ulong2_mt4 c0, ulong2_mt4 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public ulong2x2_mt4((ulong2_mt4 c0, ulong2_mt4 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x2_mt4((ulong2_mt4 c0, ulong2_mt4 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong2x2_mt4(
        ulong_mt4 m00, ulong_mt4 m01,
        ulong_mt4 m10, ulong_mt4 m11
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x2_mt4((
        ulong_mt4 m00, ulong_mt4 m01,
        ulong_mt4 m10, ulong_mt4 m11
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong2x2_mt4((
        ulong_mt4 m00, ulong_mt4 m01,
        ulong_mt4 m10, ulong_mt4 m11
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x2_mt4((
        (ulong_mt4 m00, ulong_mt4 m01) r0,
        (ulong_mt4 m10, ulong_mt4 m11) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong2x2_mt4((
        (ulong_mt4 m00, ulong_mt4 m01) r0,
        (ulong_mt4 m10, ulong_mt4 m11) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x2_mt4(ulong_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x2_mt4(ulong value) => (ulong_mt4)(value);

    [MethodImpl(256 | 512)]
    public ulong2x2_mt4(ulong_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x2_mt4(ulong2_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong2x2_mt4(ulong2_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out ulong2_mt4 c0, out ulong2_mt4 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out ulong_mt4 m00, out ulong_mt4 m01,
        out ulong_mt4 m10, out ulong_mt4 m11
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
    }

    #endregion // Deconstruct

    #region Index

    public ulong2_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ulong_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static ulong2x2_mt4 operator~(ulong2x2_mt4 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static ulong2x2_mt4 operator|(ulong2x2_mt4 a, ulong2x2_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static ulong2x2_mt4 operator&(ulong2x2_mt4 a, ulong2x2_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static ulong2x2_mt4 operator^(ulong2x2_mt4 a, ulong2x2_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"ulong2x2_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // ulong2x2_mt4

#region ulong2x2_mt8

[CpuOnly]
public partial struct ulong2x2_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => ulong_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 2); 
    }

    public static ulong2x2_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1UL, default,
            default, 1UL
        ); 
    }

    #endregion

    #region Fields

    public ulong2_mt8 c0;
    public ulong2_mt8 c1;

    #endregion

    #region Properties

    public ulong_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ulong_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ulong_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ulong_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly ulong2x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, ulong2x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public ulong2x2_mt8(ulong2_mt8 c0, ulong2_mt8 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public ulong2x2_mt8((ulong2_mt8 c0, ulong2_mt8 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x2_mt8((ulong2_mt8 c0, ulong2_mt8 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong2x2_mt8(
        ulong_mt8 m00, ulong_mt8 m01,
        ulong_mt8 m10, ulong_mt8 m11
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x2_mt8((
        ulong_mt8 m00, ulong_mt8 m01,
        ulong_mt8 m10, ulong_mt8 m11
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong2x2_mt8((
        ulong_mt8 m00, ulong_mt8 m01,
        ulong_mt8 m10, ulong_mt8 m11
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x2_mt8((
        (ulong_mt8 m00, ulong_mt8 m01) r0,
        (ulong_mt8 m10, ulong_mt8 m11) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong2x2_mt8((
        (ulong_mt8 m00, ulong_mt8 m01) r0,
        (ulong_mt8 m10, ulong_mt8 m11) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x2_mt8(ulong_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x2_mt8(ulong value) => (ulong_mt8)(value);

    [MethodImpl(256 | 512)]
    public ulong2x2_mt8(ulong_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x2_mt8(ulong2_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong2x2_mt8(ulong2_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out ulong2_mt8 c0, out ulong2_mt8 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out ulong_mt8 m00, out ulong_mt8 m01,
        out ulong_mt8 m10, out ulong_mt8 m11
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
    }

    #endregion // Deconstruct

    #region Index

    public ulong2_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ulong_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static ulong2x2_mt8 operator~(ulong2x2_mt8 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static ulong2x2_mt8 operator|(ulong2x2_mt8 a, ulong2x2_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static ulong2x2_mt8 operator&(ulong2x2_mt8 a, ulong2x2_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static ulong2x2_mt8 operator^(ulong2x2_mt8 a, ulong2x2_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"ulong2x2_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // ulong2x2_mt8

#region ulong2x2_mt16

[CpuOnly]
public partial struct ulong2x2_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => ulong_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 2); 
    }

    public static ulong2x2_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1UL, default,
            default, 1UL
        ); 
    }

    #endregion

    #region Fields

    public ulong2_mt16 c0;
    public ulong2_mt16 c1;

    #endregion

    #region Properties

    public ulong_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ulong_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ulong_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ulong_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly ulong2x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, ulong2x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public ulong2x2_mt16(ulong2_mt16 c0, ulong2_mt16 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public ulong2x2_mt16((ulong2_mt16 c0, ulong2_mt16 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x2_mt16((ulong2_mt16 c0, ulong2_mt16 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong2x2_mt16(
        ulong_mt16 m00, ulong_mt16 m01,
        ulong_mt16 m10, ulong_mt16 m11
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x2_mt16((
        ulong_mt16 m00, ulong_mt16 m01,
        ulong_mt16 m10, ulong_mt16 m11
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong2x2_mt16((
        ulong_mt16 m00, ulong_mt16 m01,
        ulong_mt16 m10, ulong_mt16 m11
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x2_mt16((
        (ulong_mt16 m00, ulong_mt16 m01) r0,
        (ulong_mt16 m10, ulong_mt16 m11) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong2x2_mt16((
        (ulong_mt16 m00, ulong_mt16 m01) r0,
        (ulong_mt16 m10, ulong_mt16 m11) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x2_mt16(ulong_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x2_mt16(ulong value) => (ulong_mt16)(value);

    [MethodImpl(256 | 512)]
    public ulong2x2_mt16(ulong_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x2_mt16(ulong2_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong2x2_mt16(ulong2_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out ulong2_mt16 c0, out ulong2_mt16 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out ulong_mt16 m00, out ulong_mt16 m01,
        out ulong_mt16 m10, out ulong_mt16 m11
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
    }

    #endregion // Deconstruct

    #region Index

    public ulong2_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ulong_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static ulong2x2_mt16 operator~(ulong2x2_mt16 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static ulong2x2_mt16 operator|(ulong2x2_mt16 a, ulong2x2_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static ulong2x2_mt16 operator&(ulong2x2_mt16 a, ulong2x2_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static ulong2x2_mt16 operator^(ulong2x2_mt16 a, ulong2x2_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"ulong2x2_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // ulong2x2_mt16

#region ulong2x3_mt4

[CpuOnly]
public partial struct ulong2x3_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => ulong_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 3); 
    }

    public static ulong2x3_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1UL, default, default,
            default, 1UL, default
        ); 
    }

    #endregion

    #region Fields

    public ulong2_mt4 c0;
    public ulong2_mt4 c1;
    public ulong2_mt4 c2;

    #endregion

    #region Properties

    public ulong_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ulong_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ulong_mt4 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public ulong_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ulong_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public ulong_mt4 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly ulong2x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, ulong2x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public ulong2x3_mt4(ulong2_mt4 c0, ulong2_mt4 c1, ulong2_mt4 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public ulong2x3_mt4((ulong2_mt4 c0, ulong2_mt4 c1, ulong2_mt4 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x3_mt4((ulong2_mt4 c0, ulong2_mt4 c1, ulong2_mt4 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong2x3_mt4(
        ulong_mt4 m00, ulong_mt4 m01, ulong_mt4 m02,
        ulong_mt4 m10, ulong_mt4 m11, ulong_mt4 m12
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x3_mt4((
        ulong_mt4 m00, ulong_mt4 m01, ulong_mt4 m02,
        ulong_mt4 m10, ulong_mt4 m11, ulong_mt4 m12
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong2x3_mt4((
        ulong_mt4 m00, ulong_mt4 m01, ulong_mt4 m02,
        ulong_mt4 m10, ulong_mt4 m11, ulong_mt4 m12
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x3_mt4((
        (ulong_mt4 m00, ulong_mt4 m01, ulong_mt4 m02) r0,
        (ulong_mt4 m10, ulong_mt4 m11, ulong_mt4 m12) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong2x3_mt4((
        (ulong_mt4 m00, ulong_mt4 m01, ulong_mt4 m02) r0,
        (ulong_mt4 m10, ulong_mt4 m11, ulong_mt4 m12) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x3_mt4(ulong_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x3_mt4(ulong value) => (ulong_mt4)(value);

    [MethodImpl(256 | 512)]
    public ulong2x3_mt4(ulong_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x3_mt4(ulong2_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong2x3_mt4(ulong2_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out ulong2_mt4 c0, out ulong2_mt4 c1, out ulong2_mt4 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out ulong_mt4 m00, out ulong_mt4 m01, out ulong_mt4 m02,
        out ulong_mt4 m10, out ulong_mt4 m11, out ulong_mt4 m12
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
    }

    #endregion // Deconstruct

    #region Index

    public ulong2_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ulong_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static ulong2x3_mt4 operator~(ulong2x3_mt4 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static ulong2x3_mt4 operator|(ulong2x3_mt4 a, ulong2x3_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static ulong2x3_mt4 operator&(ulong2x3_mt4 a, ulong2x3_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static ulong2x3_mt4 operator^(ulong2x3_mt4 a, ulong2x3_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"ulong2x3_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // ulong2x3_mt4

#region ulong2x3_mt8

[CpuOnly]
public partial struct ulong2x3_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => ulong_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 3); 
    }

    public static ulong2x3_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1UL, default, default,
            default, 1UL, default
        ); 
    }

    #endregion

    #region Fields

    public ulong2_mt8 c0;
    public ulong2_mt8 c1;
    public ulong2_mt8 c2;

    #endregion

    #region Properties

    public ulong_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ulong_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ulong_mt8 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public ulong_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ulong_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public ulong_mt8 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly ulong2x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, ulong2x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public ulong2x3_mt8(ulong2_mt8 c0, ulong2_mt8 c1, ulong2_mt8 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public ulong2x3_mt8((ulong2_mt8 c0, ulong2_mt8 c1, ulong2_mt8 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x3_mt8((ulong2_mt8 c0, ulong2_mt8 c1, ulong2_mt8 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong2x3_mt8(
        ulong_mt8 m00, ulong_mt8 m01, ulong_mt8 m02,
        ulong_mt8 m10, ulong_mt8 m11, ulong_mt8 m12
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x3_mt8((
        ulong_mt8 m00, ulong_mt8 m01, ulong_mt8 m02,
        ulong_mt8 m10, ulong_mt8 m11, ulong_mt8 m12
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong2x3_mt8((
        ulong_mt8 m00, ulong_mt8 m01, ulong_mt8 m02,
        ulong_mt8 m10, ulong_mt8 m11, ulong_mt8 m12
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x3_mt8((
        (ulong_mt8 m00, ulong_mt8 m01, ulong_mt8 m02) r0,
        (ulong_mt8 m10, ulong_mt8 m11, ulong_mt8 m12) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong2x3_mt8((
        (ulong_mt8 m00, ulong_mt8 m01, ulong_mt8 m02) r0,
        (ulong_mt8 m10, ulong_mt8 m11, ulong_mt8 m12) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x3_mt8(ulong_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x3_mt8(ulong value) => (ulong_mt8)(value);

    [MethodImpl(256 | 512)]
    public ulong2x3_mt8(ulong_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x3_mt8(ulong2_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong2x3_mt8(ulong2_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out ulong2_mt8 c0, out ulong2_mt8 c1, out ulong2_mt8 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out ulong_mt8 m00, out ulong_mt8 m01, out ulong_mt8 m02,
        out ulong_mt8 m10, out ulong_mt8 m11, out ulong_mt8 m12
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
    }

    #endregion // Deconstruct

    #region Index

    public ulong2_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ulong_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static ulong2x3_mt8 operator~(ulong2x3_mt8 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static ulong2x3_mt8 operator|(ulong2x3_mt8 a, ulong2x3_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static ulong2x3_mt8 operator&(ulong2x3_mt8 a, ulong2x3_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static ulong2x3_mt8 operator^(ulong2x3_mt8 a, ulong2x3_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"ulong2x3_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // ulong2x3_mt8

#region ulong2x3_mt16

[CpuOnly]
public partial struct ulong2x3_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => ulong_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 3); 
    }

    public static ulong2x3_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1UL, default, default,
            default, 1UL, default
        ); 
    }

    #endregion

    #region Fields

    public ulong2_mt16 c0;
    public ulong2_mt16 c1;
    public ulong2_mt16 c2;

    #endregion

    #region Properties

    public ulong_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ulong_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ulong_mt16 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public ulong_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ulong_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public ulong_mt16 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly ulong2x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, ulong2x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public ulong2x3_mt16(ulong2_mt16 c0, ulong2_mt16 c1, ulong2_mt16 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public ulong2x3_mt16((ulong2_mt16 c0, ulong2_mt16 c1, ulong2_mt16 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x3_mt16((ulong2_mt16 c0, ulong2_mt16 c1, ulong2_mt16 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong2x3_mt16(
        ulong_mt16 m00, ulong_mt16 m01, ulong_mt16 m02,
        ulong_mt16 m10, ulong_mt16 m11, ulong_mt16 m12
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x3_mt16((
        ulong_mt16 m00, ulong_mt16 m01, ulong_mt16 m02,
        ulong_mt16 m10, ulong_mt16 m11, ulong_mt16 m12
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong2x3_mt16((
        ulong_mt16 m00, ulong_mt16 m01, ulong_mt16 m02,
        ulong_mt16 m10, ulong_mt16 m11, ulong_mt16 m12
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x3_mt16((
        (ulong_mt16 m00, ulong_mt16 m01, ulong_mt16 m02) r0,
        (ulong_mt16 m10, ulong_mt16 m11, ulong_mt16 m12) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong2x3_mt16((
        (ulong_mt16 m00, ulong_mt16 m01, ulong_mt16 m02) r0,
        (ulong_mt16 m10, ulong_mt16 m11, ulong_mt16 m12) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x3_mt16(ulong_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x3_mt16(ulong value) => (ulong_mt16)(value);

    [MethodImpl(256 | 512)]
    public ulong2x3_mt16(ulong_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x3_mt16(ulong2_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong2x3_mt16(ulong2_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out ulong2_mt16 c0, out ulong2_mt16 c1, out ulong2_mt16 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out ulong_mt16 m00, out ulong_mt16 m01, out ulong_mt16 m02,
        out ulong_mt16 m10, out ulong_mt16 m11, out ulong_mt16 m12
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
    }

    #endregion // Deconstruct

    #region Index

    public ulong2_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ulong_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static ulong2x3_mt16 operator~(ulong2x3_mt16 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static ulong2x3_mt16 operator|(ulong2x3_mt16 a, ulong2x3_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static ulong2x3_mt16 operator&(ulong2x3_mt16 a, ulong2x3_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static ulong2x3_mt16 operator^(ulong2x3_mt16 a, ulong2x3_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"ulong2x3_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // ulong2x3_mt16

#region ulong2x4_mt4

[CpuOnly]
public partial struct ulong2x4_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => ulong_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 4); 
    }

    public static ulong2x4_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1UL, default, default, default,
            default, 1UL, default, default
        ); 
    }

    #endregion

    #region Fields

    public ulong2_mt4 c0;
    public ulong2_mt4 c1;
    public ulong2_mt4 c2;
    public ulong2_mt4 c3;

    #endregion

    #region Properties

    public ulong_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ulong_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ulong_mt4 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public ulong_mt4 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public ulong_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ulong_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public ulong_mt4 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public ulong_mt4 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly ulong2x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, ulong2x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public ulong2x4_mt4(ulong2_mt4 c0, ulong2_mt4 c1, ulong2_mt4 c2, ulong2_mt4 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public ulong2x4_mt4((ulong2_mt4 c0, ulong2_mt4 c1, ulong2_mt4 c2, ulong2_mt4 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x4_mt4((ulong2_mt4 c0, ulong2_mt4 c1, ulong2_mt4 c2, ulong2_mt4 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong2x4_mt4(
        ulong_mt4 m00, ulong_mt4 m01, ulong_mt4 m02, ulong_mt4 m03,
        ulong_mt4 m10, ulong_mt4 m11, ulong_mt4 m12, ulong_mt4 m13
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
        this.c3 = new(m03, m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x4_mt4((
        ulong_mt4 m00, ulong_mt4 m01, ulong_mt4 m02, ulong_mt4 m03,
        ulong_mt4 m10, ulong_mt4 m11, ulong_mt4 m12, ulong_mt4 m13
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong2x4_mt4((
        ulong_mt4 m00, ulong_mt4 m01, ulong_mt4 m02, ulong_mt4 m03,
        ulong_mt4 m10, ulong_mt4 m11, ulong_mt4 m12, ulong_mt4 m13
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
        this.c3 = new(tuple.m03, tuple.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x4_mt4((
        (ulong_mt4 m00, ulong_mt4 m01, ulong_mt4 m02, ulong_mt4 m03) r0,
        (ulong_mt4 m10, ulong_mt4 m11, ulong_mt4 m12, ulong_mt4 m13) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong2x4_mt4((
        (ulong_mt4 m00, ulong_mt4 m01, ulong_mt4 m02, ulong_mt4 m03) r0,
        (ulong_mt4 m10, ulong_mt4 m11, ulong_mt4 m12, ulong_mt4 m13) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x4_mt4(ulong_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x4_mt4(ulong value) => (ulong_mt4)(value);

    [MethodImpl(256 | 512)]
    public ulong2x4_mt4(ulong_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x4_mt4(ulong2_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong2x4_mt4(ulong2_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out ulong2_mt4 c0, out ulong2_mt4 c1, out ulong2_mt4 c2, out ulong2_mt4 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out ulong_mt4 m00, out ulong_mt4 m01, out ulong_mt4 m02, out ulong_mt4 m03,
        out ulong_mt4 m10, out ulong_mt4 m11, out ulong_mt4 m12, out ulong_mt4 m13
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
        this.c3.Deconstruct(out m03, out m13);
    }

    #endregion // Deconstruct

    #region Index

    public ulong2_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ulong_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static ulong2x4_mt4 operator~(ulong2x4_mt4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static ulong2x4_mt4 operator|(ulong2x4_mt4 a, ulong2x4_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static ulong2x4_mt4 operator&(ulong2x4_mt4 a, ulong2x4_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static ulong2x4_mt4 operator^(ulong2x4_mt4 a, ulong2x4_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"ulong2x4_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // ulong2x4_mt4

#region ulong2x4_mt8

[CpuOnly]
public partial struct ulong2x4_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => ulong_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 4); 
    }

    public static ulong2x4_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1UL, default, default, default,
            default, 1UL, default, default
        ); 
    }

    #endregion

    #region Fields

    public ulong2_mt8 c0;
    public ulong2_mt8 c1;
    public ulong2_mt8 c2;
    public ulong2_mt8 c3;

    #endregion

    #region Properties

    public ulong_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ulong_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ulong_mt8 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public ulong_mt8 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public ulong_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ulong_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public ulong_mt8 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public ulong_mt8 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly ulong2x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, ulong2x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public ulong2x4_mt8(ulong2_mt8 c0, ulong2_mt8 c1, ulong2_mt8 c2, ulong2_mt8 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public ulong2x4_mt8((ulong2_mt8 c0, ulong2_mt8 c1, ulong2_mt8 c2, ulong2_mt8 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x4_mt8((ulong2_mt8 c0, ulong2_mt8 c1, ulong2_mt8 c2, ulong2_mt8 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong2x4_mt8(
        ulong_mt8 m00, ulong_mt8 m01, ulong_mt8 m02, ulong_mt8 m03,
        ulong_mt8 m10, ulong_mt8 m11, ulong_mt8 m12, ulong_mt8 m13
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
        this.c3 = new(m03, m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x4_mt8((
        ulong_mt8 m00, ulong_mt8 m01, ulong_mt8 m02, ulong_mt8 m03,
        ulong_mt8 m10, ulong_mt8 m11, ulong_mt8 m12, ulong_mt8 m13
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong2x4_mt8((
        ulong_mt8 m00, ulong_mt8 m01, ulong_mt8 m02, ulong_mt8 m03,
        ulong_mt8 m10, ulong_mt8 m11, ulong_mt8 m12, ulong_mt8 m13
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
        this.c3 = new(tuple.m03, tuple.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x4_mt8((
        (ulong_mt8 m00, ulong_mt8 m01, ulong_mt8 m02, ulong_mt8 m03) r0,
        (ulong_mt8 m10, ulong_mt8 m11, ulong_mt8 m12, ulong_mt8 m13) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong2x4_mt8((
        (ulong_mt8 m00, ulong_mt8 m01, ulong_mt8 m02, ulong_mt8 m03) r0,
        (ulong_mt8 m10, ulong_mt8 m11, ulong_mt8 m12, ulong_mt8 m13) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x4_mt8(ulong_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x4_mt8(ulong value) => (ulong_mt8)(value);

    [MethodImpl(256 | 512)]
    public ulong2x4_mt8(ulong_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x4_mt8(ulong2_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong2x4_mt8(ulong2_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out ulong2_mt8 c0, out ulong2_mt8 c1, out ulong2_mt8 c2, out ulong2_mt8 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out ulong_mt8 m00, out ulong_mt8 m01, out ulong_mt8 m02, out ulong_mt8 m03,
        out ulong_mt8 m10, out ulong_mt8 m11, out ulong_mt8 m12, out ulong_mt8 m13
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
        this.c3.Deconstruct(out m03, out m13);
    }

    #endregion // Deconstruct

    #region Index

    public ulong2_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ulong_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static ulong2x4_mt8 operator~(ulong2x4_mt8 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static ulong2x4_mt8 operator|(ulong2x4_mt8 a, ulong2x4_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static ulong2x4_mt8 operator&(ulong2x4_mt8 a, ulong2x4_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static ulong2x4_mt8 operator^(ulong2x4_mt8 a, ulong2x4_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"ulong2x4_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // ulong2x4_mt8

#region ulong2x4_mt16

[CpuOnly]
public partial struct ulong2x4_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => ulong_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 4); 
    }

    public static ulong2x4_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1UL, default, default, default,
            default, 1UL, default, default
        ); 
    }

    #endregion

    #region Fields

    public ulong2_mt16 c0;
    public ulong2_mt16 c1;
    public ulong2_mt16 c2;
    public ulong2_mt16 c3;

    #endregion

    #region Properties

    public ulong_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ulong_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ulong_mt16 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public ulong_mt16 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public ulong_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ulong_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public ulong_mt16 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public ulong_mt16 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly ulong2x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, ulong2x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public ulong2x4_mt16(ulong2_mt16 c0, ulong2_mt16 c1, ulong2_mt16 c2, ulong2_mt16 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public ulong2x4_mt16((ulong2_mt16 c0, ulong2_mt16 c1, ulong2_mt16 c2, ulong2_mt16 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x4_mt16((ulong2_mt16 c0, ulong2_mt16 c1, ulong2_mt16 c2, ulong2_mt16 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong2x4_mt16(
        ulong_mt16 m00, ulong_mt16 m01, ulong_mt16 m02, ulong_mt16 m03,
        ulong_mt16 m10, ulong_mt16 m11, ulong_mt16 m12, ulong_mt16 m13
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
        this.c3 = new(m03, m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x4_mt16((
        ulong_mt16 m00, ulong_mt16 m01, ulong_mt16 m02, ulong_mt16 m03,
        ulong_mt16 m10, ulong_mt16 m11, ulong_mt16 m12, ulong_mt16 m13
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong2x4_mt16((
        ulong_mt16 m00, ulong_mt16 m01, ulong_mt16 m02, ulong_mt16 m03,
        ulong_mt16 m10, ulong_mt16 m11, ulong_mt16 m12, ulong_mt16 m13
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
        this.c3 = new(tuple.m03, tuple.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x4_mt16((
        (ulong_mt16 m00, ulong_mt16 m01, ulong_mt16 m02, ulong_mt16 m03) r0,
        (ulong_mt16 m10, ulong_mt16 m11, ulong_mt16 m12, ulong_mt16 m13) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong2x4_mt16((
        (ulong_mt16 m00, ulong_mt16 m01, ulong_mt16 m02, ulong_mt16 m03) r0,
        (ulong_mt16 m10, ulong_mt16 m11, ulong_mt16 m12, ulong_mt16 m13) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x4_mt16(ulong_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x4_mt16(ulong value) => (ulong_mt16)(value);

    [MethodImpl(256 | 512)]
    public ulong2x4_mt16(ulong_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong2x4_mt16(ulong2_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong2x4_mt16(ulong2_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out ulong2_mt16 c0, out ulong2_mt16 c1, out ulong2_mt16 c2, out ulong2_mt16 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out ulong_mt16 m00, out ulong_mt16 m01, out ulong_mt16 m02, out ulong_mt16 m03,
        out ulong_mt16 m10, out ulong_mt16 m11, out ulong_mt16 m12, out ulong_mt16 m13
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
        this.c3.Deconstruct(out m03, out m13);
    }

    #endregion // Deconstruct

    #region Index

    public ulong2_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ulong_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static ulong2x4_mt16 operator~(ulong2x4_mt16 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static ulong2x4_mt16 operator|(ulong2x4_mt16 a, ulong2x4_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static ulong2x4_mt16 operator&(ulong2x4_mt16 a, ulong2x4_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static ulong2x4_mt16 operator^(ulong2x4_mt16 a, ulong2x4_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"ulong2x4_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // ulong2x4_mt16

#region ulong3x2_mt4

[CpuOnly]
public partial struct ulong3x2_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => ulong_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 2); 
    }

    public static ulong3x2_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1UL, default,
            default, 1UL,
            default, default
        ); 
    }

    #endregion

    #region Fields

    public ulong3_mt4 c0;
    public ulong3_mt4 c1;

    #endregion

    #region Properties

    public ulong_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ulong_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ulong_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ulong_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public ulong_mt4 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public ulong_mt4 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly ulong3x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, ulong3x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public ulong3x2_mt4(ulong3_mt4 c0, ulong3_mt4 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public ulong3x2_mt4((ulong3_mt4 c0, ulong3_mt4 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x2_mt4((ulong3_mt4 c0, ulong3_mt4 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong3x2_mt4(
        ulong_mt4 m00, ulong_mt4 m01,
        ulong_mt4 m10, ulong_mt4 m11,
        ulong_mt4 m20, ulong_mt4 m21
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x2_mt4((
        ulong_mt4 m00, ulong_mt4 m01,
        ulong_mt4 m10, ulong_mt4 m11,
        ulong_mt4 m20, ulong_mt4 m21
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong3x2_mt4((
        ulong_mt4 m00, ulong_mt4 m01,
        ulong_mt4 m10, ulong_mt4 m11,
        ulong_mt4 m20, ulong_mt4 m21
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x2_mt4((
        (ulong_mt4 m00, ulong_mt4 m01) r0,
        (ulong_mt4 m10, ulong_mt4 m11) r1,
        (ulong_mt4 m20, ulong_mt4 m21) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong3x2_mt4((
        (ulong_mt4 m00, ulong_mt4 m01) r0,
        (ulong_mt4 m10, ulong_mt4 m11) r1,
        (ulong_mt4 m20, ulong_mt4 m21) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x2_mt4(ulong_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x2_mt4(ulong value) => (ulong_mt4)(value);

    [MethodImpl(256 | 512)]
    public ulong3x2_mt4(ulong_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x2_mt4(ulong3_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong3x2_mt4(ulong3_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out ulong3_mt4 c0, out ulong3_mt4 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out ulong_mt4 m00, out ulong_mt4 m01,
        out ulong_mt4 m10, out ulong_mt4 m11,
        out ulong_mt4 m20, out ulong_mt4 m21
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
    }

    #endregion // Deconstruct

    #region Index

    public ulong3_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ulong_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static ulong3x2_mt4 operator~(ulong3x2_mt4 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static ulong3x2_mt4 operator|(ulong3x2_mt4 a, ulong3x2_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static ulong3x2_mt4 operator&(ulong3x2_mt4 a, ulong3x2_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static ulong3x2_mt4 operator^(ulong3x2_mt4 a, ulong3x2_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"ulong3x2_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // ulong3x2_mt4

#region ulong3x2_mt8

[CpuOnly]
public partial struct ulong3x2_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => ulong_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 2); 
    }

    public static ulong3x2_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1UL, default,
            default, 1UL,
            default, default
        ); 
    }

    #endregion

    #region Fields

    public ulong3_mt8 c0;
    public ulong3_mt8 c1;

    #endregion

    #region Properties

    public ulong_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ulong_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ulong_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ulong_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public ulong_mt8 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public ulong_mt8 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly ulong3x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, ulong3x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public ulong3x2_mt8(ulong3_mt8 c0, ulong3_mt8 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public ulong3x2_mt8((ulong3_mt8 c0, ulong3_mt8 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x2_mt8((ulong3_mt8 c0, ulong3_mt8 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong3x2_mt8(
        ulong_mt8 m00, ulong_mt8 m01,
        ulong_mt8 m10, ulong_mt8 m11,
        ulong_mt8 m20, ulong_mt8 m21
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x2_mt8((
        ulong_mt8 m00, ulong_mt8 m01,
        ulong_mt8 m10, ulong_mt8 m11,
        ulong_mt8 m20, ulong_mt8 m21
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong3x2_mt8((
        ulong_mt8 m00, ulong_mt8 m01,
        ulong_mt8 m10, ulong_mt8 m11,
        ulong_mt8 m20, ulong_mt8 m21
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x2_mt8((
        (ulong_mt8 m00, ulong_mt8 m01) r0,
        (ulong_mt8 m10, ulong_mt8 m11) r1,
        (ulong_mt8 m20, ulong_mt8 m21) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong3x2_mt8((
        (ulong_mt8 m00, ulong_mt8 m01) r0,
        (ulong_mt8 m10, ulong_mt8 m11) r1,
        (ulong_mt8 m20, ulong_mt8 m21) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x2_mt8(ulong_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x2_mt8(ulong value) => (ulong_mt8)(value);

    [MethodImpl(256 | 512)]
    public ulong3x2_mt8(ulong_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x2_mt8(ulong3_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong3x2_mt8(ulong3_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out ulong3_mt8 c0, out ulong3_mt8 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out ulong_mt8 m00, out ulong_mt8 m01,
        out ulong_mt8 m10, out ulong_mt8 m11,
        out ulong_mt8 m20, out ulong_mt8 m21
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
    }

    #endregion // Deconstruct

    #region Index

    public ulong3_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ulong_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static ulong3x2_mt8 operator~(ulong3x2_mt8 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static ulong3x2_mt8 operator|(ulong3x2_mt8 a, ulong3x2_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static ulong3x2_mt8 operator&(ulong3x2_mt8 a, ulong3x2_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static ulong3x2_mt8 operator^(ulong3x2_mt8 a, ulong3x2_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"ulong3x2_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // ulong3x2_mt8

#region ulong3x2_mt16

[CpuOnly]
public partial struct ulong3x2_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => ulong_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 2); 
    }

    public static ulong3x2_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1UL, default,
            default, 1UL,
            default, default
        ); 
    }

    #endregion

    #region Fields

    public ulong3_mt16 c0;
    public ulong3_mt16 c1;

    #endregion

    #region Properties

    public ulong_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ulong_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ulong_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ulong_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public ulong_mt16 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public ulong_mt16 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly ulong3x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, ulong3x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public ulong3x2_mt16(ulong3_mt16 c0, ulong3_mt16 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public ulong3x2_mt16((ulong3_mt16 c0, ulong3_mt16 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x2_mt16((ulong3_mt16 c0, ulong3_mt16 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong3x2_mt16(
        ulong_mt16 m00, ulong_mt16 m01,
        ulong_mt16 m10, ulong_mt16 m11,
        ulong_mt16 m20, ulong_mt16 m21
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x2_mt16((
        ulong_mt16 m00, ulong_mt16 m01,
        ulong_mt16 m10, ulong_mt16 m11,
        ulong_mt16 m20, ulong_mt16 m21
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong3x2_mt16((
        ulong_mt16 m00, ulong_mt16 m01,
        ulong_mt16 m10, ulong_mt16 m11,
        ulong_mt16 m20, ulong_mt16 m21
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x2_mt16((
        (ulong_mt16 m00, ulong_mt16 m01) r0,
        (ulong_mt16 m10, ulong_mt16 m11) r1,
        (ulong_mt16 m20, ulong_mt16 m21) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong3x2_mt16((
        (ulong_mt16 m00, ulong_mt16 m01) r0,
        (ulong_mt16 m10, ulong_mt16 m11) r1,
        (ulong_mt16 m20, ulong_mt16 m21) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x2_mt16(ulong_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x2_mt16(ulong value) => (ulong_mt16)(value);

    [MethodImpl(256 | 512)]
    public ulong3x2_mt16(ulong_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x2_mt16(ulong3_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong3x2_mt16(ulong3_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out ulong3_mt16 c0, out ulong3_mt16 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out ulong_mt16 m00, out ulong_mt16 m01,
        out ulong_mt16 m10, out ulong_mt16 m11,
        out ulong_mt16 m20, out ulong_mt16 m21
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
    }

    #endregion // Deconstruct

    #region Index

    public ulong3_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ulong_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static ulong3x2_mt16 operator~(ulong3x2_mt16 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static ulong3x2_mt16 operator|(ulong3x2_mt16 a, ulong3x2_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static ulong3x2_mt16 operator&(ulong3x2_mt16 a, ulong3x2_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static ulong3x2_mt16 operator^(ulong3x2_mt16 a, ulong3x2_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"ulong3x2_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // ulong3x2_mt16

#region ulong3x3_mt4

[CpuOnly]
public partial struct ulong3x3_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => ulong_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 9; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 3); 
    }

    public static ulong3x3_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1UL, default, default,
            default, 1UL, default,
            default, default, 1UL
        ); 
    }

    #endregion

    #region Fields

    public ulong3_mt4 c0;
    public ulong3_mt4 c1;
    public ulong3_mt4 c2;

    #endregion

    #region Properties

    public ulong_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ulong_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ulong_mt4 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public ulong_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ulong_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public ulong_mt4 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public ulong_mt4 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public ulong_mt4 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public ulong_mt4 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly ulong3x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, ulong3x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public ulong3x3_mt4(ulong3_mt4 c0, ulong3_mt4 c1, ulong3_mt4 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public ulong3x3_mt4((ulong3_mt4 c0, ulong3_mt4 c1, ulong3_mt4 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x3_mt4((ulong3_mt4 c0, ulong3_mt4 c1, ulong3_mt4 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong3x3_mt4(
        ulong_mt4 m00, ulong_mt4 m01, ulong_mt4 m02,
        ulong_mt4 m10, ulong_mt4 m11, ulong_mt4 m12,
        ulong_mt4 m20, ulong_mt4 m21, ulong_mt4 m22
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x3_mt4((
        ulong_mt4 m00, ulong_mt4 m01, ulong_mt4 m02,
        ulong_mt4 m10, ulong_mt4 m11, ulong_mt4 m12,
        ulong_mt4 m20, ulong_mt4 m21, ulong_mt4 m22
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong3x3_mt4((
        ulong_mt4 m00, ulong_mt4 m01, ulong_mt4 m02,
        ulong_mt4 m10, ulong_mt4 m11, ulong_mt4 m12,
        ulong_mt4 m20, ulong_mt4 m21, ulong_mt4 m22
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x3_mt4((
        (ulong_mt4 m00, ulong_mt4 m01, ulong_mt4 m02) r0,
        (ulong_mt4 m10, ulong_mt4 m11, ulong_mt4 m12) r1,
        (ulong_mt4 m20, ulong_mt4 m21, ulong_mt4 m22) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong3x3_mt4((
        (ulong_mt4 m00, ulong_mt4 m01, ulong_mt4 m02) r0,
        (ulong_mt4 m10, ulong_mt4 m11, ulong_mt4 m12) r1,
        (ulong_mt4 m20, ulong_mt4 m21, ulong_mt4 m22) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x3_mt4(ulong_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x3_mt4(ulong value) => (ulong_mt4)(value);

    [MethodImpl(256 | 512)]
    public ulong3x3_mt4(ulong_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x3_mt4(ulong3_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong3x3_mt4(ulong3_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out ulong3_mt4 c0, out ulong3_mt4 c1, out ulong3_mt4 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out ulong_mt4 m00, out ulong_mt4 m01, out ulong_mt4 m02,
        out ulong_mt4 m10, out ulong_mt4 m11, out ulong_mt4 m12,
        out ulong_mt4 m20, out ulong_mt4 m21, out ulong_mt4 m22
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
    }

    #endregion // Deconstruct

    #region Index

    public ulong3_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ulong_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static ulong3x3_mt4 operator~(ulong3x3_mt4 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static ulong3x3_mt4 operator|(ulong3x3_mt4 a, ulong3x3_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static ulong3x3_mt4 operator&(ulong3x3_mt4 a, ulong3x3_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static ulong3x3_mt4 operator^(ulong3x3_mt4 a, ulong3x3_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"ulong3x3_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // ulong3x3_mt4

#region ulong3x3_mt8

[CpuOnly]
public partial struct ulong3x3_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => ulong_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 9; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 3); 
    }

    public static ulong3x3_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1UL, default, default,
            default, 1UL, default,
            default, default, 1UL
        ); 
    }

    #endregion

    #region Fields

    public ulong3_mt8 c0;
    public ulong3_mt8 c1;
    public ulong3_mt8 c2;

    #endregion

    #region Properties

    public ulong_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ulong_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ulong_mt8 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public ulong_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ulong_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public ulong_mt8 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public ulong_mt8 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public ulong_mt8 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public ulong_mt8 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly ulong3x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, ulong3x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public ulong3x3_mt8(ulong3_mt8 c0, ulong3_mt8 c1, ulong3_mt8 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public ulong3x3_mt8((ulong3_mt8 c0, ulong3_mt8 c1, ulong3_mt8 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x3_mt8((ulong3_mt8 c0, ulong3_mt8 c1, ulong3_mt8 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong3x3_mt8(
        ulong_mt8 m00, ulong_mt8 m01, ulong_mt8 m02,
        ulong_mt8 m10, ulong_mt8 m11, ulong_mt8 m12,
        ulong_mt8 m20, ulong_mt8 m21, ulong_mt8 m22
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x3_mt8((
        ulong_mt8 m00, ulong_mt8 m01, ulong_mt8 m02,
        ulong_mt8 m10, ulong_mt8 m11, ulong_mt8 m12,
        ulong_mt8 m20, ulong_mt8 m21, ulong_mt8 m22
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong3x3_mt8((
        ulong_mt8 m00, ulong_mt8 m01, ulong_mt8 m02,
        ulong_mt8 m10, ulong_mt8 m11, ulong_mt8 m12,
        ulong_mt8 m20, ulong_mt8 m21, ulong_mt8 m22
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x3_mt8((
        (ulong_mt8 m00, ulong_mt8 m01, ulong_mt8 m02) r0,
        (ulong_mt8 m10, ulong_mt8 m11, ulong_mt8 m12) r1,
        (ulong_mt8 m20, ulong_mt8 m21, ulong_mt8 m22) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong3x3_mt8((
        (ulong_mt8 m00, ulong_mt8 m01, ulong_mt8 m02) r0,
        (ulong_mt8 m10, ulong_mt8 m11, ulong_mt8 m12) r1,
        (ulong_mt8 m20, ulong_mt8 m21, ulong_mt8 m22) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x3_mt8(ulong_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x3_mt8(ulong value) => (ulong_mt8)(value);

    [MethodImpl(256 | 512)]
    public ulong3x3_mt8(ulong_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x3_mt8(ulong3_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong3x3_mt8(ulong3_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out ulong3_mt8 c0, out ulong3_mt8 c1, out ulong3_mt8 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out ulong_mt8 m00, out ulong_mt8 m01, out ulong_mt8 m02,
        out ulong_mt8 m10, out ulong_mt8 m11, out ulong_mt8 m12,
        out ulong_mt8 m20, out ulong_mt8 m21, out ulong_mt8 m22
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
    }

    #endregion // Deconstruct

    #region Index

    public ulong3_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ulong_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static ulong3x3_mt8 operator~(ulong3x3_mt8 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static ulong3x3_mt8 operator|(ulong3x3_mt8 a, ulong3x3_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static ulong3x3_mt8 operator&(ulong3x3_mt8 a, ulong3x3_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static ulong3x3_mt8 operator^(ulong3x3_mt8 a, ulong3x3_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"ulong3x3_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // ulong3x3_mt8

#region ulong3x3_mt16

[CpuOnly]
public partial struct ulong3x3_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => ulong_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 9; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 3); 
    }

    public static ulong3x3_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1UL, default, default,
            default, 1UL, default,
            default, default, 1UL
        ); 
    }

    #endregion

    #region Fields

    public ulong3_mt16 c0;
    public ulong3_mt16 c1;
    public ulong3_mt16 c2;

    #endregion

    #region Properties

    public ulong_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ulong_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ulong_mt16 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public ulong_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ulong_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public ulong_mt16 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public ulong_mt16 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public ulong_mt16 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public ulong_mt16 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly ulong3x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, ulong3x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public ulong3x3_mt16(ulong3_mt16 c0, ulong3_mt16 c1, ulong3_mt16 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public ulong3x3_mt16((ulong3_mt16 c0, ulong3_mt16 c1, ulong3_mt16 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x3_mt16((ulong3_mt16 c0, ulong3_mt16 c1, ulong3_mt16 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong3x3_mt16(
        ulong_mt16 m00, ulong_mt16 m01, ulong_mt16 m02,
        ulong_mt16 m10, ulong_mt16 m11, ulong_mt16 m12,
        ulong_mt16 m20, ulong_mt16 m21, ulong_mt16 m22
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x3_mt16((
        ulong_mt16 m00, ulong_mt16 m01, ulong_mt16 m02,
        ulong_mt16 m10, ulong_mt16 m11, ulong_mt16 m12,
        ulong_mt16 m20, ulong_mt16 m21, ulong_mt16 m22
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong3x3_mt16((
        ulong_mt16 m00, ulong_mt16 m01, ulong_mt16 m02,
        ulong_mt16 m10, ulong_mt16 m11, ulong_mt16 m12,
        ulong_mt16 m20, ulong_mt16 m21, ulong_mt16 m22
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x3_mt16((
        (ulong_mt16 m00, ulong_mt16 m01, ulong_mt16 m02) r0,
        (ulong_mt16 m10, ulong_mt16 m11, ulong_mt16 m12) r1,
        (ulong_mt16 m20, ulong_mt16 m21, ulong_mt16 m22) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong3x3_mt16((
        (ulong_mt16 m00, ulong_mt16 m01, ulong_mt16 m02) r0,
        (ulong_mt16 m10, ulong_mt16 m11, ulong_mt16 m12) r1,
        (ulong_mt16 m20, ulong_mt16 m21, ulong_mt16 m22) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x3_mt16(ulong_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x3_mt16(ulong value) => (ulong_mt16)(value);

    [MethodImpl(256 | 512)]
    public ulong3x3_mt16(ulong_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x3_mt16(ulong3_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong3x3_mt16(ulong3_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out ulong3_mt16 c0, out ulong3_mt16 c1, out ulong3_mt16 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out ulong_mt16 m00, out ulong_mt16 m01, out ulong_mt16 m02,
        out ulong_mt16 m10, out ulong_mt16 m11, out ulong_mt16 m12,
        out ulong_mt16 m20, out ulong_mt16 m21, out ulong_mt16 m22
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
    }

    #endregion // Deconstruct

    #region Index

    public ulong3_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ulong_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static ulong3x3_mt16 operator~(ulong3x3_mt16 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static ulong3x3_mt16 operator|(ulong3x3_mt16 a, ulong3x3_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static ulong3x3_mt16 operator&(ulong3x3_mt16 a, ulong3x3_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static ulong3x3_mt16 operator^(ulong3x3_mt16 a, ulong3x3_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"ulong3x3_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // ulong3x3_mt16

#region ulong3x4_mt4

[CpuOnly]
public partial struct ulong3x4_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => ulong_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 4); 
    }

    public static ulong3x4_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1UL, default, default, default,
            default, 1UL, default, default,
            default, default, 1UL, default
        ); 
    }

    #endregion

    #region Fields

    public ulong3_mt4 c0;
    public ulong3_mt4 c1;
    public ulong3_mt4 c2;
    public ulong3_mt4 c3;

    #endregion

    #region Properties

    public ulong_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ulong_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ulong_mt4 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public ulong_mt4 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public ulong_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ulong_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public ulong_mt4 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public ulong_mt4 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public ulong_mt4 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public ulong_mt4 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public ulong_mt4 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public ulong_mt4 m23
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly ulong3x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, ulong3x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public ulong3x4_mt4(ulong3_mt4 c0, ulong3_mt4 c1, ulong3_mt4 c2, ulong3_mt4 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public ulong3x4_mt4((ulong3_mt4 c0, ulong3_mt4 c1, ulong3_mt4 c2, ulong3_mt4 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x4_mt4((ulong3_mt4 c0, ulong3_mt4 c1, ulong3_mt4 c2, ulong3_mt4 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong3x4_mt4(
        ulong_mt4 m00, ulong_mt4 m01, ulong_mt4 m02, ulong_mt4 m03,
        ulong_mt4 m10, ulong_mt4 m11, ulong_mt4 m12, ulong_mt4 m13,
        ulong_mt4 m20, ulong_mt4 m21, ulong_mt4 m22, ulong_mt4 m23
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
        this.c3 = new(m03, m13, m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x4_mt4((
        ulong_mt4 m00, ulong_mt4 m01, ulong_mt4 m02, ulong_mt4 m03,
        ulong_mt4 m10, ulong_mt4 m11, ulong_mt4 m12, ulong_mt4 m13,
        ulong_mt4 m20, ulong_mt4 m21, ulong_mt4 m22, ulong_mt4 m23
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong3x4_mt4((
        ulong_mt4 m00, ulong_mt4 m01, ulong_mt4 m02, ulong_mt4 m03,
        ulong_mt4 m10, ulong_mt4 m11, ulong_mt4 m12, ulong_mt4 m13,
        ulong_mt4 m20, ulong_mt4 m21, ulong_mt4 m22, ulong_mt4 m23
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x4_mt4((
        (ulong_mt4 m00, ulong_mt4 m01, ulong_mt4 m02, ulong_mt4 m03) r0,
        (ulong_mt4 m10, ulong_mt4 m11, ulong_mt4 m12, ulong_mt4 m13) r1,
        (ulong_mt4 m20, ulong_mt4 m21, ulong_mt4 m22, ulong_mt4 m23) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong3x4_mt4((
        (ulong_mt4 m00, ulong_mt4 m01, ulong_mt4 m02, ulong_mt4 m03) r0,
        (ulong_mt4 m10, ulong_mt4 m11, ulong_mt4 m12, ulong_mt4 m13) r1,
        (ulong_mt4 m20, ulong_mt4 m21, ulong_mt4 m22, ulong_mt4 m23) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x4_mt4(ulong_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x4_mt4(ulong value) => (ulong_mt4)(value);

    [MethodImpl(256 | 512)]
    public ulong3x4_mt4(ulong_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x4_mt4(ulong3_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong3x4_mt4(ulong3_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out ulong3_mt4 c0, out ulong3_mt4 c1, out ulong3_mt4 c2, out ulong3_mt4 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out ulong_mt4 m00, out ulong_mt4 m01, out ulong_mt4 m02, out ulong_mt4 m03,
        out ulong_mt4 m10, out ulong_mt4 m11, out ulong_mt4 m12, out ulong_mt4 m13,
        out ulong_mt4 m20, out ulong_mt4 m21, out ulong_mt4 m22, out ulong_mt4 m23
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
        this.c3.Deconstruct(out m03, out m13, out m23);
    }

    #endregion // Deconstruct

    #region Index

    public ulong3_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ulong_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static ulong3x4_mt4 operator~(ulong3x4_mt4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static ulong3x4_mt4 operator|(ulong3x4_mt4 a, ulong3x4_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static ulong3x4_mt4 operator&(ulong3x4_mt4 a, ulong3x4_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static ulong3x4_mt4 operator^(ulong3x4_mt4 a, ulong3x4_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"ulong3x4_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // ulong3x4_mt4

#region ulong3x4_mt8

[CpuOnly]
public partial struct ulong3x4_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => ulong_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 4); 
    }

    public static ulong3x4_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1UL, default, default, default,
            default, 1UL, default, default,
            default, default, 1UL, default
        ); 
    }

    #endregion

    #region Fields

    public ulong3_mt8 c0;
    public ulong3_mt8 c1;
    public ulong3_mt8 c2;
    public ulong3_mt8 c3;

    #endregion

    #region Properties

    public ulong_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ulong_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ulong_mt8 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public ulong_mt8 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public ulong_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ulong_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public ulong_mt8 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public ulong_mt8 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public ulong_mt8 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public ulong_mt8 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public ulong_mt8 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public ulong_mt8 m23
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly ulong3x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, ulong3x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public ulong3x4_mt8(ulong3_mt8 c0, ulong3_mt8 c1, ulong3_mt8 c2, ulong3_mt8 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public ulong3x4_mt8((ulong3_mt8 c0, ulong3_mt8 c1, ulong3_mt8 c2, ulong3_mt8 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x4_mt8((ulong3_mt8 c0, ulong3_mt8 c1, ulong3_mt8 c2, ulong3_mt8 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong3x4_mt8(
        ulong_mt8 m00, ulong_mt8 m01, ulong_mt8 m02, ulong_mt8 m03,
        ulong_mt8 m10, ulong_mt8 m11, ulong_mt8 m12, ulong_mt8 m13,
        ulong_mt8 m20, ulong_mt8 m21, ulong_mt8 m22, ulong_mt8 m23
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
        this.c3 = new(m03, m13, m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x4_mt8((
        ulong_mt8 m00, ulong_mt8 m01, ulong_mt8 m02, ulong_mt8 m03,
        ulong_mt8 m10, ulong_mt8 m11, ulong_mt8 m12, ulong_mt8 m13,
        ulong_mt8 m20, ulong_mt8 m21, ulong_mt8 m22, ulong_mt8 m23
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong3x4_mt8((
        ulong_mt8 m00, ulong_mt8 m01, ulong_mt8 m02, ulong_mt8 m03,
        ulong_mt8 m10, ulong_mt8 m11, ulong_mt8 m12, ulong_mt8 m13,
        ulong_mt8 m20, ulong_mt8 m21, ulong_mt8 m22, ulong_mt8 m23
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x4_mt8((
        (ulong_mt8 m00, ulong_mt8 m01, ulong_mt8 m02, ulong_mt8 m03) r0,
        (ulong_mt8 m10, ulong_mt8 m11, ulong_mt8 m12, ulong_mt8 m13) r1,
        (ulong_mt8 m20, ulong_mt8 m21, ulong_mt8 m22, ulong_mt8 m23) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong3x4_mt8((
        (ulong_mt8 m00, ulong_mt8 m01, ulong_mt8 m02, ulong_mt8 m03) r0,
        (ulong_mt8 m10, ulong_mt8 m11, ulong_mt8 m12, ulong_mt8 m13) r1,
        (ulong_mt8 m20, ulong_mt8 m21, ulong_mt8 m22, ulong_mt8 m23) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x4_mt8(ulong_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x4_mt8(ulong value) => (ulong_mt8)(value);

    [MethodImpl(256 | 512)]
    public ulong3x4_mt8(ulong_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x4_mt8(ulong3_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong3x4_mt8(ulong3_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out ulong3_mt8 c0, out ulong3_mt8 c1, out ulong3_mt8 c2, out ulong3_mt8 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out ulong_mt8 m00, out ulong_mt8 m01, out ulong_mt8 m02, out ulong_mt8 m03,
        out ulong_mt8 m10, out ulong_mt8 m11, out ulong_mt8 m12, out ulong_mt8 m13,
        out ulong_mt8 m20, out ulong_mt8 m21, out ulong_mt8 m22, out ulong_mt8 m23
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
        this.c3.Deconstruct(out m03, out m13, out m23);
    }

    #endregion // Deconstruct

    #region Index

    public ulong3_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ulong_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static ulong3x4_mt8 operator~(ulong3x4_mt8 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static ulong3x4_mt8 operator|(ulong3x4_mt8 a, ulong3x4_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static ulong3x4_mt8 operator&(ulong3x4_mt8 a, ulong3x4_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static ulong3x4_mt8 operator^(ulong3x4_mt8 a, ulong3x4_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"ulong3x4_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // ulong3x4_mt8

#region ulong3x4_mt16

[CpuOnly]
public partial struct ulong3x4_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => ulong_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 4); 
    }

    public static ulong3x4_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1UL, default, default, default,
            default, 1UL, default, default,
            default, default, 1UL, default
        ); 
    }

    #endregion

    #region Fields

    public ulong3_mt16 c0;
    public ulong3_mt16 c1;
    public ulong3_mt16 c2;
    public ulong3_mt16 c3;

    #endregion

    #region Properties

    public ulong_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ulong_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ulong_mt16 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public ulong_mt16 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public ulong_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ulong_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public ulong_mt16 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public ulong_mt16 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public ulong_mt16 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public ulong_mt16 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public ulong_mt16 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public ulong_mt16 m23
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly ulong3x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, ulong3x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public ulong3x4_mt16(ulong3_mt16 c0, ulong3_mt16 c1, ulong3_mt16 c2, ulong3_mt16 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public ulong3x4_mt16((ulong3_mt16 c0, ulong3_mt16 c1, ulong3_mt16 c2, ulong3_mt16 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x4_mt16((ulong3_mt16 c0, ulong3_mt16 c1, ulong3_mt16 c2, ulong3_mt16 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong3x4_mt16(
        ulong_mt16 m00, ulong_mt16 m01, ulong_mt16 m02, ulong_mt16 m03,
        ulong_mt16 m10, ulong_mt16 m11, ulong_mt16 m12, ulong_mt16 m13,
        ulong_mt16 m20, ulong_mt16 m21, ulong_mt16 m22, ulong_mt16 m23
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
        this.c3 = new(m03, m13, m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x4_mt16((
        ulong_mt16 m00, ulong_mt16 m01, ulong_mt16 m02, ulong_mt16 m03,
        ulong_mt16 m10, ulong_mt16 m11, ulong_mt16 m12, ulong_mt16 m13,
        ulong_mt16 m20, ulong_mt16 m21, ulong_mt16 m22, ulong_mt16 m23
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong3x4_mt16((
        ulong_mt16 m00, ulong_mt16 m01, ulong_mt16 m02, ulong_mt16 m03,
        ulong_mt16 m10, ulong_mt16 m11, ulong_mt16 m12, ulong_mt16 m13,
        ulong_mt16 m20, ulong_mt16 m21, ulong_mt16 m22, ulong_mt16 m23
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x4_mt16((
        (ulong_mt16 m00, ulong_mt16 m01, ulong_mt16 m02, ulong_mt16 m03) r0,
        (ulong_mt16 m10, ulong_mt16 m11, ulong_mt16 m12, ulong_mt16 m13) r1,
        (ulong_mt16 m20, ulong_mt16 m21, ulong_mt16 m22, ulong_mt16 m23) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong3x4_mt16((
        (ulong_mt16 m00, ulong_mt16 m01, ulong_mt16 m02, ulong_mt16 m03) r0,
        (ulong_mt16 m10, ulong_mt16 m11, ulong_mt16 m12, ulong_mt16 m13) r1,
        (ulong_mt16 m20, ulong_mt16 m21, ulong_mt16 m22, ulong_mt16 m23) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x4_mt16(ulong_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x4_mt16(ulong value) => (ulong_mt16)(value);

    [MethodImpl(256 | 512)]
    public ulong3x4_mt16(ulong_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong3x4_mt16(ulong3_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong3x4_mt16(ulong3_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out ulong3_mt16 c0, out ulong3_mt16 c1, out ulong3_mt16 c2, out ulong3_mt16 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out ulong_mt16 m00, out ulong_mt16 m01, out ulong_mt16 m02, out ulong_mt16 m03,
        out ulong_mt16 m10, out ulong_mt16 m11, out ulong_mt16 m12, out ulong_mt16 m13,
        out ulong_mt16 m20, out ulong_mt16 m21, out ulong_mt16 m22, out ulong_mt16 m23
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
        this.c3.Deconstruct(out m03, out m13, out m23);
    }

    #endregion // Deconstruct

    #region Index

    public ulong3_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ulong_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static ulong3x4_mt16 operator~(ulong3x4_mt16 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static ulong3x4_mt16 operator|(ulong3x4_mt16 a, ulong3x4_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static ulong3x4_mt16 operator&(ulong3x4_mt16 a, ulong3x4_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static ulong3x4_mt16 operator^(ulong3x4_mt16 a, ulong3x4_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"ulong3x4_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // ulong3x4_mt16

#region ulong4x2_mt4

[CpuOnly]
public partial struct ulong4x2_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => ulong_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 2); 
    }

    public static ulong4x2_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1UL, default,
            default, 1UL,
            default, default,
            default, default
        ); 
    }

    #endregion

    #region Fields

    public ulong4_mt4 c0;
    public ulong4_mt4 c1;

    #endregion

    #region Properties

    public ulong_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ulong_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ulong_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ulong_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public ulong_mt4 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public ulong_mt4 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public ulong_mt4 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public ulong_mt4 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly ulong4x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, ulong4x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public ulong4x2_mt4(ulong4_mt4 c0, ulong4_mt4 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public ulong4x2_mt4((ulong4_mt4 c0, ulong4_mt4 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x2_mt4((ulong4_mt4 c0, ulong4_mt4 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong4x2_mt4(
        ulong_mt4 m00, ulong_mt4 m01,
        ulong_mt4 m10, ulong_mt4 m11,
        ulong_mt4 m20, ulong_mt4 m21,
        ulong_mt4 m30, ulong_mt4 m31
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x2_mt4((
        ulong_mt4 m00, ulong_mt4 m01,
        ulong_mt4 m10, ulong_mt4 m11,
        ulong_mt4 m20, ulong_mt4 m21,
        ulong_mt4 m30, ulong_mt4 m31
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong4x2_mt4((
        ulong_mt4 m00, ulong_mt4 m01,
        ulong_mt4 m10, ulong_mt4 m11,
        ulong_mt4 m20, ulong_mt4 m21,
        ulong_mt4 m30, ulong_mt4 m31
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x2_mt4((
        (ulong_mt4 m00, ulong_mt4 m01) r0,
        (ulong_mt4 m10, ulong_mt4 m11) r1,
        (ulong_mt4 m20, ulong_mt4 m21) r2,
        (ulong_mt4 m30, ulong_mt4 m31) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong4x2_mt4((
        (ulong_mt4 m00, ulong_mt4 m01) r0,
        (ulong_mt4 m10, ulong_mt4 m11) r1,
        (ulong_mt4 m20, ulong_mt4 m21) r2,
        (ulong_mt4 m30, ulong_mt4 m31) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x2_mt4(ulong_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x2_mt4(ulong value) => (ulong_mt4)(value);

    [MethodImpl(256 | 512)]
    public ulong4x2_mt4(ulong_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x2_mt4(ulong4_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong4x2_mt4(ulong4_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out ulong4_mt4 c0, out ulong4_mt4 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out ulong_mt4 m00, out ulong_mt4 m01,
        out ulong_mt4 m10, out ulong_mt4 m11,
        out ulong_mt4 m20, out ulong_mt4 m21,
        out ulong_mt4 m30, out ulong_mt4 m31
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
    }

    #endregion // Deconstruct

    #region Index

    public ulong4_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ulong_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static ulong4x2_mt4 operator~(ulong4x2_mt4 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static ulong4x2_mt4 operator|(ulong4x2_mt4 a, ulong4x2_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static ulong4x2_mt4 operator&(ulong4x2_mt4 a, ulong4x2_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static ulong4x2_mt4 operator^(ulong4x2_mt4 a, ulong4x2_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"ulong4x2_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // ulong4x2_mt4

#region ulong4x2_mt8

[CpuOnly]
public partial struct ulong4x2_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => ulong_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 2); 
    }

    public static ulong4x2_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1UL, default,
            default, 1UL,
            default, default,
            default, default
        ); 
    }

    #endregion

    #region Fields

    public ulong4_mt8 c0;
    public ulong4_mt8 c1;

    #endregion

    #region Properties

    public ulong_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ulong_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ulong_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ulong_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public ulong_mt8 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public ulong_mt8 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public ulong_mt8 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public ulong_mt8 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly ulong4x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, ulong4x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public ulong4x2_mt8(ulong4_mt8 c0, ulong4_mt8 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public ulong4x2_mt8((ulong4_mt8 c0, ulong4_mt8 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x2_mt8((ulong4_mt8 c0, ulong4_mt8 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong4x2_mt8(
        ulong_mt8 m00, ulong_mt8 m01,
        ulong_mt8 m10, ulong_mt8 m11,
        ulong_mt8 m20, ulong_mt8 m21,
        ulong_mt8 m30, ulong_mt8 m31
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x2_mt8((
        ulong_mt8 m00, ulong_mt8 m01,
        ulong_mt8 m10, ulong_mt8 m11,
        ulong_mt8 m20, ulong_mt8 m21,
        ulong_mt8 m30, ulong_mt8 m31
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong4x2_mt8((
        ulong_mt8 m00, ulong_mt8 m01,
        ulong_mt8 m10, ulong_mt8 m11,
        ulong_mt8 m20, ulong_mt8 m21,
        ulong_mt8 m30, ulong_mt8 m31
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x2_mt8((
        (ulong_mt8 m00, ulong_mt8 m01) r0,
        (ulong_mt8 m10, ulong_mt8 m11) r1,
        (ulong_mt8 m20, ulong_mt8 m21) r2,
        (ulong_mt8 m30, ulong_mt8 m31) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong4x2_mt8((
        (ulong_mt8 m00, ulong_mt8 m01) r0,
        (ulong_mt8 m10, ulong_mt8 m11) r1,
        (ulong_mt8 m20, ulong_mt8 m21) r2,
        (ulong_mt8 m30, ulong_mt8 m31) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x2_mt8(ulong_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x2_mt8(ulong value) => (ulong_mt8)(value);

    [MethodImpl(256 | 512)]
    public ulong4x2_mt8(ulong_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x2_mt8(ulong4_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong4x2_mt8(ulong4_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out ulong4_mt8 c0, out ulong4_mt8 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out ulong_mt8 m00, out ulong_mt8 m01,
        out ulong_mt8 m10, out ulong_mt8 m11,
        out ulong_mt8 m20, out ulong_mt8 m21,
        out ulong_mt8 m30, out ulong_mt8 m31
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
    }

    #endregion // Deconstruct

    #region Index

    public ulong4_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ulong_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static ulong4x2_mt8 operator~(ulong4x2_mt8 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static ulong4x2_mt8 operator|(ulong4x2_mt8 a, ulong4x2_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static ulong4x2_mt8 operator&(ulong4x2_mt8 a, ulong4x2_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static ulong4x2_mt8 operator^(ulong4x2_mt8 a, ulong4x2_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"ulong4x2_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // ulong4x2_mt8

#region ulong4x2_mt16

[CpuOnly]
public partial struct ulong4x2_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => ulong_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 2); 
    }

    public static ulong4x2_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1UL, default,
            default, 1UL,
            default, default,
            default, default
        ); 
    }

    #endregion

    #region Fields

    public ulong4_mt16 c0;
    public ulong4_mt16 c1;

    #endregion

    #region Properties

    public ulong_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ulong_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ulong_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ulong_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public ulong_mt16 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public ulong_mt16 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public ulong_mt16 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public ulong_mt16 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly ulong4x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, ulong4x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public ulong4x2_mt16(ulong4_mt16 c0, ulong4_mt16 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public ulong4x2_mt16((ulong4_mt16 c0, ulong4_mt16 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x2_mt16((ulong4_mt16 c0, ulong4_mt16 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong4x2_mt16(
        ulong_mt16 m00, ulong_mt16 m01,
        ulong_mt16 m10, ulong_mt16 m11,
        ulong_mt16 m20, ulong_mt16 m21,
        ulong_mt16 m30, ulong_mt16 m31
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x2_mt16((
        ulong_mt16 m00, ulong_mt16 m01,
        ulong_mt16 m10, ulong_mt16 m11,
        ulong_mt16 m20, ulong_mt16 m21,
        ulong_mt16 m30, ulong_mt16 m31
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong4x2_mt16((
        ulong_mt16 m00, ulong_mt16 m01,
        ulong_mt16 m10, ulong_mt16 m11,
        ulong_mt16 m20, ulong_mt16 m21,
        ulong_mt16 m30, ulong_mt16 m31
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x2_mt16((
        (ulong_mt16 m00, ulong_mt16 m01) r0,
        (ulong_mt16 m10, ulong_mt16 m11) r1,
        (ulong_mt16 m20, ulong_mt16 m21) r2,
        (ulong_mt16 m30, ulong_mt16 m31) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong4x2_mt16((
        (ulong_mt16 m00, ulong_mt16 m01) r0,
        (ulong_mt16 m10, ulong_mt16 m11) r1,
        (ulong_mt16 m20, ulong_mt16 m21) r2,
        (ulong_mt16 m30, ulong_mt16 m31) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x2_mt16(ulong_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x2_mt16(ulong value) => (ulong_mt16)(value);

    [MethodImpl(256 | 512)]
    public ulong4x2_mt16(ulong_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x2_mt16(ulong4_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong4x2_mt16(ulong4_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out ulong4_mt16 c0, out ulong4_mt16 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out ulong_mt16 m00, out ulong_mt16 m01,
        out ulong_mt16 m10, out ulong_mt16 m11,
        out ulong_mt16 m20, out ulong_mt16 m21,
        out ulong_mt16 m30, out ulong_mt16 m31
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
    }

    #endregion // Deconstruct

    #region Index

    public ulong4_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ulong_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static ulong4x2_mt16 operator~(ulong4x2_mt16 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static ulong4x2_mt16 operator|(ulong4x2_mt16 a, ulong4x2_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static ulong4x2_mt16 operator&(ulong4x2_mt16 a, ulong4x2_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static ulong4x2_mt16 operator^(ulong4x2_mt16 a, ulong4x2_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"ulong4x2_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // ulong4x2_mt16

#region ulong4x3_mt4

[CpuOnly]
public partial struct ulong4x3_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => ulong_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 3); 
    }

    public static ulong4x3_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1UL, default, default,
            default, 1UL, default,
            default, default, 1UL,
            default, default, default
        ); 
    }

    #endregion

    #region Fields

    public ulong4_mt4 c0;
    public ulong4_mt4 c1;
    public ulong4_mt4 c2;

    #endregion

    #region Properties

    public ulong_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ulong_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ulong_mt4 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public ulong_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ulong_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public ulong_mt4 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public ulong_mt4 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public ulong_mt4 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public ulong_mt4 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public ulong_mt4 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public ulong_mt4 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public ulong_mt4 m32
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly ulong4x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, ulong4x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public ulong4x3_mt4(ulong4_mt4 c0, ulong4_mt4 c1, ulong4_mt4 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public ulong4x3_mt4((ulong4_mt4 c0, ulong4_mt4 c1, ulong4_mt4 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x3_mt4((ulong4_mt4 c0, ulong4_mt4 c1, ulong4_mt4 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong4x3_mt4(
        ulong_mt4 m00, ulong_mt4 m01, ulong_mt4 m02,
        ulong_mt4 m10, ulong_mt4 m11, ulong_mt4 m12,
        ulong_mt4 m20, ulong_mt4 m21, ulong_mt4 m22,
        ulong_mt4 m30, ulong_mt4 m31, ulong_mt4 m32
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x3_mt4((
        ulong_mt4 m00, ulong_mt4 m01, ulong_mt4 m02,
        ulong_mt4 m10, ulong_mt4 m11, ulong_mt4 m12,
        ulong_mt4 m20, ulong_mt4 m21, ulong_mt4 m22,
        ulong_mt4 m30, ulong_mt4 m31, ulong_mt4 m32
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong4x3_mt4((
        ulong_mt4 m00, ulong_mt4 m01, ulong_mt4 m02,
        ulong_mt4 m10, ulong_mt4 m11, ulong_mt4 m12,
        ulong_mt4 m20, ulong_mt4 m21, ulong_mt4 m22,
        ulong_mt4 m30, ulong_mt4 m31, ulong_mt4 m32
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x3_mt4((
        (ulong_mt4 m00, ulong_mt4 m01, ulong_mt4 m02) r0,
        (ulong_mt4 m10, ulong_mt4 m11, ulong_mt4 m12) r1,
        (ulong_mt4 m20, ulong_mt4 m21, ulong_mt4 m22) r2,
        (ulong_mt4 m30, ulong_mt4 m31, ulong_mt4 m32) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong4x3_mt4((
        (ulong_mt4 m00, ulong_mt4 m01, ulong_mt4 m02) r0,
        (ulong_mt4 m10, ulong_mt4 m11, ulong_mt4 m12) r1,
        (ulong_mt4 m20, ulong_mt4 m21, ulong_mt4 m22) r2,
        (ulong_mt4 m30, ulong_mt4 m31, ulong_mt4 m32) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x3_mt4(ulong_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x3_mt4(ulong value) => (ulong_mt4)(value);

    [MethodImpl(256 | 512)]
    public ulong4x3_mt4(ulong_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x3_mt4(ulong4_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong4x3_mt4(ulong4_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out ulong4_mt4 c0, out ulong4_mt4 c1, out ulong4_mt4 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out ulong_mt4 m00, out ulong_mt4 m01, out ulong_mt4 m02,
        out ulong_mt4 m10, out ulong_mt4 m11, out ulong_mt4 m12,
        out ulong_mt4 m20, out ulong_mt4 m21, out ulong_mt4 m22,
        out ulong_mt4 m30, out ulong_mt4 m31, out ulong_mt4 m32
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
    }

    #endregion // Deconstruct

    #region Index

    public ulong4_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ulong_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static ulong4x3_mt4 operator~(ulong4x3_mt4 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static ulong4x3_mt4 operator|(ulong4x3_mt4 a, ulong4x3_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static ulong4x3_mt4 operator&(ulong4x3_mt4 a, ulong4x3_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static ulong4x3_mt4 operator^(ulong4x3_mt4 a, ulong4x3_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"ulong4x3_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // ulong4x3_mt4

#region ulong4x3_mt8

[CpuOnly]
public partial struct ulong4x3_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => ulong_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 3); 
    }

    public static ulong4x3_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1UL, default, default,
            default, 1UL, default,
            default, default, 1UL,
            default, default, default
        ); 
    }

    #endregion

    #region Fields

    public ulong4_mt8 c0;
    public ulong4_mt8 c1;
    public ulong4_mt8 c2;

    #endregion

    #region Properties

    public ulong_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ulong_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ulong_mt8 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public ulong_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ulong_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public ulong_mt8 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public ulong_mt8 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public ulong_mt8 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public ulong_mt8 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public ulong_mt8 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public ulong_mt8 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public ulong_mt8 m32
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly ulong4x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, ulong4x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public ulong4x3_mt8(ulong4_mt8 c0, ulong4_mt8 c1, ulong4_mt8 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public ulong4x3_mt8((ulong4_mt8 c0, ulong4_mt8 c1, ulong4_mt8 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x3_mt8((ulong4_mt8 c0, ulong4_mt8 c1, ulong4_mt8 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong4x3_mt8(
        ulong_mt8 m00, ulong_mt8 m01, ulong_mt8 m02,
        ulong_mt8 m10, ulong_mt8 m11, ulong_mt8 m12,
        ulong_mt8 m20, ulong_mt8 m21, ulong_mt8 m22,
        ulong_mt8 m30, ulong_mt8 m31, ulong_mt8 m32
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x3_mt8((
        ulong_mt8 m00, ulong_mt8 m01, ulong_mt8 m02,
        ulong_mt8 m10, ulong_mt8 m11, ulong_mt8 m12,
        ulong_mt8 m20, ulong_mt8 m21, ulong_mt8 m22,
        ulong_mt8 m30, ulong_mt8 m31, ulong_mt8 m32
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong4x3_mt8((
        ulong_mt8 m00, ulong_mt8 m01, ulong_mt8 m02,
        ulong_mt8 m10, ulong_mt8 m11, ulong_mt8 m12,
        ulong_mt8 m20, ulong_mt8 m21, ulong_mt8 m22,
        ulong_mt8 m30, ulong_mt8 m31, ulong_mt8 m32
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x3_mt8((
        (ulong_mt8 m00, ulong_mt8 m01, ulong_mt8 m02) r0,
        (ulong_mt8 m10, ulong_mt8 m11, ulong_mt8 m12) r1,
        (ulong_mt8 m20, ulong_mt8 m21, ulong_mt8 m22) r2,
        (ulong_mt8 m30, ulong_mt8 m31, ulong_mt8 m32) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong4x3_mt8((
        (ulong_mt8 m00, ulong_mt8 m01, ulong_mt8 m02) r0,
        (ulong_mt8 m10, ulong_mt8 m11, ulong_mt8 m12) r1,
        (ulong_mt8 m20, ulong_mt8 m21, ulong_mt8 m22) r2,
        (ulong_mt8 m30, ulong_mt8 m31, ulong_mt8 m32) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x3_mt8(ulong_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x3_mt8(ulong value) => (ulong_mt8)(value);

    [MethodImpl(256 | 512)]
    public ulong4x3_mt8(ulong_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x3_mt8(ulong4_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong4x3_mt8(ulong4_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out ulong4_mt8 c0, out ulong4_mt8 c1, out ulong4_mt8 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out ulong_mt8 m00, out ulong_mt8 m01, out ulong_mt8 m02,
        out ulong_mt8 m10, out ulong_mt8 m11, out ulong_mt8 m12,
        out ulong_mt8 m20, out ulong_mt8 m21, out ulong_mt8 m22,
        out ulong_mt8 m30, out ulong_mt8 m31, out ulong_mt8 m32
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
    }

    #endregion // Deconstruct

    #region Index

    public ulong4_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ulong_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static ulong4x3_mt8 operator~(ulong4x3_mt8 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static ulong4x3_mt8 operator|(ulong4x3_mt8 a, ulong4x3_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static ulong4x3_mt8 operator&(ulong4x3_mt8 a, ulong4x3_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static ulong4x3_mt8 operator^(ulong4x3_mt8 a, ulong4x3_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"ulong4x3_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // ulong4x3_mt8

#region ulong4x3_mt16

[CpuOnly]
public partial struct ulong4x3_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => ulong_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 3); 
    }

    public static ulong4x3_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1UL, default, default,
            default, 1UL, default,
            default, default, 1UL,
            default, default, default
        ); 
    }

    #endregion

    #region Fields

    public ulong4_mt16 c0;
    public ulong4_mt16 c1;
    public ulong4_mt16 c2;

    #endregion

    #region Properties

    public ulong_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ulong_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ulong_mt16 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public ulong_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ulong_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public ulong_mt16 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public ulong_mt16 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public ulong_mt16 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public ulong_mt16 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public ulong_mt16 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public ulong_mt16 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public ulong_mt16 m32
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly ulong4x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, ulong4x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public ulong4x3_mt16(ulong4_mt16 c0, ulong4_mt16 c1, ulong4_mt16 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public ulong4x3_mt16((ulong4_mt16 c0, ulong4_mt16 c1, ulong4_mt16 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x3_mt16((ulong4_mt16 c0, ulong4_mt16 c1, ulong4_mt16 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong4x3_mt16(
        ulong_mt16 m00, ulong_mt16 m01, ulong_mt16 m02,
        ulong_mt16 m10, ulong_mt16 m11, ulong_mt16 m12,
        ulong_mt16 m20, ulong_mt16 m21, ulong_mt16 m22,
        ulong_mt16 m30, ulong_mt16 m31, ulong_mt16 m32
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x3_mt16((
        ulong_mt16 m00, ulong_mt16 m01, ulong_mt16 m02,
        ulong_mt16 m10, ulong_mt16 m11, ulong_mt16 m12,
        ulong_mt16 m20, ulong_mt16 m21, ulong_mt16 m22,
        ulong_mt16 m30, ulong_mt16 m31, ulong_mt16 m32
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong4x3_mt16((
        ulong_mt16 m00, ulong_mt16 m01, ulong_mt16 m02,
        ulong_mt16 m10, ulong_mt16 m11, ulong_mt16 m12,
        ulong_mt16 m20, ulong_mt16 m21, ulong_mt16 m22,
        ulong_mt16 m30, ulong_mt16 m31, ulong_mt16 m32
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x3_mt16((
        (ulong_mt16 m00, ulong_mt16 m01, ulong_mt16 m02) r0,
        (ulong_mt16 m10, ulong_mt16 m11, ulong_mt16 m12) r1,
        (ulong_mt16 m20, ulong_mt16 m21, ulong_mt16 m22) r2,
        (ulong_mt16 m30, ulong_mt16 m31, ulong_mt16 m32) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong4x3_mt16((
        (ulong_mt16 m00, ulong_mt16 m01, ulong_mt16 m02) r0,
        (ulong_mt16 m10, ulong_mt16 m11, ulong_mt16 m12) r1,
        (ulong_mt16 m20, ulong_mt16 m21, ulong_mt16 m22) r2,
        (ulong_mt16 m30, ulong_mt16 m31, ulong_mt16 m32) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x3_mt16(ulong_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x3_mt16(ulong value) => (ulong_mt16)(value);

    [MethodImpl(256 | 512)]
    public ulong4x3_mt16(ulong_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x3_mt16(ulong4_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong4x3_mt16(ulong4_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out ulong4_mt16 c0, out ulong4_mt16 c1, out ulong4_mt16 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out ulong_mt16 m00, out ulong_mt16 m01, out ulong_mt16 m02,
        out ulong_mt16 m10, out ulong_mt16 m11, out ulong_mt16 m12,
        out ulong_mt16 m20, out ulong_mt16 m21, out ulong_mt16 m22,
        out ulong_mt16 m30, out ulong_mt16 m31, out ulong_mt16 m32
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
    }

    #endregion // Deconstruct

    #region Index

    public ulong4_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ulong_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static ulong4x3_mt16 operator~(ulong4x3_mt16 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static ulong4x3_mt16 operator|(ulong4x3_mt16 a, ulong4x3_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static ulong4x3_mt16 operator&(ulong4x3_mt16 a, ulong4x3_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static ulong4x3_mt16 operator^(ulong4x3_mt16 a, ulong4x3_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"ulong4x3_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // ulong4x3_mt16

#region ulong4x4_mt4

[CpuOnly]
public partial struct ulong4x4_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => ulong_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 4); 
    }

    public static ulong4x4_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1UL, default, default, default,
            default, 1UL, default, default,
            default, default, 1UL, default,
            default, default, default, 1UL
        ); 
    }

    #endregion

    #region Fields

    public ulong4_mt4 c0;
    public ulong4_mt4 c1;
    public ulong4_mt4 c2;
    public ulong4_mt4 c3;

    #endregion

    #region Properties

    public ulong_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ulong_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ulong_mt4 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public ulong_mt4 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public ulong_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ulong_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public ulong_mt4 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public ulong_mt4 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public ulong_mt4 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public ulong_mt4 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public ulong_mt4 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public ulong_mt4 m23
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }
    public ulong_mt4 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public ulong_mt4 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public ulong_mt4 m32
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }
    public ulong_mt4 m33
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.w;
        [MethodImpl(256 | 512)]
        set => c3.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly ulong4x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, ulong4x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public ulong4x4_mt4(ulong4_mt4 c0, ulong4_mt4 c1, ulong4_mt4 c2, ulong4_mt4 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public ulong4x4_mt4((ulong4_mt4 c0, ulong4_mt4 c1, ulong4_mt4 c2, ulong4_mt4 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x4_mt4((ulong4_mt4 c0, ulong4_mt4 c1, ulong4_mt4 c2, ulong4_mt4 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong4x4_mt4(
        ulong_mt4 m00, ulong_mt4 m01, ulong_mt4 m02, ulong_mt4 m03,
        ulong_mt4 m10, ulong_mt4 m11, ulong_mt4 m12, ulong_mt4 m13,
        ulong_mt4 m20, ulong_mt4 m21, ulong_mt4 m22, ulong_mt4 m23,
        ulong_mt4 m30, ulong_mt4 m31, ulong_mt4 m32, ulong_mt4 m33
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
        this.c3 = new(m03, m13, m23, m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x4_mt4((
        ulong_mt4 m00, ulong_mt4 m01, ulong_mt4 m02, ulong_mt4 m03,
        ulong_mt4 m10, ulong_mt4 m11, ulong_mt4 m12, ulong_mt4 m13,
        ulong_mt4 m20, ulong_mt4 m21, ulong_mt4 m22, ulong_mt4 m23,
        ulong_mt4 m30, ulong_mt4 m31, ulong_mt4 m32, ulong_mt4 m33
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong4x4_mt4((
        ulong_mt4 m00, ulong_mt4 m01, ulong_mt4 m02, ulong_mt4 m03,
        ulong_mt4 m10, ulong_mt4 m11, ulong_mt4 m12, ulong_mt4 m13,
        ulong_mt4 m20, ulong_mt4 m21, ulong_mt4 m22, ulong_mt4 m23,
        ulong_mt4 m30, ulong_mt4 m31, ulong_mt4 m32, ulong_mt4 m33
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23, tuple.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x4_mt4((
        (ulong_mt4 m00, ulong_mt4 m01, ulong_mt4 m02, ulong_mt4 m03) r0,
        (ulong_mt4 m10, ulong_mt4 m11, ulong_mt4 m12, ulong_mt4 m13) r1,
        (ulong_mt4 m20, ulong_mt4 m21, ulong_mt4 m22, ulong_mt4 m23) r2,
        (ulong_mt4 m30, ulong_mt4 m31, ulong_mt4 m32, ulong_mt4 m33) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong4x4_mt4((
        (ulong_mt4 m00, ulong_mt4 m01, ulong_mt4 m02, ulong_mt4 m03) r0,
        (ulong_mt4 m10, ulong_mt4 m11, ulong_mt4 m12, ulong_mt4 m13) r1,
        (ulong_mt4 m20, ulong_mt4 m21, ulong_mt4 m22, ulong_mt4 m23) r2,
        (ulong_mt4 m30, ulong_mt4 m31, ulong_mt4 m32, ulong_mt4 m33) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23, tuple.r3.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x4_mt4(ulong_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x4_mt4(ulong value) => (ulong_mt4)(value);

    [MethodImpl(256 | 512)]
    public ulong4x4_mt4(ulong_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x4_mt4(ulong4_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong4x4_mt4(ulong4_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out ulong4_mt4 c0, out ulong4_mt4 c1, out ulong4_mt4 c2, out ulong4_mt4 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out ulong_mt4 m00, out ulong_mt4 m01, out ulong_mt4 m02, out ulong_mt4 m03,
        out ulong_mt4 m10, out ulong_mt4 m11, out ulong_mt4 m12, out ulong_mt4 m13,
        out ulong_mt4 m20, out ulong_mt4 m21, out ulong_mt4 m22, out ulong_mt4 m23,
        out ulong_mt4 m30, out ulong_mt4 m31, out ulong_mt4 m32, out ulong_mt4 m33
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
        this.c3.Deconstruct(out m03, out m13, out m23, out m33);
    }

    #endregion // Deconstruct

    #region Index

    public ulong4_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ulong_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static ulong4x4_mt4 operator~(ulong4x4_mt4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static ulong4x4_mt4 operator|(ulong4x4_mt4 a, ulong4x4_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static ulong4x4_mt4 operator&(ulong4x4_mt4 a, ulong4x4_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static ulong4x4_mt4 operator^(ulong4x4_mt4 a, ulong4x4_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"ulong4x4_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // ulong4x4_mt4

#region ulong4x4_mt8

[CpuOnly]
public partial struct ulong4x4_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => ulong_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 4); 
    }

    public static ulong4x4_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1UL, default, default, default,
            default, 1UL, default, default,
            default, default, 1UL, default,
            default, default, default, 1UL
        ); 
    }

    #endregion

    #region Fields

    public ulong4_mt8 c0;
    public ulong4_mt8 c1;
    public ulong4_mt8 c2;
    public ulong4_mt8 c3;

    #endregion

    #region Properties

    public ulong_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ulong_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ulong_mt8 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public ulong_mt8 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public ulong_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ulong_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public ulong_mt8 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public ulong_mt8 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public ulong_mt8 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public ulong_mt8 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public ulong_mt8 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public ulong_mt8 m23
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }
    public ulong_mt8 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public ulong_mt8 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public ulong_mt8 m32
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }
    public ulong_mt8 m33
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.w;
        [MethodImpl(256 | 512)]
        set => c3.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly ulong4x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, ulong4x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public ulong4x4_mt8(ulong4_mt8 c0, ulong4_mt8 c1, ulong4_mt8 c2, ulong4_mt8 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public ulong4x4_mt8((ulong4_mt8 c0, ulong4_mt8 c1, ulong4_mt8 c2, ulong4_mt8 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x4_mt8((ulong4_mt8 c0, ulong4_mt8 c1, ulong4_mt8 c2, ulong4_mt8 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong4x4_mt8(
        ulong_mt8 m00, ulong_mt8 m01, ulong_mt8 m02, ulong_mt8 m03,
        ulong_mt8 m10, ulong_mt8 m11, ulong_mt8 m12, ulong_mt8 m13,
        ulong_mt8 m20, ulong_mt8 m21, ulong_mt8 m22, ulong_mt8 m23,
        ulong_mt8 m30, ulong_mt8 m31, ulong_mt8 m32, ulong_mt8 m33
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
        this.c3 = new(m03, m13, m23, m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x4_mt8((
        ulong_mt8 m00, ulong_mt8 m01, ulong_mt8 m02, ulong_mt8 m03,
        ulong_mt8 m10, ulong_mt8 m11, ulong_mt8 m12, ulong_mt8 m13,
        ulong_mt8 m20, ulong_mt8 m21, ulong_mt8 m22, ulong_mt8 m23,
        ulong_mt8 m30, ulong_mt8 m31, ulong_mt8 m32, ulong_mt8 m33
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong4x4_mt8((
        ulong_mt8 m00, ulong_mt8 m01, ulong_mt8 m02, ulong_mt8 m03,
        ulong_mt8 m10, ulong_mt8 m11, ulong_mt8 m12, ulong_mt8 m13,
        ulong_mt8 m20, ulong_mt8 m21, ulong_mt8 m22, ulong_mt8 m23,
        ulong_mt8 m30, ulong_mt8 m31, ulong_mt8 m32, ulong_mt8 m33
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23, tuple.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x4_mt8((
        (ulong_mt8 m00, ulong_mt8 m01, ulong_mt8 m02, ulong_mt8 m03) r0,
        (ulong_mt8 m10, ulong_mt8 m11, ulong_mt8 m12, ulong_mt8 m13) r1,
        (ulong_mt8 m20, ulong_mt8 m21, ulong_mt8 m22, ulong_mt8 m23) r2,
        (ulong_mt8 m30, ulong_mt8 m31, ulong_mt8 m32, ulong_mt8 m33) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong4x4_mt8((
        (ulong_mt8 m00, ulong_mt8 m01, ulong_mt8 m02, ulong_mt8 m03) r0,
        (ulong_mt8 m10, ulong_mt8 m11, ulong_mt8 m12, ulong_mt8 m13) r1,
        (ulong_mt8 m20, ulong_mt8 m21, ulong_mt8 m22, ulong_mt8 m23) r2,
        (ulong_mt8 m30, ulong_mt8 m31, ulong_mt8 m32, ulong_mt8 m33) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23, tuple.r3.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x4_mt8(ulong_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x4_mt8(ulong value) => (ulong_mt8)(value);

    [MethodImpl(256 | 512)]
    public ulong4x4_mt8(ulong_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x4_mt8(ulong4_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong4x4_mt8(ulong4_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out ulong4_mt8 c0, out ulong4_mt8 c1, out ulong4_mt8 c2, out ulong4_mt8 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out ulong_mt8 m00, out ulong_mt8 m01, out ulong_mt8 m02, out ulong_mt8 m03,
        out ulong_mt8 m10, out ulong_mt8 m11, out ulong_mt8 m12, out ulong_mt8 m13,
        out ulong_mt8 m20, out ulong_mt8 m21, out ulong_mt8 m22, out ulong_mt8 m23,
        out ulong_mt8 m30, out ulong_mt8 m31, out ulong_mt8 m32, out ulong_mt8 m33
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
        this.c3.Deconstruct(out m03, out m13, out m23, out m33);
    }

    #endregion // Deconstruct

    #region Index

    public ulong4_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ulong_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static ulong4x4_mt8 operator~(ulong4x4_mt8 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static ulong4x4_mt8 operator|(ulong4x4_mt8 a, ulong4x4_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static ulong4x4_mt8 operator&(ulong4x4_mt8 a, ulong4x4_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static ulong4x4_mt8 operator^(ulong4x4_mt8 a, ulong4x4_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"ulong4x4_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // ulong4x4_mt8

#region ulong4x4_mt16

[CpuOnly]
public partial struct ulong4x4_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => ulong_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 4); 
    }

    public static ulong4x4_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            1UL, default, default, default,
            default, 1UL, default, default,
            default, default, 1UL, default,
            default, default, default, 1UL
        ); 
    }

    #endregion

    #region Fields

    public ulong4_mt16 c0;
    public ulong4_mt16 c1;
    public ulong4_mt16 c2;
    public ulong4_mt16 c3;

    #endregion

    #region Properties

    public ulong_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public ulong_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public ulong_mt16 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public ulong_mt16 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public ulong_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public ulong_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public ulong_mt16 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public ulong_mt16 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public ulong_mt16 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public ulong_mt16 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public ulong_mt16 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public ulong_mt16 m23
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }
    public ulong_mt16 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public ulong_mt16 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public ulong_mt16 m32
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }
    public ulong_mt16 m33
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.w;
        [MethodImpl(256 | 512)]
        set => c3.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly ulong4x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, ulong4x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public ulong4x4_mt16(ulong4_mt16 c0, ulong4_mt16 c1, ulong4_mt16 c2, ulong4_mt16 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public ulong4x4_mt16((ulong4_mt16 c0, ulong4_mt16 c1, ulong4_mt16 c2, ulong4_mt16 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x4_mt16((ulong4_mt16 c0, ulong4_mt16 c1, ulong4_mt16 c2, ulong4_mt16 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong4x4_mt16(
        ulong_mt16 m00, ulong_mt16 m01, ulong_mt16 m02, ulong_mt16 m03,
        ulong_mt16 m10, ulong_mt16 m11, ulong_mt16 m12, ulong_mt16 m13,
        ulong_mt16 m20, ulong_mt16 m21, ulong_mt16 m22, ulong_mt16 m23,
        ulong_mt16 m30, ulong_mt16 m31, ulong_mt16 m32, ulong_mt16 m33
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
        this.c3 = new(m03, m13, m23, m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x4_mt16((
        ulong_mt16 m00, ulong_mt16 m01, ulong_mt16 m02, ulong_mt16 m03,
        ulong_mt16 m10, ulong_mt16 m11, ulong_mt16 m12, ulong_mt16 m13,
        ulong_mt16 m20, ulong_mt16 m21, ulong_mt16 m22, ulong_mt16 m23,
        ulong_mt16 m30, ulong_mt16 m31, ulong_mt16 m32, ulong_mt16 m33
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong4x4_mt16((
        ulong_mt16 m00, ulong_mt16 m01, ulong_mt16 m02, ulong_mt16 m03,
        ulong_mt16 m10, ulong_mt16 m11, ulong_mt16 m12, ulong_mt16 m13,
        ulong_mt16 m20, ulong_mt16 m21, ulong_mt16 m22, ulong_mt16 m23,
        ulong_mt16 m30, ulong_mt16 m31, ulong_mt16 m32, ulong_mt16 m33
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23, tuple.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x4_mt16((
        (ulong_mt16 m00, ulong_mt16 m01, ulong_mt16 m02, ulong_mt16 m03) r0,
        (ulong_mt16 m10, ulong_mt16 m11, ulong_mt16 m12, ulong_mt16 m13) r1,
        (ulong_mt16 m20, ulong_mt16 m21, ulong_mt16 m22, ulong_mt16 m23) r2,
        (ulong_mt16 m30, ulong_mt16 m31, ulong_mt16 m32, ulong_mt16 m33) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public ulong4x4_mt16((
        (ulong_mt16 m00, ulong_mt16 m01, ulong_mt16 m02, ulong_mt16 m03) r0,
        (ulong_mt16 m10, ulong_mt16 m11, ulong_mt16 m12, ulong_mt16 m13) r1,
        (ulong_mt16 m20, ulong_mt16 m21, ulong_mt16 m22, ulong_mt16 m23) r2,
        (ulong_mt16 m30, ulong_mt16 m31, ulong_mt16 m32, ulong_mt16 m33) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23, tuple.r3.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x4_mt16(ulong_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x4_mt16(ulong value) => (ulong_mt16)(value);

    [MethodImpl(256 | 512)]
    public ulong4x4_mt16(ulong_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator ulong4x4_mt16(ulong4_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public ulong4x4_mt16(ulong4_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out ulong4_mt16 c0, out ulong4_mt16 c1, out ulong4_mt16 c2, out ulong4_mt16 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out ulong_mt16 m00, out ulong_mt16 m01, out ulong_mt16 m02, out ulong_mt16 m03,
        out ulong_mt16 m10, out ulong_mt16 m11, out ulong_mt16 m12, out ulong_mt16 m13,
        out ulong_mt16 m20, out ulong_mt16 m21, out ulong_mt16 m22, out ulong_mt16 m23,
        out ulong_mt16 m30, out ulong_mt16 m31, out ulong_mt16 m32, out ulong_mt16 m33
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
        this.c3.Deconstruct(out m03, out m13, out m23, out m33);
    }

    #endregion // Deconstruct

    #region Index

    public ulong4_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public ulong_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static ulong4x4_mt16 operator~(ulong4x4_mt16 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static ulong4x4_mt16 operator|(ulong4x4_mt16 a, ulong4x4_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static ulong4x4_mt16 operator&(ulong4x4_mt16 a, ulong4x4_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static ulong4x4_mt16 operator^(ulong4x4_mt16 a, ulong4x4_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"ulong4x4_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // ulong4x4_mt16

#region b32m2x2_mt4

[CpuOnly]
public partial struct b32m2x2_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b32_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 2); 
    }

    public static b32m2x2_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default,
            default, true
        ); 
    }

    #endregion

    #region Fields

    public b32v2_mt4 c0;
    public b32v2_mt4 c1;

    #endregion

    #region Properties

    public b32_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b32_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b32_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b32_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b32m2x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b32m2x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b32m2x2_mt4(b32v2_mt4 c0, b32v2_mt4 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public b32m2x2_mt4((b32v2_mt4 c0, b32v2_mt4 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x2_mt4((b32v2_mt4 c0, b32v2_mt4 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m2x2_mt4(
        b32_mt4 m00, b32_mt4 m01,
        b32_mt4 m10, b32_mt4 m11
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x2_mt4((
        b32_mt4 m00, b32_mt4 m01,
        b32_mt4 m10, b32_mt4 m11
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m2x2_mt4((
        b32_mt4 m00, b32_mt4 m01,
        b32_mt4 m10, b32_mt4 m11
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x2_mt4((
        (b32_mt4 m00, b32_mt4 m01) r0,
        (b32_mt4 m10, b32_mt4 m11) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m2x2_mt4((
        (b32_mt4 m00, b32_mt4 m01) r0,
        (b32_mt4 m10, b32_mt4 m11) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x2_mt4(b32_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x2_mt4(b32 value) => (b32_mt4)(value);

    [MethodImpl(256 | 512)]
    public b32m2x2_mt4(b32_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x2_mt4(b32v2_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x2_mt4(bool value) => (b32)(value);

    [MethodImpl(256 | 512)]
    public b32m2x2_mt4(b32v2_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b32v2_mt4 c0, out b32v2_mt4 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b32_mt4 m00, out b32_mt4 m01,
        out b32_mt4 m10, out b32_mt4 m11
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
    }

    #endregion // Deconstruct

    #region Index

    public b32v2_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b32_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b32m2x2_mt4 operator~(b32m2x2_mt4 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static b32m2x2_mt4 operator|(b32m2x2_mt4 a, b32m2x2_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static b32m2x2_mt4 operator&(b32m2x2_mt4 a, b32m2x2_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static b32m2x2_mt4 operator^(b32m2x2_mt4 a, b32m2x2_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b32m2x2_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // b32m2x2_mt4

#region b32m2x2_mt8

[CpuOnly]
public partial struct b32m2x2_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b32_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 2); 
    }

    public static b32m2x2_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default,
            default, true
        ); 
    }

    #endregion

    #region Fields

    public b32v2_mt8 c0;
    public b32v2_mt8 c1;

    #endregion

    #region Properties

    public b32_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b32_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b32_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b32_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b32m2x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b32m2x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b32m2x2_mt8(b32v2_mt8 c0, b32v2_mt8 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public b32m2x2_mt8((b32v2_mt8 c0, b32v2_mt8 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x2_mt8((b32v2_mt8 c0, b32v2_mt8 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m2x2_mt8(
        b32_mt8 m00, b32_mt8 m01,
        b32_mt8 m10, b32_mt8 m11
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x2_mt8((
        b32_mt8 m00, b32_mt8 m01,
        b32_mt8 m10, b32_mt8 m11
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m2x2_mt8((
        b32_mt8 m00, b32_mt8 m01,
        b32_mt8 m10, b32_mt8 m11
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x2_mt8((
        (b32_mt8 m00, b32_mt8 m01) r0,
        (b32_mt8 m10, b32_mt8 m11) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m2x2_mt8((
        (b32_mt8 m00, b32_mt8 m01) r0,
        (b32_mt8 m10, b32_mt8 m11) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x2_mt8(b32_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x2_mt8(b32 value) => (b32_mt8)(value);

    [MethodImpl(256 | 512)]
    public b32m2x2_mt8(b32_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x2_mt8(b32v2_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x2_mt8(bool value) => (b32)(value);

    [MethodImpl(256 | 512)]
    public b32m2x2_mt8(b32v2_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b32v2_mt8 c0, out b32v2_mt8 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b32_mt8 m00, out b32_mt8 m01,
        out b32_mt8 m10, out b32_mt8 m11
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
    }

    #endregion // Deconstruct

    #region Index

    public b32v2_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b32_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b32m2x2_mt8 operator~(b32m2x2_mt8 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static b32m2x2_mt8 operator|(b32m2x2_mt8 a, b32m2x2_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static b32m2x2_mt8 operator&(b32m2x2_mt8 a, b32m2x2_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static b32m2x2_mt8 operator^(b32m2x2_mt8 a, b32m2x2_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b32m2x2_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // b32m2x2_mt8

#region b32m2x2_mt16

[CpuOnly]
public partial struct b32m2x2_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b32_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 2); 
    }

    public static b32m2x2_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default,
            default, true
        ); 
    }

    #endregion

    #region Fields

    public b32v2_mt16 c0;
    public b32v2_mt16 c1;

    #endregion

    #region Properties

    public b32_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b32_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b32_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b32_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b32m2x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b32m2x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b32m2x2_mt16(b32v2_mt16 c0, b32v2_mt16 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public b32m2x2_mt16((b32v2_mt16 c0, b32v2_mt16 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x2_mt16((b32v2_mt16 c0, b32v2_mt16 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m2x2_mt16(
        b32_mt16 m00, b32_mt16 m01,
        b32_mt16 m10, b32_mt16 m11
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x2_mt16((
        b32_mt16 m00, b32_mt16 m01,
        b32_mt16 m10, b32_mt16 m11
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m2x2_mt16((
        b32_mt16 m00, b32_mt16 m01,
        b32_mt16 m10, b32_mt16 m11
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x2_mt16((
        (b32_mt16 m00, b32_mt16 m01) r0,
        (b32_mt16 m10, b32_mt16 m11) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m2x2_mt16((
        (b32_mt16 m00, b32_mt16 m01) r0,
        (b32_mt16 m10, b32_mt16 m11) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x2_mt16(b32_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x2_mt16(b32 value) => (b32_mt16)(value);

    [MethodImpl(256 | 512)]
    public b32m2x2_mt16(b32_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x2_mt16(b32v2_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x2_mt16(bool value) => (b32)(value);

    [MethodImpl(256 | 512)]
    public b32m2x2_mt16(b32v2_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b32v2_mt16 c0, out b32v2_mt16 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b32_mt16 m00, out b32_mt16 m01,
        out b32_mt16 m10, out b32_mt16 m11
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
    }

    #endregion // Deconstruct

    #region Index

    public b32v2_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b32_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b32m2x2_mt16 operator~(b32m2x2_mt16 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static b32m2x2_mt16 operator|(b32m2x2_mt16 a, b32m2x2_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static b32m2x2_mt16 operator&(b32m2x2_mt16 a, b32m2x2_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static b32m2x2_mt16 operator^(b32m2x2_mt16 a, b32m2x2_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b32m2x2_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // b32m2x2_mt16

#region b32m2x3_mt4

[CpuOnly]
public partial struct b32m2x3_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b32_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 3); 
    }

    public static b32m2x3_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default,
            default, true, default
        ); 
    }

    #endregion

    #region Fields

    public b32v2_mt4 c0;
    public b32v2_mt4 c1;
    public b32v2_mt4 c2;

    #endregion

    #region Properties

    public b32_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b32_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b32_mt4 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b32_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b32_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b32_mt4 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b32m2x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b32m2x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b32m2x3_mt4(b32v2_mt4 c0, b32v2_mt4 c1, b32v2_mt4 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public b32m2x3_mt4((b32v2_mt4 c0, b32v2_mt4 c1, b32v2_mt4 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x3_mt4((b32v2_mt4 c0, b32v2_mt4 c1, b32v2_mt4 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m2x3_mt4(
        b32_mt4 m00, b32_mt4 m01, b32_mt4 m02,
        b32_mt4 m10, b32_mt4 m11, b32_mt4 m12
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x3_mt4((
        b32_mt4 m00, b32_mt4 m01, b32_mt4 m02,
        b32_mt4 m10, b32_mt4 m11, b32_mt4 m12
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m2x3_mt4((
        b32_mt4 m00, b32_mt4 m01, b32_mt4 m02,
        b32_mt4 m10, b32_mt4 m11, b32_mt4 m12
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x3_mt4((
        (b32_mt4 m00, b32_mt4 m01, b32_mt4 m02) r0,
        (b32_mt4 m10, b32_mt4 m11, b32_mt4 m12) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m2x3_mt4((
        (b32_mt4 m00, b32_mt4 m01, b32_mt4 m02) r0,
        (b32_mt4 m10, b32_mt4 m11, b32_mt4 m12) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x3_mt4(b32_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x3_mt4(b32 value) => (b32_mt4)(value);

    [MethodImpl(256 | 512)]
    public b32m2x3_mt4(b32_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x3_mt4(b32v2_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x3_mt4(bool value) => (b32)(value);

    [MethodImpl(256 | 512)]
    public b32m2x3_mt4(b32v2_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b32v2_mt4 c0, out b32v2_mt4 c1, out b32v2_mt4 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b32_mt4 m00, out b32_mt4 m01, out b32_mt4 m02,
        out b32_mt4 m10, out b32_mt4 m11, out b32_mt4 m12
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
    }

    #endregion // Deconstruct

    #region Index

    public b32v2_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b32_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b32m2x3_mt4 operator~(b32m2x3_mt4 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static b32m2x3_mt4 operator|(b32m2x3_mt4 a, b32m2x3_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static b32m2x3_mt4 operator&(b32m2x3_mt4 a, b32m2x3_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static b32m2x3_mt4 operator^(b32m2x3_mt4 a, b32m2x3_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b32m2x3_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // b32m2x3_mt4

#region b32m2x3_mt8

[CpuOnly]
public partial struct b32m2x3_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b32_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 3); 
    }

    public static b32m2x3_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default,
            default, true, default
        ); 
    }

    #endregion

    #region Fields

    public b32v2_mt8 c0;
    public b32v2_mt8 c1;
    public b32v2_mt8 c2;

    #endregion

    #region Properties

    public b32_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b32_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b32_mt8 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b32_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b32_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b32_mt8 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b32m2x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b32m2x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b32m2x3_mt8(b32v2_mt8 c0, b32v2_mt8 c1, b32v2_mt8 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public b32m2x3_mt8((b32v2_mt8 c0, b32v2_mt8 c1, b32v2_mt8 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x3_mt8((b32v2_mt8 c0, b32v2_mt8 c1, b32v2_mt8 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m2x3_mt8(
        b32_mt8 m00, b32_mt8 m01, b32_mt8 m02,
        b32_mt8 m10, b32_mt8 m11, b32_mt8 m12
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x3_mt8((
        b32_mt8 m00, b32_mt8 m01, b32_mt8 m02,
        b32_mt8 m10, b32_mt8 m11, b32_mt8 m12
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m2x3_mt8((
        b32_mt8 m00, b32_mt8 m01, b32_mt8 m02,
        b32_mt8 m10, b32_mt8 m11, b32_mt8 m12
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x3_mt8((
        (b32_mt8 m00, b32_mt8 m01, b32_mt8 m02) r0,
        (b32_mt8 m10, b32_mt8 m11, b32_mt8 m12) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m2x3_mt8((
        (b32_mt8 m00, b32_mt8 m01, b32_mt8 m02) r0,
        (b32_mt8 m10, b32_mt8 m11, b32_mt8 m12) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x3_mt8(b32_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x3_mt8(b32 value) => (b32_mt8)(value);

    [MethodImpl(256 | 512)]
    public b32m2x3_mt8(b32_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x3_mt8(b32v2_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x3_mt8(bool value) => (b32)(value);

    [MethodImpl(256 | 512)]
    public b32m2x3_mt8(b32v2_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b32v2_mt8 c0, out b32v2_mt8 c1, out b32v2_mt8 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b32_mt8 m00, out b32_mt8 m01, out b32_mt8 m02,
        out b32_mt8 m10, out b32_mt8 m11, out b32_mt8 m12
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
    }

    #endregion // Deconstruct

    #region Index

    public b32v2_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b32_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b32m2x3_mt8 operator~(b32m2x3_mt8 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static b32m2x3_mt8 operator|(b32m2x3_mt8 a, b32m2x3_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static b32m2x3_mt8 operator&(b32m2x3_mt8 a, b32m2x3_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static b32m2x3_mt8 operator^(b32m2x3_mt8 a, b32m2x3_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b32m2x3_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // b32m2x3_mt8

#region b32m2x3_mt16

[CpuOnly]
public partial struct b32m2x3_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b32_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 3); 
    }

    public static b32m2x3_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default,
            default, true, default
        ); 
    }

    #endregion

    #region Fields

    public b32v2_mt16 c0;
    public b32v2_mt16 c1;
    public b32v2_mt16 c2;

    #endregion

    #region Properties

    public b32_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b32_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b32_mt16 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b32_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b32_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b32_mt16 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b32m2x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b32m2x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b32m2x3_mt16(b32v2_mt16 c0, b32v2_mt16 c1, b32v2_mt16 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public b32m2x3_mt16((b32v2_mt16 c0, b32v2_mt16 c1, b32v2_mt16 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x3_mt16((b32v2_mt16 c0, b32v2_mt16 c1, b32v2_mt16 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m2x3_mt16(
        b32_mt16 m00, b32_mt16 m01, b32_mt16 m02,
        b32_mt16 m10, b32_mt16 m11, b32_mt16 m12
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x3_mt16((
        b32_mt16 m00, b32_mt16 m01, b32_mt16 m02,
        b32_mt16 m10, b32_mt16 m11, b32_mt16 m12
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m2x3_mt16((
        b32_mt16 m00, b32_mt16 m01, b32_mt16 m02,
        b32_mt16 m10, b32_mt16 m11, b32_mt16 m12
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x3_mt16((
        (b32_mt16 m00, b32_mt16 m01, b32_mt16 m02) r0,
        (b32_mt16 m10, b32_mt16 m11, b32_mt16 m12) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m2x3_mt16((
        (b32_mt16 m00, b32_mt16 m01, b32_mt16 m02) r0,
        (b32_mt16 m10, b32_mt16 m11, b32_mt16 m12) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x3_mt16(b32_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x3_mt16(b32 value) => (b32_mt16)(value);

    [MethodImpl(256 | 512)]
    public b32m2x3_mt16(b32_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x3_mt16(b32v2_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x3_mt16(bool value) => (b32)(value);

    [MethodImpl(256 | 512)]
    public b32m2x3_mt16(b32v2_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b32v2_mt16 c0, out b32v2_mt16 c1, out b32v2_mt16 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b32_mt16 m00, out b32_mt16 m01, out b32_mt16 m02,
        out b32_mt16 m10, out b32_mt16 m11, out b32_mt16 m12
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
    }

    #endregion // Deconstruct

    #region Index

    public b32v2_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b32_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b32m2x3_mt16 operator~(b32m2x3_mt16 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static b32m2x3_mt16 operator|(b32m2x3_mt16 a, b32m2x3_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static b32m2x3_mt16 operator&(b32m2x3_mt16 a, b32m2x3_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static b32m2x3_mt16 operator^(b32m2x3_mt16 a, b32m2x3_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b32m2x3_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // b32m2x3_mt16

#region b32m2x4_mt4

[CpuOnly]
public partial struct b32m2x4_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b32_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 4); 
    }

    public static b32m2x4_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default, default,
            default, true, default, default
        ); 
    }

    #endregion

    #region Fields

    public b32v2_mt4 c0;
    public b32v2_mt4 c1;
    public b32v2_mt4 c2;
    public b32v2_mt4 c3;

    #endregion

    #region Properties

    public b32_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b32_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b32_mt4 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b32_mt4 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public b32_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b32_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b32_mt4 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b32_mt4 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b32m2x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b32m2x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b32m2x4_mt4(b32v2_mt4 c0, b32v2_mt4 c1, b32v2_mt4 c2, b32v2_mt4 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public b32m2x4_mt4((b32v2_mt4 c0, b32v2_mt4 c1, b32v2_mt4 c2, b32v2_mt4 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x4_mt4((b32v2_mt4 c0, b32v2_mt4 c1, b32v2_mt4 c2, b32v2_mt4 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m2x4_mt4(
        b32_mt4 m00, b32_mt4 m01, b32_mt4 m02, b32_mt4 m03,
        b32_mt4 m10, b32_mt4 m11, b32_mt4 m12, b32_mt4 m13
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
        this.c3 = new(m03, m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x4_mt4((
        b32_mt4 m00, b32_mt4 m01, b32_mt4 m02, b32_mt4 m03,
        b32_mt4 m10, b32_mt4 m11, b32_mt4 m12, b32_mt4 m13
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m2x4_mt4((
        b32_mt4 m00, b32_mt4 m01, b32_mt4 m02, b32_mt4 m03,
        b32_mt4 m10, b32_mt4 m11, b32_mt4 m12, b32_mt4 m13
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
        this.c3 = new(tuple.m03, tuple.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x4_mt4((
        (b32_mt4 m00, b32_mt4 m01, b32_mt4 m02, b32_mt4 m03) r0,
        (b32_mt4 m10, b32_mt4 m11, b32_mt4 m12, b32_mt4 m13) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m2x4_mt4((
        (b32_mt4 m00, b32_mt4 m01, b32_mt4 m02, b32_mt4 m03) r0,
        (b32_mt4 m10, b32_mt4 m11, b32_mt4 m12, b32_mt4 m13) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x4_mt4(b32_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x4_mt4(b32 value) => (b32_mt4)(value);

    [MethodImpl(256 | 512)]
    public b32m2x4_mt4(b32_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x4_mt4(b32v2_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x4_mt4(bool value) => (b32)(value);

    [MethodImpl(256 | 512)]
    public b32m2x4_mt4(b32v2_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b32v2_mt4 c0, out b32v2_mt4 c1, out b32v2_mt4 c2, out b32v2_mt4 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b32_mt4 m00, out b32_mt4 m01, out b32_mt4 m02, out b32_mt4 m03,
        out b32_mt4 m10, out b32_mt4 m11, out b32_mt4 m12, out b32_mt4 m13
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
        this.c3.Deconstruct(out m03, out m13);
    }

    #endregion // Deconstruct

    #region Index

    public b32v2_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b32_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b32m2x4_mt4 operator~(b32m2x4_mt4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static b32m2x4_mt4 operator|(b32m2x4_mt4 a, b32m2x4_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static b32m2x4_mt4 operator&(b32m2x4_mt4 a, b32m2x4_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static b32m2x4_mt4 operator^(b32m2x4_mt4 a, b32m2x4_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b32m2x4_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // b32m2x4_mt4

#region b32m2x4_mt8

[CpuOnly]
public partial struct b32m2x4_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b32_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 4); 
    }

    public static b32m2x4_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default, default,
            default, true, default, default
        ); 
    }

    #endregion

    #region Fields

    public b32v2_mt8 c0;
    public b32v2_mt8 c1;
    public b32v2_mt8 c2;
    public b32v2_mt8 c3;

    #endregion

    #region Properties

    public b32_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b32_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b32_mt8 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b32_mt8 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public b32_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b32_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b32_mt8 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b32_mt8 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b32m2x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b32m2x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b32m2x4_mt8(b32v2_mt8 c0, b32v2_mt8 c1, b32v2_mt8 c2, b32v2_mt8 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public b32m2x4_mt8((b32v2_mt8 c0, b32v2_mt8 c1, b32v2_mt8 c2, b32v2_mt8 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x4_mt8((b32v2_mt8 c0, b32v2_mt8 c1, b32v2_mt8 c2, b32v2_mt8 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m2x4_mt8(
        b32_mt8 m00, b32_mt8 m01, b32_mt8 m02, b32_mt8 m03,
        b32_mt8 m10, b32_mt8 m11, b32_mt8 m12, b32_mt8 m13
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
        this.c3 = new(m03, m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x4_mt8((
        b32_mt8 m00, b32_mt8 m01, b32_mt8 m02, b32_mt8 m03,
        b32_mt8 m10, b32_mt8 m11, b32_mt8 m12, b32_mt8 m13
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m2x4_mt8((
        b32_mt8 m00, b32_mt8 m01, b32_mt8 m02, b32_mt8 m03,
        b32_mt8 m10, b32_mt8 m11, b32_mt8 m12, b32_mt8 m13
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
        this.c3 = new(tuple.m03, tuple.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x4_mt8((
        (b32_mt8 m00, b32_mt8 m01, b32_mt8 m02, b32_mt8 m03) r0,
        (b32_mt8 m10, b32_mt8 m11, b32_mt8 m12, b32_mt8 m13) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m2x4_mt8((
        (b32_mt8 m00, b32_mt8 m01, b32_mt8 m02, b32_mt8 m03) r0,
        (b32_mt8 m10, b32_mt8 m11, b32_mt8 m12, b32_mt8 m13) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x4_mt8(b32_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x4_mt8(b32 value) => (b32_mt8)(value);

    [MethodImpl(256 | 512)]
    public b32m2x4_mt8(b32_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x4_mt8(b32v2_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x4_mt8(bool value) => (b32)(value);

    [MethodImpl(256 | 512)]
    public b32m2x4_mt8(b32v2_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b32v2_mt8 c0, out b32v2_mt8 c1, out b32v2_mt8 c2, out b32v2_mt8 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b32_mt8 m00, out b32_mt8 m01, out b32_mt8 m02, out b32_mt8 m03,
        out b32_mt8 m10, out b32_mt8 m11, out b32_mt8 m12, out b32_mt8 m13
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
        this.c3.Deconstruct(out m03, out m13);
    }

    #endregion // Deconstruct

    #region Index

    public b32v2_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b32_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b32m2x4_mt8 operator~(b32m2x4_mt8 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static b32m2x4_mt8 operator|(b32m2x4_mt8 a, b32m2x4_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static b32m2x4_mt8 operator&(b32m2x4_mt8 a, b32m2x4_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static b32m2x4_mt8 operator^(b32m2x4_mt8 a, b32m2x4_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b32m2x4_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // b32m2x4_mt8

#region b32m2x4_mt16

[CpuOnly]
public partial struct b32m2x4_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b32_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 4); 
    }

    public static b32m2x4_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default, default,
            default, true, default, default
        ); 
    }

    #endregion

    #region Fields

    public b32v2_mt16 c0;
    public b32v2_mt16 c1;
    public b32v2_mt16 c2;
    public b32v2_mt16 c3;

    #endregion

    #region Properties

    public b32_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b32_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b32_mt16 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b32_mt16 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public b32_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b32_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b32_mt16 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b32_mt16 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b32m2x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b32m2x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b32m2x4_mt16(b32v2_mt16 c0, b32v2_mt16 c1, b32v2_mt16 c2, b32v2_mt16 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public b32m2x4_mt16((b32v2_mt16 c0, b32v2_mt16 c1, b32v2_mt16 c2, b32v2_mt16 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x4_mt16((b32v2_mt16 c0, b32v2_mt16 c1, b32v2_mt16 c2, b32v2_mt16 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m2x4_mt16(
        b32_mt16 m00, b32_mt16 m01, b32_mt16 m02, b32_mt16 m03,
        b32_mt16 m10, b32_mt16 m11, b32_mt16 m12, b32_mt16 m13
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
        this.c3 = new(m03, m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x4_mt16((
        b32_mt16 m00, b32_mt16 m01, b32_mt16 m02, b32_mt16 m03,
        b32_mt16 m10, b32_mt16 m11, b32_mt16 m12, b32_mt16 m13
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m2x4_mt16((
        b32_mt16 m00, b32_mt16 m01, b32_mt16 m02, b32_mt16 m03,
        b32_mt16 m10, b32_mt16 m11, b32_mt16 m12, b32_mt16 m13
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
        this.c3 = new(tuple.m03, tuple.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x4_mt16((
        (b32_mt16 m00, b32_mt16 m01, b32_mt16 m02, b32_mt16 m03) r0,
        (b32_mt16 m10, b32_mt16 m11, b32_mt16 m12, b32_mt16 m13) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m2x4_mt16((
        (b32_mt16 m00, b32_mt16 m01, b32_mt16 m02, b32_mt16 m03) r0,
        (b32_mt16 m10, b32_mt16 m11, b32_mt16 m12, b32_mt16 m13) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x4_mt16(b32_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x4_mt16(b32 value) => (b32_mt16)(value);

    [MethodImpl(256 | 512)]
    public b32m2x4_mt16(b32_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x4_mt16(b32v2_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m2x4_mt16(bool value) => (b32)(value);

    [MethodImpl(256 | 512)]
    public b32m2x4_mt16(b32v2_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b32v2_mt16 c0, out b32v2_mt16 c1, out b32v2_mt16 c2, out b32v2_mt16 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b32_mt16 m00, out b32_mt16 m01, out b32_mt16 m02, out b32_mt16 m03,
        out b32_mt16 m10, out b32_mt16 m11, out b32_mt16 m12, out b32_mt16 m13
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
        this.c3.Deconstruct(out m03, out m13);
    }

    #endregion // Deconstruct

    #region Index

    public b32v2_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b32_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b32m2x4_mt16 operator~(b32m2x4_mt16 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static b32m2x4_mt16 operator|(b32m2x4_mt16 a, b32m2x4_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static b32m2x4_mt16 operator&(b32m2x4_mt16 a, b32m2x4_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static b32m2x4_mt16 operator^(b32m2x4_mt16 a, b32m2x4_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b32m2x4_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // b32m2x4_mt16

#region b32m3x2_mt4

[CpuOnly]
public partial struct b32m3x2_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b32_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 2); 
    }

    public static b32m3x2_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default,
            default, true,
            default, default
        ); 
    }

    #endregion

    #region Fields

    public b32v3_mt4 c0;
    public b32v3_mt4 c1;

    #endregion

    #region Properties

    public b32_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b32_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b32_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b32_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b32_mt4 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b32_mt4 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b32m3x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b32m3x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b32m3x2_mt4(b32v3_mt4 c0, b32v3_mt4 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public b32m3x2_mt4((b32v3_mt4 c0, b32v3_mt4 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x2_mt4((b32v3_mt4 c0, b32v3_mt4 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m3x2_mt4(
        b32_mt4 m00, b32_mt4 m01,
        b32_mt4 m10, b32_mt4 m11,
        b32_mt4 m20, b32_mt4 m21
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x2_mt4((
        b32_mt4 m00, b32_mt4 m01,
        b32_mt4 m10, b32_mt4 m11,
        b32_mt4 m20, b32_mt4 m21
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m3x2_mt4((
        b32_mt4 m00, b32_mt4 m01,
        b32_mt4 m10, b32_mt4 m11,
        b32_mt4 m20, b32_mt4 m21
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x2_mt4((
        (b32_mt4 m00, b32_mt4 m01) r0,
        (b32_mt4 m10, b32_mt4 m11) r1,
        (b32_mt4 m20, b32_mt4 m21) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m3x2_mt4((
        (b32_mt4 m00, b32_mt4 m01) r0,
        (b32_mt4 m10, b32_mt4 m11) r1,
        (b32_mt4 m20, b32_mt4 m21) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x2_mt4(b32_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x2_mt4(b32 value) => (b32_mt4)(value);

    [MethodImpl(256 | 512)]
    public b32m3x2_mt4(b32_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x2_mt4(b32v3_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x2_mt4(bool value) => (b32)(value);

    [MethodImpl(256 | 512)]
    public b32m3x2_mt4(b32v3_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b32v3_mt4 c0, out b32v3_mt4 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b32_mt4 m00, out b32_mt4 m01,
        out b32_mt4 m10, out b32_mt4 m11,
        out b32_mt4 m20, out b32_mt4 m21
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
    }

    #endregion // Deconstruct

    #region Index

    public b32v3_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b32_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b32m3x2_mt4 operator~(b32m3x2_mt4 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static b32m3x2_mt4 operator|(b32m3x2_mt4 a, b32m3x2_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static b32m3x2_mt4 operator&(b32m3x2_mt4 a, b32m3x2_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static b32m3x2_mt4 operator^(b32m3x2_mt4 a, b32m3x2_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b32m3x2_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // b32m3x2_mt4

#region b32m3x2_mt8

[CpuOnly]
public partial struct b32m3x2_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b32_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 2); 
    }

    public static b32m3x2_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default,
            default, true,
            default, default
        ); 
    }

    #endregion

    #region Fields

    public b32v3_mt8 c0;
    public b32v3_mt8 c1;

    #endregion

    #region Properties

    public b32_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b32_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b32_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b32_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b32_mt8 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b32_mt8 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b32m3x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b32m3x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b32m3x2_mt8(b32v3_mt8 c0, b32v3_mt8 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public b32m3x2_mt8((b32v3_mt8 c0, b32v3_mt8 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x2_mt8((b32v3_mt8 c0, b32v3_mt8 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m3x2_mt8(
        b32_mt8 m00, b32_mt8 m01,
        b32_mt8 m10, b32_mt8 m11,
        b32_mt8 m20, b32_mt8 m21
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x2_mt8((
        b32_mt8 m00, b32_mt8 m01,
        b32_mt8 m10, b32_mt8 m11,
        b32_mt8 m20, b32_mt8 m21
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m3x2_mt8((
        b32_mt8 m00, b32_mt8 m01,
        b32_mt8 m10, b32_mt8 m11,
        b32_mt8 m20, b32_mt8 m21
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x2_mt8((
        (b32_mt8 m00, b32_mt8 m01) r0,
        (b32_mt8 m10, b32_mt8 m11) r1,
        (b32_mt8 m20, b32_mt8 m21) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m3x2_mt8((
        (b32_mt8 m00, b32_mt8 m01) r0,
        (b32_mt8 m10, b32_mt8 m11) r1,
        (b32_mt8 m20, b32_mt8 m21) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x2_mt8(b32_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x2_mt8(b32 value) => (b32_mt8)(value);

    [MethodImpl(256 | 512)]
    public b32m3x2_mt8(b32_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x2_mt8(b32v3_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x2_mt8(bool value) => (b32)(value);

    [MethodImpl(256 | 512)]
    public b32m3x2_mt8(b32v3_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b32v3_mt8 c0, out b32v3_mt8 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b32_mt8 m00, out b32_mt8 m01,
        out b32_mt8 m10, out b32_mt8 m11,
        out b32_mt8 m20, out b32_mt8 m21
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
    }

    #endregion // Deconstruct

    #region Index

    public b32v3_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b32_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b32m3x2_mt8 operator~(b32m3x2_mt8 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static b32m3x2_mt8 operator|(b32m3x2_mt8 a, b32m3x2_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static b32m3x2_mt8 operator&(b32m3x2_mt8 a, b32m3x2_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static b32m3x2_mt8 operator^(b32m3x2_mt8 a, b32m3x2_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b32m3x2_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // b32m3x2_mt8

#region b32m3x2_mt16

[CpuOnly]
public partial struct b32m3x2_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b32_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 2); 
    }

    public static b32m3x2_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default,
            default, true,
            default, default
        ); 
    }

    #endregion

    #region Fields

    public b32v3_mt16 c0;
    public b32v3_mt16 c1;

    #endregion

    #region Properties

    public b32_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b32_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b32_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b32_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b32_mt16 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b32_mt16 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b32m3x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b32m3x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b32m3x2_mt16(b32v3_mt16 c0, b32v3_mt16 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public b32m3x2_mt16((b32v3_mt16 c0, b32v3_mt16 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x2_mt16((b32v3_mt16 c0, b32v3_mt16 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m3x2_mt16(
        b32_mt16 m00, b32_mt16 m01,
        b32_mt16 m10, b32_mt16 m11,
        b32_mt16 m20, b32_mt16 m21
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x2_mt16((
        b32_mt16 m00, b32_mt16 m01,
        b32_mt16 m10, b32_mt16 m11,
        b32_mt16 m20, b32_mt16 m21
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m3x2_mt16((
        b32_mt16 m00, b32_mt16 m01,
        b32_mt16 m10, b32_mt16 m11,
        b32_mt16 m20, b32_mt16 m21
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x2_mt16((
        (b32_mt16 m00, b32_mt16 m01) r0,
        (b32_mt16 m10, b32_mt16 m11) r1,
        (b32_mt16 m20, b32_mt16 m21) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m3x2_mt16((
        (b32_mt16 m00, b32_mt16 m01) r0,
        (b32_mt16 m10, b32_mt16 m11) r1,
        (b32_mt16 m20, b32_mt16 m21) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x2_mt16(b32_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x2_mt16(b32 value) => (b32_mt16)(value);

    [MethodImpl(256 | 512)]
    public b32m3x2_mt16(b32_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x2_mt16(b32v3_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x2_mt16(bool value) => (b32)(value);

    [MethodImpl(256 | 512)]
    public b32m3x2_mt16(b32v3_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b32v3_mt16 c0, out b32v3_mt16 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b32_mt16 m00, out b32_mt16 m01,
        out b32_mt16 m10, out b32_mt16 m11,
        out b32_mt16 m20, out b32_mt16 m21
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
    }

    #endregion // Deconstruct

    #region Index

    public b32v3_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b32_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b32m3x2_mt16 operator~(b32m3x2_mt16 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static b32m3x2_mt16 operator|(b32m3x2_mt16 a, b32m3x2_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static b32m3x2_mt16 operator&(b32m3x2_mt16 a, b32m3x2_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static b32m3x2_mt16 operator^(b32m3x2_mt16 a, b32m3x2_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b32m3x2_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // b32m3x2_mt16

#region b32m3x3_mt4

[CpuOnly]
public partial struct b32m3x3_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b32_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 9; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 3); 
    }

    public static b32m3x3_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default,
            default, true, default,
            default, default, true
        ); 
    }

    #endregion

    #region Fields

    public b32v3_mt4 c0;
    public b32v3_mt4 c1;
    public b32v3_mt4 c2;

    #endregion

    #region Properties

    public b32_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b32_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b32_mt4 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b32_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b32_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b32_mt4 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b32_mt4 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b32_mt4 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b32_mt4 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b32m3x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b32m3x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b32m3x3_mt4(b32v3_mt4 c0, b32v3_mt4 c1, b32v3_mt4 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public b32m3x3_mt4((b32v3_mt4 c0, b32v3_mt4 c1, b32v3_mt4 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x3_mt4((b32v3_mt4 c0, b32v3_mt4 c1, b32v3_mt4 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m3x3_mt4(
        b32_mt4 m00, b32_mt4 m01, b32_mt4 m02,
        b32_mt4 m10, b32_mt4 m11, b32_mt4 m12,
        b32_mt4 m20, b32_mt4 m21, b32_mt4 m22
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x3_mt4((
        b32_mt4 m00, b32_mt4 m01, b32_mt4 m02,
        b32_mt4 m10, b32_mt4 m11, b32_mt4 m12,
        b32_mt4 m20, b32_mt4 m21, b32_mt4 m22
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m3x3_mt4((
        b32_mt4 m00, b32_mt4 m01, b32_mt4 m02,
        b32_mt4 m10, b32_mt4 m11, b32_mt4 m12,
        b32_mt4 m20, b32_mt4 m21, b32_mt4 m22
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x3_mt4((
        (b32_mt4 m00, b32_mt4 m01, b32_mt4 m02) r0,
        (b32_mt4 m10, b32_mt4 m11, b32_mt4 m12) r1,
        (b32_mt4 m20, b32_mt4 m21, b32_mt4 m22) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m3x3_mt4((
        (b32_mt4 m00, b32_mt4 m01, b32_mt4 m02) r0,
        (b32_mt4 m10, b32_mt4 m11, b32_mt4 m12) r1,
        (b32_mt4 m20, b32_mt4 m21, b32_mt4 m22) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x3_mt4(b32_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x3_mt4(b32 value) => (b32_mt4)(value);

    [MethodImpl(256 | 512)]
    public b32m3x3_mt4(b32_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x3_mt4(b32v3_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x3_mt4(bool value) => (b32)(value);

    [MethodImpl(256 | 512)]
    public b32m3x3_mt4(b32v3_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b32v3_mt4 c0, out b32v3_mt4 c1, out b32v3_mt4 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b32_mt4 m00, out b32_mt4 m01, out b32_mt4 m02,
        out b32_mt4 m10, out b32_mt4 m11, out b32_mt4 m12,
        out b32_mt4 m20, out b32_mt4 m21, out b32_mt4 m22
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
    }

    #endregion // Deconstruct

    #region Index

    public b32v3_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b32_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b32m3x3_mt4 operator~(b32m3x3_mt4 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static b32m3x3_mt4 operator|(b32m3x3_mt4 a, b32m3x3_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static b32m3x3_mt4 operator&(b32m3x3_mt4 a, b32m3x3_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static b32m3x3_mt4 operator^(b32m3x3_mt4 a, b32m3x3_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b32m3x3_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // b32m3x3_mt4

#region b32m3x3_mt8

[CpuOnly]
public partial struct b32m3x3_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b32_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 9; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 3); 
    }

    public static b32m3x3_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default,
            default, true, default,
            default, default, true
        ); 
    }

    #endregion

    #region Fields

    public b32v3_mt8 c0;
    public b32v3_mt8 c1;
    public b32v3_mt8 c2;

    #endregion

    #region Properties

    public b32_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b32_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b32_mt8 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b32_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b32_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b32_mt8 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b32_mt8 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b32_mt8 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b32_mt8 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b32m3x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b32m3x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b32m3x3_mt8(b32v3_mt8 c0, b32v3_mt8 c1, b32v3_mt8 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public b32m3x3_mt8((b32v3_mt8 c0, b32v3_mt8 c1, b32v3_mt8 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x3_mt8((b32v3_mt8 c0, b32v3_mt8 c1, b32v3_mt8 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m3x3_mt8(
        b32_mt8 m00, b32_mt8 m01, b32_mt8 m02,
        b32_mt8 m10, b32_mt8 m11, b32_mt8 m12,
        b32_mt8 m20, b32_mt8 m21, b32_mt8 m22
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x3_mt8((
        b32_mt8 m00, b32_mt8 m01, b32_mt8 m02,
        b32_mt8 m10, b32_mt8 m11, b32_mt8 m12,
        b32_mt8 m20, b32_mt8 m21, b32_mt8 m22
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m3x3_mt8((
        b32_mt8 m00, b32_mt8 m01, b32_mt8 m02,
        b32_mt8 m10, b32_mt8 m11, b32_mt8 m12,
        b32_mt8 m20, b32_mt8 m21, b32_mt8 m22
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x3_mt8((
        (b32_mt8 m00, b32_mt8 m01, b32_mt8 m02) r0,
        (b32_mt8 m10, b32_mt8 m11, b32_mt8 m12) r1,
        (b32_mt8 m20, b32_mt8 m21, b32_mt8 m22) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m3x3_mt8((
        (b32_mt8 m00, b32_mt8 m01, b32_mt8 m02) r0,
        (b32_mt8 m10, b32_mt8 m11, b32_mt8 m12) r1,
        (b32_mt8 m20, b32_mt8 m21, b32_mt8 m22) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x3_mt8(b32_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x3_mt8(b32 value) => (b32_mt8)(value);

    [MethodImpl(256 | 512)]
    public b32m3x3_mt8(b32_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x3_mt8(b32v3_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x3_mt8(bool value) => (b32)(value);

    [MethodImpl(256 | 512)]
    public b32m3x3_mt8(b32v3_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b32v3_mt8 c0, out b32v3_mt8 c1, out b32v3_mt8 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b32_mt8 m00, out b32_mt8 m01, out b32_mt8 m02,
        out b32_mt8 m10, out b32_mt8 m11, out b32_mt8 m12,
        out b32_mt8 m20, out b32_mt8 m21, out b32_mt8 m22
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
    }

    #endregion // Deconstruct

    #region Index

    public b32v3_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b32_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b32m3x3_mt8 operator~(b32m3x3_mt8 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static b32m3x3_mt8 operator|(b32m3x3_mt8 a, b32m3x3_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static b32m3x3_mt8 operator&(b32m3x3_mt8 a, b32m3x3_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static b32m3x3_mt8 operator^(b32m3x3_mt8 a, b32m3x3_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b32m3x3_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // b32m3x3_mt8

#region b32m3x3_mt16

[CpuOnly]
public partial struct b32m3x3_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b32_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 9; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 3); 
    }

    public static b32m3x3_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default,
            default, true, default,
            default, default, true
        ); 
    }

    #endregion

    #region Fields

    public b32v3_mt16 c0;
    public b32v3_mt16 c1;
    public b32v3_mt16 c2;

    #endregion

    #region Properties

    public b32_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b32_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b32_mt16 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b32_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b32_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b32_mt16 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b32_mt16 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b32_mt16 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b32_mt16 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b32m3x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b32m3x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b32m3x3_mt16(b32v3_mt16 c0, b32v3_mt16 c1, b32v3_mt16 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public b32m3x3_mt16((b32v3_mt16 c0, b32v3_mt16 c1, b32v3_mt16 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x3_mt16((b32v3_mt16 c0, b32v3_mt16 c1, b32v3_mt16 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m3x3_mt16(
        b32_mt16 m00, b32_mt16 m01, b32_mt16 m02,
        b32_mt16 m10, b32_mt16 m11, b32_mt16 m12,
        b32_mt16 m20, b32_mt16 m21, b32_mt16 m22
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x3_mt16((
        b32_mt16 m00, b32_mt16 m01, b32_mt16 m02,
        b32_mt16 m10, b32_mt16 m11, b32_mt16 m12,
        b32_mt16 m20, b32_mt16 m21, b32_mt16 m22
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m3x3_mt16((
        b32_mt16 m00, b32_mt16 m01, b32_mt16 m02,
        b32_mt16 m10, b32_mt16 m11, b32_mt16 m12,
        b32_mt16 m20, b32_mt16 m21, b32_mt16 m22
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x3_mt16((
        (b32_mt16 m00, b32_mt16 m01, b32_mt16 m02) r0,
        (b32_mt16 m10, b32_mt16 m11, b32_mt16 m12) r1,
        (b32_mt16 m20, b32_mt16 m21, b32_mt16 m22) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m3x3_mt16((
        (b32_mt16 m00, b32_mt16 m01, b32_mt16 m02) r0,
        (b32_mt16 m10, b32_mt16 m11, b32_mt16 m12) r1,
        (b32_mt16 m20, b32_mt16 m21, b32_mt16 m22) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x3_mt16(b32_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x3_mt16(b32 value) => (b32_mt16)(value);

    [MethodImpl(256 | 512)]
    public b32m3x3_mt16(b32_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x3_mt16(b32v3_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x3_mt16(bool value) => (b32)(value);

    [MethodImpl(256 | 512)]
    public b32m3x3_mt16(b32v3_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b32v3_mt16 c0, out b32v3_mt16 c1, out b32v3_mt16 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b32_mt16 m00, out b32_mt16 m01, out b32_mt16 m02,
        out b32_mt16 m10, out b32_mt16 m11, out b32_mt16 m12,
        out b32_mt16 m20, out b32_mt16 m21, out b32_mt16 m22
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
    }

    #endregion // Deconstruct

    #region Index

    public b32v3_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b32_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b32m3x3_mt16 operator~(b32m3x3_mt16 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static b32m3x3_mt16 operator|(b32m3x3_mt16 a, b32m3x3_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static b32m3x3_mt16 operator&(b32m3x3_mt16 a, b32m3x3_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static b32m3x3_mt16 operator^(b32m3x3_mt16 a, b32m3x3_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b32m3x3_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // b32m3x3_mt16

#region b32m3x4_mt4

[CpuOnly]
public partial struct b32m3x4_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b32_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 4); 
    }

    public static b32m3x4_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default, default,
            default, true, default, default,
            default, default, true, default
        ); 
    }

    #endregion

    #region Fields

    public b32v3_mt4 c0;
    public b32v3_mt4 c1;
    public b32v3_mt4 c2;
    public b32v3_mt4 c3;

    #endregion

    #region Properties

    public b32_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b32_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b32_mt4 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b32_mt4 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public b32_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b32_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b32_mt4 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b32_mt4 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public b32_mt4 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b32_mt4 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b32_mt4 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public b32_mt4 m23
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b32m3x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b32m3x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b32m3x4_mt4(b32v3_mt4 c0, b32v3_mt4 c1, b32v3_mt4 c2, b32v3_mt4 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public b32m3x4_mt4((b32v3_mt4 c0, b32v3_mt4 c1, b32v3_mt4 c2, b32v3_mt4 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x4_mt4((b32v3_mt4 c0, b32v3_mt4 c1, b32v3_mt4 c2, b32v3_mt4 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m3x4_mt4(
        b32_mt4 m00, b32_mt4 m01, b32_mt4 m02, b32_mt4 m03,
        b32_mt4 m10, b32_mt4 m11, b32_mt4 m12, b32_mt4 m13,
        b32_mt4 m20, b32_mt4 m21, b32_mt4 m22, b32_mt4 m23
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
        this.c3 = new(m03, m13, m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x4_mt4((
        b32_mt4 m00, b32_mt4 m01, b32_mt4 m02, b32_mt4 m03,
        b32_mt4 m10, b32_mt4 m11, b32_mt4 m12, b32_mt4 m13,
        b32_mt4 m20, b32_mt4 m21, b32_mt4 m22, b32_mt4 m23
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m3x4_mt4((
        b32_mt4 m00, b32_mt4 m01, b32_mt4 m02, b32_mt4 m03,
        b32_mt4 m10, b32_mt4 m11, b32_mt4 m12, b32_mt4 m13,
        b32_mt4 m20, b32_mt4 m21, b32_mt4 m22, b32_mt4 m23
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x4_mt4((
        (b32_mt4 m00, b32_mt4 m01, b32_mt4 m02, b32_mt4 m03) r0,
        (b32_mt4 m10, b32_mt4 m11, b32_mt4 m12, b32_mt4 m13) r1,
        (b32_mt4 m20, b32_mt4 m21, b32_mt4 m22, b32_mt4 m23) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m3x4_mt4((
        (b32_mt4 m00, b32_mt4 m01, b32_mt4 m02, b32_mt4 m03) r0,
        (b32_mt4 m10, b32_mt4 m11, b32_mt4 m12, b32_mt4 m13) r1,
        (b32_mt4 m20, b32_mt4 m21, b32_mt4 m22, b32_mt4 m23) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x4_mt4(b32_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x4_mt4(b32 value) => (b32_mt4)(value);

    [MethodImpl(256 | 512)]
    public b32m3x4_mt4(b32_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x4_mt4(b32v3_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x4_mt4(bool value) => (b32)(value);

    [MethodImpl(256 | 512)]
    public b32m3x4_mt4(b32v3_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b32v3_mt4 c0, out b32v3_mt4 c1, out b32v3_mt4 c2, out b32v3_mt4 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b32_mt4 m00, out b32_mt4 m01, out b32_mt4 m02, out b32_mt4 m03,
        out b32_mt4 m10, out b32_mt4 m11, out b32_mt4 m12, out b32_mt4 m13,
        out b32_mt4 m20, out b32_mt4 m21, out b32_mt4 m22, out b32_mt4 m23
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
        this.c3.Deconstruct(out m03, out m13, out m23);
    }

    #endregion // Deconstruct

    #region Index

    public b32v3_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b32_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b32m3x4_mt4 operator~(b32m3x4_mt4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static b32m3x4_mt4 operator|(b32m3x4_mt4 a, b32m3x4_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static b32m3x4_mt4 operator&(b32m3x4_mt4 a, b32m3x4_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static b32m3x4_mt4 operator^(b32m3x4_mt4 a, b32m3x4_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b32m3x4_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // b32m3x4_mt4

#region b32m3x4_mt8

[CpuOnly]
public partial struct b32m3x4_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b32_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 4); 
    }

    public static b32m3x4_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default, default,
            default, true, default, default,
            default, default, true, default
        ); 
    }

    #endregion

    #region Fields

    public b32v3_mt8 c0;
    public b32v3_mt8 c1;
    public b32v3_mt8 c2;
    public b32v3_mt8 c3;

    #endregion

    #region Properties

    public b32_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b32_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b32_mt8 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b32_mt8 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public b32_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b32_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b32_mt8 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b32_mt8 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public b32_mt8 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b32_mt8 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b32_mt8 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public b32_mt8 m23
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b32m3x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b32m3x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b32m3x4_mt8(b32v3_mt8 c0, b32v3_mt8 c1, b32v3_mt8 c2, b32v3_mt8 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public b32m3x4_mt8((b32v3_mt8 c0, b32v3_mt8 c1, b32v3_mt8 c2, b32v3_mt8 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x4_mt8((b32v3_mt8 c0, b32v3_mt8 c1, b32v3_mt8 c2, b32v3_mt8 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m3x4_mt8(
        b32_mt8 m00, b32_mt8 m01, b32_mt8 m02, b32_mt8 m03,
        b32_mt8 m10, b32_mt8 m11, b32_mt8 m12, b32_mt8 m13,
        b32_mt8 m20, b32_mt8 m21, b32_mt8 m22, b32_mt8 m23
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
        this.c3 = new(m03, m13, m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x4_mt8((
        b32_mt8 m00, b32_mt8 m01, b32_mt8 m02, b32_mt8 m03,
        b32_mt8 m10, b32_mt8 m11, b32_mt8 m12, b32_mt8 m13,
        b32_mt8 m20, b32_mt8 m21, b32_mt8 m22, b32_mt8 m23
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m3x4_mt8((
        b32_mt8 m00, b32_mt8 m01, b32_mt8 m02, b32_mt8 m03,
        b32_mt8 m10, b32_mt8 m11, b32_mt8 m12, b32_mt8 m13,
        b32_mt8 m20, b32_mt8 m21, b32_mt8 m22, b32_mt8 m23
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x4_mt8((
        (b32_mt8 m00, b32_mt8 m01, b32_mt8 m02, b32_mt8 m03) r0,
        (b32_mt8 m10, b32_mt8 m11, b32_mt8 m12, b32_mt8 m13) r1,
        (b32_mt8 m20, b32_mt8 m21, b32_mt8 m22, b32_mt8 m23) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m3x4_mt8((
        (b32_mt8 m00, b32_mt8 m01, b32_mt8 m02, b32_mt8 m03) r0,
        (b32_mt8 m10, b32_mt8 m11, b32_mt8 m12, b32_mt8 m13) r1,
        (b32_mt8 m20, b32_mt8 m21, b32_mt8 m22, b32_mt8 m23) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x4_mt8(b32_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x4_mt8(b32 value) => (b32_mt8)(value);

    [MethodImpl(256 | 512)]
    public b32m3x4_mt8(b32_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x4_mt8(b32v3_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x4_mt8(bool value) => (b32)(value);

    [MethodImpl(256 | 512)]
    public b32m3x4_mt8(b32v3_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b32v3_mt8 c0, out b32v3_mt8 c1, out b32v3_mt8 c2, out b32v3_mt8 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b32_mt8 m00, out b32_mt8 m01, out b32_mt8 m02, out b32_mt8 m03,
        out b32_mt8 m10, out b32_mt8 m11, out b32_mt8 m12, out b32_mt8 m13,
        out b32_mt8 m20, out b32_mt8 m21, out b32_mt8 m22, out b32_mt8 m23
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
        this.c3.Deconstruct(out m03, out m13, out m23);
    }

    #endregion // Deconstruct

    #region Index

    public b32v3_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b32_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b32m3x4_mt8 operator~(b32m3x4_mt8 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static b32m3x4_mt8 operator|(b32m3x4_mt8 a, b32m3x4_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static b32m3x4_mt8 operator&(b32m3x4_mt8 a, b32m3x4_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static b32m3x4_mt8 operator^(b32m3x4_mt8 a, b32m3x4_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b32m3x4_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // b32m3x4_mt8

#region b32m3x4_mt16

[CpuOnly]
public partial struct b32m3x4_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b32_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 4); 
    }

    public static b32m3x4_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default, default,
            default, true, default, default,
            default, default, true, default
        ); 
    }

    #endregion

    #region Fields

    public b32v3_mt16 c0;
    public b32v3_mt16 c1;
    public b32v3_mt16 c2;
    public b32v3_mt16 c3;

    #endregion

    #region Properties

    public b32_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b32_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b32_mt16 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b32_mt16 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public b32_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b32_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b32_mt16 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b32_mt16 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public b32_mt16 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b32_mt16 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b32_mt16 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public b32_mt16 m23
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b32m3x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b32m3x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b32m3x4_mt16(b32v3_mt16 c0, b32v3_mt16 c1, b32v3_mt16 c2, b32v3_mt16 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public b32m3x4_mt16((b32v3_mt16 c0, b32v3_mt16 c1, b32v3_mt16 c2, b32v3_mt16 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x4_mt16((b32v3_mt16 c0, b32v3_mt16 c1, b32v3_mt16 c2, b32v3_mt16 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m3x4_mt16(
        b32_mt16 m00, b32_mt16 m01, b32_mt16 m02, b32_mt16 m03,
        b32_mt16 m10, b32_mt16 m11, b32_mt16 m12, b32_mt16 m13,
        b32_mt16 m20, b32_mt16 m21, b32_mt16 m22, b32_mt16 m23
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
        this.c3 = new(m03, m13, m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x4_mt16((
        b32_mt16 m00, b32_mt16 m01, b32_mt16 m02, b32_mt16 m03,
        b32_mt16 m10, b32_mt16 m11, b32_mt16 m12, b32_mt16 m13,
        b32_mt16 m20, b32_mt16 m21, b32_mt16 m22, b32_mt16 m23
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m3x4_mt16((
        b32_mt16 m00, b32_mt16 m01, b32_mt16 m02, b32_mt16 m03,
        b32_mt16 m10, b32_mt16 m11, b32_mt16 m12, b32_mt16 m13,
        b32_mt16 m20, b32_mt16 m21, b32_mt16 m22, b32_mt16 m23
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x4_mt16((
        (b32_mt16 m00, b32_mt16 m01, b32_mt16 m02, b32_mt16 m03) r0,
        (b32_mt16 m10, b32_mt16 m11, b32_mt16 m12, b32_mt16 m13) r1,
        (b32_mt16 m20, b32_mt16 m21, b32_mt16 m22, b32_mt16 m23) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m3x4_mt16((
        (b32_mt16 m00, b32_mt16 m01, b32_mt16 m02, b32_mt16 m03) r0,
        (b32_mt16 m10, b32_mt16 m11, b32_mt16 m12, b32_mt16 m13) r1,
        (b32_mt16 m20, b32_mt16 m21, b32_mt16 m22, b32_mt16 m23) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x4_mt16(b32_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x4_mt16(b32 value) => (b32_mt16)(value);

    [MethodImpl(256 | 512)]
    public b32m3x4_mt16(b32_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x4_mt16(b32v3_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m3x4_mt16(bool value) => (b32)(value);

    [MethodImpl(256 | 512)]
    public b32m3x4_mt16(b32v3_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b32v3_mt16 c0, out b32v3_mt16 c1, out b32v3_mt16 c2, out b32v3_mt16 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b32_mt16 m00, out b32_mt16 m01, out b32_mt16 m02, out b32_mt16 m03,
        out b32_mt16 m10, out b32_mt16 m11, out b32_mt16 m12, out b32_mt16 m13,
        out b32_mt16 m20, out b32_mt16 m21, out b32_mt16 m22, out b32_mt16 m23
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
        this.c3.Deconstruct(out m03, out m13, out m23);
    }

    #endregion // Deconstruct

    #region Index

    public b32v3_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b32_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b32m3x4_mt16 operator~(b32m3x4_mt16 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static b32m3x4_mt16 operator|(b32m3x4_mt16 a, b32m3x4_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static b32m3x4_mt16 operator&(b32m3x4_mt16 a, b32m3x4_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static b32m3x4_mt16 operator^(b32m3x4_mt16 a, b32m3x4_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b32m3x4_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // b32m3x4_mt16

#region b32m4x2_mt4

[CpuOnly]
public partial struct b32m4x2_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b32_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 2); 
    }

    public static b32m4x2_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default,
            default, true,
            default, default,
            default, default
        ); 
    }

    #endregion

    #region Fields

    public b32v4_mt4 c0;
    public b32v4_mt4 c1;

    #endregion

    #region Properties

    public b32_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b32_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b32_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b32_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b32_mt4 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b32_mt4 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b32_mt4 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public b32_mt4 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b32m4x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b32m4x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b32m4x2_mt4(b32v4_mt4 c0, b32v4_mt4 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public b32m4x2_mt4((b32v4_mt4 c0, b32v4_mt4 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x2_mt4((b32v4_mt4 c0, b32v4_mt4 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m4x2_mt4(
        b32_mt4 m00, b32_mt4 m01,
        b32_mt4 m10, b32_mt4 m11,
        b32_mt4 m20, b32_mt4 m21,
        b32_mt4 m30, b32_mt4 m31
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x2_mt4((
        b32_mt4 m00, b32_mt4 m01,
        b32_mt4 m10, b32_mt4 m11,
        b32_mt4 m20, b32_mt4 m21,
        b32_mt4 m30, b32_mt4 m31
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m4x2_mt4((
        b32_mt4 m00, b32_mt4 m01,
        b32_mt4 m10, b32_mt4 m11,
        b32_mt4 m20, b32_mt4 m21,
        b32_mt4 m30, b32_mt4 m31
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x2_mt4((
        (b32_mt4 m00, b32_mt4 m01) r0,
        (b32_mt4 m10, b32_mt4 m11) r1,
        (b32_mt4 m20, b32_mt4 m21) r2,
        (b32_mt4 m30, b32_mt4 m31) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m4x2_mt4((
        (b32_mt4 m00, b32_mt4 m01) r0,
        (b32_mt4 m10, b32_mt4 m11) r1,
        (b32_mt4 m20, b32_mt4 m21) r2,
        (b32_mt4 m30, b32_mt4 m31) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x2_mt4(b32_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x2_mt4(b32 value) => (b32_mt4)(value);

    [MethodImpl(256 | 512)]
    public b32m4x2_mt4(b32_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x2_mt4(b32v4_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x2_mt4(bool value) => (b32)(value);

    [MethodImpl(256 | 512)]
    public b32m4x2_mt4(b32v4_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b32v4_mt4 c0, out b32v4_mt4 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b32_mt4 m00, out b32_mt4 m01,
        out b32_mt4 m10, out b32_mt4 m11,
        out b32_mt4 m20, out b32_mt4 m21,
        out b32_mt4 m30, out b32_mt4 m31
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
    }

    #endregion // Deconstruct

    #region Index

    public b32v4_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b32_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b32m4x2_mt4 operator~(b32m4x2_mt4 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static b32m4x2_mt4 operator|(b32m4x2_mt4 a, b32m4x2_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static b32m4x2_mt4 operator&(b32m4x2_mt4 a, b32m4x2_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static b32m4x2_mt4 operator^(b32m4x2_mt4 a, b32m4x2_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b32m4x2_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // b32m4x2_mt4

#region b32m4x2_mt8

[CpuOnly]
public partial struct b32m4x2_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b32_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 2); 
    }

    public static b32m4x2_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default,
            default, true,
            default, default,
            default, default
        ); 
    }

    #endregion

    #region Fields

    public b32v4_mt8 c0;
    public b32v4_mt8 c1;

    #endregion

    #region Properties

    public b32_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b32_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b32_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b32_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b32_mt8 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b32_mt8 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b32_mt8 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public b32_mt8 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b32m4x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b32m4x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b32m4x2_mt8(b32v4_mt8 c0, b32v4_mt8 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public b32m4x2_mt8((b32v4_mt8 c0, b32v4_mt8 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x2_mt8((b32v4_mt8 c0, b32v4_mt8 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m4x2_mt8(
        b32_mt8 m00, b32_mt8 m01,
        b32_mt8 m10, b32_mt8 m11,
        b32_mt8 m20, b32_mt8 m21,
        b32_mt8 m30, b32_mt8 m31
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x2_mt8((
        b32_mt8 m00, b32_mt8 m01,
        b32_mt8 m10, b32_mt8 m11,
        b32_mt8 m20, b32_mt8 m21,
        b32_mt8 m30, b32_mt8 m31
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m4x2_mt8((
        b32_mt8 m00, b32_mt8 m01,
        b32_mt8 m10, b32_mt8 m11,
        b32_mt8 m20, b32_mt8 m21,
        b32_mt8 m30, b32_mt8 m31
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x2_mt8((
        (b32_mt8 m00, b32_mt8 m01) r0,
        (b32_mt8 m10, b32_mt8 m11) r1,
        (b32_mt8 m20, b32_mt8 m21) r2,
        (b32_mt8 m30, b32_mt8 m31) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m4x2_mt8((
        (b32_mt8 m00, b32_mt8 m01) r0,
        (b32_mt8 m10, b32_mt8 m11) r1,
        (b32_mt8 m20, b32_mt8 m21) r2,
        (b32_mt8 m30, b32_mt8 m31) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x2_mt8(b32_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x2_mt8(b32 value) => (b32_mt8)(value);

    [MethodImpl(256 | 512)]
    public b32m4x2_mt8(b32_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x2_mt8(b32v4_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x2_mt8(bool value) => (b32)(value);

    [MethodImpl(256 | 512)]
    public b32m4x2_mt8(b32v4_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b32v4_mt8 c0, out b32v4_mt8 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b32_mt8 m00, out b32_mt8 m01,
        out b32_mt8 m10, out b32_mt8 m11,
        out b32_mt8 m20, out b32_mt8 m21,
        out b32_mt8 m30, out b32_mt8 m31
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
    }

    #endregion // Deconstruct

    #region Index

    public b32v4_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b32_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b32m4x2_mt8 operator~(b32m4x2_mt8 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static b32m4x2_mt8 operator|(b32m4x2_mt8 a, b32m4x2_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static b32m4x2_mt8 operator&(b32m4x2_mt8 a, b32m4x2_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static b32m4x2_mt8 operator^(b32m4x2_mt8 a, b32m4x2_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b32m4x2_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // b32m4x2_mt8

#region b32m4x2_mt16

[CpuOnly]
public partial struct b32m4x2_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b32_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 2); 
    }

    public static b32m4x2_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default,
            default, true,
            default, default,
            default, default
        ); 
    }

    #endregion

    #region Fields

    public b32v4_mt16 c0;
    public b32v4_mt16 c1;

    #endregion

    #region Properties

    public b32_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b32_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b32_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b32_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b32_mt16 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b32_mt16 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b32_mt16 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public b32_mt16 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b32m4x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b32m4x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b32m4x2_mt16(b32v4_mt16 c0, b32v4_mt16 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public b32m4x2_mt16((b32v4_mt16 c0, b32v4_mt16 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x2_mt16((b32v4_mt16 c0, b32v4_mt16 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m4x2_mt16(
        b32_mt16 m00, b32_mt16 m01,
        b32_mt16 m10, b32_mt16 m11,
        b32_mt16 m20, b32_mt16 m21,
        b32_mt16 m30, b32_mt16 m31
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x2_mt16((
        b32_mt16 m00, b32_mt16 m01,
        b32_mt16 m10, b32_mt16 m11,
        b32_mt16 m20, b32_mt16 m21,
        b32_mt16 m30, b32_mt16 m31
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m4x2_mt16((
        b32_mt16 m00, b32_mt16 m01,
        b32_mt16 m10, b32_mt16 m11,
        b32_mt16 m20, b32_mt16 m21,
        b32_mt16 m30, b32_mt16 m31
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x2_mt16((
        (b32_mt16 m00, b32_mt16 m01) r0,
        (b32_mt16 m10, b32_mt16 m11) r1,
        (b32_mt16 m20, b32_mt16 m21) r2,
        (b32_mt16 m30, b32_mt16 m31) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m4x2_mt16((
        (b32_mt16 m00, b32_mt16 m01) r0,
        (b32_mt16 m10, b32_mt16 m11) r1,
        (b32_mt16 m20, b32_mt16 m21) r2,
        (b32_mt16 m30, b32_mt16 m31) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x2_mt16(b32_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x2_mt16(b32 value) => (b32_mt16)(value);

    [MethodImpl(256 | 512)]
    public b32m4x2_mt16(b32_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x2_mt16(b32v4_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x2_mt16(bool value) => (b32)(value);

    [MethodImpl(256 | 512)]
    public b32m4x2_mt16(b32v4_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b32v4_mt16 c0, out b32v4_mt16 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b32_mt16 m00, out b32_mt16 m01,
        out b32_mt16 m10, out b32_mt16 m11,
        out b32_mt16 m20, out b32_mt16 m21,
        out b32_mt16 m30, out b32_mt16 m31
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
    }

    #endregion // Deconstruct

    #region Index

    public b32v4_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b32_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b32m4x2_mt16 operator~(b32m4x2_mt16 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static b32m4x2_mt16 operator|(b32m4x2_mt16 a, b32m4x2_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static b32m4x2_mt16 operator&(b32m4x2_mt16 a, b32m4x2_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static b32m4x2_mt16 operator^(b32m4x2_mt16 a, b32m4x2_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b32m4x2_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // b32m4x2_mt16

#region b32m4x3_mt4

[CpuOnly]
public partial struct b32m4x3_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b32_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 3); 
    }

    public static b32m4x3_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default,
            default, true, default,
            default, default, true,
            default, default, default
        ); 
    }

    #endregion

    #region Fields

    public b32v4_mt4 c0;
    public b32v4_mt4 c1;
    public b32v4_mt4 c2;

    #endregion

    #region Properties

    public b32_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b32_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b32_mt4 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b32_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b32_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b32_mt4 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b32_mt4 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b32_mt4 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b32_mt4 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public b32_mt4 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public b32_mt4 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public b32_mt4 m32
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b32m4x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b32m4x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b32m4x3_mt4(b32v4_mt4 c0, b32v4_mt4 c1, b32v4_mt4 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public b32m4x3_mt4((b32v4_mt4 c0, b32v4_mt4 c1, b32v4_mt4 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x3_mt4((b32v4_mt4 c0, b32v4_mt4 c1, b32v4_mt4 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m4x3_mt4(
        b32_mt4 m00, b32_mt4 m01, b32_mt4 m02,
        b32_mt4 m10, b32_mt4 m11, b32_mt4 m12,
        b32_mt4 m20, b32_mt4 m21, b32_mt4 m22,
        b32_mt4 m30, b32_mt4 m31, b32_mt4 m32
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x3_mt4((
        b32_mt4 m00, b32_mt4 m01, b32_mt4 m02,
        b32_mt4 m10, b32_mt4 m11, b32_mt4 m12,
        b32_mt4 m20, b32_mt4 m21, b32_mt4 m22,
        b32_mt4 m30, b32_mt4 m31, b32_mt4 m32
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m4x3_mt4((
        b32_mt4 m00, b32_mt4 m01, b32_mt4 m02,
        b32_mt4 m10, b32_mt4 m11, b32_mt4 m12,
        b32_mt4 m20, b32_mt4 m21, b32_mt4 m22,
        b32_mt4 m30, b32_mt4 m31, b32_mt4 m32
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x3_mt4((
        (b32_mt4 m00, b32_mt4 m01, b32_mt4 m02) r0,
        (b32_mt4 m10, b32_mt4 m11, b32_mt4 m12) r1,
        (b32_mt4 m20, b32_mt4 m21, b32_mt4 m22) r2,
        (b32_mt4 m30, b32_mt4 m31, b32_mt4 m32) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m4x3_mt4((
        (b32_mt4 m00, b32_mt4 m01, b32_mt4 m02) r0,
        (b32_mt4 m10, b32_mt4 m11, b32_mt4 m12) r1,
        (b32_mt4 m20, b32_mt4 m21, b32_mt4 m22) r2,
        (b32_mt4 m30, b32_mt4 m31, b32_mt4 m32) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x3_mt4(b32_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x3_mt4(b32 value) => (b32_mt4)(value);

    [MethodImpl(256 | 512)]
    public b32m4x3_mt4(b32_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x3_mt4(b32v4_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x3_mt4(bool value) => (b32)(value);

    [MethodImpl(256 | 512)]
    public b32m4x3_mt4(b32v4_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b32v4_mt4 c0, out b32v4_mt4 c1, out b32v4_mt4 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b32_mt4 m00, out b32_mt4 m01, out b32_mt4 m02,
        out b32_mt4 m10, out b32_mt4 m11, out b32_mt4 m12,
        out b32_mt4 m20, out b32_mt4 m21, out b32_mt4 m22,
        out b32_mt4 m30, out b32_mt4 m31, out b32_mt4 m32
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
    }

    #endregion // Deconstruct

    #region Index

    public b32v4_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b32_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b32m4x3_mt4 operator~(b32m4x3_mt4 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static b32m4x3_mt4 operator|(b32m4x3_mt4 a, b32m4x3_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static b32m4x3_mt4 operator&(b32m4x3_mt4 a, b32m4x3_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static b32m4x3_mt4 operator^(b32m4x3_mt4 a, b32m4x3_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b32m4x3_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // b32m4x3_mt4

#region b32m4x3_mt8

[CpuOnly]
public partial struct b32m4x3_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b32_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 3); 
    }

    public static b32m4x3_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default,
            default, true, default,
            default, default, true,
            default, default, default
        ); 
    }

    #endregion

    #region Fields

    public b32v4_mt8 c0;
    public b32v4_mt8 c1;
    public b32v4_mt8 c2;

    #endregion

    #region Properties

    public b32_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b32_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b32_mt8 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b32_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b32_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b32_mt8 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b32_mt8 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b32_mt8 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b32_mt8 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public b32_mt8 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public b32_mt8 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public b32_mt8 m32
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b32m4x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b32m4x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b32m4x3_mt8(b32v4_mt8 c0, b32v4_mt8 c1, b32v4_mt8 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public b32m4x3_mt8((b32v4_mt8 c0, b32v4_mt8 c1, b32v4_mt8 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x3_mt8((b32v4_mt8 c0, b32v4_mt8 c1, b32v4_mt8 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m4x3_mt8(
        b32_mt8 m00, b32_mt8 m01, b32_mt8 m02,
        b32_mt8 m10, b32_mt8 m11, b32_mt8 m12,
        b32_mt8 m20, b32_mt8 m21, b32_mt8 m22,
        b32_mt8 m30, b32_mt8 m31, b32_mt8 m32
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x3_mt8((
        b32_mt8 m00, b32_mt8 m01, b32_mt8 m02,
        b32_mt8 m10, b32_mt8 m11, b32_mt8 m12,
        b32_mt8 m20, b32_mt8 m21, b32_mt8 m22,
        b32_mt8 m30, b32_mt8 m31, b32_mt8 m32
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m4x3_mt8((
        b32_mt8 m00, b32_mt8 m01, b32_mt8 m02,
        b32_mt8 m10, b32_mt8 m11, b32_mt8 m12,
        b32_mt8 m20, b32_mt8 m21, b32_mt8 m22,
        b32_mt8 m30, b32_mt8 m31, b32_mt8 m32
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x3_mt8((
        (b32_mt8 m00, b32_mt8 m01, b32_mt8 m02) r0,
        (b32_mt8 m10, b32_mt8 m11, b32_mt8 m12) r1,
        (b32_mt8 m20, b32_mt8 m21, b32_mt8 m22) r2,
        (b32_mt8 m30, b32_mt8 m31, b32_mt8 m32) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m4x3_mt8((
        (b32_mt8 m00, b32_mt8 m01, b32_mt8 m02) r0,
        (b32_mt8 m10, b32_mt8 m11, b32_mt8 m12) r1,
        (b32_mt8 m20, b32_mt8 m21, b32_mt8 m22) r2,
        (b32_mt8 m30, b32_mt8 m31, b32_mt8 m32) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x3_mt8(b32_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x3_mt8(b32 value) => (b32_mt8)(value);

    [MethodImpl(256 | 512)]
    public b32m4x3_mt8(b32_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x3_mt8(b32v4_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x3_mt8(bool value) => (b32)(value);

    [MethodImpl(256 | 512)]
    public b32m4x3_mt8(b32v4_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b32v4_mt8 c0, out b32v4_mt8 c1, out b32v4_mt8 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b32_mt8 m00, out b32_mt8 m01, out b32_mt8 m02,
        out b32_mt8 m10, out b32_mt8 m11, out b32_mt8 m12,
        out b32_mt8 m20, out b32_mt8 m21, out b32_mt8 m22,
        out b32_mt8 m30, out b32_mt8 m31, out b32_mt8 m32
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
    }

    #endregion // Deconstruct

    #region Index

    public b32v4_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b32_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b32m4x3_mt8 operator~(b32m4x3_mt8 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static b32m4x3_mt8 operator|(b32m4x3_mt8 a, b32m4x3_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static b32m4x3_mt8 operator&(b32m4x3_mt8 a, b32m4x3_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static b32m4x3_mt8 operator^(b32m4x3_mt8 a, b32m4x3_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b32m4x3_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // b32m4x3_mt8

#region b32m4x3_mt16

[CpuOnly]
public partial struct b32m4x3_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b32_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 3); 
    }

    public static b32m4x3_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default,
            default, true, default,
            default, default, true,
            default, default, default
        ); 
    }

    #endregion

    #region Fields

    public b32v4_mt16 c0;
    public b32v4_mt16 c1;
    public b32v4_mt16 c2;

    #endregion

    #region Properties

    public b32_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b32_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b32_mt16 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b32_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b32_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b32_mt16 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b32_mt16 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b32_mt16 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b32_mt16 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public b32_mt16 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public b32_mt16 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public b32_mt16 m32
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b32m4x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b32m4x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b32m4x3_mt16(b32v4_mt16 c0, b32v4_mt16 c1, b32v4_mt16 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public b32m4x3_mt16((b32v4_mt16 c0, b32v4_mt16 c1, b32v4_mt16 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x3_mt16((b32v4_mt16 c0, b32v4_mt16 c1, b32v4_mt16 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m4x3_mt16(
        b32_mt16 m00, b32_mt16 m01, b32_mt16 m02,
        b32_mt16 m10, b32_mt16 m11, b32_mt16 m12,
        b32_mt16 m20, b32_mt16 m21, b32_mt16 m22,
        b32_mt16 m30, b32_mt16 m31, b32_mt16 m32
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x3_mt16((
        b32_mt16 m00, b32_mt16 m01, b32_mt16 m02,
        b32_mt16 m10, b32_mt16 m11, b32_mt16 m12,
        b32_mt16 m20, b32_mt16 m21, b32_mt16 m22,
        b32_mt16 m30, b32_mt16 m31, b32_mt16 m32
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m4x3_mt16((
        b32_mt16 m00, b32_mt16 m01, b32_mt16 m02,
        b32_mt16 m10, b32_mt16 m11, b32_mt16 m12,
        b32_mt16 m20, b32_mt16 m21, b32_mt16 m22,
        b32_mt16 m30, b32_mt16 m31, b32_mt16 m32
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x3_mt16((
        (b32_mt16 m00, b32_mt16 m01, b32_mt16 m02) r0,
        (b32_mt16 m10, b32_mt16 m11, b32_mt16 m12) r1,
        (b32_mt16 m20, b32_mt16 m21, b32_mt16 m22) r2,
        (b32_mt16 m30, b32_mt16 m31, b32_mt16 m32) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m4x3_mt16((
        (b32_mt16 m00, b32_mt16 m01, b32_mt16 m02) r0,
        (b32_mt16 m10, b32_mt16 m11, b32_mt16 m12) r1,
        (b32_mt16 m20, b32_mt16 m21, b32_mt16 m22) r2,
        (b32_mt16 m30, b32_mt16 m31, b32_mt16 m32) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x3_mt16(b32_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x3_mt16(b32 value) => (b32_mt16)(value);

    [MethodImpl(256 | 512)]
    public b32m4x3_mt16(b32_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x3_mt16(b32v4_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x3_mt16(bool value) => (b32)(value);

    [MethodImpl(256 | 512)]
    public b32m4x3_mt16(b32v4_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b32v4_mt16 c0, out b32v4_mt16 c1, out b32v4_mt16 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b32_mt16 m00, out b32_mt16 m01, out b32_mt16 m02,
        out b32_mt16 m10, out b32_mt16 m11, out b32_mt16 m12,
        out b32_mt16 m20, out b32_mt16 m21, out b32_mt16 m22,
        out b32_mt16 m30, out b32_mt16 m31, out b32_mt16 m32
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
    }

    #endregion // Deconstruct

    #region Index

    public b32v4_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b32_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b32m4x3_mt16 operator~(b32m4x3_mt16 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static b32m4x3_mt16 operator|(b32m4x3_mt16 a, b32m4x3_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static b32m4x3_mt16 operator&(b32m4x3_mt16 a, b32m4x3_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static b32m4x3_mt16 operator^(b32m4x3_mt16 a, b32m4x3_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b32m4x3_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // b32m4x3_mt16

#region b32m4x4_mt4

[CpuOnly]
public partial struct b32m4x4_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b32_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 4); 
    }

    public static b32m4x4_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default, default,
            default, true, default, default,
            default, default, true, default,
            default, default, default, true
        ); 
    }

    #endregion

    #region Fields

    public b32v4_mt4 c0;
    public b32v4_mt4 c1;
    public b32v4_mt4 c2;
    public b32v4_mt4 c3;

    #endregion

    #region Properties

    public b32_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b32_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b32_mt4 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b32_mt4 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public b32_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b32_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b32_mt4 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b32_mt4 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public b32_mt4 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b32_mt4 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b32_mt4 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public b32_mt4 m23
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }
    public b32_mt4 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public b32_mt4 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public b32_mt4 m32
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }
    public b32_mt4 m33
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.w;
        [MethodImpl(256 | 512)]
        set => c3.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b32m4x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b32m4x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b32m4x4_mt4(b32v4_mt4 c0, b32v4_mt4 c1, b32v4_mt4 c2, b32v4_mt4 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public b32m4x4_mt4((b32v4_mt4 c0, b32v4_mt4 c1, b32v4_mt4 c2, b32v4_mt4 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x4_mt4((b32v4_mt4 c0, b32v4_mt4 c1, b32v4_mt4 c2, b32v4_mt4 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m4x4_mt4(
        b32_mt4 m00, b32_mt4 m01, b32_mt4 m02, b32_mt4 m03,
        b32_mt4 m10, b32_mt4 m11, b32_mt4 m12, b32_mt4 m13,
        b32_mt4 m20, b32_mt4 m21, b32_mt4 m22, b32_mt4 m23,
        b32_mt4 m30, b32_mt4 m31, b32_mt4 m32, b32_mt4 m33
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
        this.c3 = new(m03, m13, m23, m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x4_mt4((
        b32_mt4 m00, b32_mt4 m01, b32_mt4 m02, b32_mt4 m03,
        b32_mt4 m10, b32_mt4 m11, b32_mt4 m12, b32_mt4 m13,
        b32_mt4 m20, b32_mt4 m21, b32_mt4 m22, b32_mt4 m23,
        b32_mt4 m30, b32_mt4 m31, b32_mt4 m32, b32_mt4 m33
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m4x4_mt4((
        b32_mt4 m00, b32_mt4 m01, b32_mt4 m02, b32_mt4 m03,
        b32_mt4 m10, b32_mt4 m11, b32_mt4 m12, b32_mt4 m13,
        b32_mt4 m20, b32_mt4 m21, b32_mt4 m22, b32_mt4 m23,
        b32_mt4 m30, b32_mt4 m31, b32_mt4 m32, b32_mt4 m33
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23, tuple.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x4_mt4((
        (b32_mt4 m00, b32_mt4 m01, b32_mt4 m02, b32_mt4 m03) r0,
        (b32_mt4 m10, b32_mt4 m11, b32_mt4 m12, b32_mt4 m13) r1,
        (b32_mt4 m20, b32_mt4 m21, b32_mt4 m22, b32_mt4 m23) r2,
        (b32_mt4 m30, b32_mt4 m31, b32_mt4 m32, b32_mt4 m33) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m4x4_mt4((
        (b32_mt4 m00, b32_mt4 m01, b32_mt4 m02, b32_mt4 m03) r0,
        (b32_mt4 m10, b32_mt4 m11, b32_mt4 m12, b32_mt4 m13) r1,
        (b32_mt4 m20, b32_mt4 m21, b32_mt4 m22, b32_mt4 m23) r2,
        (b32_mt4 m30, b32_mt4 m31, b32_mt4 m32, b32_mt4 m33) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23, tuple.r3.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x4_mt4(b32_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x4_mt4(b32 value) => (b32_mt4)(value);

    [MethodImpl(256 | 512)]
    public b32m4x4_mt4(b32_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x4_mt4(b32v4_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x4_mt4(bool value) => (b32)(value);

    [MethodImpl(256 | 512)]
    public b32m4x4_mt4(b32v4_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b32v4_mt4 c0, out b32v4_mt4 c1, out b32v4_mt4 c2, out b32v4_mt4 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b32_mt4 m00, out b32_mt4 m01, out b32_mt4 m02, out b32_mt4 m03,
        out b32_mt4 m10, out b32_mt4 m11, out b32_mt4 m12, out b32_mt4 m13,
        out b32_mt4 m20, out b32_mt4 m21, out b32_mt4 m22, out b32_mt4 m23,
        out b32_mt4 m30, out b32_mt4 m31, out b32_mt4 m32, out b32_mt4 m33
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
        this.c3.Deconstruct(out m03, out m13, out m23, out m33);
    }

    #endregion // Deconstruct

    #region Index

    public b32v4_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b32_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b32m4x4_mt4 operator~(b32m4x4_mt4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static b32m4x4_mt4 operator|(b32m4x4_mt4 a, b32m4x4_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static b32m4x4_mt4 operator&(b32m4x4_mt4 a, b32m4x4_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static b32m4x4_mt4 operator^(b32m4x4_mt4 a, b32m4x4_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b32m4x4_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // b32m4x4_mt4

#region b32m4x4_mt8

[CpuOnly]
public partial struct b32m4x4_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b32_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 4); 
    }

    public static b32m4x4_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default, default,
            default, true, default, default,
            default, default, true, default,
            default, default, default, true
        ); 
    }

    #endregion

    #region Fields

    public b32v4_mt8 c0;
    public b32v4_mt8 c1;
    public b32v4_mt8 c2;
    public b32v4_mt8 c3;

    #endregion

    #region Properties

    public b32_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b32_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b32_mt8 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b32_mt8 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public b32_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b32_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b32_mt8 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b32_mt8 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public b32_mt8 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b32_mt8 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b32_mt8 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public b32_mt8 m23
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }
    public b32_mt8 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public b32_mt8 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public b32_mt8 m32
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }
    public b32_mt8 m33
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.w;
        [MethodImpl(256 | 512)]
        set => c3.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b32m4x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b32m4x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b32m4x4_mt8(b32v4_mt8 c0, b32v4_mt8 c1, b32v4_mt8 c2, b32v4_mt8 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public b32m4x4_mt8((b32v4_mt8 c0, b32v4_mt8 c1, b32v4_mt8 c2, b32v4_mt8 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x4_mt8((b32v4_mt8 c0, b32v4_mt8 c1, b32v4_mt8 c2, b32v4_mt8 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m4x4_mt8(
        b32_mt8 m00, b32_mt8 m01, b32_mt8 m02, b32_mt8 m03,
        b32_mt8 m10, b32_mt8 m11, b32_mt8 m12, b32_mt8 m13,
        b32_mt8 m20, b32_mt8 m21, b32_mt8 m22, b32_mt8 m23,
        b32_mt8 m30, b32_mt8 m31, b32_mt8 m32, b32_mt8 m33
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
        this.c3 = new(m03, m13, m23, m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x4_mt8((
        b32_mt8 m00, b32_mt8 m01, b32_mt8 m02, b32_mt8 m03,
        b32_mt8 m10, b32_mt8 m11, b32_mt8 m12, b32_mt8 m13,
        b32_mt8 m20, b32_mt8 m21, b32_mt8 m22, b32_mt8 m23,
        b32_mt8 m30, b32_mt8 m31, b32_mt8 m32, b32_mt8 m33
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m4x4_mt8((
        b32_mt8 m00, b32_mt8 m01, b32_mt8 m02, b32_mt8 m03,
        b32_mt8 m10, b32_mt8 m11, b32_mt8 m12, b32_mt8 m13,
        b32_mt8 m20, b32_mt8 m21, b32_mt8 m22, b32_mt8 m23,
        b32_mt8 m30, b32_mt8 m31, b32_mt8 m32, b32_mt8 m33
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23, tuple.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x4_mt8((
        (b32_mt8 m00, b32_mt8 m01, b32_mt8 m02, b32_mt8 m03) r0,
        (b32_mt8 m10, b32_mt8 m11, b32_mt8 m12, b32_mt8 m13) r1,
        (b32_mt8 m20, b32_mt8 m21, b32_mt8 m22, b32_mt8 m23) r2,
        (b32_mt8 m30, b32_mt8 m31, b32_mt8 m32, b32_mt8 m33) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m4x4_mt8((
        (b32_mt8 m00, b32_mt8 m01, b32_mt8 m02, b32_mt8 m03) r0,
        (b32_mt8 m10, b32_mt8 m11, b32_mt8 m12, b32_mt8 m13) r1,
        (b32_mt8 m20, b32_mt8 m21, b32_mt8 m22, b32_mt8 m23) r2,
        (b32_mt8 m30, b32_mt8 m31, b32_mt8 m32, b32_mt8 m33) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23, tuple.r3.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x4_mt8(b32_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x4_mt8(b32 value) => (b32_mt8)(value);

    [MethodImpl(256 | 512)]
    public b32m4x4_mt8(b32_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x4_mt8(b32v4_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x4_mt8(bool value) => (b32)(value);

    [MethodImpl(256 | 512)]
    public b32m4x4_mt8(b32v4_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b32v4_mt8 c0, out b32v4_mt8 c1, out b32v4_mt8 c2, out b32v4_mt8 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b32_mt8 m00, out b32_mt8 m01, out b32_mt8 m02, out b32_mt8 m03,
        out b32_mt8 m10, out b32_mt8 m11, out b32_mt8 m12, out b32_mt8 m13,
        out b32_mt8 m20, out b32_mt8 m21, out b32_mt8 m22, out b32_mt8 m23,
        out b32_mt8 m30, out b32_mt8 m31, out b32_mt8 m32, out b32_mt8 m33
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
        this.c3.Deconstruct(out m03, out m13, out m23, out m33);
    }

    #endregion // Deconstruct

    #region Index

    public b32v4_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b32_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b32m4x4_mt8 operator~(b32m4x4_mt8 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static b32m4x4_mt8 operator|(b32m4x4_mt8 a, b32m4x4_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static b32m4x4_mt8 operator&(b32m4x4_mt8 a, b32m4x4_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static b32m4x4_mt8 operator^(b32m4x4_mt8 a, b32m4x4_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b32m4x4_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // b32m4x4_mt8

#region b32m4x4_mt16

[CpuOnly]
public partial struct b32m4x4_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b32_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 4); 
    }

    public static b32m4x4_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default, default,
            default, true, default, default,
            default, default, true, default,
            default, default, default, true
        ); 
    }

    #endregion

    #region Fields

    public b32v4_mt16 c0;
    public b32v4_mt16 c1;
    public b32v4_mt16 c2;
    public b32v4_mt16 c3;

    #endregion

    #region Properties

    public b32_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b32_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b32_mt16 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b32_mt16 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public b32_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b32_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b32_mt16 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b32_mt16 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public b32_mt16 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b32_mt16 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b32_mt16 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public b32_mt16 m23
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }
    public b32_mt16 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public b32_mt16 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public b32_mt16 m32
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }
    public b32_mt16 m33
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.w;
        [MethodImpl(256 | 512)]
        set => c3.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b32m4x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b32m4x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b32m4x4_mt16(b32v4_mt16 c0, b32v4_mt16 c1, b32v4_mt16 c2, b32v4_mt16 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public b32m4x4_mt16((b32v4_mt16 c0, b32v4_mt16 c1, b32v4_mt16 c2, b32v4_mt16 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x4_mt16((b32v4_mt16 c0, b32v4_mt16 c1, b32v4_mt16 c2, b32v4_mt16 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m4x4_mt16(
        b32_mt16 m00, b32_mt16 m01, b32_mt16 m02, b32_mt16 m03,
        b32_mt16 m10, b32_mt16 m11, b32_mt16 m12, b32_mt16 m13,
        b32_mt16 m20, b32_mt16 m21, b32_mt16 m22, b32_mt16 m23,
        b32_mt16 m30, b32_mt16 m31, b32_mt16 m32, b32_mt16 m33
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
        this.c3 = new(m03, m13, m23, m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x4_mt16((
        b32_mt16 m00, b32_mt16 m01, b32_mt16 m02, b32_mt16 m03,
        b32_mt16 m10, b32_mt16 m11, b32_mt16 m12, b32_mt16 m13,
        b32_mt16 m20, b32_mt16 m21, b32_mt16 m22, b32_mt16 m23,
        b32_mt16 m30, b32_mt16 m31, b32_mt16 m32, b32_mt16 m33
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m4x4_mt16((
        b32_mt16 m00, b32_mt16 m01, b32_mt16 m02, b32_mt16 m03,
        b32_mt16 m10, b32_mt16 m11, b32_mt16 m12, b32_mt16 m13,
        b32_mt16 m20, b32_mt16 m21, b32_mt16 m22, b32_mt16 m23,
        b32_mt16 m30, b32_mt16 m31, b32_mt16 m32, b32_mt16 m33
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23, tuple.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x4_mt16((
        (b32_mt16 m00, b32_mt16 m01, b32_mt16 m02, b32_mt16 m03) r0,
        (b32_mt16 m10, b32_mt16 m11, b32_mt16 m12, b32_mt16 m13) r1,
        (b32_mt16 m20, b32_mt16 m21, b32_mt16 m22, b32_mt16 m23) r2,
        (b32_mt16 m30, b32_mt16 m31, b32_mt16 m32, b32_mt16 m33) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b32m4x4_mt16((
        (b32_mt16 m00, b32_mt16 m01, b32_mt16 m02, b32_mt16 m03) r0,
        (b32_mt16 m10, b32_mt16 m11, b32_mt16 m12, b32_mt16 m13) r1,
        (b32_mt16 m20, b32_mt16 m21, b32_mt16 m22, b32_mt16 m23) r2,
        (b32_mt16 m30, b32_mt16 m31, b32_mt16 m32, b32_mt16 m33) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23, tuple.r3.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x4_mt16(b32_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x4_mt16(b32 value) => (b32_mt16)(value);

    [MethodImpl(256 | 512)]
    public b32m4x4_mt16(b32_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x4_mt16(b32v4_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b32m4x4_mt16(bool value) => (b32)(value);

    [MethodImpl(256 | 512)]
    public b32m4x4_mt16(b32v4_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b32v4_mt16 c0, out b32v4_mt16 c1, out b32v4_mt16 c2, out b32v4_mt16 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b32_mt16 m00, out b32_mt16 m01, out b32_mt16 m02, out b32_mt16 m03,
        out b32_mt16 m10, out b32_mt16 m11, out b32_mt16 m12, out b32_mt16 m13,
        out b32_mt16 m20, out b32_mt16 m21, out b32_mt16 m22, out b32_mt16 m23,
        out b32_mt16 m30, out b32_mt16 m31, out b32_mt16 m32, out b32_mt16 m33
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
        this.c3.Deconstruct(out m03, out m13, out m23, out m33);
    }

    #endregion // Deconstruct

    #region Index

    public b32v4_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b32_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b32m4x4_mt16 operator~(b32m4x4_mt16 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static b32m4x4_mt16 operator|(b32m4x4_mt16 a, b32m4x4_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static b32m4x4_mt16 operator&(b32m4x4_mt16 a, b32m4x4_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static b32m4x4_mt16 operator^(b32m4x4_mt16 a, b32m4x4_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b32m4x4_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // b32m4x4_mt16

#region b64m2x2_mt4

[CpuOnly]
public partial struct b64m2x2_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b64_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 2); 
    }

    public static b64m2x2_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default,
            default, true
        ); 
    }

    #endregion

    #region Fields

    public b64v2_mt4 c0;
    public b64v2_mt4 c1;

    #endregion

    #region Properties

    public b64_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b64_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b64_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b64_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b64m2x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b64m2x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b64m2x2_mt4(b64v2_mt4 c0, b64v2_mt4 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public b64m2x2_mt4((b64v2_mt4 c0, b64v2_mt4 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x2_mt4((b64v2_mt4 c0, b64v2_mt4 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m2x2_mt4(
        b64_mt4 m00, b64_mt4 m01,
        b64_mt4 m10, b64_mt4 m11
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x2_mt4((
        b64_mt4 m00, b64_mt4 m01,
        b64_mt4 m10, b64_mt4 m11
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m2x2_mt4((
        b64_mt4 m00, b64_mt4 m01,
        b64_mt4 m10, b64_mt4 m11
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x2_mt4((
        (b64_mt4 m00, b64_mt4 m01) r0,
        (b64_mt4 m10, b64_mt4 m11) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m2x2_mt4((
        (b64_mt4 m00, b64_mt4 m01) r0,
        (b64_mt4 m10, b64_mt4 m11) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x2_mt4(b64_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x2_mt4(b64 value) => (b64_mt4)(value);

    [MethodImpl(256 | 512)]
    public b64m2x2_mt4(b64_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x2_mt4(b64v2_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x2_mt4(bool value) => (b64)(value);

    [MethodImpl(256 | 512)]
    public b64m2x2_mt4(b64v2_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b64v2_mt4 c0, out b64v2_mt4 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b64_mt4 m00, out b64_mt4 m01,
        out b64_mt4 m10, out b64_mt4 m11
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
    }

    #endregion // Deconstruct

    #region Index

    public b64v2_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b64_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b64m2x2_mt4 operator~(b64m2x2_mt4 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static b64m2x2_mt4 operator|(b64m2x2_mt4 a, b64m2x2_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static b64m2x2_mt4 operator&(b64m2x2_mt4 a, b64m2x2_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static b64m2x2_mt4 operator^(b64m2x2_mt4 a, b64m2x2_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b64m2x2_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // b64m2x2_mt4

#region b64m2x2_mt8

[CpuOnly]
public partial struct b64m2x2_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b64_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 2); 
    }

    public static b64m2x2_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default,
            default, true
        ); 
    }

    #endregion

    #region Fields

    public b64v2_mt8 c0;
    public b64v2_mt8 c1;

    #endregion

    #region Properties

    public b64_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b64_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b64_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b64_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b64m2x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b64m2x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b64m2x2_mt8(b64v2_mt8 c0, b64v2_mt8 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public b64m2x2_mt8((b64v2_mt8 c0, b64v2_mt8 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x2_mt8((b64v2_mt8 c0, b64v2_mt8 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m2x2_mt8(
        b64_mt8 m00, b64_mt8 m01,
        b64_mt8 m10, b64_mt8 m11
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x2_mt8((
        b64_mt8 m00, b64_mt8 m01,
        b64_mt8 m10, b64_mt8 m11
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m2x2_mt8((
        b64_mt8 m00, b64_mt8 m01,
        b64_mt8 m10, b64_mt8 m11
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x2_mt8((
        (b64_mt8 m00, b64_mt8 m01) r0,
        (b64_mt8 m10, b64_mt8 m11) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m2x2_mt8((
        (b64_mt8 m00, b64_mt8 m01) r0,
        (b64_mt8 m10, b64_mt8 m11) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x2_mt8(b64_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x2_mt8(b64 value) => (b64_mt8)(value);

    [MethodImpl(256 | 512)]
    public b64m2x2_mt8(b64_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x2_mt8(b64v2_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x2_mt8(bool value) => (b64)(value);

    [MethodImpl(256 | 512)]
    public b64m2x2_mt8(b64v2_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b64v2_mt8 c0, out b64v2_mt8 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b64_mt8 m00, out b64_mt8 m01,
        out b64_mt8 m10, out b64_mt8 m11
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
    }

    #endregion // Deconstruct

    #region Index

    public b64v2_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b64_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b64m2x2_mt8 operator~(b64m2x2_mt8 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static b64m2x2_mt8 operator|(b64m2x2_mt8 a, b64m2x2_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static b64m2x2_mt8 operator&(b64m2x2_mt8 a, b64m2x2_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static b64m2x2_mt8 operator^(b64m2x2_mt8 a, b64m2x2_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b64m2x2_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // b64m2x2_mt8

#region b64m2x2_mt16

[CpuOnly]
public partial struct b64m2x2_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b64_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 4; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 2); 
    }

    public static b64m2x2_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default,
            default, true
        ); 
    }

    #endregion

    #region Fields

    public b64v2_mt16 c0;
    public b64v2_mt16 c1;

    #endregion

    #region Properties

    public b64_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b64_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b64_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b64_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b64m2x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b64m2x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b64m2x2_mt16(b64v2_mt16 c0, b64v2_mt16 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public b64m2x2_mt16((b64v2_mt16 c0, b64v2_mt16 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x2_mt16((b64v2_mt16 c0, b64v2_mt16 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m2x2_mt16(
        b64_mt16 m00, b64_mt16 m01,
        b64_mt16 m10, b64_mt16 m11
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x2_mt16((
        b64_mt16 m00, b64_mt16 m01,
        b64_mt16 m10, b64_mt16 m11
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m2x2_mt16((
        b64_mt16 m00, b64_mt16 m01,
        b64_mt16 m10, b64_mt16 m11
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x2_mt16((
        (b64_mt16 m00, b64_mt16 m01) r0,
        (b64_mt16 m10, b64_mt16 m11) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m2x2_mt16((
        (b64_mt16 m00, b64_mt16 m01) r0,
        (b64_mt16 m10, b64_mt16 m11) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x2_mt16(b64_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x2_mt16(b64 value) => (b64_mt16)(value);

    [MethodImpl(256 | 512)]
    public b64m2x2_mt16(b64_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x2_mt16(b64v2_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x2_mt16(bool value) => (b64)(value);

    [MethodImpl(256 | 512)]
    public b64m2x2_mt16(b64v2_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b64v2_mt16 c0, out b64v2_mt16 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b64_mt16 m00, out b64_mt16 m01,
        out b64_mt16 m10, out b64_mt16 m11
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
    }

    #endregion // Deconstruct

    #region Index

    public b64v2_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b64_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b64m2x2_mt16 operator~(b64m2x2_mt16 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static b64m2x2_mt16 operator|(b64m2x2_mt16 a, b64m2x2_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static b64m2x2_mt16 operator&(b64m2x2_mt16 a, b64m2x2_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static b64m2x2_mt16 operator^(b64m2x2_mt16 a, b64m2x2_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b64m2x2_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // b64m2x2_mt16

#region b64m2x3_mt4

[CpuOnly]
public partial struct b64m2x3_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b64_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 3); 
    }

    public static b64m2x3_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default,
            default, true, default
        ); 
    }

    #endregion

    #region Fields

    public b64v2_mt4 c0;
    public b64v2_mt4 c1;
    public b64v2_mt4 c2;

    #endregion

    #region Properties

    public b64_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b64_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b64_mt4 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b64_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b64_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b64_mt4 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b64m2x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b64m2x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b64m2x3_mt4(b64v2_mt4 c0, b64v2_mt4 c1, b64v2_mt4 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public b64m2x3_mt4((b64v2_mt4 c0, b64v2_mt4 c1, b64v2_mt4 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x3_mt4((b64v2_mt4 c0, b64v2_mt4 c1, b64v2_mt4 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m2x3_mt4(
        b64_mt4 m00, b64_mt4 m01, b64_mt4 m02,
        b64_mt4 m10, b64_mt4 m11, b64_mt4 m12
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x3_mt4((
        b64_mt4 m00, b64_mt4 m01, b64_mt4 m02,
        b64_mt4 m10, b64_mt4 m11, b64_mt4 m12
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m2x3_mt4((
        b64_mt4 m00, b64_mt4 m01, b64_mt4 m02,
        b64_mt4 m10, b64_mt4 m11, b64_mt4 m12
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x3_mt4((
        (b64_mt4 m00, b64_mt4 m01, b64_mt4 m02) r0,
        (b64_mt4 m10, b64_mt4 m11, b64_mt4 m12) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m2x3_mt4((
        (b64_mt4 m00, b64_mt4 m01, b64_mt4 m02) r0,
        (b64_mt4 m10, b64_mt4 m11, b64_mt4 m12) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x3_mt4(b64_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x3_mt4(b64 value) => (b64_mt4)(value);

    [MethodImpl(256 | 512)]
    public b64m2x3_mt4(b64_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x3_mt4(b64v2_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x3_mt4(bool value) => (b64)(value);

    [MethodImpl(256 | 512)]
    public b64m2x3_mt4(b64v2_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b64v2_mt4 c0, out b64v2_mt4 c1, out b64v2_mt4 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b64_mt4 m00, out b64_mt4 m01, out b64_mt4 m02,
        out b64_mt4 m10, out b64_mt4 m11, out b64_mt4 m12
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
    }

    #endregion // Deconstruct

    #region Index

    public b64v2_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b64_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b64m2x3_mt4 operator~(b64m2x3_mt4 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static b64m2x3_mt4 operator|(b64m2x3_mt4 a, b64m2x3_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static b64m2x3_mt4 operator&(b64m2x3_mt4 a, b64m2x3_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static b64m2x3_mt4 operator^(b64m2x3_mt4 a, b64m2x3_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b64m2x3_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // b64m2x3_mt4

#region b64m2x3_mt8

[CpuOnly]
public partial struct b64m2x3_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b64_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 3); 
    }

    public static b64m2x3_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default,
            default, true, default
        ); 
    }

    #endregion

    #region Fields

    public b64v2_mt8 c0;
    public b64v2_mt8 c1;
    public b64v2_mt8 c2;

    #endregion

    #region Properties

    public b64_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b64_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b64_mt8 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b64_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b64_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b64_mt8 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b64m2x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b64m2x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b64m2x3_mt8(b64v2_mt8 c0, b64v2_mt8 c1, b64v2_mt8 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public b64m2x3_mt8((b64v2_mt8 c0, b64v2_mt8 c1, b64v2_mt8 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x3_mt8((b64v2_mt8 c0, b64v2_mt8 c1, b64v2_mt8 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m2x3_mt8(
        b64_mt8 m00, b64_mt8 m01, b64_mt8 m02,
        b64_mt8 m10, b64_mt8 m11, b64_mt8 m12
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x3_mt8((
        b64_mt8 m00, b64_mt8 m01, b64_mt8 m02,
        b64_mt8 m10, b64_mt8 m11, b64_mt8 m12
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m2x3_mt8((
        b64_mt8 m00, b64_mt8 m01, b64_mt8 m02,
        b64_mt8 m10, b64_mt8 m11, b64_mt8 m12
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x3_mt8((
        (b64_mt8 m00, b64_mt8 m01, b64_mt8 m02) r0,
        (b64_mt8 m10, b64_mt8 m11, b64_mt8 m12) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m2x3_mt8((
        (b64_mt8 m00, b64_mt8 m01, b64_mt8 m02) r0,
        (b64_mt8 m10, b64_mt8 m11, b64_mt8 m12) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x3_mt8(b64_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x3_mt8(b64 value) => (b64_mt8)(value);

    [MethodImpl(256 | 512)]
    public b64m2x3_mt8(b64_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x3_mt8(b64v2_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x3_mt8(bool value) => (b64)(value);

    [MethodImpl(256 | 512)]
    public b64m2x3_mt8(b64v2_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b64v2_mt8 c0, out b64v2_mt8 c1, out b64v2_mt8 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b64_mt8 m00, out b64_mt8 m01, out b64_mt8 m02,
        out b64_mt8 m10, out b64_mt8 m11, out b64_mt8 m12
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
    }

    #endregion // Deconstruct

    #region Index

    public b64v2_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b64_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b64m2x3_mt8 operator~(b64m2x3_mt8 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static b64m2x3_mt8 operator|(b64m2x3_mt8 a, b64m2x3_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static b64m2x3_mt8 operator&(b64m2x3_mt8 a, b64m2x3_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static b64m2x3_mt8 operator^(b64m2x3_mt8 a, b64m2x3_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b64m2x3_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // b64m2x3_mt8

#region b64m2x3_mt16

[CpuOnly]
public partial struct b64m2x3_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b64_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 3); 
    }

    public static b64m2x3_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default,
            default, true, default
        ); 
    }

    #endregion

    #region Fields

    public b64v2_mt16 c0;
    public b64v2_mt16 c1;
    public b64v2_mt16 c2;

    #endregion

    #region Properties

    public b64_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b64_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b64_mt16 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b64_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b64_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b64_mt16 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b64m2x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b64m2x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b64m2x3_mt16(b64v2_mt16 c0, b64v2_mt16 c1, b64v2_mt16 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public b64m2x3_mt16((b64v2_mt16 c0, b64v2_mt16 c1, b64v2_mt16 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x3_mt16((b64v2_mt16 c0, b64v2_mt16 c1, b64v2_mt16 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m2x3_mt16(
        b64_mt16 m00, b64_mt16 m01, b64_mt16 m02,
        b64_mt16 m10, b64_mt16 m11, b64_mt16 m12
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x3_mt16((
        b64_mt16 m00, b64_mt16 m01, b64_mt16 m02,
        b64_mt16 m10, b64_mt16 m11, b64_mt16 m12
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m2x3_mt16((
        b64_mt16 m00, b64_mt16 m01, b64_mt16 m02,
        b64_mt16 m10, b64_mt16 m11, b64_mt16 m12
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x3_mt16((
        (b64_mt16 m00, b64_mt16 m01, b64_mt16 m02) r0,
        (b64_mt16 m10, b64_mt16 m11, b64_mt16 m12) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m2x3_mt16((
        (b64_mt16 m00, b64_mt16 m01, b64_mt16 m02) r0,
        (b64_mt16 m10, b64_mt16 m11, b64_mt16 m12) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x3_mt16(b64_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x3_mt16(b64 value) => (b64_mt16)(value);

    [MethodImpl(256 | 512)]
    public b64m2x3_mt16(b64_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x3_mt16(b64v2_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x3_mt16(bool value) => (b64)(value);

    [MethodImpl(256 | 512)]
    public b64m2x3_mt16(b64v2_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b64v2_mt16 c0, out b64v2_mt16 c1, out b64v2_mt16 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b64_mt16 m00, out b64_mt16 m01, out b64_mt16 m02,
        out b64_mt16 m10, out b64_mt16 m11, out b64_mt16 m12
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
    }

    #endregion // Deconstruct

    #region Index

    public b64v2_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b64_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b64m2x3_mt16 operator~(b64m2x3_mt16 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static b64m2x3_mt16 operator|(b64m2x3_mt16 a, b64m2x3_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static b64m2x3_mt16 operator&(b64m2x3_mt16 a, b64m2x3_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static b64m2x3_mt16 operator^(b64m2x3_mt16 a, b64m2x3_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b64m2x3_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // b64m2x3_mt16

#region b64m2x4_mt4

[CpuOnly]
public partial struct b64m2x4_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b64_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 4); 
    }

    public static b64m2x4_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default, default,
            default, true, default, default
        ); 
    }

    #endregion

    #region Fields

    public b64v2_mt4 c0;
    public b64v2_mt4 c1;
    public b64v2_mt4 c2;
    public b64v2_mt4 c3;

    #endregion

    #region Properties

    public b64_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b64_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b64_mt4 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b64_mt4 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public b64_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b64_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b64_mt4 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b64_mt4 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b64m2x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b64m2x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b64m2x4_mt4(b64v2_mt4 c0, b64v2_mt4 c1, b64v2_mt4 c2, b64v2_mt4 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public b64m2x4_mt4((b64v2_mt4 c0, b64v2_mt4 c1, b64v2_mt4 c2, b64v2_mt4 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x4_mt4((b64v2_mt4 c0, b64v2_mt4 c1, b64v2_mt4 c2, b64v2_mt4 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m2x4_mt4(
        b64_mt4 m00, b64_mt4 m01, b64_mt4 m02, b64_mt4 m03,
        b64_mt4 m10, b64_mt4 m11, b64_mt4 m12, b64_mt4 m13
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
        this.c3 = new(m03, m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x4_mt4((
        b64_mt4 m00, b64_mt4 m01, b64_mt4 m02, b64_mt4 m03,
        b64_mt4 m10, b64_mt4 m11, b64_mt4 m12, b64_mt4 m13
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m2x4_mt4((
        b64_mt4 m00, b64_mt4 m01, b64_mt4 m02, b64_mt4 m03,
        b64_mt4 m10, b64_mt4 m11, b64_mt4 m12, b64_mt4 m13
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
        this.c3 = new(tuple.m03, tuple.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x4_mt4((
        (b64_mt4 m00, b64_mt4 m01, b64_mt4 m02, b64_mt4 m03) r0,
        (b64_mt4 m10, b64_mt4 m11, b64_mt4 m12, b64_mt4 m13) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m2x4_mt4((
        (b64_mt4 m00, b64_mt4 m01, b64_mt4 m02, b64_mt4 m03) r0,
        (b64_mt4 m10, b64_mt4 m11, b64_mt4 m12, b64_mt4 m13) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x4_mt4(b64_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x4_mt4(b64 value) => (b64_mt4)(value);

    [MethodImpl(256 | 512)]
    public b64m2x4_mt4(b64_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x4_mt4(b64v2_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x4_mt4(bool value) => (b64)(value);

    [MethodImpl(256 | 512)]
    public b64m2x4_mt4(b64v2_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b64v2_mt4 c0, out b64v2_mt4 c1, out b64v2_mt4 c2, out b64v2_mt4 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b64_mt4 m00, out b64_mt4 m01, out b64_mt4 m02, out b64_mt4 m03,
        out b64_mt4 m10, out b64_mt4 m11, out b64_mt4 m12, out b64_mt4 m13
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
        this.c3.Deconstruct(out m03, out m13);
    }

    #endregion // Deconstruct

    #region Index

    public b64v2_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b64_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b64m2x4_mt4 operator~(b64m2x4_mt4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static b64m2x4_mt4 operator|(b64m2x4_mt4 a, b64m2x4_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static b64m2x4_mt4 operator&(b64m2x4_mt4 a, b64m2x4_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static b64m2x4_mt4 operator^(b64m2x4_mt4 a, b64m2x4_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b64m2x4_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // b64m2x4_mt4

#region b64m2x4_mt8

[CpuOnly]
public partial struct b64m2x4_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b64_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 4); 
    }

    public static b64m2x4_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default, default,
            default, true, default, default
        ); 
    }

    #endregion

    #region Fields

    public b64v2_mt8 c0;
    public b64v2_mt8 c1;
    public b64v2_mt8 c2;
    public b64v2_mt8 c3;

    #endregion

    #region Properties

    public b64_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b64_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b64_mt8 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b64_mt8 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public b64_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b64_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b64_mt8 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b64_mt8 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b64m2x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b64m2x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b64m2x4_mt8(b64v2_mt8 c0, b64v2_mt8 c1, b64v2_mt8 c2, b64v2_mt8 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public b64m2x4_mt8((b64v2_mt8 c0, b64v2_mt8 c1, b64v2_mt8 c2, b64v2_mt8 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x4_mt8((b64v2_mt8 c0, b64v2_mt8 c1, b64v2_mt8 c2, b64v2_mt8 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m2x4_mt8(
        b64_mt8 m00, b64_mt8 m01, b64_mt8 m02, b64_mt8 m03,
        b64_mt8 m10, b64_mt8 m11, b64_mt8 m12, b64_mt8 m13
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
        this.c3 = new(m03, m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x4_mt8((
        b64_mt8 m00, b64_mt8 m01, b64_mt8 m02, b64_mt8 m03,
        b64_mt8 m10, b64_mt8 m11, b64_mt8 m12, b64_mt8 m13
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m2x4_mt8((
        b64_mt8 m00, b64_mt8 m01, b64_mt8 m02, b64_mt8 m03,
        b64_mt8 m10, b64_mt8 m11, b64_mt8 m12, b64_mt8 m13
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
        this.c3 = new(tuple.m03, tuple.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x4_mt8((
        (b64_mt8 m00, b64_mt8 m01, b64_mt8 m02, b64_mt8 m03) r0,
        (b64_mt8 m10, b64_mt8 m11, b64_mt8 m12, b64_mt8 m13) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m2x4_mt8((
        (b64_mt8 m00, b64_mt8 m01, b64_mt8 m02, b64_mt8 m03) r0,
        (b64_mt8 m10, b64_mt8 m11, b64_mt8 m12, b64_mt8 m13) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x4_mt8(b64_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x4_mt8(b64 value) => (b64_mt8)(value);

    [MethodImpl(256 | 512)]
    public b64m2x4_mt8(b64_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x4_mt8(b64v2_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x4_mt8(bool value) => (b64)(value);

    [MethodImpl(256 | 512)]
    public b64m2x4_mt8(b64v2_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b64v2_mt8 c0, out b64v2_mt8 c1, out b64v2_mt8 c2, out b64v2_mt8 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b64_mt8 m00, out b64_mt8 m01, out b64_mt8 m02, out b64_mt8 m03,
        out b64_mt8 m10, out b64_mt8 m11, out b64_mt8 m12, out b64_mt8 m13
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
        this.c3.Deconstruct(out m03, out m13);
    }

    #endregion // Deconstruct

    #region Index

    public b64v2_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b64_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b64m2x4_mt8 operator~(b64m2x4_mt8 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static b64m2x4_mt8 operator|(b64m2x4_mt8 a, b64m2x4_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static b64m2x4_mt8 operator&(b64m2x4_mt8 a, b64m2x4_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static b64m2x4_mt8 operator^(b64m2x4_mt8 a, b64m2x4_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b64m2x4_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // b64m2x4_mt8

#region b64m2x4_mt16

[CpuOnly]
public partial struct b64m2x4_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b64_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(2, 4); 
    }

    public static b64m2x4_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default, default,
            default, true, default, default
        ); 
    }

    #endregion

    #region Fields

    public b64v2_mt16 c0;
    public b64v2_mt16 c1;
    public b64v2_mt16 c2;
    public b64v2_mt16 c3;

    #endregion

    #region Properties

    public b64_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b64_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b64_mt16 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b64_mt16 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public b64_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b64_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b64_mt16 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b64_mt16 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b64m2x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b64m2x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b64m2x4_mt16(b64v2_mt16 c0, b64v2_mt16 c1, b64v2_mt16 c2, b64v2_mt16 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public b64m2x4_mt16((b64v2_mt16 c0, b64v2_mt16 c1, b64v2_mt16 c2, b64v2_mt16 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x4_mt16((b64v2_mt16 c0, b64v2_mt16 c1, b64v2_mt16 c2, b64v2_mt16 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m2x4_mt16(
        b64_mt16 m00, b64_mt16 m01, b64_mt16 m02, b64_mt16 m03,
        b64_mt16 m10, b64_mt16 m11, b64_mt16 m12, b64_mt16 m13
    )
    {
        this.c0 = new(m00, m10);
        this.c1 = new(m01, m11);
        this.c2 = new(m02, m12);
        this.c3 = new(m03, m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x4_mt16((
        b64_mt16 m00, b64_mt16 m01, b64_mt16 m02, b64_mt16 m03,
        b64_mt16 m10, b64_mt16 m11, b64_mt16 m12, b64_mt16 m13
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m2x4_mt16((
        b64_mt16 m00, b64_mt16 m01, b64_mt16 m02, b64_mt16 m03,
        b64_mt16 m10, b64_mt16 m11, b64_mt16 m12, b64_mt16 m13
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10);
        this.c1 = new(tuple.m01, tuple.m11);
        this.c2 = new(tuple.m02, tuple.m12);
        this.c3 = new(tuple.m03, tuple.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x4_mt16((
        (b64_mt16 m00, b64_mt16 m01, b64_mt16 m02, b64_mt16 m03) r0,
        (b64_mt16 m10, b64_mt16 m11, b64_mt16 m12, b64_mt16 m13) r1
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m2x4_mt16((
        (b64_mt16 m00, b64_mt16 m01, b64_mt16 m02, b64_mt16 m03) r0,
        (b64_mt16 m10, b64_mt16 m11, b64_mt16 m12, b64_mt16 m13) r1
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x4_mt16(b64_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x4_mt16(b64 value) => (b64_mt16)(value);

    [MethodImpl(256 | 512)]
    public b64m2x4_mt16(b64_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x4_mt16(b64v2_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m2x4_mt16(bool value) => (b64)(value);

    [MethodImpl(256 | 512)]
    public b64m2x4_mt16(b64v2_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b64v2_mt16 c0, out b64v2_mt16 c1, out b64v2_mt16 c2, out b64v2_mt16 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b64_mt16 m00, out b64_mt16 m01, out b64_mt16 m02, out b64_mt16 m03,
        out b64_mt16 m10, out b64_mt16 m11, out b64_mt16 m12, out b64_mt16 m13
    )
    {
        this.c0.Deconstruct(out m00, out m10);
        this.c1.Deconstruct(out m01, out m11);
        this.c2.Deconstruct(out m02, out m12);
        this.c3.Deconstruct(out m03, out m13);
    }

    #endregion // Deconstruct

    #region Index

    public b64v2_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b64_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b64m2x4_mt16 operator~(b64m2x4_mt16 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static b64m2x4_mt16 operator|(b64m2x4_mt16 a, b64m2x4_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static b64m2x4_mt16 operator&(b64m2x4_mt16 a, b64m2x4_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static b64m2x4_mt16 operator^(b64m2x4_mt16 a, b64m2x4_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b64m2x4_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // b64m2x4_mt16

#region b64m3x2_mt4

[CpuOnly]
public partial struct b64m3x2_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b64_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 2); 
    }

    public static b64m3x2_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default,
            default, true,
            default, default
        ); 
    }

    #endregion

    #region Fields

    public b64v3_mt4 c0;
    public b64v3_mt4 c1;

    #endregion

    #region Properties

    public b64_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b64_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b64_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b64_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b64_mt4 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b64_mt4 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b64m3x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b64m3x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b64m3x2_mt4(b64v3_mt4 c0, b64v3_mt4 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public b64m3x2_mt4((b64v3_mt4 c0, b64v3_mt4 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x2_mt4((b64v3_mt4 c0, b64v3_mt4 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m3x2_mt4(
        b64_mt4 m00, b64_mt4 m01,
        b64_mt4 m10, b64_mt4 m11,
        b64_mt4 m20, b64_mt4 m21
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x2_mt4((
        b64_mt4 m00, b64_mt4 m01,
        b64_mt4 m10, b64_mt4 m11,
        b64_mt4 m20, b64_mt4 m21
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m3x2_mt4((
        b64_mt4 m00, b64_mt4 m01,
        b64_mt4 m10, b64_mt4 m11,
        b64_mt4 m20, b64_mt4 m21
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x2_mt4((
        (b64_mt4 m00, b64_mt4 m01) r0,
        (b64_mt4 m10, b64_mt4 m11) r1,
        (b64_mt4 m20, b64_mt4 m21) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m3x2_mt4((
        (b64_mt4 m00, b64_mt4 m01) r0,
        (b64_mt4 m10, b64_mt4 m11) r1,
        (b64_mt4 m20, b64_mt4 m21) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x2_mt4(b64_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x2_mt4(b64 value) => (b64_mt4)(value);

    [MethodImpl(256 | 512)]
    public b64m3x2_mt4(b64_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x2_mt4(b64v3_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x2_mt4(bool value) => (b64)(value);

    [MethodImpl(256 | 512)]
    public b64m3x2_mt4(b64v3_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b64v3_mt4 c0, out b64v3_mt4 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b64_mt4 m00, out b64_mt4 m01,
        out b64_mt4 m10, out b64_mt4 m11,
        out b64_mt4 m20, out b64_mt4 m21
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
    }

    #endregion // Deconstruct

    #region Index

    public b64v3_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b64_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b64m3x2_mt4 operator~(b64m3x2_mt4 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static b64m3x2_mt4 operator|(b64m3x2_mt4 a, b64m3x2_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static b64m3x2_mt4 operator&(b64m3x2_mt4 a, b64m3x2_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static b64m3x2_mt4 operator^(b64m3x2_mt4 a, b64m3x2_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b64m3x2_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // b64m3x2_mt4

#region b64m3x2_mt8

[CpuOnly]
public partial struct b64m3x2_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b64_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 2); 
    }

    public static b64m3x2_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default,
            default, true,
            default, default
        ); 
    }

    #endregion

    #region Fields

    public b64v3_mt8 c0;
    public b64v3_mt8 c1;

    #endregion

    #region Properties

    public b64_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b64_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b64_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b64_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b64_mt8 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b64_mt8 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b64m3x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b64m3x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b64m3x2_mt8(b64v3_mt8 c0, b64v3_mt8 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public b64m3x2_mt8((b64v3_mt8 c0, b64v3_mt8 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x2_mt8((b64v3_mt8 c0, b64v3_mt8 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m3x2_mt8(
        b64_mt8 m00, b64_mt8 m01,
        b64_mt8 m10, b64_mt8 m11,
        b64_mt8 m20, b64_mt8 m21
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x2_mt8((
        b64_mt8 m00, b64_mt8 m01,
        b64_mt8 m10, b64_mt8 m11,
        b64_mt8 m20, b64_mt8 m21
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m3x2_mt8((
        b64_mt8 m00, b64_mt8 m01,
        b64_mt8 m10, b64_mt8 m11,
        b64_mt8 m20, b64_mt8 m21
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x2_mt8((
        (b64_mt8 m00, b64_mt8 m01) r0,
        (b64_mt8 m10, b64_mt8 m11) r1,
        (b64_mt8 m20, b64_mt8 m21) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m3x2_mt8((
        (b64_mt8 m00, b64_mt8 m01) r0,
        (b64_mt8 m10, b64_mt8 m11) r1,
        (b64_mt8 m20, b64_mt8 m21) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x2_mt8(b64_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x2_mt8(b64 value) => (b64_mt8)(value);

    [MethodImpl(256 | 512)]
    public b64m3x2_mt8(b64_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x2_mt8(b64v3_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x2_mt8(bool value) => (b64)(value);

    [MethodImpl(256 | 512)]
    public b64m3x2_mt8(b64v3_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b64v3_mt8 c0, out b64v3_mt8 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b64_mt8 m00, out b64_mt8 m01,
        out b64_mt8 m10, out b64_mt8 m11,
        out b64_mt8 m20, out b64_mt8 m21
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
    }

    #endregion // Deconstruct

    #region Index

    public b64v3_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b64_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b64m3x2_mt8 operator~(b64m3x2_mt8 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static b64m3x2_mt8 operator|(b64m3x2_mt8 a, b64m3x2_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static b64m3x2_mt8 operator&(b64m3x2_mt8 a, b64m3x2_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static b64m3x2_mt8 operator^(b64m3x2_mt8 a, b64m3x2_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b64m3x2_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // b64m3x2_mt8

#region b64m3x2_mt16

[CpuOnly]
public partial struct b64m3x2_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b64_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 6; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 2); 
    }

    public static b64m3x2_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default,
            default, true,
            default, default
        ); 
    }

    #endregion

    #region Fields

    public b64v3_mt16 c0;
    public b64v3_mt16 c1;

    #endregion

    #region Properties

    public b64_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b64_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b64_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b64_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b64_mt16 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b64_mt16 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b64m3x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b64m3x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b64m3x2_mt16(b64v3_mt16 c0, b64v3_mt16 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public b64m3x2_mt16((b64v3_mt16 c0, b64v3_mt16 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x2_mt16((b64v3_mt16 c0, b64v3_mt16 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m3x2_mt16(
        b64_mt16 m00, b64_mt16 m01,
        b64_mt16 m10, b64_mt16 m11,
        b64_mt16 m20, b64_mt16 m21
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x2_mt16((
        b64_mt16 m00, b64_mt16 m01,
        b64_mt16 m10, b64_mt16 m11,
        b64_mt16 m20, b64_mt16 m21
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m3x2_mt16((
        b64_mt16 m00, b64_mt16 m01,
        b64_mt16 m10, b64_mt16 m11,
        b64_mt16 m20, b64_mt16 m21
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x2_mt16((
        (b64_mt16 m00, b64_mt16 m01) r0,
        (b64_mt16 m10, b64_mt16 m11) r1,
        (b64_mt16 m20, b64_mt16 m21) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m3x2_mt16((
        (b64_mt16 m00, b64_mt16 m01) r0,
        (b64_mt16 m10, b64_mt16 m11) r1,
        (b64_mt16 m20, b64_mt16 m21) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x2_mt16(b64_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x2_mt16(b64 value) => (b64_mt16)(value);

    [MethodImpl(256 | 512)]
    public b64m3x2_mt16(b64_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x2_mt16(b64v3_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x2_mt16(bool value) => (b64)(value);

    [MethodImpl(256 | 512)]
    public b64m3x2_mt16(b64v3_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b64v3_mt16 c0, out b64v3_mt16 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b64_mt16 m00, out b64_mt16 m01,
        out b64_mt16 m10, out b64_mt16 m11,
        out b64_mt16 m20, out b64_mt16 m21
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
    }

    #endregion // Deconstruct

    #region Index

    public b64v3_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b64_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b64m3x2_mt16 operator~(b64m3x2_mt16 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static b64m3x2_mt16 operator|(b64m3x2_mt16 a, b64m3x2_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static b64m3x2_mt16 operator&(b64m3x2_mt16 a, b64m3x2_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static b64m3x2_mt16 operator^(b64m3x2_mt16 a, b64m3x2_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b64m3x2_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // b64m3x2_mt16

#region b64m3x3_mt4

[CpuOnly]
public partial struct b64m3x3_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b64_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 9; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 3); 
    }

    public static b64m3x3_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default,
            default, true, default,
            default, default, true
        ); 
    }

    #endregion

    #region Fields

    public b64v3_mt4 c0;
    public b64v3_mt4 c1;
    public b64v3_mt4 c2;

    #endregion

    #region Properties

    public b64_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b64_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b64_mt4 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b64_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b64_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b64_mt4 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b64_mt4 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b64_mt4 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b64_mt4 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b64m3x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b64m3x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b64m3x3_mt4(b64v3_mt4 c0, b64v3_mt4 c1, b64v3_mt4 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public b64m3x3_mt4((b64v3_mt4 c0, b64v3_mt4 c1, b64v3_mt4 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x3_mt4((b64v3_mt4 c0, b64v3_mt4 c1, b64v3_mt4 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m3x3_mt4(
        b64_mt4 m00, b64_mt4 m01, b64_mt4 m02,
        b64_mt4 m10, b64_mt4 m11, b64_mt4 m12,
        b64_mt4 m20, b64_mt4 m21, b64_mt4 m22
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x3_mt4((
        b64_mt4 m00, b64_mt4 m01, b64_mt4 m02,
        b64_mt4 m10, b64_mt4 m11, b64_mt4 m12,
        b64_mt4 m20, b64_mt4 m21, b64_mt4 m22
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m3x3_mt4((
        b64_mt4 m00, b64_mt4 m01, b64_mt4 m02,
        b64_mt4 m10, b64_mt4 m11, b64_mt4 m12,
        b64_mt4 m20, b64_mt4 m21, b64_mt4 m22
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x3_mt4((
        (b64_mt4 m00, b64_mt4 m01, b64_mt4 m02) r0,
        (b64_mt4 m10, b64_mt4 m11, b64_mt4 m12) r1,
        (b64_mt4 m20, b64_mt4 m21, b64_mt4 m22) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m3x3_mt4((
        (b64_mt4 m00, b64_mt4 m01, b64_mt4 m02) r0,
        (b64_mt4 m10, b64_mt4 m11, b64_mt4 m12) r1,
        (b64_mt4 m20, b64_mt4 m21, b64_mt4 m22) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x3_mt4(b64_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x3_mt4(b64 value) => (b64_mt4)(value);

    [MethodImpl(256 | 512)]
    public b64m3x3_mt4(b64_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x3_mt4(b64v3_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x3_mt4(bool value) => (b64)(value);

    [MethodImpl(256 | 512)]
    public b64m3x3_mt4(b64v3_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b64v3_mt4 c0, out b64v3_mt4 c1, out b64v3_mt4 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b64_mt4 m00, out b64_mt4 m01, out b64_mt4 m02,
        out b64_mt4 m10, out b64_mt4 m11, out b64_mt4 m12,
        out b64_mt4 m20, out b64_mt4 m21, out b64_mt4 m22
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
    }

    #endregion // Deconstruct

    #region Index

    public b64v3_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b64_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b64m3x3_mt4 operator~(b64m3x3_mt4 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static b64m3x3_mt4 operator|(b64m3x3_mt4 a, b64m3x3_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static b64m3x3_mt4 operator&(b64m3x3_mt4 a, b64m3x3_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static b64m3x3_mt4 operator^(b64m3x3_mt4 a, b64m3x3_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b64m3x3_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // b64m3x3_mt4

#region b64m3x3_mt8

[CpuOnly]
public partial struct b64m3x3_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b64_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 9; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 3); 
    }

    public static b64m3x3_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default,
            default, true, default,
            default, default, true
        ); 
    }

    #endregion

    #region Fields

    public b64v3_mt8 c0;
    public b64v3_mt8 c1;
    public b64v3_mt8 c2;

    #endregion

    #region Properties

    public b64_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b64_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b64_mt8 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b64_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b64_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b64_mt8 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b64_mt8 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b64_mt8 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b64_mt8 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b64m3x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b64m3x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b64m3x3_mt8(b64v3_mt8 c0, b64v3_mt8 c1, b64v3_mt8 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public b64m3x3_mt8((b64v3_mt8 c0, b64v3_mt8 c1, b64v3_mt8 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x3_mt8((b64v3_mt8 c0, b64v3_mt8 c1, b64v3_mt8 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m3x3_mt8(
        b64_mt8 m00, b64_mt8 m01, b64_mt8 m02,
        b64_mt8 m10, b64_mt8 m11, b64_mt8 m12,
        b64_mt8 m20, b64_mt8 m21, b64_mt8 m22
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x3_mt8((
        b64_mt8 m00, b64_mt8 m01, b64_mt8 m02,
        b64_mt8 m10, b64_mt8 m11, b64_mt8 m12,
        b64_mt8 m20, b64_mt8 m21, b64_mt8 m22
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m3x3_mt8((
        b64_mt8 m00, b64_mt8 m01, b64_mt8 m02,
        b64_mt8 m10, b64_mt8 m11, b64_mt8 m12,
        b64_mt8 m20, b64_mt8 m21, b64_mt8 m22
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x3_mt8((
        (b64_mt8 m00, b64_mt8 m01, b64_mt8 m02) r0,
        (b64_mt8 m10, b64_mt8 m11, b64_mt8 m12) r1,
        (b64_mt8 m20, b64_mt8 m21, b64_mt8 m22) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m3x3_mt8((
        (b64_mt8 m00, b64_mt8 m01, b64_mt8 m02) r0,
        (b64_mt8 m10, b64_mt8 m11, b64_mt8 m12) r1,
        (b64_mt8 m20, b64_mt8 m21, b64_mt8 m22) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x3_mt8(b64_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x3_mt8(b64 value) => (b64_mt8)(value);

    [MethodImpl(256 | 512)]
    public b64m3x3_mt8(b64_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x3_mt8(b64v3_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x3_mt8(bool value) => (b64)(value);

    [MethodImpl(256 | 512)]
    public b64m3x3_mt8(b64v3_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b64v3_mt8 c0, out b64v3_mt8 c1, out b64v3_mt8 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b64_mt8 m00, out b64_mt8 m01, out b64_mt8 m02,
        out b64_mt8 m10, out b64_mt8 m11, out b64_mt8 m12,
        out b64_mt8 m20, out b64_mt8 m21, out b64_mt8 m22
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
    }

    #endregion // Deconstruct

    #region Index

    public b64v3_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b64_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b64m3x3_mt8 operator~(b64m3x3_mt8 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static b64m3x3_mt8 operator|(b64m3x3_mt8 a, b64m3x3_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static b64m3x3_mt8 operator&(b64m3x3_mt8 a, b64m3x3_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static b64m3x3_mt8 operator^(b64m3x3_mt8 a, b64m3x3_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b64m3x3_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // b64m3x3_mt8

#region b64m3x3_mt16

[CpuOnly]
public partial struct b64m3x3_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b64_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 9; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 3); 
    }

    public static b64m3x3_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default,
            default, true, default,
            default, default, true
        ); 
    }

    #endregion

    #region Fields

    public b64v3_mt16 c0;
    public b64v3_mt16 c1;
    public b64v3_mt16 c2;

    #endregion

    #region Properties

    public b64_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b64_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b64_mt16 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b64_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b64_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b64_mt16 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b64_mt16 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b64_mt16 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b64_mt16 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b64m3x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b64m3x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b64m3x3_mt16(b64v3_mt16 c0, b64v3_mt16 c1, b64v3_mt16 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public b64m3x3_mt16((b64v3_mt16 c0, b64v3_mt16 c1, b64v3_mt16 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x3_mt16((b64v3_mt16 c0, b64v3_mt16 c1, b64v3_mt16 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m3x3_mt16(
        b64_mt16 m00, b64_mt16 m01, b64_mt16 m02,
        b64_mt16 m10, b64_mt16 m11, b64_mt16 m12,
        b64_mt16 m20, b64_mt16 m21, b64_mt16 m22
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x3_mt16((
        b64_mt16 m00, b64_mt16 m01, b64_mt16 m02,
        b64_mt16 m10, b64_mt16 m11, b64_mt16 m12,
        b64_mt16 m20, b64_mt16 m21, b64_mt16 m22
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m3x3_mt16((
        b64_mt16 m00, b64_mt16 m01, b64_mt16 m02,
        b64_mt16 m10, b64_mt16 m11, b64_mt16 m12,
        b64_mt16 m20, b64_mt16 m21, b64_mt16 m22
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x3_mt16((
        (b64_mt16 m00, b64_mt16 m01, b64_mt16 m02) r0,
        (b64_mt16 m10, b64_mt16 m11, b64_mt16 m12) r1,
        (b64_mt16 m20, b64_mt16 m21, b64_mt16 m22) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m3x3_mt16((
        (b64_mt16 m00, b64_mt16 m01, b64_mt16 m02) r0,
        (b64_mt16 m10, b64_mt16 m11, b64_mt16 m12) r1,
        (b64_mt16 m20, b64_mt16 m21, b64_mt16 m22) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x3_mt16(b64_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x3_mt16(b64 value) => (b64_mt16)(value);

    [MethodImpl(256 | 512)]
    public b64m3x3_mt16(b64_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x3_mt16(b64v3_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x3_mt16(bool value) => (b64)(value);

    [MethodImpl(256 | 512)]
    public b64m3x3_mt16(b64v3_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b64v3_mt16 c0, out b64v3_mt16 c1, out b64v3_mt16 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b64_mt16 m00, out b64_mt16 m01, out b64_mt16 m02,
        out b64_mt16 m10, out b64_mt16 m11, out b64_mt16 m12,
        out b64_mt16 m20, out b64_mt16 m21, out b64_mt16 m22
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
    }

    #endregion // Deconstruct

    #region Index

    public b64v3_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b64_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b64m3x3_mt16 operator~(b64m3x3_mt16 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static b64m3x3_mt16 operator|(b64m3x3_mt16 a, b64m3x3_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static b64m3x3_mt16 operator&(b64m3x3_mt16 a, b64m3x3_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static b64m3x3_mt16 operator^(b64m3x3_mt16 a, b64m3x3_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b64m3x3_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // b64m3x3_mt16

#region b64m3x4_mt4

[CpuOnly]
public partial struct b64m3x4_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b64_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 4); 
    }

    public static b64m3x4_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default, default,
            default, true, default, default,
            default, default, true, default
        ); 
    }

    #endregion

    #region Fields

    public b64v3_mt4 c0;
    public b64v3_mt4 c1;
    public b64v3_mt4 c2;
    public b64v3_mt4 c3;

    #endregion

    #region Properties

    public b64_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b64_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b64_mt4 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b64_mt4 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public b64_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b64_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b64_mt4 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b64_mt4 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public b64_mt4 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b64_mt4 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b64_mt4 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public b64_mt4 m23
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b64m3x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b64m3x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b64m3x4_mt4(b64v3_mt4 c0, b64v3_mt4 c1, b64v3_mt4 c2, b64v3_mt4 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public b64m3x4_mt4((b64v3_mt4 c0, b64v3_mt4 c1, b64v3_mt4 c2, b64v3_mt4 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x4_mt4((b64v3_mt4 c0, b64v3_mt4 c1, b64v3_mt4 c2, b64v3_mt4 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m3x4_mt4(
        b64_mt4 m00, b64_mt4 m01, b64_mt4 m02, b64_mt4 m03,
        b64_mt4 m10, b64_mt4 m11, b64_mt4 m12, b64_mt4 m13,
        b64_mt4 m20, b64_mt4 m21, b64_mt4 m22, b64_mt4 m23
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
        this.c3 = new(m03, m13, m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x4_mt4((
        b64_mt4 m00, b64_mt4 m01, b64_mt4 m02, b64_mt4 m03,
        b64_mt4 m10, b64_mt4 m11, b64_mt4 m12, b64_mt4 m13,
        b64_mt4 m20, b64_mt4 m21, b64_mt4 m22, b64_mt4 m23
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m3x4_mt4((
        b64_mt4 m00, b64_mt4 m01, b64_mt4 m02, b64_mt4 m03,
        b64_mt4 m10, b64_mt4 m11, b64_mt4 m12, b64_mt4 m13,
        b64_mt4 m20, b64_mt4 m21, b64_mt4 m22, b64_mt4 m23
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x4_mt4((
        (b64_mt4 m00, b64_mt4 m01, b64_mt4 m02, b64_mt4 m03) r0,
        (b64_mt4 m10, b64_mt4 m11, b64_mt4 m12, b64_mt4 m13) r1,
        (b64_mt4 m20, b64_mt4 m21, b64_mt4 m22, b64_mt4 m23) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m3x4_mt4((
        (b64_mt4 m00, b64_mt4 m01, b64_mt4 m02, b64_mt4 m03) r0,
        (b64_mt4 m10, b64_mt4 m11, b64_mt4 m12, b64_mt4 m13) r1,
        (b64_mt4 m20, b64_mt4 m21, b64_mt4 m22, b64_mt4 m23) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x4_mt4(b64_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x4_mt4(b64 value) => (b64_mt4)(value);

    [MethodImpl(256 | 512)]
    public b64m3x4_mt4(b64_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x4_mt4(b64v3_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x4_mt4(bool value) => (b64)(value);

    [MethodImpl(256 | 512)]
    public b64m3x4_mt4(b64v3_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b64v3_mt4 c0, out b64v3_mt4 c1, out b64v3_mt4 c2, out b64v3_mt4 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b64_mt4 m00, out b64_mt4 m01, out b64_mt4 m02, out b64_mt4 m03,
        out b64_mt4 m10, out b64_mt4 m11, out b64_mt4 m12, out b64_mt4 m13,
        out b64_mt4 m20, out b64_mt4 m21, out b64_mt4 m22, out b64_mt4 m23
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
        this.c3.Deconstruct(out m03, out m13, out m23);
    }

    #endregion // Deconstruct

    #region Index

    public b64v3_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b64_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b64m3x4_mt4 operator~(b64m3x4_mt4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static b64m3x4_mt4 operator|(b64m3x4_mt4 a, b64m3x4_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static b64m3x4_mt4 operator&(b64m3x4_mt4 a, b64m3x4_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static b64m3x4_mt4 operator^(b64m3x4_mt4 a, b64m3x4_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b64m3x4_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // b64m3x4_mt4

#region b64m3x4_mt8

[CpuOnly]
public partial struct b64m3x4_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b64_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 4); 
    }

    public static b64m3x4_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default, default,
            default, true, default, default,
            default, default, true, default
        ); 
    }

    #endregion

    #region Fields

    public b64v3_mt8 c0;
    public b64v3_mt8 c1;
    public b64v3_mt8 c2;
    public b64v3_mt8 c3;

    #endregion

    #region Properties

    public b64_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b64_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b64_mt8 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b64_mt8 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public b64_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b64_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b64_mt8 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b64_mt8 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public b64_mt8 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b64_mt8 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b64_mt8 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public b64_mt8 m23
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b64m3x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b64m3x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b64m3x4_mt8(b64v3_mt8 c0, b64v3_mt8 c1, b64v3_mt8 c2, b64v3_mt8 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public b64m3x4_mt8((b64v3_mt8 c0, b64v3_mt8 c1, b64v3_mt8 c2, b64v3_mt8 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x4_mt8((b64v3_mt8 c0, b64v3_mt8 c1, b64v3_mt8 c2, b64v3_mt8 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m3x4_mt8(
        b64_mt8 m00, b64_mt8 m01, b64_mt8 m02, b64_mt8 m03,
        b64_mt8 m10, b64_mt8 m11, b64_mt8 m12, b64_mt8 m13,
        b64_mt8 m20, b64_mt8 m21, b64_mt8 m22, b64_mt8 m23
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
        this.c3 = new(m03, m13, m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x4_mt8((
        b64_mt8 m00, b64_mt8 m01, b64_mt8 m02, b64_mt8 m03,
        b64_mt8 m10, b64_mt8 m11, b64_mt8 m12, b64_mt8 m13,
        b64_mt8 m20, b64_mt8 m21, b64_mt8 m22, b64_mt8 m23
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m3x4_mt8((
        b64_mt8 m00, b64_mt8 m01, b64_mt8 m02, b64_mt8 m03,
        b64_mt8 m10, b64_mt8 m11, b64_mt8 m12, b64_mt8 m13,
        b64_mt8 m20, b64_mt8 m21, b64_mt8 m22, b64_mt8 m23
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x4_mt8((
        (b64_mt8 m00, b64_mt8 m01, b64_mt8 m02, b64_mt8 m03) r0,
        (b64_mt8 m10, b64_mt8 m11, b64_mt8 m12, b64_mt8 m13) r1,
        (b64_mt8 m20, b64_mt8 m21, b64_mt8 m22, b64_mt8 m23) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m3x4_mt8((
        (b64_mt8 m00, b64_mt8 m01, b64_mt8 m02, b64_mt8 m03) r0,
        (b64_mt8 m10, b64_mt8 m11, b64_mt8 m12, b64_mt8 m13) r1,
        (b64_mt8 m20, b64_mt8 m21, b64_mt8 m22, b64_mt8 m23) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x4_mt8(b64_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x4_mt8(b64 value) => (b64_mt8)(value);

    [MethodImpl(256 | 512)]
    public b64m3x4_mt8(b64_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x4_mt8(b64v3_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x4_mt8(bool value) => (b64)(value);

    [MethodImpl(256 | 512)]
    public b64m3x4_mt8(b64v3_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b64v3_mt8 c0, out b64v3_mt8 c1, out b64v3_mt8 c2, out b64v3_mt8 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b64_mt8 m00, out b64_mt8 m01, out b64_mt8 m02, out b64_mt8 m03,
        out b64_mt8 m10, out b64_mt8 m11, out b64_mt8 m12, out b64_mt8 m13,
        out b64_mt8 m20, out b64_mt8 m21, out b64_mt8 m22, out b64_mt8 m23
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
        this.c3.Deconstruct(out m03, out m13, out m23);
    }

    #endregion // Deconstruct

    #region Index

    public b64v3_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b64_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b64m3x4_mt8 operator~(b64m3x4_mt8 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static b64m3x4_mt8 operator|(b64m3x4_mt8 a, b64m3x4_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static b64m3x4_mt8 operator&(b64m3x4_mt8 a, b64m3x4_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static b64m3x4_mt8 operator^(b64m3x4_mt8 a, b64m3x4_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b64m3x4_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // b64m3x4_mt8

#region b64m3x4_mt16

[CpuOnly]
public partial struct b64m3x4_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b64_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(3, 4); 
    }

    public static b64m3x4_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default, default,
            default, true, default, default,
            default, default, true, default
        ); 
    }

    #endregion

    #region Fields

    public b64v3_mt16 c0;
    public b64v3_mt16 c1;
    public b64v3_mt16 c2;
    public b64v3_mt16 c3;

    #endregion

    #region Properties

    public b64_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b64_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b64_mt16 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b64_mt16 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public b64_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b64_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b64_mt16 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b64_mt16 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public b64_mt16 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b64_mt16 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b64_mt16 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public b64_mt16 m23
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b64m3x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b64m3x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b64m3x4_mt16(b64v3_mt16 c0, b64v3_mt16 c1, b64v3_mt16 c2, b64v3_mt16 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public b64m3x4_mt16((b64v3_mt16 c0, b64v3_mt16 c1, b64v3_mt16 c2, b64v3_mt16 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x4_mt16((b64v3_mt16 c0, b64v3_mt16 c1, b64v3_mt16 c2, b64v3_mt16 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m3x4_mt16(
        b64_mt16 m00, b64_mt16 m01, b64_mt16 m02, b64_mt16 m03,
        b64_mt16 m10, b64_mt16 m11, b64_mt16 m12, b64_mt16 m13,
        b64_mt16 m20, b64_mt16 m21, b64_mt16 m22, b64_mt16 m23
    )
    {
        this.c0 = new(m00, m10, m20);
        this.c1 = new(m01, m11, m21);
        this.c2 = new(m02, m12, m22);
        this.c3 = new(m03, m13, m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x4_mt16((
        b64_mt16 m00, b64_mt16 m01, b64_mt16 m02, b64_mt16 m03,
        b64_mt16 m10, b64_mt16 m11, b64_mt16 m12, b64_mt16 m13,
        b64_mt16 m20, b64_mt16 m21, b64_mt16 m22, b64_mt16 m23
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m3x4_mt16((
        b64_mt16 m00, b64_mt16 m01, b64_mt16 m02, b64_mt16 m03,
        b64_mt16 m10, b64_mt16 m11, b64_mt16 m12, b64_mt16 m13,
        b64_mt16 m20, b64_mt16 m21, b64_mt16 m22, b64_mt16 m23
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x4_mt16((
        (b64_mt16 m00, b64_mt16 m01, b64_mt16 m02, b64_mt16 m03) r0,
        (b64_mt16 m10, b64_mt16 m11, b64_mt16 m12, b64_mt16 m13) r1,
        (b64_mt16 m20, b64_mt16 m21, b64_mt16 m22, b64_mt16 m23) r2
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m3x4_mt16((
        (b64_mt16 m00, b64_mt16 m01, b64_mt16 m02, b64_mt16 m03) r0,
        (b64_mt16 m10, b64_mt16 m11, b64_mt16 m12, b64_mt16 m13) r1,
        (b64_mt16 m20, b64_mt16 m21, b64_mt16 m22, b64_mt16 m23) r2
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x4_mt16(b64_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x4_mt16(b64 value) => (b64_mt16)(value);

    [MethodImpl(256 | 512)]
    public b64m3x4_mt16(b64_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x4_mt16(b64v3_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m3x4_mt16(bool value) => (b64)(value);

    [MethodImpl(256 | 512)]
    public b64m3x4_mt16(b64v3_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b64v3_mt16 c0, out b64v3_mt16 c1, out b64v3_mt16 c2, out b64v3_mt16 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b64_mt16 m00, out b64_mt16 m01, out b64_mt16 m02, out b64_mt16 m03,
        out b64_mt16 m10, out b64_mt16 m11, out b64_mt16 m12, out b64_mt16 m13,
        out b64_mt16 m20, out b64_mt16 m21, out b64_mt16 m22, out b64_mt16 m23
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20);
        this.c1.Deconstruct(out m01, out m11, out m21);
        this.c2.Deconstruct(out m02, out m12, out m22);
        this.c3.Deconstruct(out m03, out m13, out m23);
    }

    #endregion // Deconstruct

    #region Index

    public b64v3_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b64_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b64m3x4_mt16 operator~(b64m3x4_mt16 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static b64m3x4_mt16 operator|(b64m3x4_mt16 a, b64m3x4_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static b64m3x4_mt16 operator&(b64m3x4_mt16 a, b64m3x4_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static b64m3x4_mt16 operator^(b64m3x4_mt16 a, b64m3x4_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b64m3x4_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // b64m3x4_mt16

#region b64m4x2_mt4

[CpuOnly]
public partial struct b64m4x2_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b64_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 2); 
    }

    public static b64m4x2_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default,
            default, true,
            default, default,
            default, default
        ); 
    }

    #endregion

    #region Fields

    public b64v4_mt4 c0;
    public b64v4_mt4 c1;

    #endregion

    #region Properties

    public b64_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b64_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b64_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b64_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b64_mt4 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b64_mt4 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b64_mt4 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public b64_mt4 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b64m4x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b64m4x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b64m4x2_mt4(b64v4_mt4 c0, b64v4_mt4 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public b64m4x2_mt4((b64v4_mt4 c0, b64v4_mt4 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x2_mt4((b64v4_mt4 c0, b64v4_mt4 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m4x2_mt4(
        b64_mt4 m00, b64_mt4 m01,
        b64_mt4 m10, b64_mt4 m11,
        b64_mt4 m20, b64_mt4 m21,
        b64_mt4 m30, b64_mt4 m31
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x2_mt4((
        b64_mt4 m00, b64_mt4 m01,
        b64_mt4 m10, b64_mt4 m11,
        b64_mt4 m20, b64_mt4 m21,
        b64_mt4 m30, b64_mt4 m31
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m4x2_mt4((
        b64_mt4 m00, b64_mt4 m01,
        b64_mt4 m10, b64_mt4 m11,
        b64_mt4 m20, b64_mt4 m21,
        b64_mt4 m30, b64_mt4 m31
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x2_mt4((
        (b64_mt4 m00, b64_mt4 m01) r0,
        (b64_mt4 m10, b64_mt4 m11) r1,
        (b64_mt4 m20, b64_mt4 m21) r2,
        (b64_mt4 m30, b64_mt4 m31) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m4x2_mt4((
        (b64_mt4 m00, b64_mt4 m01) r0,
        (b64_mt4 m10, b64_mt4 m11) r1,
        (b64_mt4 m20, b64_mt4 m21) r2,
        (b64_mt4 m30, b64_mt4 m31) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x2_mt4(b64_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x2_mt4(b64 value) => (b64_mt4)(value);

    [MethodImpl(256 | 512)]
    public b64m4x2_mt4(b64_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x2_mt4(b64v4_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x2_mt4(bool value) => (b64)(value);

    [MethodImpl(256 | 512)]
    public b64m4x2_mt4(b64v4_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b64v4_mt4 c0, out b64v4_mt4 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b64_mt4 m00, out b64_mt4 m01,
        out b64_mt4 m10, out b64_mt4 m11,
        out b64_mt4 m20, out b64_mt4 m21,
        out b64_mt4 m30, out b64_mt4 m31
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
    }

    #endregion // Deconstruct

    #region Index

    public b64v4_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b64_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b64m4x2_mt4 operator~(b64m4x2_mt4 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static b64m4x2_mt4 operator|(b64m4x2_mt4 a, b64m4x2_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static b64m4x2_mt4 operator&(b64m4x2_mt4 a, b64m4x2_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static b64m4x2_mt4 operator^(b64m4x2_mt4 a, b64m4x2_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b64m4x2_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // b64m4x2_mt4

#region b64m4x2_mt8

[CpuOnly]
public partial struct b64m4x2_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b64_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 2); 
    }

    public static b64m4x2_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default,
            default, true,
            default, default,
            default, default
        ); 
    }

    #endregion

    #region Fields

    public b64v4_mt8 c0;
    public b64v4_mt8 c1;

    #endregion

    #region Properties

    public b64_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b64_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b64_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b64_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b64_mt8 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b64_mt8 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b64_mt8 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public b64_mt8 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b64m4x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b64m4x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b64m4x2_mt8(b64v4_mt8 c0, b64v4_mt8 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public b64m4x2_mt8((b64v4_mt8 c0, b64v4_mt8 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x2_mt8((b64v4_mt8 c0, b64v4_mt8 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m4x2_mt8(
        b64_mt8 m00, b64_mt8 m01,
        b64_mt8 m10, b64_mt8 m11,
        b64_mt8 m20, b64_mt8 m21,
        b64_mt8 m30, b64_mt8 m31
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x2_mt8((
        b64_mt8 m00, b64_mt8 m01,
        b64_mt8 m10, b64_mt8 m11,
        b64_mt8 m20, b64_mt8 m21,
        b64_mt8 m30, b64_mt8 m31
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m4x2_mt8((
        b64_mt8 m00, b64_mt8 m01,
        b64_mt8 m10, b64_mt8 m11,
        b64_mt8 m20, b64_mt8 m21,
        b64_mt8 m30, b64_mt8 m31
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x2_mt8((
        (b64_mt8 m00, b64_mt8 m01) r0,
        (b64_mt8 m10, b64_mt8 m11) r1,
        (b64_mt8 m20, b64_mt8 m21) r2,
        (b64_mt8 m30, b64_mt8 m31) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m4x2_mt8((
        (b64_mt8 m00, b64_mt8 m01) r0,
        (b64_mt8 m10, b64_mt8 m11) r1,
        (b64_mt8 m20, b64_mt8 m21) r2,
        (b64_mt8 m30, b64_mt8 m31) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x2_mt8(b64_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x2_mt8(b64 value) => (b64_mt8)(value);

    [MethodImpl(256 | 512)]
    public b64m4x2_mt8(b64_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x2_mt8(b64v4_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x2_mt8(bool value) => (b64)(value);

    [MethodImpl(256 | 512)]
    public b64m4x2_mt8(b64v4_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b64v4_mt8 c0, out b64v4_mt8 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b64_mt8 m00, out b64_mt8 m01,
        out b64_mt8 m10, out b64_mt8 m11,
        out b64_mt8 m20, out b64_mt8 m21,
        out b64_mt8 m30, out b64_mt8 m31
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
    }

    #endregion // Deconstruct

    #region Index

    public b64v4_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b64_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b64m4x2_mt8 operator~(b64m4x2_mt8 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static b64m4x2_mt8 operator|(b64m4x2_mt8 a, b64m4x2_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static b64m4x2_mt8 operator&(b64m4x2_mt8 a, b64m4x2_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static b64m4x2_mt8 operator^(b64m4x2_mt8 a, b64m4x2_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b64m4x2_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // b64m4x2_mt8

#region b64m4x2_mt16

[CpuOnly]
public partial struct b64m4x2_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b64_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 8; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 2); 
    }

    public static b64m4x2_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default,
            default, true,
            default, default,
            default, default
        ); 
    }

    #endregion

    #region Fields

    public b64v4_mt16 c0;
    public b64v4_mt16 c1;

    #endregion

    #region Properties

    public b64_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b64_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b64_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b64_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b64_mt16 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b64_mt16 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b64_mt16 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public b64_mt16 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b64m4x2 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b64m4x2 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b64m4x2_mt16(b64v4_mt16 c0, b64v4_mt16 c1)
    {
        this.c0 = c0;
        this.c1 = c1;
    }

    [MethodImpl(256 | 512)]
    public b64m4x2_mt16((b64v4_mt16 c0, b64v4_mt16 c1) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x2_mt16((b64v4_mt16 c0, b64v4_mt16 c1) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m4x2_mt16(
        b64_mt16 m00, b64_mt16 m01,
        b64_mt16 m10, b64_mt16 m11,
        b64_mt16 m20, b64_mt16 m21,
        b64_mt16 m30, b64_mt16 m31
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x2_mt16((
        b64_mt16 m00, b64_mt16 m01,
        b64_mt16 m10, b64_mt16 m11,
        b64_mt16 m20, b64_mt16 m21,
        b64_mt16 m30, b64_mt16 m31
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m4x2_mt16((
        b64_mt16 m00, b64_mt16 m01,
        b64_mt16 m10, b64_mt16 m11,
        b64_mt16 m20, b64_mt16 m21,
        b64_mt16 m30, b64_mt16 m31
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x2_mt16((
        (b64_mt16 m00, b64_mt16 m01) r0,
        (b64_mt16 m10, b64_mt16 m11) r1,
        (b64_mt16 m20, b64_mt16 m21) r2,
        (b64_mt16 m30, b64_mt16 m31) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m4x2_mt16((
        (b64_mt16 m00, b64_mt16 m01) r0,
        (b64_mt16 m10, b64_mt16 m11) r1,
        (b64_mt16 m20, b64_mt16 m21) r2,
        (b64_mt16 m30, b64_mt16 m31) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x2_mt16(b64_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x2_mt16(b64 value) => (b64_mt16)(value);

    [MethodImpl(256 | 512)]
    public b64m4x2_mt16(b64_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x2_mt16(b64v4_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x2_mt16(bool value) => (b64)(value);

    [MethodImpl(256 | 512)]
    public b64m4x2_mt16(b64v4_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b64v4_mt16 c0, out b64v4_mt16 c1)
    {
        c0 = this.c0;
        c1 = this.c1;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b64_mt16 m00, out b64_mt16 m01,
        out b64_mt16 m10, out b64_mt16 m11,
        out b64_mt16 m20, out b64_mt16 m21,
        out b64_mt16 m30, out b64_mt16 m31
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
    }

    #endregion // Deconstruct

    #region Index

    public b64v4_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b64_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b64m4x2_mt16 operator~(b64m4x2_mt16 a) => new(~a.c0, ~a.c1);

    [MethodImpl(256 | 512)]
    public static b64m4x2_mt16 operator|(b64m4x2_mt16 a, b64m4x2_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1);

    [MethodImpl(256 | 512)]
    public static b64m4x2_mt16 operator&(b64m4x2_mt16 a, b64m4x2_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1);

    [MethodImpl(256 | 512)]
    public static b64m4x2_mt16 operator^(b64m4x2_mt16 a, b64m4x2_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b64m4x2_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // b64m4x2_mt16

#region b64m4x3_mt4

[CpuOnly]
public partial struct b64m4x3_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b64_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 3); 
    }

    public static b64m4x3_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default,
            default, true, default,
            default, default, true,
            default, default, default
        ); 
    }

    #endregion

    #region Fields

    public b64v4_mt4 c0;
    public b64v4_mt4 c1;
    public b64v4_mt4 c2;

    #endregion

    #region Properties

    public b64_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b64_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b64_mt4 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b64_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b64_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b64_mt4 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b64_mt4 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b64_mt4 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b64_mt4 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public b64_mt4 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public b64_mt4 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public b64_mt4 m32
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b64m4x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b64m4x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b64m4x3_mt4(b64v4_mt4 c0, b64v4_mt4 c1, b64v4_mt4 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public b64m4x3_mt4((b64v4_mt4 c0, b64v4_mt4 c1, b64v4_mt4 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x3_mt4((b64v4_mt4 c0, b64v4_mt4 c1, b64v4_mt4 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m4x3_mt4(
        b64_mt4 m00, b64_mt4 m01, b64_mt4 m02,
        b64_mt4 m10, b64_mt4 m11, b64_mt4 m12,
        b64_mt4 m20, b64_mt4 m21, b64_mt4 m22,
        b64_mt4 m30, b64_mt4 m31, b64_mt4 m32
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x3_mt4((
        b64_mt4 m00, b64_mt4 m01, b64_mt4 m02,
        b64_mt4 m10, b64_mt4 m11, b64_mt4 m12,
        b64_mt4 m20, b64_mt4 m21, b64_mt4 m22,
        b64_mt4 m30, b64_mt4 m31, b64_mt4 m32
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m4x3_mt4((
        b64_mt4 m00, b64_mt4 m01, b64_mt4 m02,
        b64_mt4 m10, b64_mt4 m11, b64_mt4 m12,
        b64_mt4 m20, b64_mt4 m21, b64_mt4 m22,
        b64_mt4 m30, b64_mt4 m31, b64_mt4 m32
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x3_mt4((
        (b64_mt4 m00, b64_mt4 m01, b64_mt4 m02) r0,
        (b64_mt4 m10, b64_mt4 m11, b64_mt4 m12) r1,
        (b64_mt4 m20, b64_mt4 m21, b64_mt4 m22) r2,
        (b64_mt4 m30, b64_mt4 m31, b64_mt4 m32) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m4x3_mt4((
        (b64_mt4 m00, b64_mt4 m01, b64_mt4 m02) r0,
        (b64_mt4 m10, b64_mt4 m11, b64_mt4 m12) r1,
        (b64_mt4 m20, b64_mt4 m21, b64_mt4 m22) r2,
        (b64_mt4 m30, b64_mt4 m31, b64_mt4 m32) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x3_mt4(b64_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x3_mt4(b64 value) => (b64_mt4)(value);

    [MethodImpl(256 | 512)]
    public b64m4x3_mt4(b64_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x3_mt4(b64v4_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x3_mt4(bool value) => (b64)(value);

    [MethodImpl(256 | 512)]
    public b64m4x3_mt4(b64v4_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b64v4_mt4 c0, out b64v4_mt4 c1, out b64v4_mt4 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b64_mt4 m00, out b64_mt4 m01, out b64_mt4 m02,
        out b64_mt4 m10, out b64_mt4 m11, out b64_mt4 m12,
        out b64_mt4 m20, out b64_mt4 m21, out b64_mt4 m22,
        out b64_mt4 m30, out b64_mt4 m31, out b64_mt4 m32
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
    }

    #endregion // Deconstruct

    #region Index

    public b64v4_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b64_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b64m4x3_mt4 operator~(b64m4x3_mt4 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static b64m4x3_mt4 operator|(b64m4x3_mt4 a, b64m4x3_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static b64m4x3_mt4 operator&(b64m4x3_mt4 a, b64m4x3_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static b64m4x3_mt4 operator^(b64m4x3_mt4 a, b64m4x3_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b64m4x3_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // b64m4x3_mt4

#region b64m4x3_mt8

[CpuOnly]
public partial struct b64m4x3_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b64_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 3); 
    }

    public static b64m4x3_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default,
            default, true, default,
            default, default, true,
            default, default, default
        ); 
    }

    #endregion

    #region Fields

    public b64v4_mt8 c0;
    public b64v4_mt8 c1;
    public b64v4_mt8 c2;

    #endregion

    #region Properties

    public b64_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b64_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b64_mt8 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b64_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b64_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b64_mt8 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b64_mt8 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b64_mt8 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b64_mt8 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public b64_mt8 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public b64_mt8 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public b64_mt8 m32
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b64m4x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b64m4x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b64m4x3_mt8(b64v4_mt8 c0, b64v4_mt8 c1, b64v4_mt8 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public b64m4x3_mt8((b64v4_mt8 c0, b64v4_mt8 c1, b64v4_mt8 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x3_mt8((b64v4_mt8 c0, b64v4_mt8 c1, b64v4_mt8 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m4x3_mt8(
        b64_mt8 m00, b64_mt8 m01, b64_mt8 m02,
        b64_mt8 m10, b64_mt8 m11, b64_mt8 m12,
        b64_mt8 m20, b64_mt8 m21, b64_mt8 m22,
        b64_mt8 m30, b64_mt8 m31, b64_mt8 m32
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x3_mt8((
        b64_mt8 m00, b64_mt8 m01, b64_mt8 m02,
        b64_mt8 m10, b64_mt8 m11, b64_mt8 m12,
        b64_mt8 m20, b64_mt8 m21, b64_mt8 m22,
        b64_mt8 m30, b64_mt8 m31, b64_mt8 m32
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m4x3_mt8((
        b64_mt8 m00, b64_mt8 m01, b64_mt8 m02,
        b64_mt8 m10, b64_mt8 m11, b64_mt8 m12,
        b64_mt8 m20, b64_mt8 m21, b64_mt8 m22,
        b64_mt8 m30, b64_mt8 m31, b64_mt8 m32
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x3_mt8((
        (b64_mt8 m00, b64_mt8 m01, b64_mt8 m02) r0,
        (b64_mt8 m10, b64_mt8 m11, b64_mt8 m12) r1,
        (b64_mt8 m20, b64_mt8 m21, b64_mt8 m22) r2,
        (b64_mt8 m30, b64_mt8 m31, b64_mt8 m32) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m4x3_mt8((
        (b64_mt8 m00, b64_mt8 m01, b64_mt8 m02) r0,
        (b64_mt8 m10, b64_mt8 m11, b64_mt8 m12) r1,
        (b64_mt8 m20, b64_mt8 m21, b64_mt8 m22) r2,
        (b64_mt8 m30, b64_mt8 m31, b64_mt8 m32) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x3_mt8(b64_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x3_mt8(b64 value) => (b64_mt8)(value);

    [MethodImpl(256 | 512)]
    public b64m4x3_mt8(b64_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x3_mt8(b64v4_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x3_mt8(bool value) => (b64)(value);

    [MethodImpl(256 | 512)]
    public b64m4x3_mt8(b64v4_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b64v4_mt8 c0, out b64v4_mt8 c1, out b64v4_mt8 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b64_mt8 m00, out b64_mt8 m01, out b64_mt8 m02,
        out b64_mt8 m10, out b64_mt8 m11, out b64_mt8 m12,
        out b64_mt8 m20, out b64_mt8 m21, out b64_mt8 m22,
        out b64_mt8 m30, out b64_mt8 m31, out b64_mt8 m32
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
    }

    #endregion // Deconstruct

    #region Index

    public b64v4_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b64_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b64m4x3_mt8 operator~(b64m4x3_mt8 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static b64m4x3_mt8 operator|(b64m4x3_mt8 a, b64m4x3_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static b64m4x3_mt8 operator&(b64m4x3_mt8 a, b64m4x3_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static b64m4x3_mt8 operator^(b64m4x3_mt8 a, b64m4x3_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b64m4x3_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // b64m4x3_mt8

#region b64m4x3_mt16

[CpuOnly]
public partial struct b64m4x3_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b64_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 12; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 3); 
    }

    public static b64m4x3_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default,
            default, true, default,
            default, default, true,
            default, default, default
        ); 
    }

    #endregion

    #region Fields

    public b64v4_mt16 c0;
    public b64v4_mt16 c1;
    public b64v4_mt16 c2;

    #endregion

    #region Properties

    public b64_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b64_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b64_mt16 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b64_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b64_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b64_mt16 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b64_mt16 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b64_mt16 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b64_mt16 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public b64_mt16 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public b64_mt16 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public b64_mt16 m32
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b64m4x3 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b64m4x3 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b64m4x3_mt16(b64v4_mt16 c0, b64v4_mt16 c1, b64v4_mt16 c2)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }

    [MethodImpl(256 | 512)]
    public b64m4x3_mt16((b64v4_mt16 c0, b64v4_mt16 c1, b64v4_mt16 c2) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x3_mt16((b64v4_mt16 c0, b64v4_mt16 c1, b64v4_mt16 c2) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m4x3_mt16(
        b64_mt16 m00, b64_mt16 m01, b64_mt16 m02,
        b64_mt16 m10, b64_mt16 m11, b64_mt16 m12,
        b64_mt16 m20, b64_mt16 m21, b64_mt16 m22,
        b64_mt16 m30, b64_mt16 m31, b64_mt16 m32
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x3_mt16((
        b64_mt16 m00, b64_mt16 m01, b64_mt16 m02,
        b64_mt16 m10, b64_mt16 m11, b64_mt16 m12,
        b64_mt16 m20, b64_mt16 m21, b64_mt16 m22,
        b64_mt16 m30, b64_mt16 m31, b64_mt16 m32
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m4x3_mt16((
        b64_mt16 m00, b64_mt16 m01, b64_mt16 m02,
        b64_mt16 m10, b64_mt16 m11, b64_mt16 m12,
        b64_mt16 m20, b64_mt16 m21, b64_mt16 m22,
        b64_mt16 m30, b64_mt16 m31, b64_mt16 m32
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x3_mt16((
        (b64_mt16 m00, b64_mt16 m01, b64_mt16 m02) r0,
        (b64_mt16 m10, b64_mt16 m11, b64_mt16 m12) r1,
        (b64_mt16 m20, b64_mt16 m21, b64_mt16 m22) r2,
        (b64_mt16 m30, b64_mt16 m31, b64_mt16 m32) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m4x3_mt16((
        (b64_mt16 m00, b64_mt16 m01, b64_mt16 m02) r0,
        (b64_mt16 m10, b64_mt16 m11, b64_mt16 m12) r1,
        (b64_mt16 m20, b64_mt16 m21, b64_mt16 m22) r2,
        (b64_mt16 m30, b64_mt16 m31, b64_mt16 m32) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x3_mt16(b64_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x3_mt16(b64 value) => (b64_mt16)(value);

    [MethodImpl(256 | 512)]
    public b64m4x3_mt16(b64_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x3_mt16(b64v4_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x3_mt16(bool value) => (b64)(value);

    [MethodImpl(256 | 512)]
    public b64m4x3_mt16(b64v4_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b64v4_mt16 c0, out b64v4_mt16 c1, out b64v4_mt16 c2)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b64_mt16 m00, out b64_mt16 m01, out b64_mt16 m02,
        out b64_mt16 m10, out b64_mt16 m11, out b64_mt16 m12,
        out b64_mt16 m20, out b64_mt16 m21, out b64_mt16 m22,
        out b64_mt16 m30, out b64_mt16 m31, out b64_mt16 m32
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
    }

    #endregion // Deconstruct

    #region Index

    public b64v4_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b64_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b64m4x3_mt16 operator~(b64m4x3_mt16 a) => new(~a.c0, ~a.c1, ~a.c2);

    [MethodImpl(256 | 512)]
    public static b64m4x3_mt16 operator|(b64m4x3_mt16 a, b64m4x3_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2);

    [MethodImpl(256 | 512)]
    public static b64m4x3_mt16 operator&(b64m4x3_mt16 a, b64m4x3_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2);

    [MethodImpl(256 | 512)]
    public static b64m4x3_mt16 operator^(b64m4x3_mt16 a, b64m4x3_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b64m4x3_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // b64m4x3_mt16

#region b64m4x4_mt4

[CpuOnly]
public partial struct b64m4x4_mt4
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b64_mt4.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 4); 
    }

    public static b64m4x4_mt4 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default, default,
            default, true, default, default,
            default, default, true, default,
            default, default, default, true
        ); 
    }

    #endregion

    #region Fields

    public b64v4_mt4 c0;
    public b64v4_mt4 c1;
    public b64v4_mt4 c2;
    public b64v4_mt4 c3;

    #endregion

    #region Properties

    public b64_mt4 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b64_mt4 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b64_mt4 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b64_mt4 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public b64_mt4 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b64_mt4 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b64_mt4 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b64_mt4 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public b64_mt4 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b64_mt4 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b64_mt4 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public b64_mt4 m23
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }
    public b64_mt4 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public b64_mt4 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public b64_mt4 m32
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }
    public b64_mt4 m33
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.w;
        [MethodImpl(256 | 512)]
        set => c3.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b64m4x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b64m4x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b64m4x4_mt4(b64v4_mt4 c0, b64v4_mt4 c1, b64v4_mt4 c2, b64v4_mt4 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public b64m4x4_mt4((b64v4_mt4 c0, b64v4_mt4 c1, b64v4_mt4 c2, b64v4_mt4 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x4_mt4((b64v4_mt4 c0, b64v4_mt4 c1, b64v4_mt4 c2, b64v4_mt4 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m4x4_mt4(
        b64_mt4 m00, b64_mt4 m01, b64_mt4 m02, b64_mt4 m03,
        b64_mt4 m10, b64_mt4 m11, b64_mt4 m12, b64_mt4 m13,
        b64_mt4 m20, b64_mt4 m21, b64_mt4 m22, b64_mt4 m23,
        b64_mt4 m30, b64_mt4 m31, b64_mt4 m32, b64_mt4 m33
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
        this.c3 = new(m03, m13, m23, m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x4_mt4((
        b64_mt4 m00, b64_mt4 m01, b64_mt4 m02, b64_mt4 m03,
        b64_mt4 m10, b64_mt4 m11, b64_mt4 m12, b64_mt4 m13,
        b64_mt4 m20, b64_mt4 m21, b64_mt4 m22, b64_mt4 m23,
        b64_mt4 m30, b64_mt4 m31, b64_mt4 m32, b64_mt4 m33
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m4x4_mt4((
        b64_mt4 m00, b64_mt4 m01, b64_mt4 m02, b64_mt4 m03,
        b64_mt4 m10, b64_mt4 m11, b64_mt4 m12, b64_mt4 m13,
        b64_mt4 m20, b64_mt4 m21, b64_mt4 m22, b64_mt4 m23,
        b64_mt4 m30, b64_mt4 m31, b64_mt4 m32, b64_mt4 m33
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23, tuple.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x4_mt4((
        (b64_mt4 m00, b64_mt4 m01, b64_mt4 m02, b64_mt4 m03) r0,
        (b64_mt4 m10, b64_mt4 m11, b64_mt4 m12, b64_mt4 m13) r1,
        (b64_mt4 m20, b64_mt4 m21, b64_mt4 m22, b64_mt4 m23) r2,
        (b64_mt4 m30, b64_mt4 m31, b64_mt4 m32, b64_mt4 m33) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m4x4_mt4((
        (b64_mt4 m00, b64_mt4 m01, b64_mt4 m02, b64_mt4 m03) r0,
        (b64_mt4 m10, b64_mt4 m11, b64_mt4 m12, b64_mt4 m13) r1,
        (b64_mt4 m20, b64_mt4 m21, b64_mt4 m22, b64_mt4 m23) r2,
        (b64_mt4 m30, b64_mt4 m31, b64_mt4 m32, b64_mt4 m33) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23, tuple.r3.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x4_mt4(b64_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x4_mt4(b64 value) => (b64_mt4)(value);

    [MethodImpl(256 | 512)]
    public b64m4x4_mt4(b64_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x4_mt4(b64v4_mt4 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x4_mt4(bool value) => (b64)(value);

    [MethodImpl(256 | 512)]
    public b64m4x4_mt4(b64v4_mt4 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b64v4_mt4 c0, out b64v4_mt4 c1, out b64v4_mt4 c2, out b64v4_mt4 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b64_mt4 m00, out b64_mt4 m01, out b64_mt4 m02, out b64_mt4 m03,
        out b64_mt4 m10, out b64_mt4 m11, out b64_mt4 m12, out b64_mt4 m13,
        out b64_mt4 m20, out b64_mt4 m21, out b64_mt4 m22, out b64_mt4 m23,
        out b64_mt4 m30, out b64_mt4 m31, out b64_mt4 m32, out b64_mt4 m33
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
        this.c3.Deconstruct(out m03, out m13, out m23, out m33);
    }

    #endregion // Deconstruct

    #region Index

    public b64v4_mt4 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b64_mt4 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b64m4x4_mt4 operator~(b64m4x4_mt4 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static b64m4x4_mt4 operator|(b64m4x4_mt4 a, b64m4x4_mt4 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static b64m4x4_mt4 operator&(b64m4x4_mt4 a, b64m4x4_mt4 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static b64m4x4_mt4 operator^(b64m4x4_mt4 a, b64m4x4_mt4 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b64m4x4_mt4 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)} }}";
    
    #endregion // ToString
}

#endregion // b64m4x4_mt4

#region b64m4x4_mt8

[CpuOnly]
public partial struct b64m4x4_mt8
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b64_mt8.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 4); 
    }

    public static b64m4x4_mt8 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default, default,
            default, true, default, default,
            default, default, true, default,
            default, default, default, true
        ); 
    }

    #endregion

    #region Fields

    public b64v4_mt8 c0;
    public b64v4_mt8 c1;
    public b64v4_mt8 c2;
    public b64v4_mt8 c3;

    #endregion

    #region Properties

    public b64_mt8 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b64_mt8 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b64_mt8 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b64_mt8 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public b64_mt8 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b64_mt8 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b64_mt8 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b64_mt8 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public b64_mt8 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b64_mt8 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b64_mt8 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public b64_mt8 m23
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }
    public b64_mt8 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public b64_mt8 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public b64_mt8 m32
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }
    public b64_mt8 m33
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.w;
        [MethodImpl(256 | 512)]
        set => c3.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b64m4x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b64m4x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b64m4x4_mt8(b64v4_mt8 c0, b64v4_mt8 c1, b64v4_mt8 c2, b64v4_mt8 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public b64m4x4_mt8((b64v4_mt8 c0, b64v4_mt8 c1, b64v4_mt8 c2, b64v4_mt8 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x4_mt8((b64v4_mt8 c0, b64v4_mt8 c1, b64v4_mt8 c2, b64v4_mt8 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m4x4_mt8(
        b64_mt8 m00, b64_mt8 m01, b64_mt8 m02, b64_mt8 m03,
        b64_mt8 m10, b64_mt8 m11, b64_mt8 m12, b64_mt8 m13,
        b64_mt8 m20, b64_mt8 m21, b64_mt8 m22, b64_mt8 m23,
        b64_mt8 m30, b64_mt8 m31, b64_mt8 m32, b64_mt8 m33
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
        this.c3 = new(m03, m13, m23, m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x4_mt8((
        b64_mt8 m00, b64_mt8 m01, b64_mt8 m02, b64_mt8 m03,
        b64_mt8 m10, b64_mt8 m11, b64_mt8 m12, b64_mt8 m13,
        b64_mt8 m20, b64_mt8 m21, b64_mt8 m22, b64_mt8 m23,
        b64_mt8 m30, b64_mt8 m31, b64_mt8 m32, b64_mt8 m33
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m4x4_mt8((
        b64_mt8 m00, b64_mt8 m01, b64_mt8 m02, b64_mt8 m03,
        b64_mt8 m10, b64_mt8 m11, b64_mt8 m12, b64_mt8 m13,
        b64_mt8 m20, b64_mt8 m21, b64_mt8 m22, b64_mt8 m23,
        b64_mt8 m30, b64_mt8 m31, b64_mt8 m32, b64_mt8 m33
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23, tuple.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x4_mt8((
        (b64_mt8 m00, b64_mt8 m01, b64_mt8 m02, b64_mt8 m03) r0,
        (b64_mt8 m10, b64_mt8 m11, b64_mt8 m12, b64_mt8 m13) r1,
        (b64_mt8 m20, b64_mt8 m21, b64_mt8 m22, b64_mt8 m23) r2,
        (b64_mt8 m30, b64_mt8 m31, b64_mt8 m32, b64_mt8 m33) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m4x4_mt8((
        (b64_mt8 m00, b64_mt8 m01, b64_mt8 m02, b64_mt8 m03) r0,
        (b64_mt8 m10, b64_mt8 m11, b64_mt8 m12, b64_mt8 m13) r1,
        (b64_mt8 m20, b64_mt8 m21, b64_mt8 m22, b64_mt8 m23) r2,
        (b64_mt8 m30, b64_mt8 m31, b64_mt8 m32, b64_mt8 m33) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23, tuple.r3.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x4_mt8(b64_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x4_mt8(b64 value) => (b64_mt8)(value);

    [MethodImpl(256 | 512)]
    public b64m4x4_mt8(b64_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x4_mt8(b64v4_mt8 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x4_mt8(bool value) => (b64)(value);

    [MethodImpl(256 | 512)]
    public b64m4x4_mt8(b64v4_mt8 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b64v4_mt8 c0, out b64v4_mt8 c1, out b64v4_mt8 c2, out b64v4_mt8 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b64_mt8 m00, out b64_mt8 m01, out b64_mt8 m02, out b64_mt8 m03,
        out b64_mt8 m10, out b64_mt8 m11, out b64_mt8 m12, out b64_mt8 m13,
        out b64_mt8 m20, out b64_mt8 m21, out b64_mt8 m22, out b64_mt8 m23,
        out b64_mt8 m30, out b64_mt8 m31, out b64_mt8 m32, out b64_mt8 m33
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
        this.c3.Deconstruct(out m03, out m13, out m23, out m33);
    }

    #endregion // Deconstruct

    #region Index

    public b64v4_mt8 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b64_mt8 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b64m4x4_mt8 operator~(b64m4x4_mt8 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static b64m4x4_mt8 operator|(b64m4x4_mt8 a, b64m4x4_mt8 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static b64m4x4_mt8 operator&(b64m4x4_mt8 a, b64m4x4_mt8 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static b64m4x4_mt8 operator^(b64m4x4_mt8 a, b64m4x4_mt8 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b64m4x4_mt8 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)} }}";
    
    #endregion // ToString
}

#endregion // b64m4x4_mt8

#region b64m4x4_mt16

[CpuOnly]
public partial struct b64m4x4_mt16
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => b64_mt16.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => 16; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(4, 4); 
    }

    public static b64m4x4_mt16 Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            true, default, default, default,
            default, true, default, default,
            default, default, true, default,
            default, default, default, true
        ); 
    }

    #endregion

    #region Fields

    public b64v4_mt16 c0;
    public b64v4_mt16 c1;
    public b64v4_mt16 c2;
    public b64v4_mt16 c3;

    #endregion

    #region Properties

    public b64_mt16 m00
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.x;
        [MethodImpl(256 | 512)]
        set => c0.x = value;
    }
    public b64_mt16 m01
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.x;
        [MethodImpl(256 | 512)]
        set => c1.x = value;
    }
    public b64_mt16 m02
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.x;
        [MethodImpl(256 | 512)]
        set => c2.x = value;
    }
    public b64_mt16 m03
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.x;
        [MethodImpl(256 | 512)]
        set => c3.x = value;
    }
    public b64_mt16 m10
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.y;
        [MethodImpl(256 | 512)]
        set => c0.y = value;
    }
    public b64_mt16 m11
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.y;
        [MethodImpl(256 | 512)]
        set => c1.y = value;
    }
    public b64_mt16 m12
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.y;
        [MethodImpl(256 | 512)]
        set => c2.y = value;
    }
    public b64_mt16 m13
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.y;
        [MethodImpl(256 | 512)]
        set => c3.y = value;
    }
    public b64_mt16 m20
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.z;
        [MethodImpl(256 | 512)]
        set => c0.z = value;
    }
    public b64_mt16 m21
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.z;
        [MethodImpl(256 | 512)]
        set => c1.z = value;
    }
    public b64_mt16 m22
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.z;
        [MethodImpl(256 | 512)]
        set => c2.z = value;
    }
    public b64_mt16 m23
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.z;
        [MethodImpl(256 | 512)]
        set => c3.z = value;
    }
    public b64_mt16 m30
    {
        [MethodImpl(256 | 512)]
        readonly get => c0.w;
        [MethodImpl(256 | 512)]
        set => c0.w = value;
    }
    public b64_mt16 m31
    {
        [MethodImpl(256 | 512)]
        readonly get => c1.w;
        [MethodImpl(256 | 512)]
        set => c1.w = value;
    }
    public b64_mt16 m32
    {
        [MethodImpl(256 | 512)]
        readonly get => c2.w;
        [MethodImpl(256 | 512)]
        set => c2.w = value;
    }
    public b64_mt16 m33
    {
        [MethodImpl(256 | 512)]
        readonly get => c3.w;
        [MethodImpl(256 | 512)]
        set => c3.w = value;
    }

    [MethodImpl(256 | 512)]
    public readonly b64m4x4 LaneGet(int index) => new(c0.LaneGet(index), c1.LaneGet(index), c2.LaneGet(index), c3.LaneGet(index));

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, b64m4x4 value)
    {
        c0.LaneSet(index, value.c0);
        c1.LaneSet(index, value.c1);
        c2.LaneSet(index, value.c2);
        c3.LaneSet(index, value.c3);
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public b64m4x4_mt16(b64v4_mt16 c0, b64v4_mt16 c1, b64v4_mt16 c2, b64v4_mt16 c3)
    {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
        this.c3 = c3;
    }

    [MethodImpl(256 | 512)]
    public b64m4x4_mt16((b64v4_mt16 c0, b64v4_mt16 c1, b64v4_mt16 c2, b64v4_mt16 c3) tuple)
    {
        this.c0 = tuple.c0;
        this.c1 = tuple.c1;
        this.c2 = tuple.c2;
        this.c3 = tuple.c3;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x4_mt16((b64v4_mt16 c0, b64v4_mt16 c1, b64v4_mt16 c2, b64v4_mt16 c3) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m4x4_mt16(
        b64_mt16 m00, b64_mt16 m01, b64_mt16 m02, b64_mt16 m03,
        b64_mt16 m10, b64_mt16 m11, b64_mt16 m12, b64_mt16 m13,
        b64_mt16 m20, b64_mt16 m21, b64_mt16 m22, b64_mt16 m23,
        b64_mt16 m30, b64_mt16 m31, b64_mt16 m32, b64_mt16 m33
    )
    {
        this.c0 = new(m00, m10, m20, m30);
        this.c1 = new(m01, m11, m21, m31);
        this.c2 = new(m02, m12, m22, m32);
        this.c3 = new(m03, m13, m23, m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x4_mt16((
        b64_mt16 m00, b64_mt16 m01, b64_mt16 m02, b64_mt16 m03,
        b64_mt16 m10, b64_mt16 m11, b64_mt16 m12, b64_mt16 m13,
        b64_mt16 m20, b64_mt16 m21, b64_mt16 m22, b64_mt16 m23,
        b64_mt16 m30, b64_mt16 m31, b64_mt16 m32, b64_mt16 m33
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m4x4_mt16((
        b64_mt16 m00, b64_mt16 m01, b64_mt16 m02, b64_mt16 m03,
        b64_mt16 m10, b64_mt16 m11, b64_mt16 m12, b64_mt16 m13,
        b64_mt16 m20, b64_mt16 m21, b64_mt16 m22, b64_mt16 m23,
        b64_mt16 m30, b64_mt16 m31, b64_mt16 m32, b64_mt16 m33
    ) tuple)
    {
        this.c0 = new(tuple.m00, tuple.m10, tuple.m20, tuple.m30);
        this.c1 = new(tuple.m01, tuple.m11, tuple.m21, tuple.m31);
        this.c2 = new(tuple.m02, tuple.m12, tuple.m22, tuple.m32);
        this.c3 = new(tuple.m03, tuple.m13, tuple.m23, tuple.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x4_mt16((
        (b64_mt16 m00, b64_mt16 m01, b64_mt16 m02, b64_mt16 m03) r0,
        (b64_mt16 m10, b64_mt16 m11, b64_mt16 m12, b64_mt16 m13) r1,
        (b64_mt16 m20, b64_mt16 m21, b64_mt16 m22, b64_mt16 m23) r2,
        (b64_mt16 m30, b64_mt16 m31, b64_mt16 m32, b64_mt16 m33) r3
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public b64m4x4_mt16((
        (b64_mt16 m00, b64_mt16 m01, b64_mt16 m02, b64_mt16 m03) r0,
        (b64_mt16 m10, b64_mt16 m11, b64_mt16 m12, b64_mt16 m13) r1,
        (b64_mt16 m20, b64_mt16 m21, b64_mt16 m22, b64_mt16 m23) r2,
        (b64_mt16 m30, b64_mt16 m31, b64_mt16 m32, b64_mt16 m33) r3
    ) tuple)
    {
        this.c0 = new(tuple.r0.m00, tuple.r1.m10, tuple.r2.m20, tuple.r3.m30);
        this.c1 = new(tuple.r0.m01, tuple.r1.m11, tuple.r2.m21, tuple.r3.m31);
        this.c2 = new(tuple.r0.m02, tuple.r1.m12, tuple.r2.m22, tuple.r3.m32);
        this.c3 = new(tuple.r0.m03, tuple.r1.m13, tuple.r2.m23, tuple.r3.m33);
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x4_mt16(b64_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x4_mt16(b64 value) => (b64_mt16)(value);

    [MethodImpl(256 | 512)]
    public b64m4x4_mt16(b64_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x4_mt16(b64v4_mt16 value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator b64m4x4_mt16(bool value) => (b64)(value);

    [MethodImpl(256 | 512)]
    public b64m4x4_mt16(b64v4_mt16 value)
    {
        this.c0 = value;
        this.c1 = value;
        this.c2 = value;
        this.c3 = value;
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(out b64v4_mt16 c0, out b64v4_mt16 c1, out b64v4_mt16 c2, out b64v4_mt16 c3)
    {
        c0 = this.c0;
        c1 = this.c1;
        c2 = this.c2;
        c3 = this.c3;
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        out b64_mt16 m00, out b64_mt16 m01, out b64_mt16 m02, out b64_mt16 m03,
        out b64_mt16 m10, out b64_mt16 m11, out b64_mt16 m12, out b64_mt16 m13,
        out b64_mt16 m20, out b64_mt16 m21, out b64_mt16 m22, out b64_mt16 m23,
        out b64_mt16 m30, out b64_mt16 m31, out b64_mt16 m32, out b64_mt16 m33
    )
    {
        this.c0.Deconstruct(out m00, out m10, out m20, out m30);
        this.c1.Deconstruct(out m01, out m11, out m21, out m31);
        this.c2.Deconstruct(out m02, out m12, out m22, out m32);
        this.c3.Deconstruct(out m03, out m13, out m23, out m33);
    }

    #endregion // Deconstruct

    #region Index

    public b64v4_mt16 this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0,
            1 => c1,
            2 => c2,
            3 => c3,
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0 = value;
                    break;
                case 1:
                    c1 = value;
                    break;
                case 2:
                    c2 = value;
                    break;
                case 3:
                    c3 = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public b64_mt16 this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
            0 => c0[r],
            1 => c1[r],
            2 => c2[r],
            3 => c3[r],
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
                case 0:
                    c0[r] = value;
                    break;
                case 1:
                    c1[r] = value;
                    break;
                case 2:
                    c2[r] = value;
                    break;
                case 3:
                    c3[r] = value;
                    break;
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static b64m4x4_mt16 operator~(b64m4x4_mt16 a) => new(~a.c0, ~a.c1, ~a.c2, ~a.c3);

    [MethodImpl(256 | 512)]
    public static b64m4x4_mt16 operator|(b64m4x4_mt16 a, b64m4x4_mt16 b) => new(a.c0 | b.c0, a.c1 | b.c1, a.c2 | b.c2, a.c3 | b.c3);

    [MethodImpl(256 | 512)]
    public static b64m4x4_mt16 operator&(b64m4x4_mt16 a, b64m4x4_mt16 b) => new(a.c0 & b.c0, a.c1 & b.c1, a.c2 & b.c2, a.c3 & b.c3);

    [MethodImpl(256 | 512)]
    public static b64m4x4_mt16 operator^(b64m4x4_mt16 a, b64m4x4_mt16 b) => new(a.c0 ^ b.c0, a.c1 ^ b.c1, a.c2 ^ b.c2, a.c3 ^ b.c3);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"b64m4x4_mt16 {{ t0 = {this.LaneGet(0)}, t1 = {this.LaneGet(1)}, t2 = {this.LaneGet(2)}, t3 = {this.LaneGet(3)}, t4 = {this.LaneGet(4)}, t5 = {this.LaneGet(5)}, t6 = {this.LaneGet(6)}, t7 = {this.LaneGet(7)}, t8 = {this.LaneGet(8)}, t9 = {this.LaneGet(9)}, t10 = {this.LaneGet(10)}, t11 = {this.LaneGet(11)}, t12 = {this.LaneGet(12)}, t13 = {this.LaneGet(13)}, t14 = {this.LaneGet(14)}, t15 = {this.LaneGet(15)} }}";
    
    #endregion // ToString
}

#endregion // b64m4x4_mt16
