<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="../../Coplt.Mathematics/types.ttinclude" #><#@ import namespace="System.Linq" #>// generated by template, do not modify manually

namespace Coplt.Mathematics.Simt;
<#
    var sizes = new[] { 16 };
    foreach (var typ in Typ.Typs)
    {
        if (!typ.simd) continue;
        if (typ.size < 4) continue;
        for (var n = 2; n <= 4; n++)
        {
            for (var m = 2; m <= 4; m++)
            {
                foreach (var size in sizes)
                {
                    var byteSize = typ.size * size;
                    var bitSize = 8 * byteSize;
                    var num_vectors = Math.Max(1, bitSize / 512);
                    bitSize = Math.Min(512, bitSize);

                    var scalarName = $"{typ.compType}_mt";
                    var vecTypeName = $"{typ.name}{n}_mt";
                    var typeName = $"{typ.name.Replace('v', 'm')}{n}x{m}_mt";
                    var simd_typeName = $"{typ.name.Replace('v', 'm')}{n}x{m}";
#>

#region <#= typeName #>

[CpuOnly]
public partial struct <#= typeName #>
{
    #region Constants

    public static int LineCount
    {
        [MethodImpl(256 | 512)]
        get => <#= scalarName #>.LineCount;
    }

    public static int Length
    { 
        [MethodImpl(256 | 512)]
        get => <#= n * m #>; 
    }

    public static int2 Size
    { 
        [MethodImpl(256 | 512)]
        get => new(<#= n #>, <#= m #>); 
    }

    public static <#= typeName #> Identity
    { 
        [MethodImpl(256 | 512)]
        get => new(
            <#=
                        string.Join(",\n            ", Enumerable.Range(0, n).Select(j => string.Join(", ", Enumerable.Range(0, m).Select(i => j == i ? typ.one : "default")))) #>
        ); 
    }

    #endregion

    #region Fields

<#
                    for (int i = 0; i < m; i++)
                    {
#>
    public <#= vecTypeName #> c<#= i #>;
<#
                    }
#>

    #endregion

    #region Properties

<#
                    for (int i = 0; i < n; i++)
                    {
                        for (int j = 0; j < m; j++)
                        {
#>
    public <#= scalarName #> m<#= i #><#= j #>
    {
        [MethodImpl(256 | 512)]
        readonly get => c<#= j #>.<#= Typ.xyzw[i] #>;
        [MethodImpl(256 | 512)]
        set => c<#= j #>.<#= Typ.xyzw[i] #> = value;
    }
<#
                        }
                    }
#>

    [MethodImpl(256 | 512)]
    public readonly <#= simd_typeName #> LaneGet(int index) => new(<#= string.Join(", ", Enumerable.Range(0, m).Select(i => $"c{i}.LaneGet(index)")) #>);

    [MethodImpl(256 | 512)]
    public void LaneSet(int index, <#= simd_typeName #> value)
    {
<#
                foreach (var i in Enumerable.Range(0, m))
                {
#>
        c<#=i#>.LaneSet(index, value.c<#=i#>);
<#
                }
#>
    }

    #endregion

    #region Ctor

    [MethodImpl(256 | 512)]
    public <#= typeName #>(<#= string.Join(", ", Enumerable.Range(0, m).Select(i => $"{vecTypeName} c{i}")) #>)
    {
<#
                    for (int i = 0; i < m; i++)
                    {
#>
        this.c<#= i #> = c<#= i #>;
<#
                    }
#>
    }

    [MethodImpl(256 | 512)]
    public <#= typeName #>((<#= string.Join(", ", Enumerable.Range(0, m).Select(i => $"{vecTypeName} c{i}")) #>) tuple)
    {
<#
                    for (int i = 0; i < m; i++)
                    {
#>
        this.c<#= i #> = tuple.c<#= i #>;
<#
                    }
#>
    }

    [MethodImpl(256 | 512)]
    public static implicit operator <#= typeName #>((<#= string.Join(", ", Enumerable.Range(0, m).Select(i => $"{vecTypeName} c{i}")) #>) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public <#= typeName #>(
        <#=
                        string.Join(",\n        ", Enumerable.Range(0, n).Select(j => string.Join(", ", Enumerable.Range(0, m).Select(i => $"{scalarName} m{j}{i}")))) #>
    )
    {
<#
                    for (int i = 0; i < m; i++)
                    {
#>
        this.c<#= i #> = new(<#= string.Join(", ", Enumerable.Range(0, n).Select(j => $"m{j}{i}")) #>);
<#
                    }
#>
    }

    [MethodImpl(256 | 512)]
    public static implicit operator <#= typeName #>((
        <#=
                        string.Join(",\n        ", Enumerable.Range(0, n).Select(j => string.Join(", ", Enumerable.Range(0, m).Select(i => $"{scalarName} m{j}{i}")))) #>
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public <#= typeName #>((
        <#=
                        string.Join(",\n        ", Enumerable.Range(0, n).Select(j => string.Join(", ", Enumerable.Range(0, m).Select(i => $"{scalarName} m{j}{i}")))) #>
    ) tuple)
    {
<#
                    for (int i = 0; i < m; i++)
                    {
#>
        this.c<#= i #> = new(<#= string.Join(", ", Enumerable.Range(0, n).Select(j => $"tuple.m{j}{i}")) #>);
<#
                    }
#>
    }

    [MethodImpl(256 | 512)]
    public static implicit operator <#= typeName #>((
        <#=
                        string.Join(",\n        ", Enumerable.Range(0, n).Select(j => $"({string.Join(", ", Enumerable.Range(0, m).Select(i => $"{scalarName} m{j}{i}"))}) r{j}")) #>
    ) tuple) => new(tuple);

    [MethodImpl(256 | 512)]
    public <#= typeName #>((
        <#=
                        string.Join(",\n        ", Enumerable.Range(0, n).Select(j => $"({string.Join(", ", Enumerable.Range(0, m).Select(i => $"{scalarName} m{j}{i}"))}) r{j}")) #>
    ) tuple)
    {
<#
                    for (int i = 0; i < m; i++)
                    {
#>
        this.c<#= i #> = new(<#= string.Join(", ", Enumerable.Range(0, n).Select(j => $"tuple.r{j}.m{j}{i}")) #>);
<#
                    }
#>
    }

    [MethodImpl(256 | 512)]
    public static implicit operator <#= typeName #>(<#= scalarName #> value) => new(value);

    [MethodImpl(256 | 512)]
    public static implicit operator <#= typeName #>(<#= typ.compType #> value) => (<#= scalarName #>)(value);

    [MethodImpl(256 | 512)]
    public <#= typeName #>(<#= scalarName #> value)
    {
<#
                    for (int i = 0; i < m; i++)
                    {
#>
        this.c<#= i #> = value;
<#
                    }
#>
    }

    [MethodImpl(256 | 512)]
    public static implicit operator <#= typeName #>(<#= vecTypeName #> value) => new(value);
<#
                    if (typ.bol)
                    {
#>

    [MethodImpl(256 | 512)]
    public static implicit operator <#= typeName #>(bool value) => (<#= typ.compType #>)(value);
<#
                    }
#>

    [MethodImpl(256 | 512)]
    public <#= typeName #>(<#= vecTypeName #> value)
    {
<#
                    for (int i = 0; i < m; i++)
                    {
#>
        this.c<#= i #> = value;
<#
                    }
#>
    }

    #endregion

    #region Deconstruct
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(<#= string.Join(", ", Enumerable.Range(0, m).Select(i => $"out {vecTypeName} c{i}")) #>)
    {
<#
                    for (int i = 0; i < m; i++)
                    {
#>
        c<#= i #> = this.c<#= i #>;
<#
                    }
#>
    }
    
    [MethodImpl(256 | 512)]
    public readonly void Deconstruct(
        <#=
                        string.Join(",\n        ", Enumerable.Range(0, n).Select(j => string.Join(", ", Enumerable.Range(0, m).Select(i => $"out {scalarName} m{j}{i}")))) #>
    )
    {
<#
                    for (int i = 0; i < m; i++)
                    {
#>
        this.c<#= i #>.Deconstruct(<#= string.Join(", ", Enumerable.Range(0, n).Select(j => $"out m{j}{i}")) #>);
<#
                    }
#>
    }

    #endregion // Deconstruct

    #region Index

    public <#= vecTypeName #> this[int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
<#
                    for (var j = 0; j < m; j++)
                    {
#>
            <#= j #> => c<#= j #>,
<#
                    }
#>
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
<#
                    for (var j = 0; j < m; j++)
                    {
#>
                case <#= j #>:
                    c<#= j #> = value;
                    break;
<#
                    }
#>
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    public <#= scalarName #> this[int r, int c]
    {
        [MethodImpl(256 | 512)]
        readonly get => c switch
        {
<#
                    for (var j = 0; j < m; j++)
                    {
#>
            <#= j #> => c<#= j #>[r],
<#
                    }
#>
            _ => throw new IndexOutOfRangeException(nameof(c)),
        };
        [MethodImpl(256 | 512)]
        set
        {
            switch (c)
            {
<#
                    for (var j = 0; j < m; j++)
                    {
#>
                case <#= j #>:
                    c<#= j #>[r] = value;
                    break;
<#
                    }
#>
                default:
                    throw new IndexOutOfRangeException(nameof(c));
            }
        }
    }

    #endregion // Index

    #region Operators


    [MethodImpl(256 | 512)]

    public static <#= typeName #> operator~(<#= typeName #> a) => new(<#=
                    string.Join(", ", Enumerable.Range(0, m).Select(i => $"~a.c{i}")) #>);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator|(<#= typeName #> a, <#= typeName #> b) => new(<#=
                    string.Join(", ", Enumerable.Range(0, m).Select(i => $"a.c{i} | b.c{i}")) #>);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator&(<#= typeName #> a, <#= typeName #> b) => new(<#=
                    string.Join(", ", Enumerable.Range(0, m).Select(i => $"a.c{i} & b.c{i}")) #>);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator^(<#= typeName #> a, <#= typeName #> b) => new(<#=
                    string.Join(", ", Enumerable.Range(0, m).Select(i => $"a.c{i} ^ b.c{i}")) #>);

    #endregion // Operatores

    #region ToString

    public readonly override string ToString() => $"<#= typeName #> {{ <#=
                    string.Join(", ", Enumerable.Range(0, size).Select(l => $"t{l} = {{this.LaneGet({l})}}")) #> }}";
    
    #endregion // ToString
}

#endregion // <#= typeName #>
<#
                }
            }
        }
    }
#>
