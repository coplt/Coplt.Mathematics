<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="../../../Coplt.Mathematics/types.ttinclude" #><#@ import namespace="System.Linq" #>// generated by template, do not modify manually

namespace Coplt.Mathematics.Simt;
<#
    var sizes = new[] { 16 };
    foreach (var typ in Typ.Typs)
    {
        if (!typ.simd) continue;
        if (typ.size < 4) continue;
        if (!typ.arith) continue;
        foreach (var size in sizes)
        {
            var scalarName = $"{typ.compType}_mt";
            var vecTypeName = $"{typ.name}{2}_mt";
            var typeName = $"{typ.name.Replace('v', 'm')}{2}x{2}_mt";
#>

#region <#= typeName #>

public partial struct <#= typeName #>
{
<#
            if (typ.f && typ.bin)
            {
#>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> Rotate(<#= scalarName #> angle)
    {
        angle.sincos(out var s, out var c);
        return new(
            c, -s,
            s,  c
        );
    }

<#
            }
#>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> Scale(<#= scalarName #> s) => new(
        s,   default,
        default, s
    );

    [MethodImpl(256 | 512)]
    public static <#= typeName #> Scale(<#= scalarName #> x, <#= scalarName #> y) => new(
        x,   default,
        default, y
    );

    [MethodImpl(256 | 512)]
    public static <#= typeName #> Scale(<#= vecTypeName #> v) => new(
        v.x,   default,
        default, v.y
    );
}

[Ex]
public static partial class math_mt
{
<#
            if (typ.f)
            {
#>
    /// <summary>Returns the determinant of a <#= typeName #> matrix</summary>
    /// <param name="m">Matrix to use when computing determinant</param>
    /// <returns>The determinant of the matrix</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> inverse([This] <#= typeName #> m)
    {
        var a = m.c0.x;
        var b = m.c1.x;
        var c = m.c0.y;
        var d = m.c1.y;

        // var det = a * d - b * c;
        var det = fsm(a * d, b, c);

        return new <#= typeName #>(d, -b, -c, a) * (<#= typ.one #> / det);
    }

    [MethodImpl(256 | 512)]
    public static <#= scalarName #> determinant([This] <#= typeName #> m)
    {
        var a = m.c0.x;
        var b = m.c1.x;
        var c = m.c0.y;
        var d = m.c1.y;

        // return a * d - b * c;
        return fsm(a * d, b, c);
    }
<#
            }
#>
}

#endregion // <#= typeName #>
<#
        }
    }
#>
