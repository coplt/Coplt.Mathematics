<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="../../../Coplt.Mathematics/types.ttinclude" #><#@ import namespace="System.Linq" #>// generated by template, do not modify manually

namespace Coplt.Mathematics.Simt;
<#
    var sizes = new[] { 16 };
    foreach (var typ in Typ.Typs)
    {
        if (!typ.simd) continue;
        if (typ.size < 4) continue;
        if (!typ.arith) continue;
        foreach (var size in sizes)
        {
            var scalarName = $"{typ.compType}_mt";
            var vecTypeName = $"{typ.name}{3}_mt";
            var typeName = $"{typ.name.Replace('v', 'm')}{3}x{3}_mt";

            var vecTypeName4 = $"{typ.name}{4}_mt";
            var typeName4x4 = $"{typ.name.Replace('v', 'm')}{4}x{4}_mt";

            var quaternionName = $"quaternion{typ.structSuffix}_mt";
#>

#region <#= typeName #>

public partial struct <#= typeName #>
{
    /// <summary>
    /// Constructs a <#= typeName #> from the upper left 3x3 of a <#= typeName4x4 #>
    /// </summary>
    /// <param name="m4x4"><see cref="<#= typeName4x4 #>"/> to extract a <#= typeName #> from</param>
    [MethodImpl(256 | 512)]
    public <#= typeName #>(<#= typeName4x4 #> m4x4)
    {
        c0 = m4x4.c0.xyz;
        c1 = m4x4.c1.xyz;
        c2 = m4x4.c2.xyz;
    }
<#
            if (typ.f && typ.bin)
            {
#>

    /// <summary>Constructs a <#= typeName #> matrix from a unit quaternion</summary>
    /// <param name="q">The quaternion rotation</param>
    [MethodImpl(256 | 512)]
    public <#= typeName #>(<#= quaternionName #> q)
    {
        var v = q.value;
        var v2 = v + v;

        var npn = new <#= typ.maskType #>3_mt(<#= typ.maskNeg #>, default, <#= typ.maskNeg #>).asf();
        var nnp = new <#= typ.maskType #>3_mt(<#= typ.maskNeg #>, <#= typ.maskNeg #>, default).asf();
        var pnn = new <#= typ.maskType #>3_mt(default, <#= typ.maskNeg #>, <#= typ.maskNeg #>).asf();

        c0 = v2.yyy.fms(v.yxw ^ npn, v2.zzz * (v.zwx ^ pnn)) + new <#= vecTypeName #>(<#= typ.one #>, default, default);
        c1 = v2.zzz.fms(v.wzy ^ nnp, v2.xxx * (v.yxw ^ npn)) + new <#= vecTypeName #>(default, <#= typ.one #>, default);
        c2 = v2.xxx.fms(v.zwx ^ pnn, v2.yyy * (v.wzy ^ nnp)) + new <#= vecTypeName #>(default, default, <#= typ.one #>);
    }

    /// <summary>
    /// Returns a <#= typeName #> view rotation matrix given a unit length forward vector and a unit length up vector.
    /// The two input vectors are assumed to be unit length and not collinear.
    /// If these assumptions are not met use <see cref="<#= typeName #>.LookRotationSafe" /> instead.
    /// </summary>
    /// <param name="forward">The forward vector to align the center of view with</param>
    /// <param name="up">The up vector to point top of view toward</param>
    /// <returns>The <#= typeName #> view rotation matrix</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> LookRotation(<#= vecTypeName #> forward, <#= vecTypeName #> up)
    {
        var t = up.cross(forward).normalize();
        return new(t, forward.cross(t), forward);
    }

    /// <summary>
    /// Returns a <#= typeName #> view rotation matrix given a forward vector and an up vector.
    /// The two input vectors are not assumed to be unit length.
    /// If the magnitude of either of the vectors is so extreme that the calculation cannot be carried out reliably or the vectors are collinear,
    /// the identity will be returned instead.
    /// </summary>
    /// <param name="forward">The forward vector to align the center of view with</param>
    /// <param name="up">The up vector to point top of view toward</param>
    /// <returns>The <#= typeName #> view rotation matrix or the identity matrix.</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> LookRotationSafe(<#= vecTypeName #> forward, <#= vecTypeName #> up)
    {
        var forwardLengthSq = forward.dot(forward);
        var upLengthSq = up.dot(up);

        forward *= forwardLengthSq.rsqrt();
        up *= upLengthSq.rsqrt();

        var t = up.cross(forward);
        var tLengthSq = t.dot(t);
        t *= tLengthSq.rsqrt();

        var mn = forwardLengthSq.min(upLengthSq).min(tLengthSq);
        var mx = forwardLengthSq.max(upLengthSq).max(tLengthSq);

        var accept = mn > math_mt.MinRotateSafe<<#= typ.compType #>>() & mx < math_mt.MaxRotateSafe<<#= typ.compType #>>()
            & forwardLengthSq.isFinite() & upLengthSq.isFinite() & tLengthSq.isFinite();
        return math_mt.select(accept, new <#= typeName #>(t, forward.cross(t), forward), Identity);
    }
    
    /// <summary>
    /// Returns a <#= typeName #> matrix representing a rotation around a unit axis by an angle in radians.
    /// The rotation direction is clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="axis">The rotation axis</param>
    /// <param name="angle">The angle of rotation in radians</param>
    /// <returns>The <#= typeName #> matrix representing the rotation around an axis.</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> AxisAngle(<#= vecTypeName #> axis, <#= scalarName #> angle)
    {
        angle.sincos(out var sina, out var cosa);
        var u = axis;
        var u_inv_cosa = math_mt.fsm(u, u, cosa); // u - u * cosa // u * (1 - cosa);
        var t = new <#= vecTypeName4 #>(u * sina, cosa);

        var ppn = new <#= typ.maskType #>3_mt(default, default, <#= typ.maskNeg #>).as<#= typ.compType #>();
        var npp = new <#= typ.maskType #>3_mt(<#= typ.maskNeg #>, default, default).as<#= typ.compType #>();
        var pnp = new <#= typ.maskType #>3_mt(default, <#= typ.maskNeg #>, default).as<#= typ.compType #>();

        return new(
            u.xxx.fma(u_inv_cosa, t.wzy ^ ppn),
            u.yyy.fma(u_inv_cosa, t.zwx ^ npp),
            u.zzz.fma(u_inv_cosa, t.yxw ^ pnp)
        );
    }
    
    /// <summary>
    /// Returns a <#= typeName #> matrix representing a rotation around a unit axis by an angle in radians.
    /// The rotation direction is clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="axis">The rotation axis</param>
    /// <param name="angle">The angle of rotation in radians</param>
    /// <returns>The <#= typeName #> matrix representing the rotation around an axis.</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> AxisAngle(<#= vecTypeName #> axis, <#= typ.compType #> angle)
    {
        angle.sincos(out var sina, out var cosa);
        var u = axis;
        var u_inv_cosa = math_mt.fsm(u, u, cosa); // u - u * cosa // u * (1 - cosa);
        var t = new <#= vecTypeName4 #>(u * sina, cosa);

        var ppn = new <#= typ.maskType #>3_mt(default, default, <#= typ.maskNeg #>).as<#= typ.compType #>();
        var npp = new <#= typ.maskType #>3_mt(<#= typ.maskNeg #>, default, default).as<#= typ.compType #>();
        var pnp = new <#= typ.maskType #>3_mt(default, <#= typ.maskNeg #>, default).as<#= typ.compType #>();

        return new(
            u.xxx.fma(u_inv_cosa, t.wzy ^ ppn),
            u.yyy.fma(u_inv_cosa, t.zwx ^ npp),
            u.zzz.fma(u_inv_cosa, t.yxw ^ pnp)
        );
    }

    /// <summary>
    /// Returns a <#= typeName #> rotation matrix constructed by first performing a rotation around the x-axis, then the y-axis and finally the z-axis.
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="xyz">A <#= vecTypeName #> vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The <#= typeName #> rotation matrix of the Euler angle rotation in x-y-z order</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> EulerXYZ(<#= vecTypeName #> xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            <#= typ.arithCast #>(c.y * c.z),  <#= typ.arithCast #>(c.z * s.x * s.y - c.x * s.z),    <#= typ.arithCast #>(c.x * c.z * s.y + s.x * s.z),
            <#= typ.arithCast #>(c.y * s.z),  <#= typ.arithCast #>(c.x * c.z + s.x * s.y * s.z),    <#= typ.arithCast #>(c.x * s.y * s.z - c.z * s.x),
            <#= typ.arithCast #>(-s.y),       <#= typ.arithCast #>(c.y * s.x),                      <#= typ.arithCast #>(c.x * c.y)
        );
    }

    /// <summary>
    /// Returns a <#= typeName #> rotation matrix constructed by first performing a rotation around the x-axis, then the z-axis and finally the y-axis.
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="xyz">A <#= vecTypeName #> vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The <#= typeName #> rotation matrix of the Euler angle rotation in x-z-y order</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> EulerXZY(<#= vecTypeName #> xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            <#= typ.arithCast #>(c.y * c.z),  <#= typ.arithCast #>(s.x * s.y - c.x * c.y * s.z),    <#= typ.arithCast #>(c.x * s.y + c.y * s.x * s.z),
            <#= typ.arithCast #>(s.z),        <#= typ.arithCast #>(c.x * c.z),                      <#= typ.arithCast #>(-c.z * s.x),                 
            <#= typ.arithCast #>(-c.z * s.y), <#= typ.arithCast #>(c.y * s.x + c.x * s.y * s.z),    <#= typ.arithCast #>(c.x * c.y - s.x * s.y * s.z)
        );
    }

    /// <summary>
    /// Returns a <#= typeName #> rotation matrix constructed by first performing a rotation around the y-axis, then the x-axis and finally the z-axis.
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="xyz">A <#= vecTypeName #> vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The <#= typeName #> rotation matrix of the Euler angle rotation in y-x-z order</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> EulerYXZ(<#= vecTypeName #> xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            <#= typ.arithCast #>(c.y * c.z - s.x * s.y * s.z),    <#= typ.arithCast #>(-c.x * s.z), <#= typ.arithCast #>(c.z * s.y + c.y * s.x * s.z),
            <#= typ.arithCast #>(c.z * s.x * s.y + c.y * s.z),    <#= typ.arithCast #>(c.x * c.z),  <#= typ.arithCast #>(s.y * s.z - c.y * c.z * s.x),
            <#= typ.arithCast #>(-c.x * s.y),                     <#= typ.arithCast #>(s.x),        <#= typ.arithCast #>(c.x * c.y)
        );
    }

    /// <summary>
    /// Returns a <#= typeName #> rotation matrix constructed by first performing a rotation around the y-axis, then the z-axis and finally the x-axis.
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="xyz">A <#= vecTypeName #> vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The <#= typeName #> rotation matrix of the Euler angle rotation in y-z-x order</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> EulerYZX(<#= vecTypeName #> xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            <#= typ.arithCast #>(c.y * c.z),                      <#= typ.arithCast #>(-s.z),       <#= typ.arithCast #>(c.z * s.y),                  
            <#= typ.arithCast #>(s.x * s.y + c.x * c.y * s.z),    <#= typ.arithCast #>(c.x * c.z),  <#= typ.arithCast #>(c.x * s.y * s.z - c.y * s.x),
            <#= typ.arithCast #>(c.y * s.x * s.z - c.x * s.y),    <#= typ.arithCast #>(c.z * s.x),  <#= typ.arithCast #>(c.x * c.y + s.x * s.y * s.z)
        );
    }

    /// <summary>
    /// Returns a <#= typeName #> rotation matrix constructed by first performing a rotation around the z-axis, then the x-axis and finally the y-axis.
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="xyz">A <#= vecTypeName #> vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The <#= typeName #> rotation matrix of the Euler angle rotation in z-x-y order</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> EulerZXY(<#= vecTypeName #> xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            <#= typ.arithCast #>(c.y * c.z + s.x * s.y * s.z),    <#= typ.arithCast #>(c.z * s.x * s.y - c.y * s.z),    <#= typ.arithCast #>(c.x * s.y),
            <#= typ.arithCast #>(c.x * s.z),                      <#= typ.arithCast #>(c.x * c.z),                      <#= typ.arithCast #>(-s.x),     
            <#= typ.arithCast #>(c.y * s.x * s.z - c.z * s.y),    <#= typ.arithCast #>(c.y * c.z * s.x + s.y * s.z),    <#= typ.arithCast #>(c.x * c.y)
        );
    }

    /// <summary>
    /// Returns a <#= typeName #> rotation matrix constructed by first performing a rotation around the z-axis, then the y-axis and finally the x-axis
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin
    /// </summary>
    /// <param name="xyz">A <#= vecTypeName #> vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The <#= typeName #> rotation matrix of the Euler angle rotation in z-y-x order</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> EulerZYX(<#= vecTypeName #> xyz)
    {
        xyz.sincos(out var s, out var c);
        return new(
            <#= typ.arithCast #>(c.y * c.z),                      <#= typ.arithCast #>(-c.y * s.z),                     <#= typ.arithCast #>(s.y),       
            <#= typ.arithCast #>(c.z * s.x * s.y + c.x * s.z),    <#= typ.arithCast #>(c.x * c.z - s.x * s.y * s.z),    <#= typ.arithCast #>(-c.y * s.x),
            <#= typ.arithCast #>(s.x * s.z - c.x * c.z * s.y),    <#= typ.arithCast #>(c.z * s.x + c.x * s.y * s.z),    <#= typ.arithCast #>(c.x * c.y)
        );
    }

    /// <summary>Returns a <#= typeName #> matrix that rotates around the x-axis by a given number of radians</summary>
    /// <param name="angle">The clockwise rotation angle when looking along the x-axis towards the origin in radians</param>
    /// <returns>The <#= typeName #> rotation matrix that rotates around the x-axis</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> RotateX(<#= scalarName #> angle)
    {
        angle.sincos(out var s, out var c);
        return new(
            <#= typ.one #>, default, default,
            default, c,     -s,
            default, s,     c
        );
    }

    /// <summary>Returns a <#= typeName #> matrix that rotates around the y-axis by a given number of radians</summary>
    /// <param name="angle">The clockwise rotation angle when looking along the y-axis towards the origin in radians</param>
    /// <returns>The <#= typeName #> rotation matrix that rotates around the y-axis</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> RotateY(<#= scalarName #> angle)
    {
        angle.sincos(out var s, out var c);
        return new(
            c,     default, s,
            default, <#= typ.one #>, default,
            -s,    default, c
        );
    }

    /// <summary>Returns a <#= typeName #> matrix that rotates around the z-axis by a given number of radians</summary>
    /// <param name="angle">The clockwise rotation angle when looking along the z-axis towards the origin in radians</param>
    /// <returns>The <#= typeName #> rotation matrix that rotates around the z-axis</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> RotateZ(<#= scalarName #> angle)
    {
        angle.sincos(out var s, out var c);
        return new(
            c,     -s,    default,
            s,     c,     default,
            default, default, <#= typ.one #>
        );
    }
<#
            }
#>
    
    /// <summary>Returns a <#= typeName #> matrix representing a uniform scaling of all axes by s</summary>
    /// <param name="s">The uniform scaling factor</param>
    /// <returns>The <#= typeName #> matrix representing a uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> Scale(<#= scalarName #> s) => new(
        s,    default, default,
        default, s,    default,
        default, default, s
    );
    
    /// <summary>Returns a <#= typeName #> matrix representing a non-uniform axis scaling by x, y and z</summary>
    /// <param name="x">The x-axis scaling factor</param>
    /// <param name="y">The y-axis scaling factor</param>
    /// <param name="z">The z-axis scaling factor</param>
    /// <returns>The <#= typeName #> rotation matrix representing a non-uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> Scale(<#= scalarName #> x, <#= scalarName #> y, <#= scalarName #> z) => new(
        x,    default, default,
        default, y,    default,
        default, default, z
    );

    /// <summary>Returns a <#= typeName #> matrix representing a non-uniform axis scaling by the components of the <#= vecTypeName #> vector v</summary>
    /// <param name="v">The vector containing non-uniform scaling factors</param>
    /// <returns>The <#= typeName #> rotation matrix representing a non-uniform scale</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> Scale(<#= vecTypeName #> v) => new(
        v.x,    default, default,
        default, v.y,    default,
        default, default, v.z
    );

    /// <summary>
    /// Converts a <#= typeName4x4 #> to a <#= typeName #>
    /// </summary>
    /// <param name="m4x4">The <#= typeName4x4 #> to convert to a <#= typeName #></param>
    /// <returns>The <#= typeName #> constructed from the upper left 3x3 of the input <#= typeName4x4 #> matrix</returns>
    [MethodImpl(256 | 512)]
    public static explicit operator <#= typeName #>(<#= typeName4x4 #> m4x4) => new(m4x4);
}

[Ex]
public static partial class math_mt
{
<#
            if (typ.f)
            {
#>

    /// <summary>Returns the <#= typeName #> full inverse of a <#= typeName #> matrix</summary>
    /// <param name="m">Matrix to invert</param>
    /// <returns>The inverted matrix</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> inverse([This] <#= typeName #> m)
    {
        var (c0, c1, c2) = m;
        // var t0 = new <#= vecTypeName #>(c1.x, c2.x, c0.x);
        // var t1 = new <#= vecTypeName #>(c1.y, c2.y, c0.y);
        // var t2 = new <#= vecTypeName #>(c1.z, c2.z, c0.z);
        var (t0, t1, t2) = transpose(new <#= typeName #>(c1, c2, c0));
    
        // var m0 = t1 * t2.yzx - t1.yzx * t2;
        // var m1 = t0.yzx * t2 - t0 * t2.yzx;
        // var m2 = t0 * t1.yzx - t0.yzx * t1;
        var m0 = fsm(t1 * t2.yzx, t1.yzx, t2);
        var m1 = fsm(t0.yzx * t2, t0, t2.yzx);
        var m2 = fsm(t0 * t1.yzx, t0.yzx, t1);
    
        var rcpDet = <#= typ.arithCast #>(<#= typ.one #> / csum(t0.zxy * m0));
        return new <#= typeName #>(m0, m1, m2) * rcpDet;
    }

    // <summary>Returns the determinant of a <#= typeName #> matrix</summary>
    /// <param name="m">Matrix to use when computing determinant</param>
    /// <returns>The determinant of the matrix</returns>
    [MethodImpl(256 | 512)]
    public static <#= scalarName #> determinant([This] <#= typeName #> m)
    {
        var (c0, c1, c2) = m;

        // var m00 = c1.y * c2.z - c1.z * c2.y;
        // var m01 = c0.y * c2.z - c0.z * c2.y;
        // var m02 = c0.y * c1.z - c0.z * c1.y;
        var m00 = fsm(c1.y * c2.z, c1.z, c2.y);
        var m01 = fsm(c0.y * c2.z, c0.z, c2.y);
        var m02 = fsm(c0.y * c1.z, c0.z, c1.y);

        //var r = c0.x * m00 - c1.x * m01 + c2.x * m02;
        var r = fam(fsm(c0.x * m00, c1.x, m01), c2.x, m02);

        return r;
    }
<#
            }
#>
}

#endregion // <#= typeName #>
<#
        }
    }
#>
