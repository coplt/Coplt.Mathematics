// generated by template, do not modify manually

namespace Coplt.Mathematics.Simt;

#region float2x2_mt4

public partial struct float2x2_mt4 : IComparable<float2x2_mt4>, IComparable
    , IComparisonOperators<float2x2_mt4, float2x2_mt4, bool>
    , IComparisonOperators<float2x2_mt4, float2x2_mt4, b32m2x2_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is float2x2_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(float2x2_mt4)}");
    }

    static bool IComparisonOperators<float2x2_mt4, float2x2_mt4, bool>.operator <(float2x2_mt4 left, float2x2_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float2x2_mt4, float2x2_mt4, bool>.operator >(float2x2_mt4 left, float2x2_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float2x2_mt4, float2x2_mt4, bool>.operator <=(float2x2_mt4 left, float2x2_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float2x2_mt4, float2x2_mt4, bool>.operator >=(float2x2_mt4 left, float2x2_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(float2x2_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m2x2_mt4 operator <(float2x2_mt4 left, float2x2_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b32m2x2_mt4 operator >(float2x2_mt4 left, float2x2_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b32m2x2_mt4 operator <=(float2x2_mt4 left, float2x2_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b32m2x2_mt4 operator >=(float2x2_mt4 left, float2x2_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(float2x2_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(float2x2_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(float2x2_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(float2x2_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(float2x2_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(float2x2_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(float2x2_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(float2x2_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // float2x2_mt4

#region float2x2_mt8

public partial struct float2x2_mt8 : IComparable<float2x2_mt8>, IComparable
    , IComparisonOperators<float2x2_mt8, float2x2_mt8, bool>
    , IComparisonOperators<float2x2_mt8, float2x2_mt8, b32m2x2_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is float2x2_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(float2x2_mt8)}");
    }

    static bool IComparisonOperators<float2x2_mt8, float2x2_mt8, bool>.operator <(float2x2_mt8 left, float2x2_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float2x2_mt8, float2x2_mt8, bool>.operator >(float2x2_mt8 left, float2x2_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float2x2_mt8, float2x2_mt8, bool>.operator <=(float2x2_mt8 left, float2x2_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float2x2_mt8, float2x2_mt8, bool>.operator >=(float2x2_mt8 left, float2x2_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(float2x2_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m2x2_mt8 operator <(float2x2_mt8 left, float2x2_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b32m2x2_mt8 operator >(float2x2_mt8 left, float2x2_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b32m2x2_mt8 operator <=(float2x2_mt8 left, float2x2_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b32m2x2_mt8 operator >=(float2x2_mt8 left, float2x2_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(float2x2_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(float2x2_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(float2x2_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(float2x2_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(float2x2_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(float2x2_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(float2x2_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(float2x2_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // float2x2_mt8

#region float2x2_mt16

public partial struct float2x2_mt16 : IComparable<float2x2_mt16>, IComparable
    , IComparisonOperators<float2x2_mt16, float2x2_mt16, bool>
    , IComparisonOperators<float2x2_mt16, float2x2_mt16, b32m2x2_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is float2x2_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(float2x2_mt16)}");
    }

    static bool IComparisonOperators<float2x2_mt16, float2x2_mt16, bool>.operator <(float2x2_mt16 left, float2x2_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float2x2_mt16, float2x2_mt16, bool>.operator >(float2x2_mt16 left, float2x2_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float2x2_mt16, float2x2_mt16, bool>.operator <=(float2x2_mt16 left, float2x2_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float2x2_mt16, float2x2_mt16, bool>.operator >=(float2x2_mt16 left, float2x2_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(float2x2_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m2x2_mt16 operator <(float2x2_mt16 left, float2x2_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b32m2x2_mt16 operator >(float2x2_mt16 left, float2x2_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b32m2x2_mt16 operator <=(float2x2_mt16 left, float2x2_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b32m2x2_mt16 operator >=(float2x2_mt16 left, float2x2_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(float2x2_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(float2x2_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(float2x2_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(float2x2_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(float2x2_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(float2x2_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(float2x2_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(float2x2_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // float2x2_mt16

#region float2x3_mt4

public partial struct float2x3_mt4 : IComparable<float2x3_mt4>, IComparable
    , IComparisonOperators<float2x3_mt4, float2x3_mt4, bool>
    , IComparisonOperators<float2x3_mt4, float2x3_mt4, b32m2x3_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is float2x3_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(float2x3_mt4)}");
    }

    static bool IComparisonOperators<float2x3_mt4, float2x3_mt4, bool>.operator <(float2x3_mt4 left, float2x3_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float2x3_mt4, float2x3_mt4, bool>.operator >(float2x3_mt4 left, float2x3_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float2x3_mt4, float2x3_mt4, bool>.operator <=(float2x3_mt4 left, float2x3_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float2x3_mt4, float2x3_mt4, bool>.operator >=(float2x3_mt4 left, float2x3_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(float2x3_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m2x3_mt4 operator <(float2x3_mt4 left, float2x3_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b32m2x3_mt4 operator >(float2x3_mt4 left, float2x3_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b32m2x3_mt4 operator <=(float2x3_mt4 left, float2x3_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b32m2x3_mt4 operator >=(float2x3_mt4 left, float2x3_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(float2x3_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(float2x3_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(float2x3_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(float2x3_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(float2x3_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(float2x3_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(float2x3_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(float2x3_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // float2x3_mt4

#region float2x3_mt8

public partial struct float2x3_mt8 : IComparable<float2x3_mt8>, IComparable
    , IComparisonOperators<float2x3_mt8, float2x3_mt8, bool>
    , IComparisonOperators<float2x3_mt8, float2x3_mt8, b32m2x3_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is float2x3_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(float2x3_mt8)}");
    }

    static bool IComparisonOperators<float2x3_mt8, float2x3_mt8, bool>.operator <(float2x3_mt8 left, float2x3_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float2x3_mt8, float2x3_mt8, bool>.operator >(float2x3_mt8 left, float2x3_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float2x3_mt8, float2x3_mt8, bool>.operator <=(float2x3_mt8 left, float2x3_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float2x3_mt8, float2x3_mt8, bool>.operator >=(float2x3_mt8 left, float2x3_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(float2x3_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m2x3_mt8 operator <(float2x3_mt8 left, float2x3_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b32m2x3_mt8 operator >(float2x3_mt8 left, float2x3_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b32m2x3_mt8 operator <=(float2x3_mt8 left, float2x3_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b32m2x3_mt8 operator >=(float2x3_mt8 left, float2x3_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(float2x3_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(float2x3_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(float2x3_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(float2x3_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(float2x3_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(float2x3_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(float2x3_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(float2x3_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // float2x3_mt8

#region float2x3_mt16

public partial struct float2x3_mt16 : IComparable<float2x3_mt16>, IComparable
    , IComparisonOperators<float2x3_mt16, float2x3_mt16, bool>
    , IComparisonOperators<float2x3_mt16, float2x3_mt16, b32m2x3_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is float2x3_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(float2x3_mt16)}");
    }

    static bool IComparisonOperators<float2x3_mt16, float2x3_mt16, bool>.operator <(float2x3_mt16 left, float2x3_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float2x3_mt16, float2x3_mt16, bool>.operator >(float2x3_mt16 left, float2x3_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float2x3_mt16, float2x3_mt16, bool>.operator <=(float2x3_mt16 left, float2x3_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float2x3_mt16, float2x3_mt16, bool>.operator >=(float2x3_mt16 left, float2x3_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(float2x3_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m2x3_mt16 operator <(float2x3_mt16 left, float2x3_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b32m2x3_mt16 operator >(float2x3_mt16 left, float2x3_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b32m2x3_mt16 operator <=(float2x3_mt16 left, float2x3_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b32m2x3_mt16 operator >=(float2x3_mt16 left, float2x3_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(float2x3_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(float2x3_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(float2x3_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(float2x3_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(float2x3_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(float2x3_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(float2x3_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(float2x3_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // float2x3_mt16

#region float2x4_mt4

public partial struct float2x4_mt4 : IComparable<float2x4_mt4>, IComparable
    , IComparisonOperators<float2x4_mt4, float2x4_mt4, bool>
    , IComparisonOperators<float2x4_mt4, float2x4_mt4, b32m2x4_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is float2x4_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(float2x4_mt4)}");
    }

    static bool IComparisonOperators<float2x4_mt4, float2x4_mt4, bool>.operator <(float2x4_mt4 left, float2x4_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float2x4_mt4, float2x4_mt4, bool>.operator >(float2x4_mt4 left, float2x4_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float2x4_mt4, float2x4_mt4, bool>.operator <=(float2x4_mt4 left, float2x4_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float2x4_mt4, float2x4_mt4, bool>.operator >=(float2x4_mt4 left, float2x4_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(float2x4_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m2x4_mt4 operator <(float2x4_mt4 left, float2x4_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b32m2x4_mt4 operator >(float2x4_mt4 left, float2x4_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b32m2x4_mt4 operator <=(float2x4_mt4 left, float2x4_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b32m2x4_mt4 operator >=(float2x4_mt4 left, float2x4_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(float2x4_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(float2x4_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(float2x4_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(float2x4_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(float2x4_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(float2x4_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(float2x4_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(float2x4_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // float2x4_mt4

#region float2x4_mt8

public partial struct float2x4_mt8 : IComparable<float2x4_mt8>, IComparable
    , IComparisonOperators<float2x4_mt8, float2x4_mt8, bool>
    , IComparisonOperators<float2x4_mt8, float2x4_mt8, b32m2x4_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is float2x4_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(float2x4_mt8)}");
    }

    static bool IComparisonOperators<float2x4_mt8, float2x4_mt8, bool>.operator <(float2x4_mt8 left, float2x4_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float2x4_mt8, float2x4_mt8, bool>.operator >(float2x4_mt8 left, float2x4_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float2x4_mt8, float2x4_mt8, bool>.operator <=(float2x4_mt8 left, float2x4_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float2x4_mt8, float2x4_mt8, bool>.operator >=(float2x4_mt8 left, float2x4_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(float2x4_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m2x4_mt8 operator <(float2x4_mt8 left, float2x4_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b32m2x4_mt8 operator >(float2x4_mt8 left, float2x4_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b32m2x4_mt8 operator <=(float2x4_mt8 left, float2x4_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b32m2x4_mt8 operator >=(float2x4_mt8 left, float2x4_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(float2x4_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(float2x4_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(float2x4_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(float2x4_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(float2x4_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(float2x4_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(float2x4_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(float2x4_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // float2x4_mt8

#region float2x4_mt16

public partial struct float2x4_mt16 : IComparable<float2x4_mt16>, IComparable
    , IComparisonOperators<float2x4_mt16, float2x4_mt16, bool>
    , IComparisonOperators<float2x4_mt16, float2x4_mt16, b32m2x4_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is float2x4_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(float2x4_mt16)}");
    }

    static bool IComparisonOperators<float2x4_mt16, float2x4_mt16, bool>.operator <(float2x4_mt16 left, float2x4_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float2x4_mt16, float2x4_mt16, bool>.operator >(float2x4_mt16 left, float2x4_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float2x4_mt16, float2x4_mt16, bool>.operator <=(float2x4_mt16 left, float2x4_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float2x4_mt16, float2x4_mt16, bool>.operator >=(float2x4_mt16 left, float2x4_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(float2x4_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m2x4_mt16 operator <(float2x4_mt16 left, float2x4_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b32m2x4_mt16 operator >(float2x4_mt16 left, float2x4_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b32m2x4_mt16 operator <=(float2x4_mt16 left, float2x4_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b32m2x4_mt16 operator >=(float2x4_mt16 left, float2x4_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(float2x4_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(float2x4_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(float2x4_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(float2x4_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(float2x4_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(float2x4_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(float2x4_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(float2x4_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // float2x4_mt16

#region float3x2_mt4

public partial struct float3x2_mt4 : IComparable<float3x2_mt4>, IComparable
    , IComparisonOperators<float3x2_mt4, float3x2_mt4, bool>
    , IComparisonOperators<float3x2_mt4, float3x2_mt4, b32m3x2_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is float3x2_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(float3x2_mt4)}");
    }

    static bool IComparisonOperators<float3x2_mt4, float3x2_mt4, bool>.operator <(float3x2_mt4 left, float3x2_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float3x2_mt4, float3x2_mt4, bool>.operator >(float3x2_mt4 left, float3x2_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float3x2_mt4, float3x2_mt4, bool>.operator <=(float3x2_mt4 left, float3x2_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float3x2_mt4, float3x2_mt4, bool>.operator >=(float3x2_mt4 left, float3x2_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(float3x2_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m3x2_mt4 operator <(float3x2_mt4 left, float3x2_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b32m3x2_mt4 operator >(float3x2_mt4 left, float3x2_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b32m3x2_mt4 operator <=(float3x2_mt4 left, float3x2_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b32m3x2_mt4 operator >=(float3x2_mt4 left, float3x2_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(float3x2_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(float3x2_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(float3x2_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(float3x2_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(float3x2_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(float3x2_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(float3x2_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(float3x2_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // float3x2_mt4

#region float3x2_mt8

public partial struct float3x2_mt8 : IComparable<float3x2_mt8>, IComparable
    , IComparisonOperators<float3x2_mt8, float3x2_mt8, bool>
    , IComparisonOperators<float3x2_mt8, float3x2_mt8, b32m3x2_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is float3x2_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(float3x2_mt8)}");
    }

    static bool IComparisonOperators<float3x2_mt8, float3x2_mt8, bool>.operator <(float3x2_mt8 left, float3x2_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float3x2_mt8, float3x2_mt8, bool>.operator >(float3x2_mt8 left, float3x2_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float3x2_mt8, float3x2_mt8, bool>.operator <=(float3x2_mt8 left, float3x2_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float3x2_mt8, float3x2_mt8, bool>.operator >=(float3x2_mt8 left, float3x2_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(float3x2_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m3x2_mt8 operator <(float3x2_mt8 left, float3x2_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b32m3x2_mt8 operator >(float3x2_mt8 left, float3x2_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b32m3x2_mt8 operator <=(float3x2_mt8 left, float3x2_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b32m3x2_mt8 operator >=(float3x2_mt8 left, float3x2_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(float3x2_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(float3x2_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(float3x2_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(float3x2_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(float3x2_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(float3x2_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(float3x2_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(float3x2_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // float3x2_mt8

#region float3x2_mt16

public partial struct float3x2_mt16 : IComparable<float3x2_mt16>, IComparable
    , IComparisonOperators<float3x2_mt16, float3x2_mt16, bool>
    , IComparisonOperators<float3x2_mt16, float3x2_mt16, b32m3x2_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is float3x2_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(float3x2_mt16)}");
    }

    static bool IComparisonOperators<float3x2_mt16, float3x2_mt16, bool>.operator <(float3x2_mt16 left, float3x2_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float3x2_mt16, float3x2_mt16, bool>.operator >(float3x2_mt16 left, float3x2_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float3x2_mt16, float3x2_mt16, bool>.operator <=(float3x2_mt16 left, float3x2_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float3x2_mt16, float3x2_mt16, bool>.operator >=(float3x2_mt16 left, float3x2_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(float3x2_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m3x2_mt16 operator <(float3x2_mt16 left, float3x2_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b32m3x2_mt16 operator >(float3x2_mt16 left, float3x2_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b32m3x2_mt16 operator <=(float3x2_mt16 left, float3x2_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b32m3x2_mt16 operator >=(float3x2_mt16 left, float3x2_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(float3x2_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(float3x2_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(float3x2_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(float3x2_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(float3x2_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(float3x2_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(float3x2_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(float3x2_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // float3x2_mt16

#region float3x3_mt4

public partial struct float3x3_mt4 : IComparable<float3x3_mt4>, IComparable
    , IComparisonOperators<float3x3_mt4, float3x3_mt4, bool>
    , IComparisonOperators<float3x3_mt4, float3x3_mt4, b32m3x3_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is float3x3_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(float3x3_mt4)}");
    }

    static bool IComparisonOperators<float3x3_mt4, float3x3_mt4, bool>.operator <(float3x3_mt4 left, float3x3_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float3x3_mt4, float3x3_mt4, bool>.operator >(float3x3_mt4 left, float3x3_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float3x3_mt4, float3x3_mt4, bool>.operator <=(float3x3_mt4 left, float3x3_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float3x3_mt4, float3x3_mt4, bool>.operator >=(float3x3_mt4 left, float3x3_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(float3x3_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m3x3_mt4 operator <(float3x3_mt4 left, float3x3_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b32m3x3_mt4 operator >(float3x3_mt4 left, float3x3_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b32m3x3_mt4 operator <=(float3x3_mt4 left, float3x3_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b32m3x3_mt4 operator >=(float3x3_mt4 left, float3x3_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(float3x3_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(float3x3_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(float3x3_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(float3x3_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(float3x3_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(float3x3_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(float3x3_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(float3x3_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // float3x3_mt4

#region float3x3_mt8

public partial struct float3x3_mt8 : IComparable<float3x3_mt8>, IComparable
    , IComparisonOperators<float3x3_mt8, float3x3_mt8, bool>
    , IComparisonOperators<float3x3_mt8, float3x3_mt8, b32m3x3_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is float3x3_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(float3x3_mt8)}");
    }

    static bool IComparisonOperators<float3x3_mt8, float3x3_mt8, bool>.operator <(float3x3_mt8 left, float3x3_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float3x3_mt8, float3x3_mt8, bool>.operator >(float3x3_mt8 left, float3x3_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float3x3_mt8, float3x3_mt8, bool>.operator <=(float3x3_mt8 left, float3x3_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float3x3_mt8, float3x3_mt8, bool>.operator >=(float3x3_mt8 left, float3x3_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(float3x3_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m3x3_mt8 operator <(float3x3_mt8 left, float3x3_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b32m3x3_mt8 operator >(float3x3_mt8 left, float3x3_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b32m3x3_mt8 operator <=(float3x3_mt8 left, float3x3_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b32m3x3_mt8 operator >=(float3x3_mt8 left, float3x3_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(float3x3_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(float3x3_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(float3x3_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(float3x3_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(float3x3_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(float3x3_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(float3x3_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(float3x3_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // float3x3_mt8

#region float3x3_mt16

public partial struct float3x3_mt16 : IComparable<float3x3_mt16>, IComparable
    , IComparisonOperators<float3x3_mt16, float3x3_mt16, bool>
    , IComparisonOperators<float3x3_mt16, float3x3_mt16, b32m3x3_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is float3x3_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(float3x3_mt16)}");
    }

    static bool IComparisonOperators<float3x3_mt16, float3x3_mt16, bool>.operator <(float3x3_mt16 left, float3x3_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float3x3_mt16, float3x3_mt16, bool>.operator >(float3x3_mt16 left, float3x3_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float3x3_mt16, float3x3_mt16, bool>.operator <=(float3x3_mt16 left, float3x3_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float3x3_mt16, float3x3_mt16, bool>.operator >=(float3x3_mt16 left, float3x3_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(float3x3_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m3x3_mt16 operator <(float3x3_mt16 left, float3x3_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b32m3x3_mt16 operator >(float3x3_mt16 left, float3x3_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b32m3x3_mt16 operator <=(float3x3_mt16 left, float3x3_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b32m3x3_mt16 operator >=(float3x3_mt16 left, float3x3_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(float3x3_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(float3x3_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(float3x3_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(float3x3_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(float3x3_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(float3x3_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(float3x3_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(float3x3_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // float3x3_mt16

#region float3x4_mt4

public partial struct float3x4_mt4 : IComparable<float3x4_mt4>, IComparable
    , IComparisonOperators<float3x4_mt4, float3x4_mt4, bool>
    , IComparisonOperators<float3x4_mt4, float3x4_mt4, b32m3x4_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is float3x4_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(float3x4_mt4)}");
    }

    static bool IComparisonOperators<float3x4_mt4, float3x4_mt4, bool>.operator <(float3x4_mt4 left, float3x4_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float3x4_mt4, float3x4_mt4, bool>.operator >(float3x4_mt4 left, float3x4_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float3x4_mt4, float3x4_mt4, bool>.operator <=(float3x4_mt4 left, float3x4_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float3x4_mt4, float3x4_mt4, bool>.operator >=(float3x4_mt4 left, float3x4_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(float3x4_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m3x4_mt4 operator <(float3x4_mt4 left, float3x4_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b32m3x4_mt4 operator >(float3x4_mt4 left, float3x4_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b32m3x4_mt4 operator <=(float3x4_mt4 left, float3x4_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b32m3x4_mt4 operator >=(float3x4_mt4 left, float3x4_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(float3x4_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(float3x4_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(float3x4_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(float3x4_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(float3x4_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(float3x4_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(float3x4_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(float3x4_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // float3x4_mt4

#region float3x4_mt8

public partial struct float3x4_mt8 : IComparable<float3x4_mt8>, IComparable
    , IComparisonOperators<float3x4_mt8, float3x4_mt8, bool>
    , IComparisonOperators<float3x4_mt8, float3x4_mt8, b32m3x4_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is float3x4_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(float3x4_mt8)}");
    }

    static bool IComparisonOperators<float3x4_mt8, float3x4_mt8, bool>.operator <(float3x4_mt8 left, float3x4_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float3x4_mt8, float3x4_mt8, bool>.operator >(float3x4_mt8 left, float3x4_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float3x4_mt8, float3x4_mt8, bool>.operator <=(float3x4_mt8 left, float3x4_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float3x4_mt8, float3x4_mt8, bool>.operator >=(float3x4_mt8 left, float3x4_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(float3x4_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m3x4_mt8 operator <(float3x4_mt8 left, float3x4_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b32m3x4_mt8 operator >(float3x4_mt8 left, float3x4_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b32m3x4_mt8 operator <=(float3x4_mt8 left, float3x4_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b32m3x4_mt8 operator >=(float3x4_mt8 left, float3x4_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(float3x4_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(float3x4_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(float3x4_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(float3x4_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(float3x4_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(float3x4_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(float3x4_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(float3x4_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // float3x4_mt8

#region float3x4_mt16

public partial struct float3x4_mt16 : IComparable<float3x4_mt16>, IComparable
    , IComparisonOperators<float3x4_mt16, float3x4_mt16, bool>
    , IComparisonOperators<float3x4_mt16, float3x4_mt16, b32m3x4_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is float3x4_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(float3x4_mt16)}");
    }

    static bool IComparisonOperators<float3x4_mt16, float3x4_mt16, bool>.operator <(float3x4_mt16 left, float3x4_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float3x4_mt16, float3x4_mt16, bool>.operator >(float3x4_mt16 left, float3x4_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float3x4_mt16, float3x4_mt16, bool>.operator <=(float3x4_mt16 left, float3x4_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float3x4_mt16, float3x4_mt16, bool>.operator >=(float3x4_mt16 left, float3x4_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(float3x4_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m3x4_mt16 operator <(float3x4_mt16 left, float3x4_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b32m3x4_mt16 operator >(float3x4_mt16 left, float3x4_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b32m3x4_mt16 operator <=(float3x4_mt16 left, float3x4_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b32m3x4_mt16 operator >=(float3x4_mt16 left, float3x4_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(float3x4_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(float3x4_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(float3x4_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(float3x4_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(float3x4_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(float3x4_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(float3x4_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(float3x4_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // float3x4_mt16

#region float4x2_mt4

public partial struct float4x2_mt4 : IComparable<float4x2_mt4>, IComparable
    , IComparisonOperators<float4x2_mt4, float4x2_mt4, bool>
    , IComparisonOperators<float4x2_mt4, float4x2_mt4, b32m4x2_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is float4x2_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(float4x2_mt4)}");
    }

    static bool IComparisonOperators<float4x2_mt4, float4x2_mt4, bool>.operator <(float4x2_mt4 left, float4x2_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float4x2_mt4, float4x2_mt4, bool>.operator >(float4x2_mt4 left, float4x2_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float4x2_mt4, float4x2_mt4, bool>.operator <=(float4x2_mt4 left, float4x2_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float4x2_mt4, float4x2_mt4, bool>.operator >=(float4x2_mt4 left, float4x2_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(float4x2_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m4x2_mt4 operator <(float4x2_mt4 left, float4x2_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b32m4x2_mt4 operator >(float4x2_mt4 left, float4x2_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b32m4x2_mt4 operator <=(float4x2_mt4 left, float4x2_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b32m4x2_mt4 operator >=(float4x2_mt4 left, float4x2_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(float4x2_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(float4x2_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(float4x2_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(float4x2_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(float4x2_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(float4x2_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(float4x2_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(float4x2_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // float4x2_mt4

#region float4x2_mt8

public partial struct float4x2_mt8 : IComparable<float4x2_mt8>, IComparable
    , IComparisonOperators<float4x2_mt8, float4x2_mt8, bool>
    , IComparisonOperators<float4x2_mt8, float4x2_mt8, b32m4x2_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is float4x2_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(float4x2_mt8)}");
    }

    static bool IComparisonOperators<float4x2_mt8, float4x2_mt8, bool>.operator <(float4x2_mt8 left, float4x2_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float4x2_mt8, float4x2_mt8, bool>.operator >(float4x2_mt8 left, float4x2_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float4x2_mt8, float4x2_mt8, bool>.operator <=(float4x2_mt8 left, float4x2_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float4x2_mt8, float4x2_mt8, bool>.operator >=(float4x2_mt8 left, float4x2_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(float4x2_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m4x2_mt8 operator <(float4x2_mt8 left, float4x2_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b32m4x2_mt8 operator >(float4x2_mt8 left, float4x2_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b32m4x2_mt8 operator <=(float4x2_mt8 left, float4x2_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b32m4x2_mt8 operator >=(float4x2_mt8 left, float4x2_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(float4x2_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(float4x2_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(float4x2_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(float4x2_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(float4x2_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(float4x2_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(float4x2_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(float4x2_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // float4x2_mt8

#region float4x2_mt16

public partial struct float4x2_mt16 : IComparable<float4x2_mt16>, IComparable
    , IComparisonOperators<float4x2_mt16, float4x2_mt16, bool>
    , IComparisonOperators<float4x2_mt16, float4x2_mt16, b32m4x2_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is float4x2_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(float4x2_mt16)}");
    }

    static bool IComparisonOperators<float4x2_mt16, float4x2_mt16, bool>.operator <(float4x2_mt16 left, float4x2_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float4x2_mt16, float4x2_mt16, bool>.operator >(float4x2_mt16 left, float4x2_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float4x2_mt16, float4x2_mt16, bool>.operator <=(float4x2_mt16 left, float4x2_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float4x2_mt16, float4x2_mt16, bool>.operator >=(float4x2_mt16 left, float4x2_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(float4x2_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m4x2_mt16 operator <(float4x2_mt16 left, float4x2_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b32m4x2_mt16 operator >(float4x2_mt16 left, float4x2_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b32m4x2_mt16 operator <=(float4x2_mt16 left, float4x2_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b32m4x2_mt16 operator >=(float4x2_mt16 left, float4x2_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(float4x2_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(float4x2_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(float4x2_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(float4x2_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(float4x2_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(float4x2_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(float4x2_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(float4x2_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // float4x2_mt16

#region float4x3_mt4

public partial struct float4x3_mt4 : IComparable<float4x3_mt4>, IComparable
    , IComparisonOperators<float4x3_mt4, float4x3_mt4, bool>
    , IComparisonOperators<float4x3_mt4, float4x3_mt4, b32m4x3_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is float4x3_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(float4x3_mt4)}");
    }

    static bool IComparisonOperators<float4x3_mt4, float4x3_mt4, bool>.operator <(float4x3_mt4 left, float4x3_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float4x3_mt4, float4x3_mt4, bool>.operator >(float4x3_mt4 left, float4x3_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float4x3_mt4, float4x3_mt4, bool>.operator <=(float4x3_mt4 left, float4x3_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float4x3_mt4, float4x3_mt4, bool>.operator >=(float4x3_mt4 left, float4x3_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(float4x3_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m4x3_mt4 operator <(float4x3_mt4 left, float4x3_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b32m4x3_mt4 operator >(float4x3_mt4 left, float4x3_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b32m4x3_mt4 operator <=(float4x3_mt4 left, float4x3_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b32m4x3_mt4 operator >=(float4x3_mt4 left, float4x3_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(float4x3_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(float4x3_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(float4x3_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(float4x3_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(float4x3_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(float4x3_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(float4x3_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(float4x3_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // float4x3_mt4

#region float4x3_mt8

public partial struct float4x3_mt8 : IComparable<float4x3_mt8>, IComparable
    , IComparisonOperators<float4x3_mt8, float4x3_mt8, bool>
    , IComparisonOperators<float4x3_mt8, float4x3_mt8, b32m4x3_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is float4x3_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(float4x3_mt8)}");
    }

    static bool IComparisonOperators<float4x3_mt8, float4x3_mt8, bool>.operator <(float4x3_mt8 left, float4x3_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float4x3_mt8, float4x3_mt8, bool>.operator >(float4x3_mt8 left, float4x3_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float4x3_mt8, float4x3_mt8, bool>.operator <=(float4x3_mt8 left, float4x3_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float4x3_mt8, float4x3_mt8, bool>.operator >=(float4x3_mt8 left, float4x3_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(float4x3_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m4x3_mt8 operator <(float4x3_mt8 left, float4x3_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b32m4x3_mt8 operator >(float4x3_mt8 left, float4x3_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b32m4x3_mt8 operator <=(float4x3_mt8 left, float4x3_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b32m4x3_mt8 operator >=(float4x3_mt8 left, float4x3_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(float4x3_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(float4x3_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(float4x3_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(float4x3_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(float4x3_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(float4x3_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(float4x3_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(float4x3_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // float4x3_mt8

#region float4x3_mt16

public partial struct float4x3_mt16 : IComparable<float4x3_mt16>, IComparable
    , IComparisonOperators<float4x3_mt16, float4x3_mt16, bool>
    , IComparisonOperators<float4x3_mt16, float4x3_mt16, b32m4x3_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is float4x3_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(float4x3_mt16)}");
    }

    static bool IComparisonOperators<float4x3_mt16, float4x3_mt16, bool>.operator <(float4x3_mt16 left, float4x3_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float4x3_mt16, float4x3_mt16, bool>.operator >(float4x3_mt16 left, float4x3_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float4x3_mt16, float4x3_mt16, bool>.operator <=(float4x3_mt16 left, float4x3_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float4x3_mt16, float4x3_mt16, bool>.operator >=(float4x3_mt16 left, float4x3_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(float4x3_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m4x3_mt16 operator <(float4x3_mt16 left, float4x3_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b32m4x3_mt16 operator >(float4x3_mt16 left, float4x3_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b32m4x3_mt16 operator <=(float4x3_mt16 left, float4x3_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b32m4x3_mt16 operator >=(float4x3_mt16 left, float4x3_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(float4x3_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(float4x3_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(float4x3_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(float4x3_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(float4x3_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(float4x3_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(float4x3_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(float4x3_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // float4x3_mt16

#region float4x4_mt4

public partial struct float4x4_mt4 : IComparable<float4x4_mt4>, IComparable
    , IComparisonOperators<float4x4_mt4, float4x4_mt4, bool>
    , IComparisonOperators<float4x4_mt4, float4x4_mt4, b32m4x4_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is float4x4_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(float4x4_mt4)}");
    }

    static bool IComparisonOperators<float4x4_mt4, float4x4_mt4, bool>.operator <(float4x4_mt4 left, float4x4_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float4x4_mt4, float4x4_mt4, bool>.operator >(float4x4_mt4 left, float4x4_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float4x4_mt4, float4x4_mt4, bool>.operator <=(float4x4_mt4 left, float4x4_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float4x4_mt4, float4x4_mt4, bool>.operator >=(float4x4_mt4 left, float4x4_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(float4x4_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m4x4_mt4 operator <(float4x4_mt4 left, float4x4_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b32m4x4_mt4 operator >(float4x4_mt4 left, float4x4_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b32m4x4_mt4 operator <=(float4x4_mt4 left, float4x4_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b32m4x4_mt4 operator >=(float4x4_mt4 left, float4x4_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(float4x4_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(float4x4_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(float4x4_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(float4x4_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(float4x4_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(float4x4_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(float4x4_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(float4x4_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // float4x4_mt4

#region float4x4_mt8

public partial struct float4x4_mt8 : IComparable<float4x4_mt8>, IComparable
    , IComparisonOperators<float4x4_mt8, float4x4_mt8, bool>
    , IComparisonOperators<float4x4_mt8, float4x4_mt8, b32m4x4_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is float4x4_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(float4x4_mt8)}");
    }

    static bool IComparisonOperators<float4x4_mt8, float4x4_mt8, bool>.operator <(float4x4_mt8 left, float4x4_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float4x4_mt8, float4x4_mt8, bool>.operator >(float4x4_mt8 left, float4x4_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float4x4_mt8, float4x4_mt8, bool>.operator <=(float4x4_mt8 left, float4x4_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float4x4_mt8, float4x4_mt8, bool>.operator >=(float4x4_mt8 left, float4x4_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(float4x4_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m4x4_mt8 operator <(float4x4_mt8 left, float4x4_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b32m4x4_mt8 operator >(float4x4_mt8 left, float4x4_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b32m4x4_mt8 operator <=(float4x4_mt8 left, float4x4_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b32m4x4_mt8 operator >=(float4x4_mt8 left, float4x4_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(float4x4_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(float4x4_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(float4x4_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(float4x4_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(float4x4_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(float4x4_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(float4x4_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(float4x4_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // float4x4_mt8

#region float4x4_mt16

public partial struct float4x4_mt16 : IComparable<float4x4_mt16>, IComparable
    , IComparisonOperators<float4x4_mt16, float4x4_mt16, bool>
    , IComparisonOperators<float4x4_mt16, float4x4_mt16, b32m4x4_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is float4x4_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(float4x4_mt16)}");
    }

    static bool IComparisonOperators<float4x4_mt16, float4x4_mt16, bool>.operator <(float4x4_mt16 left, float4x4_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float4x4_mt16, float4x4_mt16, bool>.operator >(float4x4_mt16 left, float4x4_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float4x4_mt16, float4x4_mt16, bool>.operator <=(float4x4_mt16 left, float4x4_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float4x4_mt16, float4x4_mt16, bool>.operator >=(float4x4_mt16 left, float4x4_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(float4x4_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m4x4_mt16 operator <(float4x4_mt16 left, float4x4_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b32m4x4_mt16 operator >(float4x4_mt16 left, float4x4_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b32m4x4_mt16 operator <=(float4x4_mt16 left, float4x4_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b32m4x4_mt16 operator >=(float4x4_mt16 left, float4x4_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(float4x4_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(float4x4_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(float4x4_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(float4x4_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(float4x4_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(float4x4_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(float4x4_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(float4x4_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // float4x4_mt16

#region double2x2_mt4

public partial struct double2x2_mt4 : IComparable<double2x2_mt4>, IComparable
    , IComparisonOperators<double2x2_mt4, double2x2_mt4, bool>
    , IComparisonOperators<double2x2_mt4, double2x2_mt4, b64m2x2_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is double2x2_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(double2x2_mt4)}");
    }

    static bool IComparisonOperators<double2x2_mt4, double2x2_mt4, bool>.operator <(double2x2_mt4 left, double2x2_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double2x2_mt4, double2x2_mt4, bool>.operator >(double2x2_mt4 left, double2x2_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double2x2_mt4, double2x2_mt4, bool>.operator <=(double2x2_mt4 left, double2x2_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double2x2_mt4, double2x2_mt4, bool>.operator >=(double2x2_mt4 left, double2x2_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(double2x2_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m2x2_mt4 operator <(double2x2_mt4 left, double2x2_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b64m2x2_mt4 operator >(double2x2_mt4 left, double2x2_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b64m2x2_mt4 operator <=(double2x2_mt4 left, double2x2_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b64m2x2_mt4 operator >=(double2x2_mt4 left, double2x2_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(double2x2_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(double2x2_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(double2x2_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(double2x2_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(double2x2_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(double2x2_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(double2x2_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(double2x2_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // double2x2_mt4

#region double2x2_mt8

public partial struct double2x2_mt8 : IComparable<double2x2_mt8>, IComparable
    , IComparisonOperators<double2x2_mt8, double2x2_mt8, bool>
    , IComparisonOperators<double2x2_mt8, double2x2_mt8, b64m2x2_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is double2x2_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(double2x2_mt8)}");
    }

    static bool IComparisonOperators<double2x2_mt8, double2x2_mt8, bool>.operator <(double2x2_mt8 left, double2x2_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double2x2_mt8, double2x2_mt8, bool>.operator >(double2x2_mt8 left, double2x2_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double2x2_mt8, double2x2_mt8, bool>.operator <=(double2x2_mt8 left, double2x2_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double2x2_mt8, double2x2_mt8, bool>.operator >=(double2x2_mt8 left, double2x2_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(double2x2_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m2x2_mt8 operator <(double2x2_mt8 left, double2x2_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b64m2x2_mt8 operator >(double2x2_mt8 left, double2x2_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b64m2x2_mt8 operator <=(double2x2_mt8 left, double2x2_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b64m2x2_mt8 operator >=(double2x2_mt8 left, double2x2_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(double2x2_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(double2x2_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(double2x2_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(double2x2_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(double2x2_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(double2x2_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(double2x2_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(double2x2_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // double2x2_mt8

#region double2x2_mt16

public partial struct double2x2_mt16 : IComparable<double2x2_mt16>, IComparable
    , IComparisonOperators<double2x2_mt16, double2x2_mt16, bool>
    , IComparisonOperators<double2x2_mt16, double2x2_mt16, b64m2x2_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is double2x2_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(double2x2_mt16)}");
    }

    static bool IComparisonOperators<double2x2_mt16, double2x2_mt16, bool>.operator <(double2x2_mt16 left, double2x2_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double2x2_mt16, double2x2_mt16, bool>.operator >(double2x2_mt16 left, double2x2_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double2x2_mt16, double2x2_mt16, bool>.operator <=(double2x2_mt16 left, double2x2_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double2x2_mt16, double2x2_mt16, bool>.operator >=(double2x2_mt16 left, double2x2_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(double2x2_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m2x2_mt16 operator <(double2x2_mt16 left, double2x2_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b64m2x2_mt16 operator >(double2x2_mt16 left, double2x2_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b64m2x2_mt16 operator <=(double2x2_mt16 left, double2x2_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b64m2x2_mt16 operator >=(double2x2_mt16 left, double2x2_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(double2x2_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(double2x2_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(double2x2_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(double2x2_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(double2x2_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(double2x2_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(double2x2_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(double2x2_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // double2x2_mt16

#region double2x3_mt4

public partial struct double2x3_mt4 : IComparable<double2x3_mt4>, IComparable
    , IComparisonOperators<double2x3_mt4, double2x3_mt4, bool>
    , IComparisonOperators<double2x3_mt4, double2x3_mt4, b64m2x3_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is double2x3_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(double2x3_mt4)}");
    }

    static bool IComparisonOperators<double2x3_mt4, double2x3_mt4, bool>.operator <(double2x3_mt4 left, double2x3_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double2x3_mt4, double2x3_mt4, bool>.operator >(double2x3_mt4 left, double2x3_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double2x3_mt4, double2x3_mt4, bool>.operator <=(double2x3_mt4 left, double2x3_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double2x3_mt4, double2x3_mt4, bool>.operator >=(double2x3_mt4 left, double2x3_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(double2x3_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m2x3_mt4 operator <(double2x3_mt4 left, double2x3_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b64m2x3_mt4 operator >(double2x3_mt4 left, double2x3_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b64m2x3_mt4 operator <=(double2x3_mt4 left, double2x3_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b64m2x3_mt4 operator >=(double2x3_mt4 left, double2x3_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(double2x3_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(double2x3_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(double2x3_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(double2x3_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(double2x3_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(double2x3_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(double2x3_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(double2x3_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // double2x3_mt4

#region double2x3_mt8

public partial struct double2x3_mt8 : IComparable<double2x3_mt8>, IComparable
    , IComparisonOperators<double2x3_mt8, double2x3_mt8, bool>
    , IComparisonOperators<double2x3_mt8, double2x3_mt8, b64m2x3_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is double2x3_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(double2x3_mt8)}");
    }

    static bool IComparisonOperators<double2x3_mt8, double2x3_mt8, bool>.operator <(double2x3_mt8 left, double2x3_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double2x3_mt8, double2x3_mt8, bool>.operator >(double2x3_mt8 left, double2x3_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double2x3_mt8, double2x3_mt8, bool>.operator <=(double2x3_mt8 left, double2x3_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double2x3_mt8, double2x3_mt8, bool>.operator >=(double2x3_mt8 left, double2x3_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(double2x3_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m2x3_mt8 operator <(double2x3_mt8 left, double2x3_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b64m2x3_mt8 operator >(double2x3_mt8 left, double2x3_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b64m2x3_mt8 operator <=(double2x3_mt8 left, double2x3_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b64m2x3_mt8 operator >=(double2x3_mt8 left, double2x3_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(double2x3_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(double2x3_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(double2x3_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(double2x3_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(double2x3_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(double2x3_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(double2x3_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(double2x3_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // double2x3_mt8

#region double2x3_mt16

public partial struct double2x3_mt16 : IComparable<double2x3_mt16>, IComparable
    , IComparisonOperators<double2x3_mt16, double2x3_mt16, bool>
    , IComparisonOperators<double2x3_mt16, double2x3_mt16, b64m2x3_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is double2x3_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(double2x3_mt16)}");
    }

    static bool IComparisonOperators<double2x3_mt16, double2x3_mt16, bool>.operator <(double2x3_mt16 left, double2x3_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double2x3_mt16, double2x3_mt16, bool>.operator >(double2x3_mt16 left, double2x3_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double2x3_mt16, double2x3_mt16, bool>.operator <=(double2x3_mt16 left, double2x3_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double2x3_mt16, double2x3_mt16, bool>.operator >=(double2x3_mt16 left, double2x3_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(double2x3_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m2x3_mt16 operator <(double2x3_mt16 left, double2x3_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b64m2x3_mt16 operator >(double2x3_mt16 left, double2x3_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b64m2x3_mt16 operator <=(double2x3_mt16 left, double2x3_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b64m2x3_mt16 operator >=(double2x3_mt16 left, double2x3_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(double2x3_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(double2x3_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(double2x3_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(double2x3_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(double2x3_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(double2x3_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(double2x3_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(double2x3_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // double2x3_mt16

#region double2x4_mt4

public partial struct double2x4_mt4 : IComparable<double2x4_mt4>, IComparable
    , IComparisonOperators<double2x4_mt4, double2x4_mt4, bool>
    , IComparisonOperators<double2x4_mt4, double2x4_mt4, b64m2x4_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is double2x4_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(double2x4_mt4)}");
    }

    static bool IComparisonOperators<double2x4_mt4, double2x4_mt4, bool>.operator <(double2x4_mt4 left, double2x4_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double2x4_mt4, double2x4_mt4, bool>.operator >(double2x4_mt4 left, double2x4_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double2x4_mt4, double2x4_mt4, bool>.operator <=(double2x4_mt4 left, double2x4_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double2x4_mt4, double2x4_mt4, bool>.operator >=(double2x4_mt4 left, double2x4_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(double2x4_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m2x4_mt4 operator <(double2x4_mt4 left, double2x4_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b64m2x4_mt4 operator >(double2x4_mt4 left, double2x4_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b64m2x4_mt4 operator <=(double2x4_mt4 left, double2x4_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b64m2x4_mt4 operator >=(double2x4_mt4 left, double2x4_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(double2x4_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(double2x4_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(double2x4_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(double2x4_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(double2x4_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(double2x4_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(double2x4_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(double2x4_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // double2x4_mt4

#region double2x4_mt8

public partial struct double2x4_mt8 : IComparable<double2x4_mt8>, IComparable
    , IComparisonOperators<double2x4_mt8, double2x4_mt8, bool>
    , IComparisonOperators<double2x4_mt8, double2x4_mt8, b64m2x4_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is double2x4_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(double2x4_mt8)}");
    }

    static bool IComparisonOperators<double2x4_mt8, double2x4_mt8, bool>.operator <(double2x4_mt8 left, double2x4_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double2x4_mt8, double2x4_mt8, bool>.operator >(double2x4_mt8 left, double2x4_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double2x4_mt8, double2x4_mt8, bool>.operator <=(double2x4_mt8 left, double2x4_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double2x4_mt8, double2x4_mt8, bool>.operator >=(double2x4_mt8 left, double2x4_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(double2x4_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m2x4_mt8 operator <(double2x4_mt8 left, double2x4_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b64m2x4_mt8 operator >(double2x4_mt8 left, double2x4_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b64m2x4_mt8 operator <=(double2x4_mt8 left, double2x4_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b64m2x4_mt8 operator >=(double2x4_mt8 left, double2x4_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(double2x4_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(double2x4_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(double2x4_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(double2x4_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(double2x4_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(double2x4_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(double2x4_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(double2x4_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // double2x4_mt8

#region double2x4_mt16

public partial struct double2x4_mt16 : IComparable<double2x4_mt16>, IComparable
    , IComparisonOperators<double2x4_mt16, double2x4_mt16, bool>
    , IComparisonOperators<double2x4_mt16, double2x4_mt16, b64m2x4_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is double2x4_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(double2x4_mt16)}");
    }

    static bool IComparisonOperators<double2x4_mt16, double2x4_mt16, bool>.operator <(double2x4_mt16 left, double2x4_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double2x4_mt16, double2x4_mt16, bool>.operator >(double2x4_mt16 left, double2x4_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double2x4_mt16, double2x4_mt16, bool>.operator <=(double2x4_mt16 left, double2x4_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double2x4_mt16, double2x4_mt16, bool>.operator >=(double2x4_mt16 left, double2x4_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(double2x4_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m2x4_mt16 operator <(double2x4_mt16 left, double2x4_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b64m2x4_mt16 operator >(double2x4_mt16 left, double2x4_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b64m2x4_mt16 operator <=(double2x4_mt16 left, double2x4_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b64m2x4_mt16 operator >=(double2x4_mt16 left, double2x4_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(double2x4_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(double2x4_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(double2x4_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(double2x4_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(double2x4_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(double2x4_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(double2x4_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(double2x4_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // double2x4_mt16

#region double3x2_mt4

public partial struct double3x2_mt4 : IComparable<double3x2_mt4>, IComparable
    , IComparisonOperators<double3x2_mt4, double3x2_mt4, bool>
    , IComparisonOperators<double3x2_mt4, double3x2_mt4, b64m3x2_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is double3x2_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(double3x2_mt4)}");
    }

    static bool IComparisonOperators<double3x2_mt4, double3x2_mt4, bool>.operator <(double3x2_mt4 left, double3x2_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double3x2_mt4, double3x2_mt4, bool>.operator >(double3x2_mt4 left, double3x2_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double3x2_mt4, double3x2_mt4, bool>.operator <=(double3x2_mt4 left, double3x2_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double3x2_mt4, double3x2_mt4, bool>.operator >=(double3x2_mt4 left, double3x2_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(double3x2_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m3x2_mt4 operator <(double3x2_mt4 left, double3x2_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b64m3x2_mt4 operator >(double3x2_mt4 left, double3x2_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b64m3x2_mt4 operator <=(double3x2_mt4 left, double3x2_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b64m3x2_mt4 operator >=(double3x2_mt4 left, double3x2_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(double3x2_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(double3x2_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(double3x2_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(double3x2_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(double3x2_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(double3x2_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(double3x2_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(double3x2_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // double3x2_mt4

#region double3x2_mt8

public partial struct double3x2_mt8 : IComparable<double3x2_mt8>, IComparable
    , IComparisonOperators<double3x2_mt8, double3x2_mt8, bool>
    , IComparisonOperators<double3x2_mt8, double3x2_mt8, b64m3x2_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is double3x2_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(double3x2_mt8)}");
    }

    static bool IComparisonOperators<double3x2_mt8, double3x2_mt8, bool>.operator <(double3x2_mt8 left, double3x2_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double3x2_mt8, double3x2_mt8, bool>.operator >(double3x2_mt8 left, double3x2_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double3x2_mt8, double3x2_mt8, bool>.operator <=(double3x2_mt8 left, double3x2_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double3x2_mt8, double3x2_mt8, bool>.operator >=(double3x2_mt8 left, double3x2_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(double3x2_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m3x2_mt8 operator <(double3x2_mt8 left, double3x2_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b64m3x2_mt8 operator >(double3x2_mt8 left, double3x2_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b64m3x2_mt8 operator <=(double3x2_mt8 left, double3x2_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b64m3x2_mt8 operator >=(double3x2_mt8 left, double3x2_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(double3x2_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(double3x2_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(double3x2_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(double3x2_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(double3x2_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(double3x2_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(double3x2_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(double3x2_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // double3x2_mt8

#region double3x2_mt16

public partial struct double3x2_mt16 : IComparable<double3x2_mt16>, IComparable
    , IComparisonOperators<double3x2_mt16, double3x2_mt16, bool>
    , IComparisonOperators<double3x2_mt16, double3x2_mt16, b64m3x2_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is double3x2_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(double3x2_mt16)}");
    }

    static bool IComparisonOperators<double3x2_mt16, double3x2_mt16, bool>.operator <(double3x2_mt16 left, double3x2_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double3x2_mt16, double3x2_mt16, bool>.operator >(double3x2_mt16 left, double3x2_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double3x2_mt16, double3x2_mt16, bool>.operator <=(double3x2_mt16 left, double3x2_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double3x2_mt16, double3x2_mt16, bool>.operator >=(double3x2_mt16 left, double3x2_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(double3x2_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m3x2_mt16 operator <(double3x2_mt16 left, double3x2_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b64m3x2_mt16 operator >(double3x2_mt16 left, double3x2_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b64m3x2_mt16 operator <=(double3x2_mt16 left, double3x2_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b64m3x2_mt16 operator >=(double3x2_mt16 left, double3x2_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(double3x2_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(double3x2_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(double3x2_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(double3x2_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(double3x2_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(double3x2_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(double3x2_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(double3x2_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // double3x2_mt16

#region double3x3_mt4

public partial struct double3x3_mt4 : IComparable<double3x3_mt4>, IComparable
    , IComparisonOperators<double3x3_mt4, double3x3_mt4, bool>
    , IComparisonOperators<double3x3_mt4, double3x3_mt4, b64m3x3_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is double3x3_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(double3x3_mt4)}");
    }

    static bool IComparisonOperators<double3x3_mt4, double3x3_mt4, bool>.operator <(double3x3_mt4 left, double3x3_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double3x3_mt4, double3x3_mt4, bool>.operator >(double3x3_mt4 left, double3x3_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double3x3_mt4, double3x3_mt4, bool>.operator <=(double3x3_mt4 left, double3x3_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double3x3_mt4, double3x3_mt4, bool>.operator >=(double3x3_mt4 left, double3x3_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(double3x3_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m3x3_mt4 operator <(double3x3_mt4 left, double3x3_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b64m3x3_mt4 operator >(double3x3_mt4 left, double3x3_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b64m3x3_mt4 operator <=(double3x3_mt4 left, double3x3_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b64m3x3_mt4 operator >=(double3x3_mt4 left, double3x3_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(double3x3_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(double3x3_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(double3x3_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(double3x3_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(double3x3_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(double3x3_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(double3x3_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(double3x3_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // double3x3_mt4

#region double3x3_mt8

public partial struct double3x3_mt8 : IComparable<double3x3_mt8>, IComparable
    , IComparisonOperators<double3x3_mt8, double3x3_mt8, bool>
    , IComparisonOperators<double3x3_mt8, double3x3_mt8, b64m3x3_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is double3x3_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(double3x3_mt8)}");
    }

    static bool IComparisonOperators<double3x3_mt8, double3x3_mt8, bool>.operator <(double3x3_mt8 left, double3x3_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double3x3_mt8, double3x3_mt8, bool>.operator >(double3x3_mt8 left, double3x3_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double3x3_mt8, double3x3_mt8, bool>.operator <=(double3x3_mt8 left, double3x3_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double3x3_mt8, double3x3_mt8, bool>.operator >=(double3x3_mt8 left, double3x3_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(double3x3_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m3x3_mt8 operator <(double3x3_mt8 left, double3x3_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b64m3x3_mt8 operator >(double3x3_mt8 left, double3x3_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b64m3x3_mt8 operator <=(double3x3_mt8 left, double3x3_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b64m3x3_mt8 operator >=(double3x3_mt8 left, double3x3_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(double3x3_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(double3x3_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(double3x3_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(double3x3_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(double3x3_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(double3x3_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(double3x3_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(double3x3_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // double3x3_mt8

#region double3x3_mt16

public partial struct double3x3_mt16 : IComparable<double3x3_mt16>, IComparable
    , IComparisonOperators<double3x3_mt16, double3x3_mt16, bool>
    , IComparisonOperators<double3x3_mt16, double3x3_mt16, b64m3x3_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is double3x3_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(double3x3_mt16)}");
    }

    static bool IComparisonOperators<double3x3_mt16, double3x3_mt16, bool>.operator <(double3x3_mt16 left, double3x3_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double3x3_mt16, double3x3_mt16, bool>.operator >(double3x3_mt16 left, double3x3_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double3x3_mt16, double3x3_mt16, bool>.operator <=(double3x3_mt16 left, double3x3_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double3x3_mt16, double3x3_mt16, bool>.operator >=(double3x3_mt16 left, double3x3_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(double3x3_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m3x3_mt16 operator <(double3x3_mt16 left, double3x3_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b64m3x3_mt16 operator >(double3x3_mt16 left, double3x3_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b64m3x3_mt16 operator <=(double3x3_mt16 left, double3x3_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b64m3x3_mt16 operator >=(double3x3_mt16 left, double3x3_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(double3x3_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(double3x3_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(double3x3_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(double3x3_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(double3x3_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(double3x3_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(double3x3_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(double3x3_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // double3x3_mt16

#region double3x4_mt4

public partial struct double3x4_mt4 : IComparable<double3x4_mt4>, IComparable
    , IComparisonOperators<double3x4_mt4, double3x4_mt4, bool>
    , IComparisonOperators<double3x4_mt4, double3x4_mt4, b64m3x4_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is double3x4_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(double3x4_mt4)}");
    }

    static bool IComparisonOperators<double3x4_mt4, double3x4_mt4, bool>.operator <(double3x4_mt4 left, double3x4_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double3x4_mt4, double3x4_mt4, bool>.operator >(double3x4_mt4 left, double3x4_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double3x4_mt4, double3x4_mt4, bool>.operator <=(double3x4_mt4 left, double3x4_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double3x4_mt4, double3x4_mt4, bool>.operator >=(double3x4_mt4 left, double3x4_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(double3x4_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m3x4_mt4 operator <(double3x4_mt4 left, double3x4_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b64m3x4_mt4 operator >(double3x4_mt4 left, double3x4_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b64m3x4_mt4 operator <=(double3x4_mt4 left, double3x4_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b64m3x4_mt4 operator >=(double3x4_mt4 left, double3x4_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(double3x4_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(double3x4_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(double3x4_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(double3x4_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(double3x4_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(double3x4_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(double3x4_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(double3x4_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // double3x4_mt4

#region double3x4_mt8

public partial struct double3x4_mt8 : IComparable<double3x4_mt8>, IComparable
    , IComparisonOperators<double3x4_mt8, double3x4_mt8, bool>
    , IComparisonOperators<double3x4_mt8, double3x4_mt8, b64m3x4_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is double3x4_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(double3x4_mt8)}");
    }

    static bool IComparisonOperators<double3x4_mt8, double3x4_mt8, bool>.operator <(double3x4_mt8 left, double3x4_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double3x4_mt8, double3x4_mt8, bool>.operator >(double3x4_mt8 left, double3x4_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double3x4_mt8, double3x4_mt8, bool>.operator <=(double3x4_mt8 left, double3x4_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double3x4_mt8, double3x4_mt8, bool>.operator >=(double3x4_mt8 left, double3x4_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(double3x4_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m3x4_mt8 operator <(double3x4_mt8 left, double3x4_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b64m3x4_mt8 operator >(double3x4_mt8 left, double3x4_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b64m3x4_mt8 operator <=(double3x4_mt8 left, double3x4_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b64m3x4_mt8 operator >=(double3x4_mt8 left, double3x4_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(double3x4_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(double3x4_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(double3x4_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(double3x4_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(double3x4_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(double3x4_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(double3x4_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(double3x4_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // double3x4_mt8

#region double3x4_mt16

public partial struct double3x4_mt16 : IComparable<double3x4_mt16>, IComparable
    , IComparisonOperators<double3x4_mt16, double3x4_mt16, bool>
    , IComparisonOperators<double3x4_mt16, double3x4_mt16, b64m3x4_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is double3x4_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(double3x4_mt16)}");
    }

    static bool IComparisonOperators<double3x4_mt16, double3x4_mt16, bool>.operator <(double3x4_mt16 left, double3x4_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double3x4_mt16, double3x4_mt16, bool>.operator >(double3x4_mt16 left, double3x4_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double3x4_mt16, double3x4_mt16, bool>.operator <=(double3x4_mt16 left, double3x4_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double3x4_mt16, double3x4_mt16, bool>.operator >=(double3x4_mt16 left, double3x4_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(double3x4_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m3x4_mt16 operator <(double3x4_mt16 left, double3x4_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b64m3x4_mt16 operator >(double3x4_mt16 left, double3x4_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b64m3x4_mt16 operator <=(double3x4_mt16 left, double3x4_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b64m3x4_mt16 operator >=(double3x4_mt16 left, double3x4_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(double3x4_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(double3x4_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(double3x4_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(double3x4_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(double3x4_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(double3x4_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(double3x4_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(double3x4_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // double3x4_mt16

#region double4x2_mt4

public partial struct double4x2_mt4 : IComparable<double4x2_mt4>, IComparable
    , IComparisonOperators<double4x2_mt4, double4x2_mt4, bool>
    , IComparisonOperators<double4x2_mt4, double4x2_mt4, b64m4x2_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is double4x2_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(double4x2_mt4)}");
    }

    static bool IComparisonOperators<double4x2_mt4, double4x2_mt4, bool>.operator <(double4x2_mt4 left, double4x2_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double4x2_mt4, double4x2_mt4, bool>.operator >(double4x2_mt4 left, double4x2_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double4x2_mt4, double4x2_mt4, bool>.operator <=(double4x2_mt4 left, double4x2_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double4x2_mt4, double4x2_mt4, bool>.operator >=(double4x2_mt4 left, double4x2_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(double4x2_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m4x2_mt4 operator <(double4x2_mt4 left, double4x2_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b64m4x2_mt4 operator >(double4x2_mt4 left, double4x2_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b64m4x2_mt4 operator <=(double4x2_mt4 left, double4x2_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b64m4x2_mt4 operator >=(double4x2_mt4 left, double4x2_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(double4x2_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(double4x2_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(double4x2_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(double4x2_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(double4x2_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(double4x2_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(double4x2_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(double4x2_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // double4x2_mt4

#region double4x2_mt8

public partial struct double4x2_mt8 : IComparable<double4x2_mt8>, IComparable
    , IComparisonOperators<double4x2_mt8, double4x2_mt8, bool>
    , IComparisonOperators<double4x2_mt8, double4x2_mt8, b64m4x2_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is double4x2_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(double4x2_mt8)}");
    }

    static bool IComparisonOperators<double4x2_mt8, double4x2_mt8, bool>.operator <(double4x2_mt8 left, double4x2_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double4x2_mt8, double4x2_mt8, bool>.operator >(double4x2_mt8 left, double4x2_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double4x2_mt8, double4x2_mt8, bool>.operator <=(double4x2_mt8 left, double4x2_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double4x2_mt8, double4x2_mt8, bool>.operator >=(double4x2_mt8 left, double4x2_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(double4x2_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m4x2_mt8 operator <(double4x2_mt8 left, double4x2_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b64m4x2_mt8 operator >(double4x2_mt8 left, double4x2_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b64m4x2_mt8 operator <=(double4x2_mt8 left, double4x2_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b64m4x2_mt8 operator >=(double4x2_mt8 left, double4x2_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(double4x2_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(double4x2_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(double4x2_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(double4x2_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(double4x2_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(double4x2_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(double4x2_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(double4x2_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // double4x2_mt8

#region double4x2_mt16

public partial struct double4x2_mt16 : IComparable<double4x2_mt16>, IComparable
    , IComparisonOperators<double4x2_mt16, double4x2_mt16, bool>
    , IComparisonOperators<double4x2_mt16, double4x2_mt16, b64m4x2_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is double4x2_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(double4x2_mt16)}");
    }

    static bool IComparisonOperators<double4x2_mt16, double4x2_mt16, bool>.operator <(double4x2_mt16 left, double4x2_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double4x2_mt16, double4x2_mt16, bool>.operator >(double4x2_mt16 left, double4x2_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double4x2_mt16, double4x2_mt16, bool>.operator <=(double4x2_mt16 left, double4x2_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double4x2_mt16, double4x2_mt16, bool>.operator >=(double4x2_mt16 left, double4x2_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(double4x2_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m4x2_mt16 operator <(double4x2_mt16 left, double4x2_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b64m4x2_mt16 operator >(double4x2_mt16 left, double4x2_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b64m4x2_mt16 operator <=(double4x2_mt16 left, double4x2_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b64m4x2_mt16 operator >=(double4x2_mt16 left, double4x2_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(double4x2_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(double4x2_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(double4x2_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(double4x2_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(double4x2_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(double4x2_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(double4x2_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(double4x2_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // double4x2_mt16

#region double4x3_mt4

public partial struct double4x3_mt4 : IComparable<double4x3_mt4>, IComparable
    , IComparisonOperators<double4x3_mt4, double4x3_mt4, bool>
    , IComparisonOperators<double4x3_mt4, double4x3_mt4, b64m4x3_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is double4x3_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(double4x3_mt4)}");
    }

    static bool IComparisonOperators<double4x3_mt4, double4x3_mt4, bool>.operator <(double4x3_mt4 left, double4x3_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double4x3_mt4, double4x3_mt4, bool>.operator >(double4x3_mt4 left, double4x3_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double4x3_mt4, double4x3_mt4, bool>.operator <=(double4x3_mt4 left, double4x3_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double4x3_mt4, double4x3_mt4, bool>.operator >=(double4x3_mt4 left, double4x3_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(double4x3_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m4x3_mt4 operator <(double4x3_mt4 left, double4x3_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b64m4x3_mt4 operator >(double4x3_mt4 left, double4x3_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b64m4x3_mt4 operator <=(double4x3_mt4 left, double4x3_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b64m4x3_mt4 operator >=(double4x3_mt4 left, double4x3_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(double4x3_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(double4x3_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(double4x3_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(double4x3_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(double4x3_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(double4x3_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(double4x3_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(double4x3_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // double4x3_mt4

#region double4x3_mt8

public partial struct double4x3_mt8 : IComparable<double4x3_mt8>, IComparable
    , IComparisonOperators<double4x3_mt8, double4x3_mt8, bool>
    , IComparisonOperators<double4x3_mt8, double4x3_mt8, b64m4x3_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is double4x3_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(double4x3_mt8)}");
    }

    static bool IComparisonOperators<double4x3_mt8, double4x3_mt8, bool>.operator <(double4x3_mt8 left, double4x3_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double4x3_mt8, double4x3_mt8, bool>.operator >(double4x3_mt8 left, double4x3_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double4x3_mt8, double4x3_mt8, bool>.operator <=(double4x3_mt8 left, double4x3_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double4x3_mt8, double4x3_mt8, bool>.operator >=(double4x3_mt8 left, double4x3_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(double4x3_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m4x3_mt8 operator <(double4x3_mt8 left, double4x3_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b64m4x3_mt8 operator >(double4x3_mt8 left, double4x3_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b64m4x3_mt8 operator <=(double4x3_mt8 left, double4x3_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b64m4x3_mt8 operator >=(double4x3_mt8 left, double4x3_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(double4x3_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(double4x3_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(double4x3_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(double4x3_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(double4x3_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(double4x3_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(double4x3_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(double4x3_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // double4x3_mt8

#region double4x3_mt16

public partial struct double4x3_mt16 : IComparable<double4x3_mt16>, IComparable
    , IComparisonOperators<double4x3_mt16, double4x3_mt16, bool>
    , IComparisonOperators<double4x3_mt16, double4x3_mt16, b64m4x3_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is double4x3_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(double4x3_mt16)}");
    }

    static bool IComparisonOperators<double4x3_mt16, double4x3_mt16, bool>.operator <(double4x3_mt16 left, double4x3_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double4x3_mt16, double4x3_mt16, bool>.operator >(double4x3_mt16 left, double4x3_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double4x3_mt16, double4x3_mt16, bool>.operator <=(double4x3_mt16 left, double4x3_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double4x3_mt16, double4x3_mt16, bool>.operator >=(double4x3_mt16 left, double4x3_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(double4x3_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m4x3_mt16 operator <(double4x3_mt16 left, double4x3_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b64m4x3_mt16 operator >(double4x3_mt16 left, double4x3_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b64m4x3_mt16 operator <=(double4x3_mt16 left, double4x3_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b64m4x3_mt16 operator >=(double4x3_mt16 left, double4x3_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(double4x3_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(double4x3_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(double4x3_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(double4x3_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(double4x3_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(double4x3_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(double4x3_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(double4x3_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // double4x3_mt16

#region double4x4_mt4

public partial struct double4x4_mt4 : IComparable<double4x4_mt4>, IComparable
    , IComparisonOperators<double4x4_mt4, double4x4_mt4, bool>
    , IComparisonOperators<double4x4_mt4, double4x4_mt4, b64m4x4_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is double4x4_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(double4x4_mt4)}");
    }

    static bool IComparisonOperators<double4x4_mt4, double4x4_mt4, bool>.operator <(double4x4_mt4 left, double4x4_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double4x4_mt4, double4x4_mt4, bool>.operator >(double4x4_mt4 left, double4x4_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double4x4_mt4, double4x4_mt4, bool>.operator <=(double4x4_mt4 left, double4x4_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double4x4_mt4, double4x4_mt4, bool>.operator >=(double4x4_mt4 left, double4x4_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(double4x4_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m4x4_mt4 operator <(double4x4_mt4 left, double4x4_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b64m4x4_mt4 operator >(double4x4_mt4 left, double4x4_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b64m4x4_mt4 operator <=(double4x4_mt4 left, double4x4_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b64m4x4_mt4 operator >=(double4x4_mt4 left, double4x4_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(double4x4_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(double4x4_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(double4x4_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(double4x4_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(double4x4_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(double4x4_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(double4x4_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(double4x4_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // double4x4_mt4

#region double4x4_mt8

public partial struct double4x4_mt8 : IComparable<double4x4_mt8>, IComparable
    , IComparisonOperators<double4x4_mt8, double4x4_mt8, bool>
    , IComparisonOperators<double4x4_mt8, double4x4_mt8, b64m4x4_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is double4x4_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(double4x4_mt8)}");
    }

    static bool IComparisonOperators<double4x4_mt8, double4x4_mt8, bool>.operator <(double4x4_mt8 left, double4x4_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double4x4_mt8, double4x4_mt8, bool>.operator >(double4x4_mt8 left, double4x4_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double4x4_mt8, double4x4_mt8, bool>.operator <=(double4x4_mt8 left, double4x4_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double4x4_mt8, double4x4_mt8, bool>.operator >=(double4x4_mt8 left, double4x4_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(double4x4_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m4x4_mt8 operator <(double4x4_mt8 left, double4x4_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b64m4x4_mt8 operator >(double4x4_mt8 left, double4x4_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b64m4x4_mt8 operator <=(double4x4_mt8 left, double4x4_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b64m4x4_mt8 operator >=(double4x4_mt8 left, double4x4_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(double4x4_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(double4x4_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(double4x4_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(double4x4_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(double4x4_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(double4x4_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(double4x4_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(double4x4_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // double4x4_mt8

#region double4x4_mt16

public partial struct double4x4_mt16 : IComparable<double4x4_mt16>, IComparable
    , IComparisonOperators<double4x4_mt16, double4x4_mt16, bool>
    , IComparisonOperators<double4x4_mt16, double4x4_mt16, b64m4x4_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is double4x4_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(double4x4_mt16)}");
    }

    static bool IComparisonOperators<double4x4_mt16, double4x4_mt16, bool>.operator <(double4x4_mt16 left, double4x4_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double4x4_mt16, double4x4_mt16, bool>.operator >(double4x4_mt16 left, double4x4_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double4x4_mt16, double4x4_mt16, bool>.operator <=(double4x4_mt16 left, double4x4_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double4x4_mt16, double4x4_mt16, bool>.operator >=(double4x4_mt16 left, double4x4_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(double4x4_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m4x4_mt16 operator <(double4x4_mt16 left, double4x4_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b64m4x4_mt16 operator >(double4x4_mt16 left, double4x4_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b64m4x4_mt16 operator <=(double4x4_mt16 left, double4x4_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b64m4x4_mt16 operator >=(double4x4_mt16 left, double4x4_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(double4x4_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(double4x4_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(double4x4_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(double4x4_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(double4x4_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(double4x4_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(double4x4_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(double4x4_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // double4x4_mt16

#region int2x2_mt4

public partial struct int2x2_mt4 : IComparable<int2x2_mt4>, IComparable
    , IComparisonOperators<int2x2_mt4, int2x2_mt4, bool>
    , IComparisonOperators<int2x2_mt4, int2x2_mt4, b32m2x2_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is int2x2_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(int2x2_mt4)}");
    }

    static bool IComparisonOperators<int2x2_mt4, int2x2_mt4, bool>.operator <(int2x2_mt4 left, int2x2_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int2x2_mt4, int2x2_mt4, bool>.operator >(int2x2_mt4 left, int2x2_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int2x2_mt4, int2x2_mt4, bool>.operator <=(int2x2_mt4 left, int2x2_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int2x2_mt4, int2x2_mt4, bool>.operator >=(int2x2_mt4 left, int2x2_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(int2x2_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m2x2_mt4 operator <(int2x2_mt4 left, int2x2_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b32m2x2_mt4 operator >(int2x2_mt4 left, int2x2_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b32m2x2_mt4 operator <=(int2x2_mt4 left, int2x2_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b32m2x2_mt4 operator >=(int2x2_mt4 left, int2x2_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(int2x2_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(int2x2_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(int2x2_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(int2x2_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(int2x2_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(int2x2_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(int2x2_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(int2x2_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // int2x2_mt4

#region int2x2_mt8

public partial struct int2x2_mt8 : IComparable<int2x2_mt8>, IComparable
    , IComparisonOperators<int2x2_mt8, int2x2_mt8, bool>
    , IComparisonOperators<int2x2_mt8, int2x2_mt8, b32m2x2_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is int2x2_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(int2x2_mt8)}");
    }

    static bool IComparisonOperators<int2x2_mt8, int2x2_mt8, bool>.operator <(int2x2_mt8 left, int2x2_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int2x2_mt8, int2x2_mt8, bool>.operator >(int2x2_mt8 left, int2x2_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int2x2_mt8, int2x2_mt8, bool>.operator <=(int2x2_mt8 left, int2x2_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int2x2_mt8, int2x2_mt8, bool>.operator >=(int2x2_mt8 left, int2x2_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(int2x2_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m2x2_mt8 operator <(int2x2_mt8 left, int2x2_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b32m2x2_mt8 operator >(int2x2_mt8 left, int2x2_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b32m2x2_mt8 operator <=(int2x2_mt8 left, int2x2_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b32m2x2_mt8 operator >=(int2x2_mt8 left, int2x2_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(int2x2_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(int2x2_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(int2x2_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(int2x2_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(int2x2_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(int2x2_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(int2x2_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(int2x2_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // int2x2_mt8

#region int2x2_mt16

public partial struct int2x2_mt16 : IComparable<int2x2_mt16>, IComparable
    , IComparisonOperators<int2x2_mt16, int2x2_mt16, bool>
    , IComparisonOperators<int2x2_mt16, int2x2_mt16, b32m2x2_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is int2x2_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(int2x2_mt16)}");
    }

    static bool IComparisonOperators<int2x2_mt16, int2x2_mt16, bool>.operator <(int2x2_mt16 left, int2x2_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int2x2_mt16, int2x2_mt16, bool>.operator >(int2x2_mt16 left, int2x2_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int2x2_mt16, int2x2_mt16, bool>.operator <=(int2x2_mt16 left, int2x2_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int2x2_mt16, int2x2_mt16, bool>.operator >=(int2x2_mt16 left, int2x2_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(int2x2_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m2x2_mt16 operator <(int2x2_mt16 left, int2x2_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b32m2x2_mt16 operator >(int2x2_mt16 left, int2x2_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b32m2x2_mt16 operator <=(int2x2_mt16 left, int2x2_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b32m2x2_mt16 operator >=(int2x2_mt16 left, int2x2_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(int2x2_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(int2x2_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(int2x2_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(int2x2_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(int2x2_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(int2x2_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(int2x2_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(int2x2_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // int2x2_mt16

#region int2x3_mt4

public partial struct int2x3_mt4 : IComparable<int2x3_mt4>, IComparable
    , IComparisonOperators<int2x3_mt4, int2x3_mt4, bool>
    , IComparisonOperators<int2x3_mt4, int2x3_mt4, b32m2x3_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is int2x3_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(int2x3_mt4)}");
    }

    static bool IComparisonOperators<int2x3_mt4, int2x3_mt4, bool>.operator <(int2x3_mt4 left, int2x3_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int2x3_mt4, int2x3_mt4, bool>.operator >(int2x3_mt4 left, int2x3_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int2x3_mt4, int2x3_mt4, bool>.operator <=(int2x3_mt4 left, int2x3_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int2x3_mt4, int2x3_mt4, bool>.operator >=(int2x3_mt4 left, int2x3_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(int2x3_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m2x3_mt4 operator <(int2x3_mt4 left, int2x3_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b32m2x3_mt4 operator >(int2x3_mt4 left, int2x3_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b32m2x3_mt4 operator <=(int2x3_mt4 left, int2x3_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b32m2x3_mt4 operator >=(int2x3_mt4 left, int2x3_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(int2x3_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(int2x3_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(int2x3_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(int2x3_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(int2x3_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(int2x3_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(int2x3_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(int2x3_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // int2x3_mt4

#region int2x3_mt8

public partial struct int2x3_mt8 : IComparable<int2x3_mt8>, IComparable
    , IComparisonOperators<int2x3_mt8, int2x3_mt8, bool>
    , IComparisonOperators<int2x3_mt8, int2x3_mt8, b32m2x3_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is int2x3_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(int2x3_mt8)}");
    }

    static bool IComparisonOperators<int2x3_mt8, int2x3_mt8, bool>.operator <(int2x3_mt8 left, int2x3_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int2x3_mt8, int2x3_mt8, bool>.operator >(int2x3_mt8 left, int2x3_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int2x3_mt8, int2x3_mt8, bool>.operator <=(int2x3_mt8 left, int2x3_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int2x3_mt8, int2x3_mt8, bool>.operator >=(int2x3_mt8 left, int2x3_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(int2x3_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m2x3_mt8 operator <(int2x3_mt8 left, int2x3_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b32m2x3_mt8 operator >(int2x3_mt8 left, int2x3_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b32m2x3_mt8 operator <=(int2x3_mt8 left, int2x3_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b32m2x3_mt8 operator >=(int2x3_mt8 left, int2x3_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(int2x3_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(int2x3_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(int2x3_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(int2x3_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(int2x3_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(int2x3_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(int2x3_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(int2x3_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // int2x3_mt8

#region int2x3_mt16

public partial struct int2x3_mt16 : IComparable<int2x3_mt16>, IComparable
    , IComparisonOperators<int2x3_mt16, int2x3_mt16, bool>
    , IComparisonOperators<int2x3_mt16, int2x3_mt16, b32m2x3_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is int2x3_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(int2x3_mt16)}");
    }

    static bool IComparisonOperators<int2x3_mt16, int2x3_mt16, bool>.operator <(int2x3_mt16 left, int2x3_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int2x3_mt16, int2x3_mt16, bool>.operator >(int2x3_mt16 left, int2x3_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int2x3_mt16, int2x3_mt16, bool>.operator <=(int2x3_mt16 left, int2x3_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int2x3_mt16, int2x3_mt16, bool>.operator >=(int2x3_mt16 left, int2x3_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(int2x3_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m2x3_mt16 operator <(int2x3_mt16 left, int2x3_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b32m2x3_mt16 operator >(int2x3_mt16 left, int2x3_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b32m2x3_mt16 operator <=(int2x3_mt16 left, int2x3_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b32m2x3_mt16 operator >=(int2x3_mt16 left, int2x3_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(int2x3_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(int2x3_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(int2x3_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(int2x3_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(int2x3_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(int2x3_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(int2x3_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(int2x3_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // int2x3_mt16

#region int2x4_mt4

public partial struct int2x4_mt4 : IComparable<int2x4_mt4>, IComparable
    , IComparisonOperators<int2x4_mt4, int2x4_mt4, bool>
    , IComparisonOperators<int2x4_mt4, int2x4_mt4, b32m2x4_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is int2x4_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(int2x4_mt4)}");
    }

    static bool IComparisonOperators<int2x4_mt4, int2x4_mt4, bool>.operator <(int2x4_mt4 left, int2x4_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int2x4_mt4, int2x4_mt4, bool>.operator >(int2x4_mt4 left, int2x4_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int2x4_mt4, int2x4_mt4, bool>.operator <=(int2x4_mt4 left, int2x4_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int2x4_mt4, int2x4_mt4, bool>.operator >=(int2x4_mt4 left, int2x4_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(int2x4_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m2x4_mt4 operator <(int2x4_mt4 left, int2x4_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b32m2x4_mt4 operator >(int2x4_mt4 left, int2x4_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b32m2x4_mt4 operator <=(int2x4_mt4 left, int2x4_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b32m2x4_mt4 operator >=(int2x4_mt4 left, int2x4_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(int2x4_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(int2x4_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(int2x4_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(int2x4_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(int2x4_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(int2x4_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(int2x4_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(int2x4_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // int2x4_mt4

#region int2x4_mt8

public partial struct int2x4_mt8 : IComparable<int2x4_mt8>, IComparable
    , IComparisonOperators<int2x4_mt8, int2x4_mt8, bool>
    , IComparisonOperators<int2x4_mt8, int2x4_mt8, b32m2x4_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is int2x4_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(int2x4_mt8)}");
    }

    static bool IComparisonOperators<int2x4_mt8, int2x4_mt8, bool>.operator <(int2x4_mt8 left, int2x4_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int2x4_mt8, int2x4_mt8, bool>.operator >(int2x4_mt8 left, int2x4_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int2x4_mt8, int2x4_mt8, bool>.operator <=(int2x4_mt8 left, int2x4_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int2x4_mt8, int2x4_mt8, bool>.operator >=(int2x4_mt8 left, int2x4_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(int2x4_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m2x4_mt8 operator <(int2x4_mt8 left, int2x4_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b32m2x4_mt8 operator >(int2x4_mt8 left, int2x4_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b32m2x4_mt8 operator <=(int2x4_mt8 left, int2x4_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b32m2x4_mt8 operator >=(int2x4_mt8 left, int2x4_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(int2x4_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(int2x4_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(int2x4_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(int2x4_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(int2x4_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(int2x4_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(int2x4_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(int2x4_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // int2x4_mt8

#region int2x4_mt16

public partial struct int2x4_mt16 : IComparable<int2x4_mt16>, IComparable
    , IComparisonOperators<int2x4_mt16, int2x4_mt16, bool>
    , IComparisonOperators<int2x4_mt16, int2x4_mt16, b32m2x4_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is int2x4_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(int2x4_mt16)}");
    }

    static bool IComparisonOperators<int2x4_mt16, int2x4_mt16, bool>.operator <(int2x4_mt16 left, int2x4_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int2x4_mt16, int2x4_mt16, bool>.operator >(int2x4_mt16 left, int2x4_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int2x4_mt16, int2x4_mt16, bool>.operator <=(int2x4_mt16 left, int2x4_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int2x4_mt16, int2x4_mt16, bool>.operator >=(int2x4_mt16 left, int2x4_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(int2x4_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m2x4_mt16 operator <(int2x4_mt16 left, int2x4_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b32m2x4_mt16 operator >(int2x4_mt16 left, int2x4_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b32m2x4_mt16 operator <=(int2x4_mt16 left, int2x4_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b32m2x4_mt16 operator >=(int2x4_mt16 left, int2x4_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(int2x4_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(int2x4_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(int2x4_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(int2x4_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(int2x4_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(int2x4_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(int2x4_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(int2x4_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // int2x4_mt16

#region int3x2_mt4

public partial struct int3x2_mt4 : IComparable<int3x2_mt4>, IComparable
    , IComparisonOperators<int3x2_mt4, int3x2_mt4, bool>
    , IComparisonOperators<int3x2_mt4, int3x2_mt4, b32m3x2_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is int3x2_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(int3x2_mt4)}");
    }

    static bool IComparisonOperators<int3x2_mt4, int3x2_mt4, bool>.operator <(int3x2_mt4 left, int3x2_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int3x2_mt4, int3x2_mt4, bool>.operator >(int3x2_mt4 left, int3x2_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int3x2_mt4, int3x2_mt4, bool>.operator <=(int3x2_mt4 left, int3x2_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int3x2_mt4, int3x2_mt4, bool>.operator >=(int3x2_mt4 left, int3x2_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(int3x2_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m3x2_mt4 operator <(int3x2_mt4 left, int3x2_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b32m3x2_mt4 operator >(int3x2_mt4 left, int3x2_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b32m3x2_mt4 operator <=(int3x2_mt4 left, int3x2_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b32m3x2_mt4 operator >=(int3x2_mt4 left, int3x2_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(int3x2_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(int3x2_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(int3x2_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(int3x2_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(int3x2_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(int3x2_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(int3x2_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(int3x2_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // int3x2_mt4

#region int3x2_mt8

public partial struct int3x2_mt8 : IComparable<int3x2_mt8>, IComparable
    , IComparisonOperators<int3x2_mt8, int3x2_mt8, bool>
    , IComparisonOperators<int3x2_mt8, int3x2_mt8, b32m3x2_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is int3x2_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(int3x2_mt8)}");
    }

    static bool IComparisonOperators<int3x2_mt8, int3x2_mt8, bool>.operator <(int3x2_mt8 left, int3x2_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int3x2_mt8, int3x2_mt8, bool>.operator >(int3x2_mt8 left, int3x2_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int3x2_mt8, int3x2_mt8, bool>.operator <=(int3x2_mt8 left, int3x2_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int3x2_mt8, int3x2_mt8, bool>.operator >=(int3x2_mt8 left, int3x2_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(int3x2_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m3x2_mt8 operator <(int3x2_mt8 left, int3x2_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b32m3x2_mt8 operator >(int3x2_mt8 left, int3x2_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b32m3x2_mt8 operator <=(int3x2_mt8 left, int3x2_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b32m3x2_mt8 operator >=(int3x2_mt8 left, int3x2_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(int3x2_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(int3x2_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(int3x2_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(int3x2_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(int3x2_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(int3x2_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(int3x2_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(int3x2_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // int3x2_mt8

#region int3x2_mt16

public partial struct int3x2_mt16 : IComparable<int3x2_mt16>, IComparable
    , IComparisonOperators<int3x2_mt16, int3x2_mt16, bool>
    , IComparisonOperators<int3x2_mt16, int3x2_mt16, b32m3x2_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is int3x2_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(int3x2_mt16)}");
    }

    static bool IComparisonOperators<int3x2_mt16, int3x2_mt16, bool>.operator <(int3x2_mt16 left, int3x2_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int3x2_mt16, int3x2_mt16, bool>.operator >(int3x2_mt16 left, int3x2_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int3x2_mt16, int3x2_mt16, bool>.operator <=(int3x2_mt16 left, int3x2_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int3x2_mt16, int3x2_mt16, bool>.operator >=(int3x2_mt16 left, int3x2_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(int3x2_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m3x2_mt16 operator <(int3x2_mt16 left, int3x2_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b32m3x2_mt16 operator >(int3x2_mt16 left, int3x2_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b32m3x2_mt16 operator <=(int3x2_mt16 left, int3x2_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b32m3x2_mt16 operator >=(int3x2_mt16 left, int3x2_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(int3x2_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(int3x2_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(int3x2_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(int3x2_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(int3x2_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(int3x2_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(int3x2_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(int3x2_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // int3x2_mt16

#region int3x3_mt4

public partial struct int3x3_mt4 : IComparable<int3x3_mt4>, IComparable
    , IComparisonOperators<int3x3_mt4, int3x3_mt4, bool>
    , IComparisonOperators<int3x3_mt4, int3x3_mt4, b32m3x3_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is int3x3_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(int3x3_mt4)}");
    }

    static bool IComparisonOperators<int3x3_mt4, int3x3_mt4, bool>.operator <(int3x3_mt4 left, int3x3_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int3x3_mt4, int3x3_mt4, bool>.operator >(int3x3_mt4 left, int3x3_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int3x3_mt4, int3x3_mt4, bool>.operator <=(int3x3_mt4 left, int3x3_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int3x3_mt4, int3x3_mt4, bool>.operator >=(int3x3_mt4 left, int3x3_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(int3x3_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m3x3_mt4 operator <(int3x3_mt4 left, int3x3_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b32m3x3_mt4 operator >(int3x3_mt4 left, int3x3_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b32m3x3_mt4 operator <=(int3x3_mt4 left, int3x3_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b32m3x3_mt4 operator >=(int3x3_mt4 left, int3x3_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(int3x3_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(int3x3_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(int3x3_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(int3x3_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(int3x3_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(int3x3_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(int3x3_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(int3x3_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // int3x3_mt4

#region int3x3_mt8

public partial struct int3x3_mt8 : IComparable<int3x3_mt8>, IComparable
    , IComparisonOperators<int3x3_mt8, int3x3_mt8, bool>
    , IComparisonOperators<int3x3_mt8, int3x3_mt8, b32m3x3_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is int3x3_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(int3x3_mt8)}");
    }

    static bool IComparisonOperators<int3x3_mt8, int3x3_mt8, bool>.operator <(int3x3_mt8 left, int3x3_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int3x3_mt8, int3x3_mt8, bool>.operator >(int3x3_mt8 left, int3x3_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int3x3_mt8, int3x3_mt8, bool>.operator <=(int3x3_mt8 left, int3x3_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int3x3_mt8, int3x3_mt8, bool>.operator >=(int3x3_mt8 left, int3x3_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(int3x3_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m3x3_mt8 operator <(int3x3_mt8 left, int3x3_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b32m3x3_mt8 operator >(int3x3_mt8 left, int3x3_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b32m3x3_mt8 operator <=(int3x3_mt8 left, int3x3_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b32m3x3_mt8 operator >=(int3x3_mt8 left, int3x3_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(int3x3_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(int3x3_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(int3x3_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(int3x3_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(int3x3_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(int3x3_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(int3x3_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(int3x3_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // int3x3_mt8

#region int3x3_mt16

public partial struct int3x3_mt16 : IComparable<int3x3_mt16>, IComparable
    , IComparisonOperators<int3x3_mt16, int3x3_mt16, bool>
    , IComparisonOperators<int3x3_mt16, int3x3_mt16, b32m3x3_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is int3x3_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(int3x3_mt16)}");
    }

    static bool IComparisonOperators<int3x3_mt16, int3x3_mt16, bool>.operator <(int3x3_mt16 left, int3x3_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int3x3_mt16, int3x3_mt16, bool>.operator >(int3x3_mt16 left, int3x3_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int3x3_mt16, int3x3_mt16, bool>.operator <=(int3x3_mt16 left, int3x3_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int3x3_mt16, int3x3_mt16, bool>.operator >=(int3x3_mt16 left, int3x3_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(int3x3_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m3x3_mt16 operator <(int3x3_mt16 left, int3x3_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b32m3x3_mt16 operator >(int3x3_mt16 left, int3x3_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b32m3x3_mt16 operator <=(int3x3_mt16 left, int3x3_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b32m3x3_mt16 operator >=(int3x3_mt16 left, int3x3_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(int3x3_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(int3x3_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(int3x3_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(int3x3_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(int3x3_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(int3x3_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(int3x3_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(int3x3_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // int3x3_mt16

#region int3x4_mt4

public partial struct int3x4_mt4 : IComparable<int3x4_mt4>, IComparable
    , IComparisonOperators<int3x4_mt4, int3x4_mt4, bool>
    , IComparisonOperators<int3x4_mt4, int3x4_mt4, b32m3x4_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is int3x4_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(int3x4_mt4)}");
    }

    static bool IComparisonOperators<int3x4_mt4, int3x4_mt4, bool>.operator <(int3x4_mt4 left, int3x4_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int3x4_mt4, int3x4_mt4, bool>.operator >(int3x4_mt4 left, int3x4_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int3x4_mt4, int3x4_mt4, bool>.operator <=(int3x4_mt4 left, int3x4_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int3x4_mt4, int3x4_mt4, bool>.operator >=(int3x4_mt4 left, int3x4_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(int3x4_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m3x4_mt4 operator <(int3x4_mt4 left, int3x4_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b32m3x4_mt4 operator >(int3x4_mt4 left, int3x4_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b32m3x4_mt4 operator <=(int3x4_mt4 left, int3x4_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b32m3x4_mt4 operator >=(int3x4_mt4 left, int3x4_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(int3x4_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(int3x4_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(int3x4_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(int3x4_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(int3x4_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(int3x4_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(int3x4_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(int3x4_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // int3x4_mt4

#region int3x4_mt8

public partial struct int3x4_mt8 : IComparable<int3x4_mt8>, IComparable
    , IComparisonOperators<int3x4_mt8, int3x4_mt8, bool>
    , IComparisonOperators<int3x4_mt8, int3x4_mt8, b32m3x4_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is int3x4_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(int3x4_mt8)}");
    }

    static bool IComparisonOperators<int3x4_mt8, int3x4_mt8, bool>.operator <(int3x4_mt8 left, int3x4_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int3x4_mt8, int3x4_mt8, bool>.operator >(int3x4_mt8 left, int3x4_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int3x4_mt8, int3x4_mt8, bool>.operator <=(int3x4_mt8 left, int3x4_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int3x4_mt8, int3x4_mt8, bool>.operator >=(int3x4_mt8 left, int3x4_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(int3x4_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m3x4_mt8 operator <(int3x4_mt8 left, int3x4_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b32m3x4_mt8 operator >(int3x4_mt8 left, int3x4_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b32m3x4_mt8 operator <=(int3x4_mt8 left, int3x4_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b32m3x4_mt8 operator >=(int3x4_mt8 left, int3x4_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(int3x4_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(int3x4_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(int3x4_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(int3x4_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(int3x4_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(int3x4_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(int3x4_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(int3x4_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // int3x4_mt8

#region int3x4_mt16

public partial struct int3x4_mt16 : IComparable<int3x4_mt16>, IComparable
    , IComparisonOperators<int3x4_mt16, int3x4_mt16, bool>
    , IComparisonOperators<int3x4_mt16, int3x4_mt16, b32m3x4_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is int3x4_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(int3x4_mt16)}");
    }

    static bool IComparisonOperators<int3x4_mt16, int3x4_mt16, bool>.operator <(int3x4_mt16 left, int3x4_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int3x4_mt16, int3x4_mt16, bool>.operator >(int3x4_mt16 left, int3x4_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int3x4_mt16, int3x4_mt16, bool>.operator <=(int3x4_mt16 left, int3x4_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int3x4_mt16, int3x4_mt16, bool>.operator >=(int3x4_mt16 left, int3x4_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(int3x4_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m3x4_mt16 operator <(int3x4_mt16 left, int3x4_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b32m3x4_mt16 operator >(int3x4_mt16 left, int3x4_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b32m3x4_mt16 operator <=(int3x4_mt16 left, int3x4_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b32m3x4_mt16 operator >=(int3x4_mt16 left, int3x4_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(int3x4_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(int3x4_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(int3x4_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(int3x4_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(int3x4_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(int3x4_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(int3x4_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(int3x4_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // int3x4_mt16

#region int4x2_mt4

public partial struct int4x2_mt4 : IComparable<int4x2_mt4>, IComparable
    , IComparisonOperators<int4x2_mt4, int4x2_mt4, bool>
    , IComparisonOperators<int4x2_mt4, int4x2_mt4, b32m4x2_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is int4x2_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(int4x2_mt4)}");
    }

    static bool IComparisonOperators<int4x2_mt4, int4x2_mt4, bool>.operator <(int4x2_mt4 left, int4x2_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int4x2_mt4, int4x2_mt4, bool>.operator >(int4x2_mt4 left, int4x2_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int4x2_mt4, int4x2_mt4, bool>.operator <=(int4x2_mt4 left, int4x2_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int4x2_mt4, int4x2_mt4, bool>.operator >=(int4x2_mt4 left, int4x2_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(int4x2_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m4x2_mt4 operator <(int4x2_mt4 left, int4x2_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b32m4x2_mt4 operator >(int4x2_mt4 left, int4x2_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b32m4x2_mt4 operator <=(int4x2_mt4 left, int4x2_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b32m4x2_mt4 operator >=(int4x2_mt4 left, int4x2_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(int4x2_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(int4x2_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(int4x2_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(int4x2_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(int4x2_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(int4x2_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(int4x2_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(int4x2_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // int4x2_mt4

#region int4x2_mt8

public partial struct int4x2_mt8 : IComparable<int4x2_mt8>, IComparable
    , IComparisonOperators<int4x2_mt8, int4x2_mt8, bool>
    , IComparisonOperators<int4x2_mt8, int4x2_mt8, b32m4x2_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is int4x2_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(int4x2_mt8)}");
    }

    static bool IComparisonOperators<int4x2_mt8, int4x2_mt8, bool>.operator <(int4x2_mt8 left, int4x2_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int4x2_mt8, int4x2_mt8, bool>.operator >(int4x2_mt8 left, int4x2_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int4x2_mt8, int4x2_mt8, bool>.operator <=(int4x2_mt8 left, int4x2_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int4x2_mt8, int4x2_mt8, bool>.operator >=(int4x2_mt8 left, int4x2_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(int4x2_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m4x2_mt8 operator <(int4x2_mt8 left, int4x2_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b32m4x2_mt8 operator >(int4x2_mt8 left, int4x2_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b32m4x2_mt8 operator <=(int4x2_mt8 left, int4x2_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b32m4x2_mt8 operator >=(int4x2_mt8 left, int4x2_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(int4x2_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(int4x2_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(int4x2_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(int4x2_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(int4x2_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(int4x2_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(int4x2_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(int4x2_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // int4x2_mt8

#region int4x2_mt16

public partial struct int4x2_mt16 : IComparable<int4x2_mt16>, IComparable
    , IComparisonOperators<int4x2_mt16, int4x2_mt16, bool>
    , IComparisonOperators<int4x2_mt16, int4x2_mt16, b32m4x2_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is int4x2_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(int4x2_mt16)}");
    }

    static bool IComparisonOperators<int4x2_mt16, int4x2_mt16, bool>.operator <(int4x2_mt16 left, int4x2_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int4x2_mt16, int4x2_mt16, bool>.operator >(int4x2_mt16 left, int4x2_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int4x2_mt16, int4x2_mt16, bool>.operator <=(int4x2_mt16 left, int4x2_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int4x2_mt16, int4x2_mt16, bool>.operator >=(int4x2_mt16 left, int4x2_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(int4x2_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m4x2_mt16 operator <(int4x2_mt16 left, int4x2_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b32m4x2_mt16 operator >(int4x2_mt16 left, int4x2_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b32m4x2_mt16 operator <=(int4x2_mt16 left, int4x2_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b32m4x2_mt16 operator >=(int4x2_mt16 left, int4x2_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(int4x2_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(int4x2_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(int4x2_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(int4x2_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(int4x2_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(int4x2_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(int4x2_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(int4x2_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // int4x2_mt16

#region int4x3_mt4

public partial struct int4x3_mt4 : IComparable<int4x3_mt4>, IComparable
    , IComparisonOperators<int4x3_mt4, int4x3_mt4, bool>
    , IComparisonOperators<int4x3_mt4, int4x3_mt4, b32m4x3_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is int4x3_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(int4x3_mt4)}");
    }

    static bool IComparisonOperators<int4x3_mt4, int4x3_mt4, bool>.operator <(int4x3_mt4 left, int4x3_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int4x3_mt4, int4x3_mt4, bool>.operator >(int4x3_mt4 left, int4x3_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int4x3_mt4, int4x3_mt4, bool>.operator <=(int4x3_mt4 left, int4x3_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int4x3_mt4, int4x3_mt4, bool>.operator >=(int4x3_mt4 left, int4x3_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(int4x3_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m4x3_mt4 operator <(int4x3_mt4 left, int4x3_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b32m4x3_mt4 operator >(int4x3_mt4 left, int4x3_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b32m4x3_mt4 operator <=(int4x3_mt4 left, int4x3_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b32m4x3_mt4 operator >=(int4x3_mt4 left, int4x3_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(int4x3_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(int4x3_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(int4x3_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(int4x3_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(int4x3_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(int4x3_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(int4x3_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(int4x3_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // int4x3_mt4

#region int4x3_mt8

public partial struct int4x3_mt8 : IComparable<int4x3_mt8>, IComparable
    , IComparisonOperators<int4x3_mt8, int4x3_mt8, bool>
    , IComparisonOperators<int4x3_mt8, int4x3_mt8, b32m4x3_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is int4x3_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(int4x3_mt8)}");
    }

    static bool IComparisonOperators<int4x3_mt8, int4x3_mt8, bool>.operator <(int4x3_mt8 left, int4x3_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int4x3_mt8, int4x3_mt8, bool>.operator >(int4x3_mt8 left, int4x3_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int4x3_mt8, int4x3_mt8, bool>.operator <=(int4x3_mt8 left, int4x3_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int4x3_mt8, int4x3_mt8, bool>.operator >=(int4x3_mt8 left, int4x3_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(int4x3_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m4x3_mt8 operator <(int4x3_mt8 left, int4x3_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b32m4x3_mt8 operator >(int4x3_mt8 left, int4x3_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b32m4x3_mt8 operator <=(int4x3_mt8 left, int4x3_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b32m4x3_mt8 operator >=(int4x3_mt8 left, int4x3_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(int4x3_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(int4x3_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(int4x3_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(int4x3_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(int4x3_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(int4x3_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(int4x3_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(int4x3_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // int4x3_mt8

#region int4x3_mt16

public partial struct int4x3_mt16 : IComparable<int4x3_mt16>, IComparable
    , IComparisonOperators<int4x3_mt16, int4x3_mt16, bool>
    , IComparisonOperators<int4x3_mt16, int4x3_mt16, b32m4x3_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is int4x3_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(int4x3_mt16)}");
    }

    static bool IComparisonOperators<int4x3_mt16, int4x3_mt16, bool>.operator <(int4x3_mt16 left, int4x3_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int4x3_mt16, int4x3_mt16, bool>.operator >(int4x3_mt16 left, int4x3_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int4x3_mt16, int4x3_mt16, bool>.operator <=(int4x3_mt16 left, int4x3_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int4x3_mt16, int4x3_mt16, bool>.operator >=(int4x3_mt16 left, int4x3_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(int4x3_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m4x3_mt16 operator <(int4x3_mt16 left, int4x3_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b32m4x3_mt16 operator >(int4x3_mt16 left, int4x3_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b32m4x3_mt16 operator <=(int4x3_mt16 left, int4x3_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b32m4x3_mt16 operator >=(int4x3_mt16 left, int4x3_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(int4x3_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(int4x3_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(int4x3_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(int4x3_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(int4x3_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(int4x3_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(int4x3_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(int4x3_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // int4x3_mt16

#region int4x4_mt4

public partial struct int4x4_mt4 : IComparable<int4x4_mt4>, IComparable
    , IComparisonOperators<int4x4_mt4, int4x4_mt4, bool>
    , IComparisonOperators<int4x4_mt4, int4x4_mt4, b32m4x4_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is int4x4_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(int4x4_mt4)}");
    }

    static bool IComparisonOperators<int4x4_mt4, int4x4_mt4, bool>.operator <(int4x4_mt4 left, int4x4_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int4x4_mt4, int4x4_mt4, bool>.operator >(int4x4_mt4 left, int4x4_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int4x4_mt4, int4x4_mt4, bool>.operator <=(int4x4_mt4 left, int4x4_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int4x4_mt4, int4x4_mt4, bool>.operator >=(int4x4_mt4 left, int4x4_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(int4x4_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m4x4_mt4 operator <(int4x4_mt4 left, int4x4_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b32m4x4_mt4 operator >(int4x4_mt4 left, int4x4_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b32m4x4_mt4 operator <=(int4x4_mt4 left, int4x4_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b32m4x4_mt4 operator >=(int4x4_mt4 left, int4x4_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(int4x4_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(int4x4_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(int4x4_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(int4x4_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(int4x4_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(int4x4_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(int4x4_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(int4x4_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // int4x4_mt4

#region int4x4_mt8

public partial struct int4x4_mt8 : IComparable<int4x4_mt8>, IComparable
    , IComparisonOperators<int4x4_mt8, int4x4_mt8, bool>
    , IComparisonOperators<int4x4_mt8, int4x4_mt8, b32m4x4_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is int4x4_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(int4x4_mt8)}");
    }

    static bool IComparisonOperators<int4x4_mt8, int4x4_mt8, bool>.operator <(int4x4_mt8 left, int4x4_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int4x4_mt8, int4x4_mt8, bool>.operator >(int4x4_mt8 left, int4x4_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int4x4_mt8, int4x4_mt8, bool>.operator <=(int4x4_mt8 left, int4x4_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int4x4_mt8, int4x4_mt8, bool>.operator >=(int4x4_mt8 left, int4x4_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(int4x4_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m4x4_mt8 operator <(int4x4_mt8 left, int4x4_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b32m4x4_mt8 operator >(int4x4_mt8 left, int4x4_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b32m4x4_mt8 operator <=(int4x4_mt8 left, int4x4_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b32m4x4_mt8 operator >=(int4x4_mt8 left, int4x4_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(int4x4_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(int4x4_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(int4x4_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(int4x4_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(int4x4_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(int4x4_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(int4x4_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(int4x4_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // int4x4_mt8

#region int4x4_mt16

public partial struct int4x4_mt16 : IComparable<int4x4_mt16>, IComparable
    , IComparisonOperators<int4x4_mt16, int4x4_mt16, bool>
    , IComparisonOperators<int4x4_mt16, int4x4_mt16, b32m4x4_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is int4x4_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(int4x4_mt16)}");
    }

    static bool IComparisonOperators<int4x4_mt16, int4x4_mt16, bool>.operator <(int4x4_mt16 left, int4x4_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int4x4_mt16, int4x4_mt16, bool>.operator >(int4x4_mt16 left, int4x4_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int4x4_mt16, int4x4_mt16, bool>.operator <=(int4x4_mt16 left, int4x4_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int4x4_mt16, int4x4_mt16, bool>.operator >=(int4x4_mt16 left, int4x4_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(int4x4_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m4x4_mt16 operator <(int4x4_mt16 left, int4x4_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b32m4x4_mt16 operator >(int4x4_mt16 left, int4x4_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b32m4x4_mt16 operator <=(int4x4_mt16 left, int4x4_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b32m4x4_mt16 operator >=(int4x4_mt16 left, int4x4_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(int4x4_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(int4x4_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(int4x4_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(int4x4_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(int4x4_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(int4x4_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(int4x4_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(int4x4_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // int4x4_mt16

#region uint2x2_mt4

public partial struct uint2x2_mt4 : IComparable<uint2x2_mt4>, IComparable
    , IComparisonOperators<uint2x2_mt4, uint2x2_mt4, bool>
    , IComparisonOperators<uint2x2_mt4, uint2x2_mt4, b32m2x2_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is uint2x2_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(uint2x2_mt4)}");
    }

    static bool IComparisonOperators<uint2x2_mt4, uint2x2_mt4, bool>.operator <(uint2x2_mt4 left, uint2x2_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint2x2_mt4, uint2x2_mt4, bool>.operator >(uint2x2_mt4 left, uint2x2_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint2x2_mt4, uint2x2_mt4, bool>.operator <=(uint2x2_mt4 left, uint2x2_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint2x2_mt4, uint2x2_mt4, bool>.operator >=(uint2x2_mt4 left, uint2x2_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(uint2x2_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m2x2_mt4 operator <(uint2x2_mt4 left, uint2x2_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b32m2x2_mt4 operator >(uint2x2_mt4 left, uint2x2_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b32m2x2_mt4 operator <=(uint2x2_mt4 left, uint2x2_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b32m2x2_mt4 operator >=(uint2x2_mt4 left, uint2x2_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(uint2x2_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(uint2x2_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(uint2x2_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(uint2x2_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(uint2x2_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(uint2x2_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(uint2x2_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(uint2x2_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // uint2x2_mt4

#region uint2x2_mt8

public partial struct uint2x2_mt8 : IComparable<uint2x2_mt8>, IComparable
    , IComparisonOperators<uint2x2_mt8, uint2x2_mt8, bool>
    , IComparisonOperators<uint2x2_mt8, uint2x2_mt8, b32m2x2_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is uint2x2_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(uint2x2_mt8)}");
    }

    static bool IComparisonOperators<uint2x2_mt8, uint2x2_mt8, bool>.operator <(uint2x2_mt8 left, uint2x2_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint2x2_mt8, uint2x2_mt8, bool>.operator >(uint2x2_mt8 left, uint2x2_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint2x2_mt8, uint2x2_mt8, bool>.operator <=(uint2x2_mt8 left, uint2x2_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint2x2_mt8, uint2x2_mt8, bool>.operator >=(uint2x2_mt8 left, uint2x2_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(uint2x2_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m2x2_mt8 operator <(uint2x2_mt8 left, uint2x2_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b32m2x2_mt8 operator >(uint2x2_mt8 left, uint2x2_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b32m2x2_mt8 operator <=(uint2x2_mt8 left, uint2x2_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b32m2x2_mt8 operator >=(uint2x2_mt8 left, uint2x2_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(uint2x2_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(uint2x2_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(uint2x2_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(uint2x2_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(uint2x2_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(uint2x2_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(uint2x2_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(uint2x2_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // uint2x2_mt8

#region uint2x2_mt16

public partial struct uint2x2_mt16 : IComparable<uint2x2_mt16>, IComparable
    , IComparisonOperators<uint2x2_mt16, uint2x2_mt16, bool>
    , IComparisonOperators<uint2x2_mt16, uint2x2_mt16, b32m2x2_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is uint2x2_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(uint2x2_mt16)}");
    }

    static bool IComparisonOperators<uint2x2_mt16, uint2x2_mt16, bool>.operator <(uint2x2_mt16 left, uint2x2_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint2x2_mt16, uint2x2_mt16, bool>.operator >(uint2x2_mt16 left, uint2x2_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint2x2_mt16, uint2x2_mt16, bool>.operator <=(uint2x2_mt16 left, uint2x2_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint2x2_mt16, uint2x2_mt16, bool>.operator >=(uint2x2_mt16 left, uint2x2_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(uint2x2_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m2x2_mt16 operator <(uint2x2_mt16 left, uint2x2_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b32m2x2_mt16 operator >(uint2x2_mt16 left, uint2x2_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b32m2x2_mt16 operator <=(uint2x2_mt16 left, uint2x2_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b32m2x2_mt16 operator >=(uint2x2_mt16 left, uint2x2_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(uint2x2_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(uint2x2_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(uint2x2_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(uint2x2_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(uint2x2_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(uint2x2_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(uint2x2_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(uint2x2_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // uint2x2_mt16

#region uint2x3_mt4

public partial struct uint2x3_mt4 : IComparable<uint2x3_mt4>, IComparable
    , IComparisonOperators<uint2x3_mt4, uint2x3_mt4, bool>
    , IComparisonOperators<uint2x3_mt4, uint2x3_mt4, b32m2x3_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is uint2x3_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(uint2x3_mt4)}");
    }

    static bool IComparisonOperators<uint2x3_mt4, uint2x3_mt4, bool>.operator <(uint2x3_mt4 left, uint2x3_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint2x3_mt4, uint2x3_mt4, bool>.operator >(uint2x3_mt4 left, uint2x3_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint2x3_mt4, uint2x3_mt4, bool>.operator <=(uint2x3_mt4 left, uint2x3_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint2x3_mt4, uint2x3_mt4, bool>.operator >=(uint2x3_mt4 left, uint2x3_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(uint2x3_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m2x3_mt4 operator <(uint2x3_mt4 left, uint2x3_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b32m2x3_mt4 operator >(uint2x3_mt4 left, uint2x3_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b32m2x3_mt4 operator <=(uint2x3_mt4 left, uint2x3_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b32m2x3_mt4 operator >=(uint2x3_mt4 left, uint2x3_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(uint2x3_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(uint2x3_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(uint2x3_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(uint2x3_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(uint2x3_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(uint2x3_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(uint2x3_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(uint2x3_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // uint2x3_mt4

#region uint2x3_mt8

public partial struct uint2x3_mt8 : IComparable<uint2x3_mt8>, IComparable
    , IComparisonOperators<uint2x3_mt8, uint2x3_mt8, bool>
    , IComparisonOperators<uint2x3_mt8, uint2x3_mt8, b32m2x3_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is uint2x3_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(uint2x3_mt8)}");
    }

    static bool IComparisonOperators<uint2x3_mt8, uint2x3_mt8, bool>.operator <(uint2x3_mt8 left, uint2x3_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint2x3_mt8, uint2x3_mt8, bool>.operator >(uint2x3_mt8 left, uint2x3_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint2x3_mt8, uint2x3_mt8, bool>.operator <=(uint2x3_mt8 left, uint2x3_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint2x3_mt8, uint2x3_mt8, bool>.operator >=(uint2x3_mt8 left, uint2x3_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(uint2x3_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m2x3_mt8 operator <(uint2x3_mt8 left, uint2x3_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b32m2x3_mt8 operator >(uint2x3_mt8 left, uint2x3_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b32m2x3_mt8 operator <=(uint2x3_mt8 left, uint2x3_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b32m2x3_mt8 operator >=(uint2x3_mt8 left, uint2x3_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(uint2x3_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(uint2x3_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(uint2x3_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(uint2x3_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(uint2x3_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(uint2x3_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(uint2x3_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(uint2x3_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // uint2x3_mt8

#region uint2x3_mt16

public partial struct uint2x3_mt16 : IComparable<uint2x3_mt16>, IComparable
    , IComparisonOperators<uint2x3_mt16, uint2x3_mt16, bool>
    , IComparisonOperators<uint2x3_mt16, uint2x3_mt16, b32m2x3_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is uint2x3_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(uint2x3_mt16)}");
    }

    static bool IComparisonOperators<uint2x3_mt16, uint2x3_mt16, bool>.operator <(uint2x3_mt16 left, uint2x3_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint2x3_mt16, uint2x3_mt16, bool>.operator >(uint2x3_mt16 left, uint2x3_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint2x3_mt16, uint2x3_mt16, bool>.operator <=(uint2x3_mt16 left, uint2x3_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint2x3_mt16, uint2x3_mt16, bool>.operator >=(uint2x3_mt16 left, uint2x3_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(uint2x3_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m2x3_mt16 operator <(uint2x3_mt16 left, uint2x3_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b32m2x3_mt16 operator >(uint2x3_mt16 left, uint2x3_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b32m2x3_mt16 operator <=(uint2x3_mt16 left, uint2x3_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b32m2x3_mt16 operator >=(uint2x3_mt16 left, uint2x3_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(uint2x3_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(uint2x3_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(uint2x3_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(uint2x3_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(uint2x3_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(uint2x3_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(uint2x3_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(uint2x3_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // uint2x3_mt16

#region uint2x4_mt4

public partial struct uint2x4_mt4 : IComparable<uint2x4_mt4>, IComparable
    , IComparisonOperators<uint2x4_mt4, uint2x4_mt4, bool>
    , IComparisonOperators<uint2x4_mt4, uint2x4_mt4, b32m2x4_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is uint2x4_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(uint2x4_mt4)}");
    }

    static bool IComparisonOperators<uint2x4_mt4, uint2x4_mt4, bool>.operator <(uint2x4_mt4 left, uint2x4_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint2x4_mt4, uint2x4_mt4, bool>.operator >(uint2x4_mt4 left, uint2x4_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint2x4_mt4, uint2x4_mt4, bool>.operator <=(uint2x4_mt4 left, uint2x4_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint2x4_mt4, uint2x4_mt4, bool>.operator >=(uint2x4_mt4 left, uint2x4_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(uint2x4_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m2x4_mt4 operator <(uint2x4_mt4 left, uint2x4_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b32m2x4_mt4 operator >(uint2x4_mt4 left, uint2x4_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b32m2x4_mt4 operator <=(uint2x4_mt4 left, uint2x4_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b32m2x4_mt4 operator >=(uint2x4_mt4 left, uint2x4_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(uint2x4_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(uint2x4_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(uint2x4_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(uint2x4_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(uint2x4_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(uint2x4_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(uint2x4_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(uint2x4_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // uint2x4_mt4

#region uint2x4_mt8

public partial struct uint2x4_mt8 : IComparable<uint2x4_mt8>, IComparable
    , IComparisonOperators<uint2x4_mt8, uint2x4_mt8, bool>
    , IComparisonOperators<uint2x4_mt8, uint2x4_mt8, b32m2x4_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is uint2x4_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(uint2x4_mt8)}");
    }

    static bool IComparisonOperators<uint2x4_mt8, uint2x4_mt8, bool>.operator <(uint2x4_mt8 left, uint2x4_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint2x4_mt8, uint2x4_mt8, bool>.operator >(uint2x4_mt8 left, uint2x4_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint2x4_mt8, uint2x4_mt8, bool>.operator <=(uint2x4_mt8 left, uint2x4_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint2x4_mt8, uint2x4_mt8, bool>.operator >=(uint2x4_mt8 left, uint2x4_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(uint2x4_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m2x4_mt8 operator <(uint2x4_mt8 left, uint2x4_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b32m2x4_mt8 operator >(uint2x4_mt8 left, uint2x4_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b32m2x4_mt8 operator <=(uint2x4_mt8 left, uint2x4_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b32m2x4_mt8 operator >=(uint2x4_mt8 left, uint2x4_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(uint2x4_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(uint2x4_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(uint2x4_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(uint2x4_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(uint2x4_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(uint2x4_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(uint2x4_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(uint2x4_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // uint2x4_mt8

#region uint2x4_mt16

public partial struct uint2x4_mt16 : IComparable<uint2x4_mt16>, IComparable
    , IComparisonOperators<uint2x4_mt16, uint2x4_mt16, bool>
    , IComparisonOperators<uint2x4_mt16, uint2x4_mt16, b32m2x4_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is uint2x4_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(uint2x4_mt16)}");
    }

    static bool IComparisonOperators<uint2x4_mt16, uint2x4_mt16, bool>.operator <(uint2x4_mt16 left, uint2x4_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint2x4_mt16, uint2x4_mt16, bool>.operator >(uint2x4_mt16 left, uint2x4_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint2x4_mt16, uint2x4_mt16, bool>.operator <=(uint2x4_mt16 left, uint2x4_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint2x4_mt16, uint2x4_mt16, bool>.operator >=(uint2x4_mt16 left, uint2x4_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(uint2x4_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m2x4_mt16 operator <(uint2x4_mt16 left, uint2x4_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b32m2x4_mt16 operator >(uint2x4_mt16 left, uint2x4_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b32m2x4_mt16 operator <=(uint2x4_mt16 left, uint2x4_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b32m2x4_mt16 operator >=(uint2x4_mt16 left, uint2x4_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(uint2x4_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(uint2x4_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(uint2x4_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(uint2x4_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(uint2x4_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(uint2x4_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(uint2x4_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(uint2x4_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // uint2x4_mt16

#region uint3x2_mt4

public partial struct uint3x2_mt4 : IComparable<uint3x2_mt4>, IComparable
    , IComparisonOperators<uint3x2_mt4, uint3x2_mt4, bool>
    , IComparisonOperators<uint3x2_mt4, uint3x2_mt4, b32m3x2_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is uint3x2_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(uint3x2_mt4)}");
    }

    static bool IComparisonOperators<uint3x2_mt4, uint3x2_mt4, bool>.operator <(uint3x2_mt4 left, uint3x2_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint3x2_mt4, uint3x2_mt4, bool>.operator >(uint3x2_mt4 left, uint3x2_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint3x2_mt4, uint3x2_mt4, bool>.operator <=(uint3x2_mt4 left, uint3x2_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint3x2_mt4, uint3x2_mt4, bool>.operator >=(uint3x2_mt4 left, uint3x2_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(uint3x2_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m3x2_mt4 operator <(uint3x2_mt4 left, uint3x2_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b32m3x2_mt4 operator >(uint3x2_mt4 left, uint3x2_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b32m3x2_mt4 operator <=(uint3x2_mt4 left, uint3x2_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b32m3x2_mt4 operator >=(uint3x2_mt4 left, uint3x2_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(uint3x2_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(uint3x2_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(uint3x2_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(uint3x2_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(uint3x2_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(uint3x2_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(uint3x2_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(uint3x2_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // uint3x2_mt4

#region uint3x2_mt8

public partial struct uint3x2_mt8 : IComparable<uint3x2_mt8>, IComparable
    , IComparisonOperators<uint3x2_mt8, uint3x2_mt8, bool>
    , IComparisonOperators<uint3x2_mt8, uint3x2_mt8, b32m3x2_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is uint3x2_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(uint3x2_mt8)}");
    }

    static bool IComparisonOperators<uint3x2_mt8, uint3x2_mt8, bool>.operator <(uint3x2_mt8 left, uint3x2_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint3x2_mt8, uint3x2_mt8, bool>.operator >(uint3x2_mt8 left, uint3x2_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint3x2_mt8, uint3x2_mt8, bool>.operator <=(uint3x2_mt8 left, uint3x2_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint3x2_mt8, uint3x2_mt8, bool>.operator >=(uint3x2_mt8 left, uint3x2_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(uint3x2_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m3x2_mt8 operator <(uint3x2_mt8 left, uint3x2_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b32m3x2_mt8 operator >(uint3x2_mt8 left, uint3x2_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b32m3x2_mt8 operator <=(uint3x2_mt8 left, uint3x2_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b32m3x2_mt8 operator >=(uint3x2_mt8 left, uint3x2_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(uint3x2_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(uint3x2_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(uint3x2_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(uint3x2_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(uint3x2_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(uint3x2_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(uint3x2_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(uint3x2_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // uint3x2_mt8

#region uint3x2_mt16

public partial struct uint3x2_mt16 : IComparable<uint3x2_mt16>, IComparable
    , IComparisonOperators<uint3x2_mt16, uint3x2_mt16, bool>
    , IComparisonOperators<uint3x2_mt16, uint3x2_mt16, b32m3x2_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is uint3x2_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(uint3x2_mt16)}");
    }

    static bool IComparisonOperators<uint3x2_mt16, uint3x2_mt16, bool>.operator <(uint3x2_mt16 left, uint3x2_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint3x2_mt16, uint3x2_mt16, bool>.operator >(uint3x2_mt16 left, uint3x2_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint3x2_mt16, uint3x2_mt16, bool>.operator <=(uint3x2_mt16 left, uint3x2_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint3x2_mt16, uint3x2_mt16, bool>.operator >=(uint3x2_mt16 left, uint3x2_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(uint3x2_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m3x2_mt16 operator <(uint3x2_mt16 left, uint3x2_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b32m3x2_mt16 operator >(uint3x2_mt16 left, uint3x2_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b32m3x2_mt16 operator <=(uint3x2_mt16 left, uint3x2_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b32m3x2_mt16 operator >=(uint3x2_mt16 left, uint3x2_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(uint3x2_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(uint3x2_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(uint3x2_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(uint3x2_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(uint3x2_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(uint3x2_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(uint3x2_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(uint3x2_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // uint3x2_mt16

#region uint3x3_mt4

public partial struct uint3x3_mt4 : IComparable<uint3x3_mt4>, IComparable
    , IComparisonOperators<uint3x3_mt4, uint3x3_mt4, bool>
    , IComparisonOperators<uint3x3_mt4, uint3x3_mt4, b32m3x3_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is uint3x3_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(uint3x3_mt4)}");
    }

    static bool IComparisonOperators<uint3x3_mt4, uint3x3_mt4, bool>.operator <(uint3x3_mt4 left, uint3x3_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint3x3_mt4, uint3x3_mt4, bool>.operator >(uint3x3_mt4 left, uint3x3_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint3x3_mt4, uint3x3_mt4, bool>.operator <=(uint3x3_mt4 left, uint3x3_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint3x3_mt4, uint3x3_mt4, bool>.operator >=(uint3x3_mt4 left, uint3x3_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(uint3x3_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m3x3_mt4 operator <(uint3x3_mt4 left, uint3x3_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b32m3x3_mt4 operator >(uint3x3_mt4 left, uint3x3_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b32m3x3_mt4 operator <=(uint3x3_mt4 left, uint3x3_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b32m3x3_mt4 operator >=(uint3x3_mt4 left, uint3x3_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(uint3x3_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(uint3x3_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(uint3x3_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(uint3x3_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(uint3x3_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(uint3x3_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(uint3x3_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(uint3x3_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // uint3x3_mt4

#region uint3x3_mt8

public partial struct uint3x3_mt8 : IComparable<uint3x3_mt8>, IComparable
    , IComparisonOperators<uint3x3_mt8, uint3x3_mt8, bool>
    , IComparisonOperators<uint3x3_mt8, uint3x3_mt8, b32m3x3_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is uint3x3_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(uint3x3_mt8)}");
    }

    static bool IComparisonOperators<uint3x3_mt8, uint3x3_mt8, bool>.operator <(uint3x3_mt8 left, uint3x3_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint3x3_mt8, uint3x3_mt8, bool>.operator >(uint3x3_mt8 left, uint3x3_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint3x3_mt8, uint3x3_mt8, bool>.operator <=(uint3x3_mt8 left, uint3x3_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint3x3_mt8, uint3x3_mt8, bool>.operator >=(uint3x3_mt8 left, uint3x3_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(uint3x3_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m3x3_mt8 operator <(uint3x3_mt8 left, uint3x3_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b32m3x3_mt8 operator >(uint3x3_mt8 left, uint3x3_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b32m3x3_mt8 operator <=(uint3x3_mt8 left, uint3x3_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b32m3x3_mt8 operator >=(uint3x3_mt8 left, uint3x3_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(uint3x3_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(uint3x3_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(uint3x3_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(uint3x3_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(uint3x3_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(uint3x3_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(uint3x3_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(uint3x3_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // uint3x3_mt8

#region uint3x3_mt16

public partial struct uint3x3_mt16 : IComparable<uint3x3_mt16>, IComparable
    , IComparisonOperators<uint3x3_mt16, uint3x3_mt16, bool>
    , IComparisonOperators<uint3x3_mt16, uint3x3_mt16, b32m3x3_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is uint3x3_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(uint3x3_mt16)}");
    }

    static bool IComparisonOperators<uint3x3_mt16, uint3x3_mt16, bool>.operator <(uint3x3_mt16 left, uint3x3_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint3x3_mt16, uint3x3_mt16, bool>.operator >(uint3x3_mt16 left, uint3x3_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint3x3_mt16, uint3x3_mt16, bool>.operator <=(uint3x3_mt16 left, uint3x3_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint3x3_mt16, uint3x3_mt16, bool>.operator >=(uint3x3_mt16 left, uint3x3_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(uint3x3_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m3x3_mt16 operator <(uint3x3_mt16 left, uint3x3_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b32m3x3_mt16 operator >(uint3x3_mt16 left, uint3x3_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b32m3x3_mt16 operator <=(uint3x3_mt16 left, uint3x3_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b32m3x3_mt16 operator >=(uint3x3_mt16 left, uint3x3_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(uint3x3_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(uint3x3_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(uint3x3_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(uint3x3_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(uint3x3_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(uint3x3_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(uint3x3_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(uint3x3_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // uint3x3_mt16

#region uint3x4_mt4

public partial struct uint3x4_mt4 : IComparable<uint3x4_mt4>, IComparable
    , IComparisonOperators<uint3x4_mt4, uint3x4_mt4, bool>
    , IComparisonOperators<uint3x4_mt4, uint3x4_mt4, b32m3x4_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is uint3x4_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(uint3x4_mt4)}");
    }

    static bool IComparisonOperators<uint3x4_mt4, uint3x4_mt4, bool>.operator <(uint3x4_mt4 left, uint3x4_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint3x4_mt4, uint3x4_mt4, bool>.operator >(uint3x4_mt4 left, uint3x4_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint3x4_mt4, uint3x4_mt4, bool>.operator <=(uint3x4_mt4 left, uint3x4_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint3x4_mt4, uint3x4_mt4, bool>.operator >=(uint3x4_mt4 left, uint3x4_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(uint3x4_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m3x4_mt4 operator <(uint3x4_mt4 left, uint3x4_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b32m3x4_mt4 operator >(uint3x4_mt4 left, uint3x4_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b32m3x4_mt4 operator <=(uint3x4_mt4 left, uint3x4_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b32m3x4_mt4 operator >=(uint3x4_mt4 left, uint3x4_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(uint3x4_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(uint3x4_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(uint3x4_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(uint3x4_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(uint3x4_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(uint3x4_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(uint3x4_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(uint3x4_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // uint3x4_mt4

#region uint3x4_mt8

public partial struct uint3x4_mt8 : IComparable<uint3x4_mt8>, IComparable
    , IComparisonOperators<uint3x4_mt8, uint3x4_mt8, bool>
    , IComparisonOperators<uint3x4_mt8, uint3x4_mt8, b32m3x4_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is uint3x4_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(uint3x4_mt8)}");
    }

    static bool IComparisonOperators<uint3x4_mt8, uint3x4_mt8, bool>.operator <(uint3x4_mt8 left, uint3x4_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint3x4_mt8, uint3x4_mt8, bool>.operator >(uint3x4_mt8 left, uint3x4_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint3x4_mt8, uint3x4_mt8, bool>.operator <=(uint3x4_mt8 left, uint3x4_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint3x4_mt8, uint3x4_mt8, bool>.operator >=(uint3x4_mt8 left, uint3x4_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(uint3x4_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m3x4_mt8 operator <(uint3x4_mt8 left, uint3x4_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b32m3x4_mt8 operator >(uint3x4_mt8 left, uint3x4_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b32m3x4_mt8 operator <=(uint3x4_mt8 left, uint3x4_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b32m3x4_mt8 operator >=(uint3x4_mt8 left, uint3x4_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(uint3x4_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(uint3x4_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(uint3x4_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(uint3x4_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(uint3x4_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(uint3x4_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(uint3x4_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(uint3x4_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // uint3x4_mt8

#region uint3x4_mt16

public partial struct uint3x4_mt16 : IComparable<uint3x4_mt16>, IComparable
    , IComparisonOperators<uint3x4_mt16, uint3x4_mt16, bool>
    , IComparisonOperators<uint3x4_mt16, uint3x4_mt16, b32m3x4_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is uint3x4_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(uint3x4_mt16)}");
    }

    static bool IComparisonOperators<uint3x4_mt16, uint3x4_mt16, bool>.operator <(uint3x4_mt16 left, uint3x4_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint3x4_mt16, uint3x4_mt16, bool>.operator >(uint3x4_mt16 left, uint3x4_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint3x4_mt16, uint3x4_mt16, bool>.operator <=(uint3x4_mt16 left, uint3x4_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint3x4_mt16, uint3x4_mt16, bool>.operator >=(uint3x4_mt16 left, uint3x4_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(uint3x4_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m3x4_mt16 operator <(uint3x4_mt16 left, uint3x4_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b32m3x4_mt16 operator >(uint3x4_mt16 left, uint3x4_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b32m3x4_mt16 operator <=(uint3x4_mt16 left, uint3x4_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b32m3x4_mt16 operator >=(uint3x4_mt16 left, uint3x4_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(uint3x4_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(uint3x4_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(uint3x4_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(uint3x4_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(uint3x4_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(uint3x4_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(uint3x4_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(uint3x4_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // uint3x4_mt16

#region uint4x2_mt4

public partial struct uint4x2_mt4 : IComparable<uint4x2_mt4>, IComparable
    , IComparisonOperators<uint4x2_mt4, uint4x2_mt4, bool>
    , IComparisonOperators<uint4x2_mt4, uint4x2_mt4, b32m4x2_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is uint4x2_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(uint4x2_mt4)}");
    }

    static bool IComparisonOperators<uint4x2_mt4, uint4x2_mt4, bool>.operator <(uint4x2_mt4 left, uint4x2_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint4x2_mt4, uint4x2_mt4, bool>.operator >(uint4x2_mt4 left, uint4x2_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint4x2_mt4, uint4x2_mt4, bool>.operator <=(uint4x2_mt4 left, uint4x2_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint4x2_mt4, uint4x2_mt4, bool>.operator >=(uint4x2_mt4 left, uint4x2_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(uint4x2_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m4x2_mt4 operator <(uint4x2_mt4 left, uint4x2_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b32m4x2_mt4 operator >(uint4x2_mt4 left, uint4x2_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b32m4x2_mt4 operator <=(uint4x2_mt4 left, uint4x2_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b32m4x2_mt4 operator >=(uint4x2_mt4 left, uint4x2_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(uint4x2_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(uint4x2_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(uint4x2_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(uint4x2_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(uint4x2_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(uint4x2_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(uint4x2_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(uint4x2_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // uint4x2_mt4

#region uint4x2_mt8

public partial struct uint4x2_mt8 : IComparable<uint4x2_mt8>, IComparable
    , IComparisonOperators<uint4x2_mt8, uint4x2_mt8, bool>
    , IComparisonOperators<uint4x2_mt8, uint4x2_mt8, b32m4x2_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is uint4x2_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(uint4x2_mt8)}");
    }

    static bool IComparisonOperators<uint4x2_mt8, uint4x2_mt8, bool>.operator <(uint4x2_mt8 left, uint4x2_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint4x2_mt8, uint4x2_mt8, bool>.operator >(uint4x2_mt8 left, uint4x2_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint4x2_mt8, uint4x2_mt8, bool>.operator <=(uint4x2_mt8 left, uint4x2_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint4x2_mt8, uint4x2_mt8, bool>.operator >=(uint4x2_mt8 left, uint4x2_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(uint4x2_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m4x2_mt8 operator <(uint4x2_mt8 left, uint4x2_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b32m4x2_mt8 operator >(uint4x2_mt8 left, uint4x2_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b32m4x2_mt8 operator <=(uint4x2_mt8 left, uint4x2_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b32m4x2_mt8 operator >=(uint4x2_mt8 left, uint4x2_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(uint4x2_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(uint4x2_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(uint4x2_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(uint4x2_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(uint4x2_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(uint4x2_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(uint4x2_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(uint4x2_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // uint4x2_mt8

#region uint4x2_mt16

public partial struct uint4x2_mt16 : IComparable<uint4x2_mt16>, IComparable
    , IComparisonOperators<uint4x2_mt16, uint4x2_mt16, bool>
    , IComparisonOperators<uint4x2_mt16, uint4x2_mt16, b32m4x2_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is uint4x2_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(uint4x2_mt16)}");
    }

    static bool IComparisonOperators<uint4x2_mt16, uint4x2_mt16, bool>.operator <(uint4x2_mt16 left, uint4x2_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint4x2_mt16, uint4x2_mt16, bool>.operator >(uint4x2_mt16 left, uint4x2_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint4x2_mt16, uint4x2_mt16, bool>.operator <=(uint4x2_mt16 left, uint4x2_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint4x2_mt16, uint4x2_mt16, bool>.operator >=(uint4x2_mt16 left, uint4x2_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(uint4x2_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m4x2_mt16 operator <(uint4x2_mt16 left, uint4x2_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b32m4x2_mt16 operator >(uint4x2_mt16 left, uint4x2_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b32m4x2_mt16 operator <=(uint4x2_mt16 left, uint4x2_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b32m4x2_mt16 operator >=(uint4x2_mt16 left, uint4x2_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(uint4x2_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(uint4x2_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(uint4x2_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(uint4x2_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(uint4x2_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(uint4x2_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(uint4x2_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(uint4x2_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // uint4x2_mt16

#region uint4x3_mt4

public partial struct uint4x3_mt4 : IComparable<uint4x3_mt4>, IComparable
    , IComparisonOperators<uint4x3_mt4, uint4x3_mt4, bool>
    , IComparisonOperators<uint4x3_mt4, uint4x3_mt4, b32m4x3_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is uint4x3_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(uint4x3_mt4)}");
    }

    static bool IComparisonOperators<uint4x3_mt4, uint4x3_mt4, bool>.operator <(uint4x3_mt4 left, uint4x3_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint4x3_mt4, uint4x3_mt4, bool>.operator >(uint4x3_mt4 left, uint4x3_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint4x3_mt4, uint4x3_mt4, bool>.operator <=(uint4x3_mt4 left, uint4x3_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint4x3_mt4, uint4x3_mt4, bool>.operator >=(uint4x3_mt4 left, uint4x3_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(uint4x3_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m4x3_mt4 operator <(uint4x3_mt4 left, uint4x3_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b32m4x3_mt4 operator >(uint4x3_mt4 left, uint4x3_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b32m4x3_mt4 operator <=(uint4x3_mt4 left, uint4x3_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b32m4x3_mt4 operator >=(uint4x3_mt4 left, uint4x3_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(uint4x3_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(uint4x3_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(uint4x3_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(uint4x3_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(uint4x3_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(uint4x3_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(uint4x3_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(uint4x3_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // uint4x3_mt4

#region uint4x3_mt8

public partial struct uint4x3_mt8 : IComparable<uint4x3_mt8>, IComparable
    , IComparisonOperators<uint4x3_mt8, uint4x3_mt8, bool>
    , IComparisonOperators<uint4x3_mt8, uint4x3_mt8, b32m4x3_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is uint4x3_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(uint4x3_mt8)}");
    }

    static bool IComparisonOperators<uint4x3_mt8, uint4x3_mt8, bool>.operator <(uint4x3_mt8 left, uint4x3_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint4x3_mt8, uint4x3_mt8, bool>.operator >(uint4x3_mt8 left, uint4x3_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint4x3_mt8, uint4x3_mt8, bool>.operator <=(uint4x3_mt8 left, uint4x3_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint4x3_mt8, uint4x3_mt8, bool>.operator >=(uint4x3_mt8 left, uint4x3_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(uint4x3_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m4x3_mt8 operator <(uint4x3_mt8 left, uint4x3_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b32m4x3_mt8 operator >(uint4x3_mt8 left, uint4x3_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b32m4x3_mt8 operator <=(uint4x3_mt8 left, uint4x3_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b32m4x3_mt8 operator >=(uint4x3_mt8 left, uint4x3_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(uint4x3_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(uint4x3_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(uint4x3_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(uint4x3_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(uint4x3_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(uint4x3_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(uint4x3_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(uint4x3_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // uint4x3_mt8

#region uint4x3_mt16

public partial struct uint4x3_mt16 : IComparable<uint4x3_mt16>, IComparable
    , IComparisonOperators<uint4x3_mt16, uint4x3_mt16, bool>
    , IComparisonOperators<uint4x3_mt16, uint4x3_mt16, b32m4x3_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is uint4x3_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(uint4x3_mt16)}");
    }

    static bool IComparisonOperators<uint4x3_mt16, uint4x3_mt16, bool>.operator <(uint4x3_mt16 left, uint4x3_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint4x3_mt16, uint4x3_mt16, bool>.operator >(uint4x3_mt16 left, uint4x3_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint4x3_mt16, uint4x3_mt16, bool>.operator <=(uint4x3_mt16 left, uint4x3_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint4x3_mt16, uint4x3_mt16, bool>.operator >=(uint4x3_mt16 left, uint4x3_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(uint4x3_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m4x3_mt16 operator <(uint4x3_mt16 left, uint4x3_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b32m4x3_mt16 operator >(uint4x3_mt16 left, uint4x3_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b32m4x3_mt16 operator <=(uint4x3_mt16 left, uint4x3_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b32m4x3_mt16 operator >=(uint4x3_mt16 left, uint4x3_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(uint4x3_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(uint4x3_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(uint4x3_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(uint4x3_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(uint4x3_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(uint4x3_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(uint4x3_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(uint4x3_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // uint4x3_mt16

#region uint4x4_mt4

public partial struct uint4x4_mt4 : IComparable<uint4x4_mt4>, IComparable
    , IComparisonOperators<uint4x4_mt4, uint4x4_mt4, bool>
    , IComparisonOperators<uint4x4_mt4, uint4x4_mt4, b32m4x4_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is uint4x4_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(uint4x4_mt4)}");
    }

    static bool IComparisonOperators<uint4x4_mt4, uint4x4_mt4, bool>.operator <(uint4x4_mt4 left, uint4x4_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint4x4_mt4, uint4x4_mt4, bool>.operator >(uint4x4_mt4 left, uint4x4_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint4x4_mt4, uint4x4_mt4, bool>.operator <=(uint4x4_mt4 left, uint4x4_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint4x4_mt4, uint4x4_mt4, bool>.operator >=(uint4x4_mt4 left, uint4x4_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(uint4x4_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m4x4_mt4 operator <(uint4x4_mt4 left, uint4x4_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b32m4x4_mt4 operator >(uint4x4_mt4 left, uint4x4_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b32m4x4_mt4 operator <=(uint4x4_mt4 left, uint4x4_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b32m4x4_mt4 operator >=(uint4x4_mt4 left, uint4x4_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(uint4x4_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(uint4x4_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(uint4x4_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(uint4x4_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(uint4x4_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(uint4x4_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(uint4x4_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(uint4x4_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // uint4x4_mt4

#region uint4x4_mt8

public partial struct uint4x4_mt8 : IComparable<uint4x4_mt8>, IComparable
    , IComparisonOperators<uint4x4_mt8, uint4x4_mt8, bool>
    , IComparisonOperators<uint4x4_mt8, uint4x4_mt8, b32m4x4_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is uint4x4_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(uint4x4_mt8)}");
    }

    static bool IComparisonOperators<uint4x4_mt8, uint4x4_mt8, bool>.operator <(uint4x4_mt8 left, uint4x4_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint4x4_mt8, uint4x4_mt8, bool>.operator >(uint4x4_mt8 left, uint4x4_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint4x4_mt8, uint4x4_mt8, bool>.operator <=(uint4x4_mt8 left, uint4x4_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint4x4_mt8, uint4x4_mt8, bool>.operator >=(uint4x4_mt8 left, uint4x4_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(uint4x4_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m4x4_mt8 operator <(uint4x4_mt8 left, uint4x4_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b32m4x4_mt8 operator >(uint4x4_mt8 left, uint4x4_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b32m4x4_mt8 operator <=(uint4x4_mt8 left, uint4x4_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b32m4x4_mt8 operator >=(uint4x4_mt8 left, uint4x4_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(uint4x4_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(uint4x4_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(uint4x4_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(uint4x4_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(uint4x4_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(uint4x4_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(uint4x4_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(uint4x4_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // uint4x4_mt8

#region uint4x4_mt16

public partial struct uint4x4_mt16 : IComparable<uint4x4_mt16>, IComparable
    , IComparisonOperators<uint4x4_mt16, uint4x4_mt16, bool>
    , IComparisonOperators<uint4x4_mt16, uint4x4_mt16, b32m4x4_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is uint4x4_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(uint4x4_mt16)}");
    }

    static bool IComparisonOperators<uint4x4_mt16, uint4x4_mt16, bool>.operator <(uint4x4_mt16 left, uint4x4_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint4x4_mt16, uint4x4_mt16, bool>.operator >(uint4x4_mt16 left, uint4x4_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint4x4_mt16, uint4x4_mt16, bool>.operator <=(uint4x4_mt16 left, uint4x4_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint4x4_mt16, uint4x4_mt16, bool>.operator >=(uint4x4_mt16 left, uint4x4_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(uint4x4_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m4x4_mt16 operator <(uint4x4_mt16 left, uint4x4_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b32m4x4_mt16 operator >(uint4x4_mt16 left, uint4x4_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b32m4x4_mt16 operator <=(uint4x4_mt16 left, uint4x4_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b32m4x4_mt16 operator >=(uint4x4_mt16 left, uint4x4_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(uint4x4_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(uint4x4_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(uint4x4_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(uint4x4_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(uint4x4_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(uint4x4_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(uint4x4_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(uint4x4_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // uint4x4_mt16

#region long2x2_mt4

public partial struct long2x2_mt4 : IComparable<long2x2_mt4>, IComparable
    , IComparisonOperators<long2x2_mt4, long2x2_mt4, bool>
    , IComparisonOperators<long2x2_mt4, long2x2_mt4, b64m2x2_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is long2x2_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(long2x2_mt4)}");
    }

    static bool IComparisonOperators<long2x2_mt4, long2x2_mt4, bool>.operator <(long2x2_mt4 left, long2x2_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long2x2_mt4, long2x2_mt4, bool>.operator >(long2x2_mt4 left, long2x2_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long2x2_mt4, long2x2_mt4, bool>.operator <=(long2x2_mt4 left, long2x2_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long2x2_mt4, long2x2_mt4, bool>.operator >=(long2x2_mt4 left, long2x2_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(long2x2_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m2x2_mt4 operator <(long2x2_mt4 left, long2x2_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b64m2x2_mt4 operator >(long2x2_mt4 left, long2x2_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b64m2x2_mt4 operator <=(long2x2_mt4 left, long2x2_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b64m2x2_mt4 operator >=(long2x2_mt4 left, long2x2_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(long2x2_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(long2x2_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(long2x2_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(long2x2_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(long2x2_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(long2x2_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(long2x2_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(long2x2_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // long2x2_mt4

#region long2x2_mt8

public partial struct long2x2_mt8 : IComparable<long2x2_mt8>, IComparable
    , IComparisonOperators<long2x2_mt8, long2x2_mt8, bool>
    , IComparisonOperators<long2x2_mt8, long2x2_mt8, b64m2x2_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is long2x2_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(long2x2_mt8)}");
    }

    static bool IComparisonOperators<long2x2_mt8, long2x2_mt8, bool>.operator <(long2x2_mt8 left, long2x2_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long2x2_mt8, long2x2_mt8, bool>.operator >(long2x2_mt8 left, long2x2_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long2x2_mt8, long2x2_mt8, bool>.operator <=(long2x2_mt8 left, long2x2_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long2x2_mt8, long2x2_mt8, bool>.operator >=(long2x2_mt8 left, long2x2_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(long2x2_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m2x2_mt8 operator <(long2x2_mt8 left, long2x2_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b64m2x2_mt8 operator >(long2x2_mt8 left, long2x2_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b64m2x2_mt8 operator <=(long2x2_mt8 left, long2x2_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b64m2x2_mt8 operator >=(long2x2_mt8 left, long2x2_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(long2x2_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(long2x2_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(long2x2_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(long2x2_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(long2x2_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(long2x2_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(long2x2_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(long2x2_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // long2x2_mt8

#region long2x2_mt16

public partial struct long2x2_mt16 : IComparable<long2x2_mt16>, IComparable
    , IComparisonOperators<long2x2_mt16, long2x2_mt16, bool>
    , IComparisonOperators<long2x2_mt16, long2x2_mt16, b64m2x2_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is long2x2_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(long2x2_mt16)}");
    }

    static bool IComparisonOperators<long2x2_mt16, long2x2_mt16, bool>.operator <(long2x2_mt16 left, long2x2_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long2x2_mt16, long2x2_mt16, bool>.operator >(long2x2_mt16 left, long2x2_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long2x2_mt16, long2x2_mt16, bool>.operator <=(long2x2_mt16 left, long2x2_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long2x2_mt16, long2x2_mt16, bool>.operator >=(long2x2_mt16 left, long2x2_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(long2x2_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m2x2_mt16 operator <(long2x2_mt16 left, long2x2_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b64m2x2_mt16 operator >(long2x2_mt16 left, long2x2_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b64m2x2_mt16 operator <=(long2x2_mt16 left, long2x2_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b64m2x2_mt16 operator >=(long2x2_mt16 left, long2x2_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(long2x2_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(long2x2_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(long2x2_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(long2x2_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(long2x2_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(long2x2_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(long2x2_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(long2x2_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // long2x2_mt16

#region long2x3_mt4

public partial struct long2x3_mt4 : IComparable<long2x3_mt4>, IComparable
    , IComparisonOperators<long2x3_mt4, long2x3_mt4, bool>
    , IComparisonOperators<long2x3_mt4, long2x3_mt4, b64m2x3_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is long2x3_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(long2x3_mt4)}");
    }

    static bool IComparisonOperators<long2x3_mt4, long2x3_mt4, bool>.operator <(long2x3_mt4 left, long2x3_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long2x3_mt4, long2x3_mt4, bool>.operator >(long2x3_mt4 left, long2x3_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long2x3_mt4, long2x3_mt4, bool>.operator <=(long2x3_mt4 left, long2x3_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long2x3_mt4, long2x3_mt4, bool>.operator >=(long2x3_mt4 left, long2x3_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(long2x3_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m2x3_mt4 operator <(long2x3_mt4 left, long2x3_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b64m2x3_mt4 operator >(long2x3_mt4 left, long2x3_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b64m2x3_mt4 operator <=(long2x3_mt4 left, long2x3_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b64m2x3_mt4 operator >=(long2x3_mt4 left, long2x3_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(long2x3_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(long2x3_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(long2x3_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(long2x3_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(long2x3_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(long2x3_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(long2x3_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(long2x3_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // long2x3_mt4

#region long2x3_mt8

public partial struct long2x3_mt8 : IComparable<long2x3_mt8>, IComparable
    , IComparisonOperators<long2x3_mt8, long2x3_mt8, bool>
    , IComparisonOperators<long2x3_mt8, long2x3_mt8, b64m2x3_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is long2x3_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(long2x3_mt8)}");
    }

    static bool IComparisonOperators<long2x3_mt8, long2x3_mt8, bool>.operator <(long2x3_mt8 left, long2x3_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long2x3_mt8, long2x3_mt8, bool>.operator >(long2x3_mt8 left, long2x3_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long2x3_mt8, long2x3_mt8, bool>.operator <=(long2x3_mt8 left, long2x3_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long2x3_mt8, long2x3_mt8, bool>.operator >=(long2x3_mt8 left, long2x3_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(long2x3_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m2x3_mt8 operator <(long2x3_mt8 left, long2x3_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b64m2x3_mt8 operator >(long2x3_mt8 left, long2x3_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b64m2x3_mt8 operator <=(long2x3_mt8 left, long2x3_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b64m2x3_mt8 operator >=(long2x3_mt8 left, long2x3_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(long2x3_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(long2x3_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(long2x3_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(long2x3_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(long2x3_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(long2x3_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(long2x3_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(long2x3_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // long2x3_mt8

#region long2x3_mt16

public partial struct long2x3_mt16 : IComparable<long2x3_mt16>, IComparable
    , IComparisonOperators<long2x3_mt16, long2x3_mt16, bool>
    , IComparisonOperators<long2x3_mt16, long2x3_mt16, b64m2x3_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is long2x3_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(long2x3_mt16)}");
    }

    static bool IComparisonOperators<long2x3_mt16, long2x3_mt16, bool>.operator <(long2x3_mt16 left, long2x3_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long2x3_mt16, long2x3_mt16, bool>.operator >(long2x3_mt16 left, long2x3_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long2x3_mt16, long2x3_mt16, bool>.operator <=(long2x3_mt16 left, long2x3_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long2x3_mt16, long2x3_mt16, bool>.operator >=(long2x3_mt16 left, long2x3_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(long2x3_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m2x3_mt16 operator <(long2x3_mt16 left, long2x3_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b64m2x3_mt16 operator >(long2x3_mt16 left, long2x3_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b64m2x3_mt16 operator <=(long2x3_mt16 left, long2x3_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b64m2x3_mt16 operator >=(long2x3_mt16 left, long2x3_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(long2x3_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(long2x3_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(long2x3_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(long2x3_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(long2x3_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(long2x3_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(long2x3_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(long2x3_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // long2x3_mt16

#region long2x4_mt4

public partial struct long2x4_mt4 : IComparable<long2x4_mt4>, IComparable
    , IComparisonOperators<long2x4_mt4, long2x4_mt4, bool>
    , IComparisonOperators<long2x4_mt4, long2x4_mt4, b64m2x4_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is long2x4_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(long2x4_mt4)}");
    }

    static bool IComparisonOperators<long2x4_mt4, long2x4_mt4, bool>.operator <(long2x4_mt4 left, long2x4_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long2x4_mt4, long2x4_mt4, bool>.operator >(long2x4_mt4 left, long2x4_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long2x4_mt4, long2x4_mt4, bool>.operator <=(long2x4_mt4 left, long2x4_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long2x4_mt4, long2x4_mt4, bool>.operator >=(long2x4_mt4 left, long2x4_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(long2x4_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m2x4_mt4 operator <(long2x4_mt4 left, long2x4_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b64m2x4_mt4 operator >(long2x4_mt4 left, long2x4_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b64m2x4_mt4 operator <=(long2x4_mt4 left, long2x4_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b64m2x4_mt4 operator >=(long2x4_mt4 left, long2x4_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(long2x4_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(long2x4_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(long2x4_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(long2x4_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(long2x4_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(long2x4_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(long2x4_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(long2x4_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // long2x4_mt4

#region long2x4_mt8

public partial struct long2x4_mt8 : IComparable<long2x4_mt8>, IComparable
    , IComparisonOperators<long2x4_mt8, long2x4_mt8, bool>
    , IComparisonOperators<long2x4_mt8, long2x4_mt8, b64m2x4_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is long2x4_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(long2x4_mt8)}");
    }

    static bool IComparisonOperators<long2x4_mt8, long2x4_mt8, bool>.operator <(long2x4_mt8 left, long2x4_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long2x4_mt8, long2x4_mt8, bool>.operator >(long2x4_mt8 left, long2x4_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long2x4_mt8, long2x4_mt8, bool>.operator <=(long2x4_mt8 left, long2x4_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long2x4_mt8, long2x4_mt8, bool>.operator >=(long2x4_mt8 left, long2x4_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(long2x4_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m2x4_mt8 operator <(long2x4_mt8 left, long2x4_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b64m2x4_mt8 operator >(long2x4_mt8 left, long2x4_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b64m2x4_mt8 operator <=(long2x4_mt8 left, long2x4_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b64m2x4_mt8 operator >=(long2x4_mt8 left, long2x4_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(long2x4_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(long2x4_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(long2x4_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(long2x4_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(long2x4_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(long2x4_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(long2x4_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(long2x4_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // long2x4_mt8

#region long2x4_mt16

public partial struct long2x4_mt16 : IComparable<long2x4_mt16>, IComparable
    , IComparisonOperators<long2x4_mt16, long2x4_mt16, bool>
    , IComparisonOperators<long2x4_mt16, long2x4_mt16, b64m2x4_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is long2x4_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(long2x4_mt16)}");
    }

    static bool IComparisonOperators<long2x4_mt16, long2x4_mt16, bool>.operator <(long2x4_mt16 left, long2x4_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long2x4_mt16, long2x4_mt16, bool>.operator >(long2x4_mt16 left, long2x4_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long2x4_mt16, long2x4_mt16, bool>.operator <=(long2x4_mt16 left, long2x4_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long2x4_mt16, long2x4_mt16, bool>.operator >=(long2x4_mt16 left, long2x4_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(long2x4_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m2x4_mt16 operator <(long2x4_mt16 left, long2x4_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b64m2x4_mt16 operator >(long2x4_mt16 left, long2x4_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b64m2x4_mt16 operator <=(long2x4_mt16 left, long2x4_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b64m2x4_mt16 operator >=(long2x4_mt16 left, long2x4_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(long2x4_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(long2x4_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(long2x4_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(long2x4_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(long2x4_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(long2x4_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(long2x4_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(long2x4_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // long2x4_mt16

#region long3x2_mt4

public partial struct long3x2_mt4 : IComparable<long3x2_mt4>, IComparable
    , IComparisonOperators<long3x2_mt4, long3x2_mt4, bool>
    , IComparisonOperators<long3x2_mt4, long3x2_mt4, b64m3x2_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is long3x2_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(long3x2_mt4)}");
    }

    static bool IComparisonOperators<long3x2_mt4, long3x2_mt4, bool>.operator <(long3x2_mt4 left, long3x2_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long3x2_mt4, long3x2_mt4, bool>.operator >(long3x2_mt4 left, long3x2_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long3x2_mt4, long3x2_mt4, bool>.operator <=(long3x2_mt4 left, long3x2_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long3x2_mt4, long3x2_mt4, bool>.operator >=(long3x2_mt4 left, long3x2_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(long3x2_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m3x2_mt4 operator <(long3x2_mt4 left, long3x2_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b64m3x2_mt4 operator >(long3x2_mt4 left, long3x2_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b64m3x2_mt4 operator <=(long3x2_mt4 left, long3x2_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b64m3x2_mt4 operator >=(long3x2_mt4 left, long3x2_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(long3x2_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(long3x2_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(long3x2_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(long3x2_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(long3x2_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(long3x2_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(long3x2_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(long3x2_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // long3x2_mt4

#region long3x2_mt8

public partial struct long3x2_mt8 : IComparable<long3x2_mt8>, IComparable
    , IComparisonOperators<long3x2_mt8, long3x2_mt8, bool>
    , IComparisonOperators<long3x2_mt8, long3x2_mt8, b64m3x2_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is long3x2_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(long3x2_mt8)}");
    }

    static bool IComparisonOperators<long3x2_mt8, long3x2_mt8, bool>.operator <(long3x2_mt8 left, long3x2_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long3x2_mt8, long3x2_mt8, bool>.operator >(long3x2_mt8 left, long3x2_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long3x2_mt8, long3x2_mt8, bool>.operator <=(long3x2_mt8 left, long3x2_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long3x2_mt8, long3x2_mt8, bool>.operator >=(long3x2_mt8 left, long3x2_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(long3x2_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m3x2_mt8 operator <(long3x2_mt8 left, long3x2_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b64m3x2_mt8 operator >(long3x2_mt8 left, long3x2_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b64m3x2_mt8 operator <=(long3x2_mt8 left, long3x2_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b64m3x2_mt8 operator >=(long3x2_mt8 left, long3x2_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(long3x2_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(long3x2_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(long3x2_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(long3x2_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(long3x2_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(long3x2_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(long3x2_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(long3x2_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // long3x2_mt8

#region long3x2_mt16

public partial struct long3x2_mt16 : IComparable<long3x2_mt16>, IComparable
    , IComparisonOperators<long3x2_mt16, long3x2_mt16, bool>
    , IComparisonOperators<long3x2_mt16, long3x2_mt16, b64m3x2_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is long3x2_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(long3x2_mt16)}");
    }

    static bool IComparisonOperators<long3x2_mt16, long3x2_mt16, bool>.operator <(long3x2_mt16 left, long3x2_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long3x2_mt16, long3x2_mt16, bool>.operator >(long3x2_mt16 left, long3x2_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long3x2_mt16, long3x2_mt16, bool>.operator <=(long3x2_mt16 left, long3x2_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long3x2_mt16, long3x2_mt16, bool>.operator >=(long3x2_mt16 left, long3x2_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(long3x2_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m3x2_mt16 operator <(long3x2_mt16 left, long3x2_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b64m3x2_mt16 operator >(long3x2_mt16 left, long3x2_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b64m3x2_mt16 operator <=(long3x2_mt16 left, long3x2_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b64m3x2_mt16 operator >=(long3x2_mt16 left, long3x2_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(long3x2_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(long3x2_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(long3x2_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(long3x2_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(long3x2_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(long3x2_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(long3x2_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(long3x2_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // long3x2_mt16

#region long3x3_mt4

public partial struct long3x3_mt4 : IComparable<long3x3_mt4>, IComparable
    , IComparisonOperators<long3x3_mt4, long3x3_mt4, bool>
    , IComparisonOperators<long3x3_mt4, long3x3_mt4, b64m3x3_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is long3x3_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(long3x3_mt4)}");
    }

    static bool IComparisonOperators<long3x3_mt4, long3x3_mt4, bool>.operator <(long3x3_mt4 left, long3x3_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long3x3_mt4, long3x3_mt4, bool>.operator >(long3x3_mt4 left, long3x3_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long3x3_mt4, long3x3_mt4, bool>.operator <=(long3x3_mt4 left, long3x3_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long3x3_mt4, long3x3_mt4, bool>.operator >=(long3x3_mt4 left, long3x3_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(long3x3_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m3x3_mt4 operator <(long3x3_mt4 left, long3x3_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b64m3x3_mt4 operator >(long3x3_mt4 left, long3x3_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b64m3x3_mt4 operator <=(long3x3_mt4 left, long3x3_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b64m3x3_mt4 operator >=(long3x3_mt4 left, long3x3_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(long3x3_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(long3x3_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(long3x3_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(long3x3_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(long3x3_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(long3x3_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(long3x3_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(long3x3_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // long3x3_mt4

#region long3x3_mt8

public partial struct long3x3_mt8 : IComparable<long3x3_mt8>, IComparable
    , IComparisonOperators<long3x3_mt8, long3x3_mt8, bool>
    , IComparisonOperators<long3x3_mt8, long3x3_mt8, b64m3x3_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is long3x3_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(long3x3_mt8)}");
    }

    static bool IComparisonOperators<long3x3_mt8, long3x3_mt8, bool>.operator <(long3x3_mt8 left, long3x3_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long3x3_mt8, long3x3_mt8, bool>.operator >(long3x3_mt8 left, long3x3_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long3x3_mt8, long3x3_mt8, bool>.operator <=(long3x3_mt8 left, long3x3_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long3x3_mt8, long3x3_mt8, bool>.operator >=(long3x3_mt8 left, long3x3_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(long3x3_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m3x3_mt8 operator <(long3x3_mt8 left, long3x3_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b64m3x3_mt8 operator >(long3x3_mt8 left, long3x3_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b64m3x3_mt8 operator <=(long3x3_mt8 left, long3x3_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b64m3x3_mt8 operator >=(long3x3_mt8 left, long3x3_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(long3x3_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(long3x3_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(long3x3_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(long3x3_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(long3x3_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(long3x3_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(long3x3_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(long3x3_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // long3x3_mt8

#region long3x3_mt16

public partial struct long3x3_mt16 : IComparable<long3x3_mt16>, IComparable
    , IComparisonOperators<long3x3_mt16, long3x3_mt16, bool>
    , IComparisonOperators<long3x3_mt16, long3x3_mt16, b64m3x3_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is long3x3_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(long3x3_mt16)}");
    }

    static bool IComparisonOperators<long3x3_mt16, long3x3_mt16, bool>.operator <(long3x3_mt16 left, long3x3_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long3x3_mt16, long3x3_mt16, bool>.operator >(long3x3_mt16 left, long3x3_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long3x3_mt16, long3x3_mt16, bool>.operator <=(long3x3_mt16 left, long3x3_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long3x3_mt16, long3x3_mt16, bool>.operator >=(long3x3_mt16 left, long3x3_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(long3x3_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m3x3_mt16 operator <(long3x3_mt16 left, long3x3_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b64m3x3_mt16 operator >(long3x3_mt16 left, long3x3_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b64m3x3_mt16 operator <=(long3x3_mt16 left, long3x3_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b64m3x3_mt16 operator >=(long3x3_mt16 left, long3x3_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(long3x3_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(long3x3_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(long3x3_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(long3x3_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(long3x3_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(long3x3_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(long3x3_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(long3x3_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // long3x3_mt16

#region long3x4_mt4

public partial struct long3x4_mt4 : IComparable<long3x4_mt4>, IComparable
    , IComparisonOperators<long3x4_mt4, long3x4_mt4, bool>
    , IComparisonOperators<long3x4_mt4, long3x4_mt4, b64m3x4_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is long3x4_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(long3x4_mt4)}");
    }

    static bool IComparisonOperators<long3x4_mt4, long3x4_mt4, bool>.operator <(long3x4_mt4 left, long3x4_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long3x4_mt4, long3x4_mt4, bool>.operator >(long3x4_mt4 left, long3x4_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long3x4_mt4, long3x4_mt4, bool>.operator <=(long3x4_mt4 left, long3x4_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long3x4_mt4, long3x4_mt4, bool>.operator >=(long3x4_mt4 left, long3x4_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(long3x4_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m3x4_mt4 operator <(long3x4_mt4 left, long3x4_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b64m3x4_mt4 operator >(long3x4_mt4 left, long3x4_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b64m3x4_mt4 operator <=(long3x4_mt4 left, long3x4_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b64m3x4_mt4 operator >=(long3x4_mt4 left, long3x4_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(long3x4_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(long3x4_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(long3x4_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(long3x4_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(long3x4_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(long3x4_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(long3x4_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(long3x4_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // long3x4_mt4

#region long3x4_mt8

public partial struct long3x4_mt8 : IComparable<long3x4_mt8>, IComparable
    , IComparisonOperators<long3x4_mt8, long3x4_mt8, bool>
    , IComparisonOperators<long3x4_mt8, long3x4_mt8, b64m3x4_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is long3x4_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(long3x4_mt8)}");
    }

    static bool IComparisonOperators<long3x4_mt8, long3x4_mt8, bool>.operator <(long3x4_mt8 left, long3x4_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long3x4_mt8, long3x4_mt8, bool>.operator >(long3x4_mt8 left, long3x4_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long3x4_mt8, long3x4_mt8, bool>.operator <=(long3x4_mt8 left, long3x4_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long3x4_mt8, long3x4_mt8, bool>.operator >=(long3x4_mt8 left, long3x4_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(long3x4_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m3x4_mt8 operator <(long3x4_mt8 left, long3x4_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b64m3x4_mt8 operator >(long3x4_mt8 left, long3x4_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b64m3x4_mt8 operator <=(long3x4_mt8 left, long3x4_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b64m3x4_mt8 operator >=(long3x4_mt8 left, long3x4_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(long3x4_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(long3x4_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(long3x4_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(long3x4_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(long3x4_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(long3x4_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(long3x4_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(long3x4_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // long3x4_mt8

#region long3x4_mt16

public partial struct long3x4_mt16 : IComparable<long3x4_mt16>, IComparable
    , IComparisonOperators<long3x4_mt16, long3x4_mt16, bool>
    , IComparisonOperators<long3x4_mt16, long3x4_mt16, b64m3x4_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is long3x4_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(long3x4_mt16)}");
    }

    static bool IComparisonOperators<long3x4_mt16, long3x4_mt16, bool>.operator <(long3x4_mt16 left, long3x4_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long3x4_mt16, long3x4_mt16, bool>.operator >(long3x4_mt16 left, long3x4_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long3x4_mt16, long3x4_mt16, bool>.operator <=(long3x4_mt16 left, long3x4_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long3x4_mt16, long3x4_mt16, bool>.operator >=(long3x4_mt16 left, long3x4_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(long3x4_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m3x4_mt16 operator <(long3x4_mt16 left, long3x4_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b64m3x4_mt16 operator >(long3x4_mt16 left, long3x4_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b64m3x4_mt16 operator <=(long3x4_mt16 left, long3x4_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b64m3x4_mt16 operator >=(long3x4_mt16 left, long3x4_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(long3x4_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(long3x4_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(long3x4_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(long3x4_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(long3x4_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(long3x4_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(long3x4_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(long3x4_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // long3x4_mt16

#region long4x2_mt4

public partial struct long4x2_mt4 : IComparable<long4x2_mt4>, IComparable
    , IComparisonOperators<long4x2_mt4, long4x2_mt4, bool>
    , IComparisonOperators<long4x2_mt4, long4x2_mt4, b64m4x2_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is long4x2_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(long4x2_mt4)}");
    }

    static bool IComparisonOperators<long4x2_mt4, long4x2_mt4, bool>.operator <(long4x2_mt4 left, long4x2_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long4x2_mt4, long4x2_mt4, bool>.operator >(long4x2_mt4 left, long4x2_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long4x2_mt4, long4x2_mt4, bool>.operator <=(long4x2_mt4 left, long4x2_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long4x2_mt4, long4x2_mt4, bool>.operator >=(long4x2_mt4 left, long4x2_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(long4x2_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m4x2_mt4 operator <(long4x2_mt4 left, long4x2_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b64m4x2_mt4 operator >(long4x2_mt4 left, long4x2_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b64m4x2_mt4 operator <=(long4x2_mt4 left, long4x2_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b64m4x2_mt4 operator >=(long4x2_mt4 left, long4x2_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(long4x2_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(long4x2_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(long4x2_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(long4x2_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(long4x2_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(long4x2_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(long4x2_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(long4x2_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // long4x2_mt4

#region long4x2_mt8

public partial struct long4x2_mt8 : IComparable<long4x2_mt8>, IComparable
    , IComparisonOperators<long4x2_mt8, long4x2_mt8, bool>
    , IComparisonOperators<long4x2_mt8, long4x2_mt8, b64m4x2_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is long4x2_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(long4x2_mt8)}");
    }

    static bool IComparisonOperators<long4x2_mt8, long4x2_mt8, bool>.operator <(long4x2_mt8 left, long4x2_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long4x2_mt8, long4x2_mt8, bool>.operator >(long4x2_mt8 left, long4x2_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long4x2_mt8, long4x2_mt8, bool>.operator <=(long4x2_mt8 left, long4x2_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long4x2_mt8, long4x2_mt8, bool>.operator >=(long4x2_mt8 left, long4x2_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(long4x2_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m4x2_mt8 operator <(long4x2_mt8 left, long4x2_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b64m4x2_mt8 operator >(long4x2_mt8 left, long4x2_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b64m4x2_mt8 operator <=(long4x2_mt8 left, long4x2_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b64m4x2_mt8 operator >=(long4x2_mt8 left, long4x2_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(long4x2_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(long4x2_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(long4x2_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(long4x2_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(long4x2_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(long4x2_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(long4x2_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(long4x2_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // long4x2_mt8

#region long4x2_mt16

public partial struct long4x2_mt16 : IComparable<long4x2_mt16>, IComparable
    , IComparisonOperators<long4x2_mt16, long4x2_mt16, bool>
    , IComparisonOperators<long4x2_mt16, long4x2_mt16, b64m4x2_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is long4x2_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(long4x2_mt16)}");
    }

    static bool IComparisonOperators<long4x2_mt16, long4x2_mt16, bool>.operator <(long4x2_mt16 left, long4x2_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long4x2_mt16, long4x2_mt16, bool>.operator >(long4x2_mt16 left, long4x2_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long4x2_mt16, long4x2_mt16, bool>.operator <=(long4x2_mt16 left, long4x2_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long4x2_mt16, long4x2_mt16, bool>.operator >=(long4x2_mt16 left, long4x2_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(long4x2_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m4x2_mt16 operator <(long4x2_mt16 left, long4x2_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b64m4x2_mt16 operator >(long4x2_mt16 left, long4x2_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b64m4x2_mt16 operator <=(long4x2_mt16 left, long4x2_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b64m4x2_mt16 operator >=(long4x2_mt16 left, long4x2_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(long4x2_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(long4x2_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(long4x2_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(long4x2_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(long4x2_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(long4x2_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(long4x2_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(long4x2_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // long4x2_mt16

#region long4x3_mt4

public partial struct long4x3_mt4 : IComparable<long4x3_mt4>, IComparable
    , IComparisonOperators<long4x3_mt4, long4x3_mt4, bool>
    , IComparisonOperators<long4x3_mt4, long4x3_mt4, b64m4x3_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is long4x3_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(long4x3_mt4)}");
    }

    static bool IComparisonOperators<long4x3_mt4, long4x3_mt4, bool>.operator <(long4x3_mt4 left, long4x3_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long4x3_mt4, long4x3_mt4, bool>.operator >(long4x3_mt4 left, long4x3_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long4x3_mt4, long4x3_mt4, bool>.operator <=(long4x3_mt4 left, long4x3_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long4x3_mt4, long4x3_mt4, bool>.operator >=(long4x3_mt4 left, long4x3_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(long4x3_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m4x3_mt4 operator <(long4x3_mt4 left, long4x3_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b64m4x3_mt4 operator >(long4x3_mt4 left, long4x3_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b64m4x3_mt4 operator <=(long4x3_mt4 left, long4x3_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b64m4x3_mt4 operator >=(long4x3_mt4 left, long4x3_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(long4x3_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(long4x3_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(long4x3_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(long4x3_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(long4x3_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(long4x3_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(long4x3_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(long4x3_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // long4x3_mt4

#region long4x3_mt8

public partial struct long4x3_mt8 : IComparable<long4x3_mt8>, IComparable
    , IComparisonOperators<long4x3_mt8, long4x3_mt8, bool>
    , IComparisonOperators<long4x3_mt8, long4x3_mt8, b64m4x3_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is long4x3_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(long4x3_mt8)}");
    }

    static bool IComparisonOperators<long4x3_mt8, long4x3_mt8, bool>.operator <(long4x3_mt8 left, long4x3_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long4x3_mt8, long4x3_mt8, bool>.operator >(long4x3_mt8 left, long4x3_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long4x3_mt8, long4x3_mt8, bool>.operator <=(long4x3_mt8 left, long4x3_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long4x3_mt8, long4x3_mt8, bool>.operator >=(long4x3_mt8 left, long4x3_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(long4x3_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m4x3_mt8 operator <(long4x3_mt8 left, long4x3_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b64m4x3_mt8 operator >(long4x3_mt8 left, long4x3_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b64m4x3_mt8 operator <=(long4x3_mt8 left, long4x3_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b64m4x3_mt8 operator >=(long4x3_mt8 left, long4x3_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(long4x3_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(long4x3_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(long4x3_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(long4x3_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(long4x3_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(long4x3_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(long4x3_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(long4x3_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // long4x3_mt8

#region long4x3_mt16

public partial struct long4x3_mt16 : IComparable<long4x3_mt16>, IComparable
    , IComparisonOperators<long4x3_mt16, long4x3_mt16, bool>
    , IComparisonOperators<long4x3_mt16, long4x3_mt16, b64m4x3_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is long4x3_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(long4x3_mt16)}");
    }

    static bool IComparisonOperators<long4x3_mt16, long4x3_mt16, bool>.operator <(long4x3_mt16 left, long4x3_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long4x3_mt16, long4x3_mt16, bool>.operator >(long4x3_mt16 left, long4x3_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long4x3_mt16, long4x3_mt16, bool>.operator <=(long4x3_mt16 left, long4x3_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long4x3_mt16, long4x3_mt16, bool>.operator >=(long4x3_mt16 left, long4x3_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(long4x3_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m4x3_mt16 operator <(long4x3_mt16 left, long4x3_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b64m4x3_mt16 operator >(long4x3_mt16 left, long4x3_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b64m4x3_mt16 operator <=(long4x3_mt16 left, long4x3_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b64m4x3_mt16 operator >=(long4x3_mt16 left, long4x3_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(long4x3_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(long4x3_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(long4x3_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(long4x3_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(long4x3_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(long4x3_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(long4x3_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(long4x3_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // long4x3_mt16

#region long4x4_mt4

public partial struct long4x4_mt4 : IComparable<long4x4_mt4>, IComparable
    , IComparisonOperators<long4x4_mt4, long4x4_mt4, bool>
    , IComparisonOperators<long4x4_mt4, long4x4_mt4, b64m4x4_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is long4x4_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(long4x4_mt4)}");
    }

    static bool IComparisonOperators<long4x4_mt4, long4x4_mt4, bool>.operator <(long4x4_mt4 left, long4x4_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long4x4_mt4, long4x4_mt4, bool>.operator >(long4x4_mt4 left, long4x4_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long4x4_mt4, long4x4_mt4, bool>.operator <=(long4x4_mt4 left, long4x4_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long4x4_mt4, long4x4_mt4, bool>.operator >=(long4x4_mt4 left, long4x4_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(long4x4_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m4x4_mt4 operator <(long4x4_mt4 left, long4x4_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b64m4x4_mt4 operator >(long4x4_mt4 left, long4x4_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b64m4x4_mt4 operator <=(long4x4_mt4 left, long4x4_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b64m4x4_mt4 operator >=(long4x4_mt4 left, long4x4_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(long4x4_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(long4x4_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(long4x4_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(long4x4_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(long4x4_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(long4x4_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(long4x4_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(long4x4_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // long4x4_mt4

#region long4x4_mt8

public partial struct long4x4_mt8 : IComparable<long4x4_mt8>, IComparable
    , IComparisonOperators<long4x4_mt8, long4x4_mt8, bool>
    , IComparisonOperators<long4x4_mt8, long4x4_mt8, b64m4x4_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is long4x4_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(long4x4_mt8)}");
    }

    static bool IComparisonOperators<long4x4_mt8, long4x4_mt8, bool>.operator <(long4x4_mt8 left, long4x4_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long4x4_mt8, long4x4_mt8, bool>.operator >(long4x4_mt8 left, long4x4_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long4x4_mt8, long4x4_mt8, bool>.operator <=(long4x4_mt8 left, long4x4_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long4x4_mt8, long4x4_mt8, bool>.operator >=(long4x4_mt8 left, long4x4_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(long4x4_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m4x4_mt8 operator <(long4x4_mt8 left, long4x4_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b64m4x4_mt8 operator >(long4x4_mt8 left, long4x4_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b64m4x4_mt8 operator <=(long4x4_mt8 left, long4x4_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b64m4x4_mt8 operator >=(long4x4_mt8 left, long4x4_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(long4x4_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(long4x4_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(long4x4_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(long4x4_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(long4x4_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(long4x4_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(long4x4_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(long4x4_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // long4x4_mt8

#region long4x4_mt16

public partial struct long4x4_mt16 : IComparable<long4x4_mt16>, IComparable
    , IComparisonOperators<long4x4_mt16, long4x4_mt16, bool>
    , IComparisonOperators<long4x4_mt16, long4x4_mt16, b64m4x4_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is long4x4_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(long4x4_mt16)}");
    }

    static bool IComparisonOperators<long4x4_mt16, long4x4_mt16, bool>.operator <(long4x4_mt16 left, long4x4_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long4x4_mt16, long4x4_mt16, bool>.operator >(long4x4_mt16 left, long4x4_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long4x4_mt16, long4x4_mt16, bool>.operator <=(long4x4_mt16 left, long4x4_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long4x4_mt16, long4x4_mt16, bool>.operator >=(long4x4_mt16 left, long4x4_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(long4x4_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m4x4_mt16 operator <(long4x4_mt16 left, long4x4_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b64m4x4_mt16 operator >(long4x4_mt16 left, long4x4_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b64m4x4_mt16 operator <=(long4x4_mt16 left, long4x4_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b64m4x4_mt16 operator >=(long4x4_mt16 left, long4x4_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(long4x4_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(long4x4_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(long4x4_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(long4x4_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(long4x4_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(long4x4_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(long4x4_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(long4x4_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // long4x4_mt16

#region ulong2x2_mt4

public partial struct ulong2x2_mt4 : IComparable<ulong2x2_mt4>, IComparable
    , IComparisonOperators<ulong2x2_mt4, ulong2x2_mt4, bool>
    , IComparisonOperators<ulong2x2_mt4, ulong2x2_mt4, b64m2x2_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is ulong2x2_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(ulong2x2_mt4)}");
    }

    static bool IComparisonOperators<ulong2x2_mt4, ulong2x2_mt4, bool>.operator <(ulong2x2_mt4 left, ulong2x2_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong2x2_mt4, ulong2x2_mt4, bool>.operator >(ulong2x2_mt4 left, ulong2x2_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong2x2_mt4, ulong2x2_mt4, bool>.operator <=(ulong2x2_mt4 left, ulong2x2_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong2x2_mt4, ulong2x2_mt4, bool>.operator >=(ulong2x2_mt4 left, ulong2x2_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(ulong2x2_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m2x2_mt4 operator <(ulong2x2_mt4 left, ulong2x2_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b64m2x2_mt4 operator >(ulong2x2_mt4 left, ulong2x2_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b64m2x2_mt4 operator <=(ulong2x2_mt4 left, ulong2x2_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b64m2x2_mt4 operator >=(ulong2x2_mt4 left, ulong2x2_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(ulong2x2_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(ulong2x2_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(ulong2x2_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(ulong2x2_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(ulong2x2_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(ulong2x2_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(ulong2x2_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(ulong2x2_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // ulong2x2_mt4

#region ulong2x2_mt8

public partial struct ulong2x2_mt8 : IComparable<ulong2x2_mt8>, IComparable
    , IComparisonOperators<ulong2x2_mt8, ulong2x2_mt8, bool>
    , IComparisonOperators<ulong2x2_mt8, ulong2x2_mt8, b64m2x2_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is ulong2x2_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(ulong2x2_mt8)}");
    }

    static bool IComparisonOperators<ulong2x2_mt8, ulong2x2_mt8, bool>.operator <(ulong2x2_mt8 left, ulong2x2_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong2x2_mt8, ulong2x2_mt8, bool>.operator >(ulong2x2_mt8 left, ulong2x2_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong2x2_mt8, ulong2x2_mt8, bool>.operator <=(ulong2x2_mt8 left, ulong2x2_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong2x2_mt8, ulong2x2_mt8, bool>.operator >=(ulong2x2_mt8 left, ulong2x2_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(ulong2x2_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m2x2_mt8 operator <(ulong2x2_mt8 left, ulong2x2_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b64m2x2_mt8 operator >(ulong2x2_mt8 left, ulong2x2_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b64m2x2_mt8 operator <=(ulong2x2_mt8 left, ulong2x2_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b64m2x2_mt8 operator >=(ulong2x2_mt8 left, ulong2x2_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(ulong2x2_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(ulong2x2_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(ulong2x2_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(ulong2x2_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(ulong2x2_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(ulong2x2_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(ulong2x2_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(ulong2x2_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // ulong2x2_mt8

#region ulong2x2_mt16

public partial struct ulong2x2_mt16 : IComparable<ulong2x2_mt16>, IComparable
    , IComparisonOperators<ulong2x2_mt16, ulong2x2_mt16, bool>
    , IComparisonOperators<ulong2x2_mt16, ulong2x2_mt16, b64m2x2_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is ulong2x2_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(ulong2x2_mt16)}");
    }

    static bool IComparisonOperators<ulong2x2_mt16, ulong2x2_mt16, bool>.operator <(ulong2x2_mt16 left, ulong2x2_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong2x2_mt16, ulong2x2_mt16, bool>.operator >(ulong2x2_mt16 left, ulong2x2_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong2x2_mt16, ulong2x2_mt16, bool>.operator <=(ulong2x2_mt16 left, ulong2x2_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong2x2_mt16, ulong2x2_mt16, bool>.operator >=(ulong2x2_mt16 left, ulong2x2_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(ulong2x2_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m2x2_mt16 operator <(ulong2x2_mt16 left, ulong2x2_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b64m2x2_mt16 operator >(ulong2x2_mt16 left, ulong2x2_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b64m2x2_mt16 operator <=(ulong2x2_mt16 left, ulong2x2_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b64m2x2_mt16 operator >=(ulong2x2_mt16 left, ulong2x2_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(ulong2x2_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(ulong2x2_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(ulong2x2_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(ulong2x2_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(ulong2x2_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(ulong2x2_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(ulong2x2_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(ulong2x2_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // ulong2x2_mt16

#region ulong2x3_mt4

public partial struct ulong2x3_mt4 : IComparable<ulong2x3_mt4>, IComparable
    , IComparisonOperators<ulong2x3_mt4, ulong2x3_mt4, bool>
    , IComparisonOperators<ulong2x3_mt4, ulong2x3_mt4, b64m2x3_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is ulong2x3_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(ulong2x3_mt4)}");
    }

    static bool IComparisonOperators<ulong2x3_mt4, ulong2x3_mt4, bool>.operator <(ulong2x3_mt4 left, ulong2x3_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong2x3_mt4, ulong2x3_mt4, bool>.operator >(ulong2x3_mt4 left, ulong2x3_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong2x3_mt4, ulong2x3_mt4, bool>.operator <=(ulong2x3_mt4 left, ulong2x3_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong2x3_mt4, ulong2x3_mt4, bool>.operator >=(ulong2x3_mt4 left, ulong2x3_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(ulong2x3_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m2x3_mt4 operator <(ulong2x3_mt4 left, ulong2x3_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b64m2x3_mt4 operator >(ulong2x3_mt4 left, ulong2x3_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b64m2x3_mt4 operator <=(ulong2x3_mt4 left, ulong2x3_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b64m2x3_mt4 operator >=(ulong2x3_mt4 left, ulong2x3_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(ulong2x3_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(ulong2x3_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(ulong2x3_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(ulong2x3_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(ulong2x3_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(ulong2x3_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(ulong2x3_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(ulong2x3_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // ulong2x3_mt4

#region ulong2x3_mt8

public partial struct ulong2x3_mt8 : IComparable<ulong2x3_mt8>, IComparable
    , IComparisonOperators<ulong2x3_mt8, ulong2x3_mt8, bool>
    , IComparisonOperators<ulong2x3_mt8, ulong2x3_mt8, b64m2x3_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is ulong2x3_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(ulong2x3_mt8)}");
    }

    static bool IComparisonOperators<ulong2x3_mt8, ulong2x3_mt8, bool>.operator <(ulong2x3_mt8 left, ulong2x3_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong2x3_mt8, ulong2x3_mt8, bool>.operator >(ulong2x3_mt8 left, ulong2x3_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong2x3_mt8, ulong2x3_mt8, bool>.operator <=(ulong2x3_mt8 left, ulong2x3_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong2x3_mt8, ulong2x3_mt8, bool>.operator >=(ulong2x3_mt8 left, ulong2x3_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(ulong2x3_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m2x3_mt8 operator <(ulong2x3_mt8 left, ulong2x3_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b64m2x3_mt8 operator >(ulong2x3_mt8 left, ulong2x3_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b64m2x3_mt8 operator <=(ulong2x3_mt8 left, ulong2x3_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b64m2x3_mt8 operator >=(ulong2x3_mt8 left, ulong2x3_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(ulong2x3_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(ulong2x3_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(ulong2x3_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(ulong2x3_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(ulong2x3_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(ulong2x3_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(ulong2x3_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(ulong2x3_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // ulong2x3_mt8

#region ulong2x3_mt16

public partial struct ulong2x3_mt16 : IComparable<ulong2x3_mt16>, IComparable
    , IComparisonOperators<ulong2x3_mt16, ulong2x3_mt16, bool>
    , IComparisonOperators<ulong2x3_mt16, ulong2x3_mt16, b64m2x3_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is ulong2x3_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(ulong2x3_mt16)}");
    }

    static bool IComparisonOperators<ulong2x3_mt16, ulong2x3_mt16, bool>.operator <(ulong2x3_mt16 left, ulong2x3_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong2x3_mt16, ulong2x3_mt16, bool>.operator >(ulong2x3_mt16 left, ulong2x3_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong2x3_mt16, ulong2x3_mt16, bool>.operator <=(ulong2x3_mt16 left, ulong2x3_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong2x3_mt16, ulong2x3_mt16, bool>.operator >=(ulong2x3_mt16 left, ulong2x3_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(ulong2x3_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m2x3_mt16 operator <(ulong2x3_mt16 left, ulong2x3_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b64m2x3_mt16 operator >(ulong2x3_mt16 left, ulong2x3_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b64m2x3_mt16 operator <=(ulong2x3_mt16 left, ulong2x3_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b64m2x3_mt16 operator >=(ulong2x3_mt16 left, ulong2x3_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(ulong2x3_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(ulong2x3_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(ulong2x3_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(ulong2x3_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(ulong2x3_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(ulong2x3_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(ulong2x3_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(ulong2x3_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // ulong2x3_mt16

#region ulong2x4_mt4

public partial struct ulong2x4_mt4 : IComparable<ulong2x4_mt4>, IComparable
    , IComparisonOperators<ulong2x4_mt4, ulong2x4_mt4, bool>
    , IComparisonOperators<ulong2x4_mt4, ulong2x4_mt4, b64m2x4_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is ulong2x4_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(ulong2x4_mt4)}");
    }

    static bool IComparisonOperators<ulong2x4_mt4, ulong2x4_mt4, bool>.operator <(ulong2x4_mt4 left, ulong2x4_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong2x4_mt4, ulong2x4_mt4, bool>.operator >(ulong2x4_mt4 left, ulong2x4_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong2x4_mt4, ulong2x4_mt4, bool>.operator <=(ulong2x4_mt4 left, ulong2x4_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong2x4_mt4, ulong2x4_mt4, bool>.operator >=(ulong2x4_mt4 left, ulong2x4_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(ulong2x4_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m2x4_mt4 operator <(ulong2x4_mt4 left, ulong2x4_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b64m2x4_mt4 operator >(ulong2x4_mt4 left, ulong2x4_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b64m2x4_mt4 operator <=(ulong2x4_mt4 left, ulong2x4_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b64m2x4_mt4 operator >=(ulong2x4_mt4 left, ulong2x4_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(ulong2x4_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(ulong2x4_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(ulong2x4_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(ulong2x4_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(ulong2x4_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(ulong2x4_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(ulong2x4_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(ulong2x4_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // ulong2x4_mt4

#region ulong2x4_mt8

public partial struct ulong2x4_mt8 : IComparable<ulong2x4_mt8>, IComparable
    , IComparisonOperators<ulong2x4_mt8, ulong2x4_mt8, bool>
    , IComparisonOperators<ulong2x4_mt8, ulong2x4_mt8, b64m2x4_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is ulong2x4_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(ulong2x4_mt8)}");
    }

    static bool IComparisonOperators<ulong2x4_mt8, ulong2x4_mt8, bool>.operator <(ulong2x4_mt8 left, ulong2x4_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong2x4_mt8, ulong2x4_mt8, bool>.operator >(ulong2x4_mt8 left, ulong2x4_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong2x4_mt8, ulong2x4_mt8, bool>.operator <=(ulong2x4_mt8 left, ulong2x4_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong2x4_mt8, ulong2x4_mt8, bool>.operator >=(ulong2x4_mt8 left, ulong2x4_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(ulong2x4_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m2x4_mt8 operator <(ulong2x4_mt8 left, ulong2x4_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b64m2x4_mt8 operator >(ulong2x4_mt8 left, ulong2x4_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b64m2x4_mt8 operator <=(ulong2x4_mt8 left, ulong2x4_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b64m2x4_mt8 operator >=(ulong2x4_mt8 left, ulong2x4_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(ulong2x4_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(ulong2x4_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(ulong2x4_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(ulong2x4_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(ulong2x4_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(ulong2x4_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(ulong2x4_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(ulong2x4_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // ulong2x4_mt8

#region ulong2x4_mt16

public partial struct ulong2x4_mt16 : IComparable<ulong2x4_mt16>, IComparable
    , IComparisonOperators<ulong2x4_mt16, ulong2x4_mt16, bool>
    , IComparisonOperators<ulong2x4_mt16, ulong2x4_mt16, b64m2x4_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is ulong2x4_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(ulong2x4_mt16)}");
    }

    static bool IComparisonOperators<ulong2x4_mt16, ulong2x4_mt16, bool>.operator <(ulong2x4_mt16 left, ulong2x4_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong2x4_mt16, ulong2x4_mt16, bool>.operator >(ulong2x4_mt16 left, ulong2x4_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong2x4_mt16, ulong2x4_mt16, bool>.operator <=(ulong2x4_mt16 left, ulong2x4_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong2x4_mt16, ulong2x4_mt16, bool>.operator >=(ulong2x4_mt16 left, ulong2x4_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(ulong2x4_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m2x4_mt16 operator <(ulong2x4_mt16 left, ulong2x4_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b64m2x4_mt16 operator >(ulong2x4_mt16 left, ulong2x4_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b64m2x4_mt16 operator <=(ulong2x4_mt16 left, ulong2x4_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b64m2x4_mt16 operator >=(ulong2x4_mt16 left, ulong2x4_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(ulong2x4_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(ulong2x4_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(ulong2x4_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(ulong2x4_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(ulong2x4_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(ulong2x4_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(ulong2x4_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(ulong2x4_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // ulong2x4_mt16

#region ulong3x2_mt4

public partial struct ulong3x2_mt4 : IComparable<ulong3x2_mt4>, IComparable
    , IComparisonOperators<ulong3x2_mt4, ulong3x2_mt4, bool>
    , IComparisonOperators<ulong3x2_mt4, ulong3x2_mt4, b64m3x2_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is ulong3x2_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(ulong3x2_mt4)}");
    }

    static bool IComparisonOperators<ulong3x2_mt4, ulong3x2_mt4, bool>.operator <(ulong3x2_mt4 left, ulong3x2_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong3x2_mt4, ulong3x2_mt4, bool>.operator >(ulong3x2_mt4 left, ulong3x2_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong3x2_mt4, ulong3x2_mt4, bool>.operator <=(ulong3x2_mt4 left, ulong3x2_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong3x2_mt4, ulong3x2_mt4, bool>.operator >=(ulong3x2_mt4 left, ulong3x2_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(ulong3x2_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m3x2_mt4 operator <(ulong3x2_mt4 left, ulong3x2_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b64m3x2_mt4 operator >(ulong3x2_mt4 left, ulong3x2_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b64m3x2_mt4 operator <=(ulong3x2_mt4 left, ulong3x2_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b64m3x2_mt4 operator >=(ulong3x2_mt4 left, ulong3x2_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(ulong3x2_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(ulong3x2_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(ulong3x2_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(ulong3x2_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(ulong3x2_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(ulong3x2_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(ulong3x2_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(ulong3x2_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // ulong3x2_mt4

#region ulong3x2_mt8

public partial struct ulong3x2_mt8 : IComparable<ulong3x2_mt8>, IComparable
    , IComparisonOperators<ulong3x2_mt8, ulong3x2_mt8, bool>
    , IComparisonOperators<ulong3x2_mt8, ulong3x2_mt8, b64m3x2_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is ulong3x2_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(ulong3x2_mt8)}");
    }

    static bool IComparisonOperators<ulong3x2_mt8, ulong3x2_mt8, bool>.operator <(ulong3x2_mt8 left, ulong3x2_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong3x2_mt8, ulong3x2_mt8, bool>.operator >(ulong3x2_mt8 left, ulong3x2_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong3x2_mt8, ulong3x2_mt8, bool>.operator <=(ulong3x2_mt8 left, ulong3x2_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong3x2_mt8, ulong3x2_mt8, bool>.operator >=(ulong3x2_mt8 left, ulong3x2_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(ulong3x2_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m3x2_mt8 operator <(ulong3x2_mt8 left, ulong3x2_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b64m3x2_mt8 operator >(ulong3x2_mt8 left, ulong3x2_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b64m3x2_mt8 operator <=(ulong3x2_mt8 left, ulong3x2_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b64m3x2_mt8 operator >=(ulong3x2_mt8 left, ulong3x2_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(ulong3x2_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(ulong3x2_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(ulong3x2_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(ulong3x2_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(ulong3x2_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(ulong3x2_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(ulong3x2_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(ulong3x2_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // ulong3x2_mt8

#region ulong3x2_mt16

public partial struct ulong3x2_mt16 : IComparable<ulong3x2_mt16>, IComparable
    , IComparisonOperators<ulong3x2_mt16, ulong3x2_mt16, bool>
    , IComparisonOperators<ulong3x2_mt16, ulong3x2_mt16, b64m3x2_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is ulong3x2_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(ulong3x2_mt16)}");
    }

    static bool IComparisonOperators<ulong3x2_mt16, ulong3x2_mt16, bool>.operator <(ulong3x2_mt16 left, ulong3x2_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong3x2_mt16, ulong3x2_mt16, bool>.operator >(ulong3x2_mt16 left, ulong3x2_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong3x2_mt16, ulong3x2_mt16, bool>.operator <=(ulong3x2_mt16 left, ulong3x2_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong3x2_mt16, ulong3x2_mt16, bool>.operator >=(ulong3x2_mt16 left, ulong3x2_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(ulong3x2_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m3x2_mt16 operator <(ulong3x2_mt16 left, ulong3x2_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b64m3x2_mt16 operator >(ulong3x2_mt16 left, ulong3x2_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b64m3x2_mt16 operator <=(ulong3x2_mt16 left, ulong3x2_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b64m3x2_mt16 operator >=(ulong3x2_mt16 left, ulong3x2_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(ulong3x2_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(ulong3x2_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(ulong3x2_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(ulong3x2_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(ulong3x2_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(ulong3x2_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(ulong3x2_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(ulong3x2_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // ulong3x2_mt16

#region ulong3x3_mt4

public partial struct ulong3x3_mt4 : IComparable<ulong3x3_mt4>, IComparable
    , IComparisonOperators<ulong3x3_mt4, ulong3x3_mt4, bool>
    , IComparisonOperators<ulong3x3_mt4, ulong3x3_mt4, b64m3x3_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is ulong3x3_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(ulong3x3_mt4)}");
    }

    static bool IComparisonOperators<ulong3x3_mt4, ulong3x3_mt4, bool>.operator <(ulong3x3_mt4 left, ulong3x3_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong3x3_mt4, ulong3x3_mt4, bool>.operator >(ulong3x3_mt4 left, ulong3x3_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong3x3_mt4, ulong3x3_mt4, bool>.operator <=(ulong3x3_mt4 left, ulong3x3_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong3x3_mt4, ulong3x3_mt4, bool>.operator >=(ulong3x3_mt4 left, ulong3x3_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(ulong3x3_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m3x3_mt4 operator <(ulong3x3_mt4 left, ulong3x3_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b64m3x3_mt4 operator >(ulong3x3_mt4 left, ulong3x3_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b64m3x3_mt4 operator <=(ulong3x3_mt4 left, ulong3x3_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b64m3x3_mt4 operator >=(ulong3x3_mt4 left, ulong3x3_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(ulong3x3_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(ulong3x3_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(ulong3x3_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(ulong3x3_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(ulong3x3_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(ulong3x3_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(ulong3x3_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(ulong3x3_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // ulong3x3_mt4

#region ulong3x3_mt8

public partial struct ulong3x3_mt8 : IComparable<ulong3x3_mt8>, IComparable
    , IComparisonOperators<ulong3x3_mt8, ulong3x3_mt8, bool>
    , IComparisonOperators<ulong3x3_mt8, ulong3x3_mt8, b64m3x3_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is ulong3x3_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(ulong3x3_mt8)}");
    }

    static bool IComparisonOperators<ulong3x3_mt8, ulong3x3_mt8, bool>.operator <(ulong3x3_mt8 left, ulong3x3_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong3x3_mt8, ulong3x3_mt8, bool>.operator >(ulong3x3_mt8 left, ulong3x3_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong3x3_mt8, ulong3x3_mt8, bool>.operator <=(ulong3x3_mt8 left, ulong3x3_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong3x3_mt8, ulong3x3_mt8, bool>.operator >=(ulong3x3_mt8 left, ulong3x3_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(ulong3x3_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m3x3_mt8 operator <(ulong3x3_mt8 left, ulong3x3_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b64m3x3_mt8 operator >(ulong3x3_mt8 left, ulong3x3_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b64m3x3_mt8 operator <=(ulong3x3_mt8 left, ulong3x3_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b64m3x3_mt8 operator >=(ulong3x3_mt8 left, ulong3x3_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(ulong3x3_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(ulong3x3_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(ulong3x3_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(ulong3x3_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(ulong3x3_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(ulong3x3_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(ulong3x3_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(ulong3x3_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // ulong3x3_mt8

#region ulong3x3_mt16

public partial struct ulong3x3_mt16 : IComparable<ulong3x3_mt16>, IComparable
    , IComparisonOperators<ulong3x3_mt16, ulong3x3_mt16, bool>
    , IComparisonOperators<ulong3x3_mt16, ulong3x3_mt16, b64m3x3_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is ulong3x3_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(ulong3x3_mt16)}");
    }

    static bool IComparisonOperators<ulong3x3_mt16, ulong3x3_mt16, bool>.operator <(ulong3x3_mt16 left, ulong3x3_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong3x3_mt16, ulong3x3_mt16, bool>.operator >(ulong3x3_mt16 left, ulong3x3_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong3x3_mt16, ulong3x3_mt16, bool>.operator <=(ulong3x3_mt16 left, ulong3x3_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong3x3_mt16, ulong3x3_mt16, bool>.operator >=(ulong3x3_mt16 left, ulong3x3_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(ulong3x3_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m3x3_mt16 operator <(ulong3x3_mt16 left, ulong3x3_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b64m3x3_mt16 operator >(ulong3x3_mt16 left, ulong3x3_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b64m3x3_mt16 operator <=(ulong3x3_mt16 left, ulong3x3_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b64m3x3_mt16 operator >=(ulong3x3_mt16 left, ulong3x3_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(ulong3x3_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(ulong3x3_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(ulong3x3_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(ulong3x3_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(ulong3x3_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(ulong3x3_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(ulong3x3_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(ulong3x3_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // ulong3x3_mt16

#region ulong3x4_mt4

public partial struct ulong3x4_mt4 : IComparable<ulong3x4_mt4>, IComparable
    , IComparisonOperators<ulong3x4_mt4, ulong3x4_mt4, bool>
    , IComparisonOperators<ulong3x4_mt4, ulong3x4_mt4, b64m3x4_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is ulong3x4_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(ulong3x4_mt4)}");
    }

    static bool IComparisonOperators<ulong3x4_mt4, ulong3x4_mt4, bool>.operator <(ulong3x4_mt4 left, ulong3x4_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong3x4_mt4, ulong3x4_mt4, bool>.operator >(ulong3x4_mt4 left, ulong3x4_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong3x4_mt4, ulong3x4_mt4, bool>.operator <=(ulong3x4_mt4 left, ulong3x4_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong3x4_mt4, ulong3x4_mt4, bool>.operator >=(ulong3x4_mt4 left, ulong3x4_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(ulong3x4_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m3x4_mt4 operator <(ulong3x4_mt4 left, ulong3x4_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b64m3x4_mt4 operator >(ulong3x4_mt4 left, ulong3x4_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b64m3x4_mt4 operator <=(ulong3x4_mt4 left, ulong3x4_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b64m3x4_mt4 operator >=(ulong3x4_mt4 left, ulong3x4_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(ulong3x4_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(ulong3x4_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(ulong3x4_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(ulong3x4_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(ulong3x4_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(ulong3x4_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(ulong3x4_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(ulong3x4_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // ulong3x4_mt4

#region ulong3x4_mt8

public partial struct ulong3x4_mt8 : IComparable<ulong3x4_mt8>, IComparable
    , IComparisonOperators<ulong3x4_mt8, ulong3x4_mt8, bool>
    , IComparisonOperators<ulong3x4_mt8, ulong3x4_mt8, b64m3x4_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is ulong3x4_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(ulong3x4_mt8)}");
    }

    static bool IComparisonOperators<ulong3x4_mt8, ulong3x4_mt8, bool>.operator <(ulong3x4_mt8 left, ulong3x4_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong3x4_mt8, ulong3x4_mt8, bool>.operator >(ulong3x4_mt8 left, ulong3x4_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong3x4_mt8, ulong3x4_mt8, bool>.operator <=(ulong3x4_mt8 left, ulong3x4_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong3x4_mt8, ulong3x4_mt8, bool>.operator >=(ulong3x4_mt8 left, ulong3x4_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(ulong3x4_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m3x4_mt8 operator <(ulong3x4_mt8 left, ulong3x4_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b64m3x4_mt8 operator >(ulong3x4_mt8 left, ulong3x4_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b64m3x4_mt8 operator <=(ulong3x4_mt8 left, ulong3x4_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b64m3x4_mt8 operator >=(ulong3x4_mt8 left, ulong3x4_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(ulong3x4_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(ulong3x4_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(ulong3x4_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(ulong3x4_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(ulong3x4_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(ulong3x4_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(ulong3x4_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(ulong3x4_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // ulong3x4_mt8

#region ulong3x4_mt16

public partial struct ulong3x4_mt16 : IComparable<ulong3x4_mt16>, IComparable
    , IComparisonOperators<ulong3x4_mt16, ulong3x4_mt16, bool>
    , IComparisonOperators<ulong3x4_mt16, ulong3x4_mt16, b64m3x4_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is ulong3x4_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(ulong3x4_mt16)}");
    }

    static bool IComparisonOperators<ulong3x4_mt16, ulong3x4_mt16, bool>.operator <(ulong3x4_mt16 left, ulong3x4_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong3x4_mt16, ulong3x4_mt16, bool>.operator >(ulong3x4_mt16 left, ulong3x4_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong3x4_mt16, ulong3x4_mt16, bool>.operator <=(ulong3x4_mt16 left, ulong3x4_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong3x4_mt16, ulong3x4_mt16, bool>.operator >=(ulong3x4_mt16 left, ulong3x4_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(ulong3x4_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m3x4_mt16 operator <(ulong3x4_mt16 left, ulong3x4_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b64m3x4_mt16 operator >(ulong3x4_mt16 left, ulong3x4_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b64m3x4_mt16 operator <=(ulong3x4_mt16 left, ulong3x4_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b64m3x4_mt16 operator >=(ulong3x4_mt16 left, ulong3x4_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(ulong3x4_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(ulong3x4_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(ulong3x4_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(ulong3x4_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(ulong3x4_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(ulong3x4_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(ulong3x4_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(ulong3x4_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // ulong3x4_mt16

#region ulong4x2_mt4

public partial struct ulong4x2_mt4 : IComparable<ulong4x2_mt4>, IComparable
    , IComparisonOperators<ulong4x2_mt4, ulong4x2_mt4, bool>
    , IComparisonOperators<ulong4x2_mt4, ulong4x2_mt4, b64m4x2_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is ulong4x2_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(ulong4x2_mt4)}");
    }

    static bool IComparisonOperators<ulong4x2_mt4, ulong4x2_mt4, bool>.operator <(ulong4x2_mt4 left, ulong4x2_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong4x2_mt4, ulong4x2_mt4, bool>.operator >(ulong4x2_mt4 left, ulong4x2_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong4x2_mt4, ulong4x2_mt4, bool>.operator <=(ulong4x2_mt4 left, ulong4x2_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong4x2_mt4, ulong4x2_mt4, bool>.operator >=(ulong4x2_mt4 left, ulong4x2_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(ulong4x2_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m4x2_mt4 operator <(ulong4x2_mt4 left, ulong4x2_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b64m4x2_mt4 operator >(ulong4x2_mt4 left, ulong4x2_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b64m4x2_mt4 operator <=(ulong4x2_mt4 left, ulong4x2_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b64m4x2_mt4 operator >=(ulong4x2_mt4 left, ulong4x2_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(ulong4x2_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(ulong4x2_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(ulong4x2_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(ulong4x2_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(ulong4x2_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(ulong4x2_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(ulong4x2_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(ulong4x2_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // ulong4x2_mt4

#region ulong4x2_mt8

public partial struct ulong4x2_mt8 : IComparable<ulong4x2_mt8>, IComparable
    , IComparisonOperators<ulong4x2_mt8, ulong4x2_mt8, bool>
    , IComparisonOperators<ulong4x2_mt8, ulong4x2_mt8, b64m4x2_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is ulong4x2_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(ulong4x2_mt8)}");
    }

    static bool IComparisonOperators<ulong4x2_mt8, ulong4x2_mt8, bool>.operator <(ulong4x2_mt8 left, ulong4x2_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong4x2_mt8, ulong4x2_mt8, bool>.operator >(ulong4x2_mt8 left, ulong4x2_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong4x2_mt8, ulong4x2_mt8, bool>.operator <=(ulong4x2_mt8 left, ulong4x2_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong4x2_mt8, ulong4x2_mt8, bool>.operator >=(ulong4x2_mt8 left, ulong4x2_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(ulong4x2_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m4x2_mt8 operator <(ulong4x2_mt8 left, ulong4x2_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b64m4x2_mt8 operator >(ulong4x2_mt8 left, ulong4x2_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b64m4x2_mt8 operator <=(ulong4x2_mt8 left, ulong4x2_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b64m4x2_mt8 operator >=(ulong4x2_mt8 left, ulong4x2_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(ulong4x2_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(ulong4x2_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(ulong4x2_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(ulong4x2_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(ulong4x2_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(ulong4x2_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(ulong4x2_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(ulong4x2_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // ulong4x2_mt8

#region ulong4x2_mt16

public partial struct ulong4x2_mt16 : IComparable<ulong4x2_mt16>, IComparable
    , IComparisonOperators<ulong4x2_mt16, ulong4x2_mt16, bool>
    , IComparisonOperators<ulong4x2_mt16, ulong4x2_mt16, b64m4x2_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is ulong4x2_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(ulong4x2_mt16)}");
    }

    static bool IComparisonOperators<ulong4x2_mt16, ulong4x2_mt16, bool>.operator <(ulong4x2_mt16 left, ulong4x2_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong4x2_mt16, ulong4x2_mt16, bool>.operator >(ulong4x2_mt16 left, ulong4x2_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong4x2_mt16, ulong4x2_mt16, bool>.operator <=(ulong4x2_mt16 left, ulong4x2_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong4x2_mt16, ulong4x2_mt16, bool>.operator >=(ulong4x2_mt16 left, ulong4x2_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(ulong4x2_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m4x2_mt16 operator <(ulong4x2_mt16 left, ulong4x2_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b64m4x2_mt16 operator >(ulong4x2_mt16 left, ulong4x2_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b64m4x2_mt16 operator <=(ulong4x2_mt16 left, ulong4x2_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b64m4x2_mt16 operator >=(ulong4x2_mt16 left, ulong4x2_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(ulong4x2_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(ulong4x2_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(ulong4x2_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(ulong4x2_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(ulong4x2_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(ulong4x2_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(ulong4x2_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(ulong4x2_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // ulong4x2_mt16

#region ulong4x3_mt4

public partial struct ulong4x3_mt4 : IComparable<ulong4x3_mt4>, IComparable
    , IComparisonOperators<ulong4x3_mt4, ulong4x3_mt4, bool>
    , IComparisonOperators<ulong4x3_mt4, ulong4x3_mt4, b64m4x3_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is ulong4x3_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(ulong4x3_mt4)}");
    }

    static bool IComparisonOperators<ulong4x3_mt4, ulong4x3_mt4, bool>.operator <(ulong4x3_mt4 left, ulong4x3_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong4x3_mt4, ulong4x3_mt4, bool>.operator >(ulong4x3_mt4 left, ulong4x3_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong4x3_mt4, ulong4x3_mt4, bool>.operator <=(ulong4x3_mt4 left, ulong4x3_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong4x3_mt4, ulong4x3_mt4, bool>.operator >=(ulong4x3_mt4 left, ulong4x3_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(ulong4x3_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m4x3_mt4 operator <(ulong4x3_mt4 left, ulong4x3_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b64m4x3_mt4 operator >(ulong4x3_mt4 left, ulong4x3_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b64m4x3_mt4 operator <=(ulong4x3_mt4 left, ulong4x3_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b64m4x3_mt4 operator >=(ulong4x3_mt4 left, ulong4x3_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(ulong4x3_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(ulong4x3_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(ulong4x3_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(ulong4x3_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(ulong4x3_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(ulong4x3_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(ulong4x3_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(ulong4x3_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // ulong4x3_mt4

#region ulong4x3_mt8

public partial struct ulong4x3_mt8 : IComparable<ulong4x3_mt8>, IComparable
    , IComparisonOperators<ulong4x3_mt8, ulong4x3_mt8, bool>
    , IComparisonOperators<ulong4x3_mt8, ulong4x3_mt8, b64m4x3_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is ulong4x3_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(ulong4x3_mt8)}");
    }

    static bool IComparisonOperators<ulong4x3_mt8, ulong4x3_mt8, bool>.operator <(ulong4x3_mt8 left, ulong4x3_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong4x3_mt8, ulong4x3_mt8, bool>.operator >(ulong4x3_mt8 left, ulong4x3_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong4x3_mt8, ulong4x3_mt8, bool>.operator <=(ulong4x3_mt8 left, ulong4x3_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong4x3_mt8, ulong4x3_mt8, bool>.operator >=(ulong4x3_mt8 left, ulong4x3_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(ulong4x3_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m4x3_mt8 operator <(ulong4x3_mt8 left, ulong4x3_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b64m4x3_mt8 operator >(ulong4x3_mt8 left, ulong4x3_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b64m4x3_mt8 operator <=(ulong4x3_mt8 left, ulong4x3_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b64m4x3_mt8 operator >=(ulong4x3_mt8 left, ulong4x3_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(ulong4x3_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(ulong4x3_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(ulong4x3_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(ulong4x3_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(ulong4x3_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(ulong4x3_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(ulong4x3_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(ulong4x3_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // ulong4x3_mt8

#region ulong4x3_mt16

public partial struct ulong4x3_mt16 : IComparable<ulong4x3_mt16>, IComparable
    , IComparisonOperators<ulong4x3_mt16, ulong4x3_mt16, bool>
    , IComparisonOperators<ulong4x3_mt16, ulong4x3_mt16, b64m4x3_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is ulong4x3_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(ulong4x3_mt16)}");
    }

    static bool IComparisonOperators<ulong4x3_mt16, ulong4x3_mt16, bool>.operator <(ulong4x3_mt16 left, ulong4x3_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong4x3_mt16, ulong4x3_mt16, bool>.operator >(ulong4x3_mt16 left, ulong4x3_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong4x3_mt16, ulong4x3_mt16, bool>.operator <=(ulong4x3_mt16 left, ulong4x3_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong4x3_mt16, ulong4x3_mt16, bool>.operator >=(ulong4x3_mt16 left, ulong4x3_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(ulong4x3_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m4x3_mt16 operator <(ulong4x3_mt16 left, ulong4x3_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b64m4x3_mt16 operator >(ulong4x3_mt16 left, ulong4x3_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b64m4x3_mt16 operator <=(ulong4x3_mt16 left, ulong4x3_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b64m4x3_mt16 operator >=(ulong4x3_mt16 left, ulong4x3_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(ulong4x3_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(ulong4x3_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(ulong4x3_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(ulong4x3_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(ulong4x3_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(ulong4x3_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(ulong4x3_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(ulong4x3_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // ulong4x3_mt16

#region ulong4x4_mt4

public partial struct ulong4x4_mt4 : IComparable<ulong4x4_mt4>, IComparable
    , IComparisonOperators<ulong4x4_mt4, ulong4x4_mt4, bool>
    , IComparisonOperators<ulong4x4_mt4, ulong4x4_mt4, b64m4x4_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is ulong4x4_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(ulong4x4_mt4)}");
    }

    static bool IComparisonOperators<ulong4x4_mt4, ulong4x4_mt4, bool>.operator <(ulong4x4_mt4 left, ulong4x4_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong4x4_mt4, ulong4x4_mt4, bool>.operator >(ulong4x4_mt4 left, ulong4x4_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong4x4_mt4, ulong4x4_mt4, bool>.operator <=(ulong4x4_mt4 left, ulong4x4_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong4x4_mt4, ulong4x4_mt4, bool>.operator >=(ulong4x4_mt4 left, ulong4x4_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(ulong4x4_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m4x4_mt4 operator <(ulong4x4_mt4 left, ulong4x4_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b64m4x4_mt4 operator >(ulong4x4_mt4 left, ulong4x4_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b64m4x4_mt4 operator <=(ulong4x4_mt4 left, ulong4x4_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b64m4x4_mt4 operator >=(ulong4x4_mt4 left, ulong4x4_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(ulong4x4_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(ulong4x4_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(ulong4x4_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(ulong4x4_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(ulong4x4_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(ulong4x4_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(ulong4x4_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(ulong4x4_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // ulong4x4_mt4

#region ulong4x4_mt8

public partial struct ulong4x4_mt8 : IComparable<ulong4x4_mt8>, IComparable
    , IComparisonOperators<ulong4x4_mt8, ulong4x4_mt8, bool>
    , IComparisonOperators<ulong4x4_mt8, ulong4x4_mt8, b64m4x4_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is ulong4x4_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(ulong4x4_mt8)}");
    }

    static bool IComparisonOperators<ulong4x4_mt8, ulong4x4_mt8, bool>.operator <(ulong4x4_mt8 left, ulong4x4_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong4x4_mt8, ulong4x4_mt8, bool>.operator >(ulong4x4_mt8 left, ulong4x4_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong4x4_mt8, ulong4x4_mt8, bool>.operator <=(ulong4x4_mt8 left, ulong4x4_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong4x4_mt8, ulong4x4_mt8, bool>.operator >=(ulong4x4_mt8 left, ulong4x4_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(ulong4x4_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m4x4_mt8 operator <(ulong4x4_mt8 left, ulong4x4_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b64m4x4_mt8 operator >(ulong4x4_mt8 left, ulong4x4_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b64m4x4_mt8 operator <=(ulong4x4_mt8 left, ulong4x4_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b64m4x4_mt8 operator >=(ulong4x4_mt8 left, ulong4x4_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(ulong4x4_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(ulong4x4_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(ulong4x4_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(ulong4x4_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(ulong4x4_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(ulong4x4_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(ulong4x4_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(ulong4x4_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // ulong4x4_mt8

#region ulong4x4_mt16

public partial struct ulong4x4_mt16 : IComparable<ulong4x4_mt16>, IComparable
    , IComparisonOperators<ulong4x4_mt16, ulong4x4_mt16, bool>
    , IComparisonOperators<ulong4x4_mt16, ulong4x4_mt16, b64m4x4_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is ulong4x4_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(ulong4x4_mt16)}");
    }

    static bool IComparisonOperators<ulong4x4_mt16, ulong4x4_mt16, bool>.operator <(ulong4x4_mt16 left, ulong4x4_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong4x4_mt16, ulong4x4_mt16, bool>.operator >(ulong4x4_mt16 left, ulong4x4_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong4x4_mt16, ulong4x4_mt16, bool>.operator <=(ulong4x4_mt16 left, ulong4x4_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong4x4_mt16, ulong4x4_mt16, bool>.operator >=(ulong4x4_mt16 left, ulong4x4_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(ulong4x4_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m4x4_mt16 operator <(ulong4x4_mt16 left, ulong4x4_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b64m4x4_mt16 operator >(ulong4x4_mt16 left, ulong4x4_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b64m4x4_mt16 operator <=(ulong4x4_mt16 left, ulong4x4_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b64m4x4_mt16 operator >=(ulong4x4_mt16 left, ulong4x4_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(ulong4x4_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(ulong4x4_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(ulong4x4_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(ulong4x4_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(ulong4x4_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(ulong4x4_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(ulong4x4_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(ulong4x4_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // ulong4x4_mt16

#region b32m2x2_mt4

public partial struct b32m2x2_mt4 : IComparable<b32m2x2_mt4>, IComparable
    , IComparisonOperators<b32m2x2_mt4, b32m2x2_mt4, bool>
    , IComparisonOperators<b32m2x2_mt4, b32m2x2_mt4, b32m2x2_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b32m2x2_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b32m2x2_mt4)}");
    }

    static bool IComparisonOperators<b32m2x2_mt4, b32m2x2_mt4, bool>.operator <(b32m2x2_mt4 left, b32m2x2_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m2x2_mt4, b32m2x2_mt4, bool>.operator >(b32m2x2_mt4 left, b32m2x2_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m2x2_mt4, b32m2x2_mt4, bool>.operator <=(b32m2x2_mt4 left, b32m2x2_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m2x2_mt4, b32m2x2_mt4, bool>.operator >=(b32m2x2_mt4 left, b32m2x2_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b32m2x2_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m2x2_mt4 operator <(b32m2x2_mt4 left, b32m2x2_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b32m2x2_mt4 operator >(b32m2x2_mt4 left, b32m2x2_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b32m2x2_mt4 operator <=(b32m2x2_mt4 left, b32m2x2_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b32m2x2_mt4 operator >=(b32m2x2_mt4 left, b32m2x2_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b32m2x2_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b32m2x2_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b32m2x2_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b32m2x2_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b32m2x2_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b32m2x2_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b32m2x2_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b32m2x2_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // b32m2x2_mt4

#region b32m2x2_mt8

public partial struct b32m2x2_mt8 : IComparable<b32m2x2_mt8>, IComparable
    , IComparisonOperators<b32m2x2_mt8, b32m2x2_mt8, bool>
    , IComparisonOperators<b32m2x2_mt8, b32m2x2_mt8, b32m2x2_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b32m2x2_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b32m2x2_mt8)}");
    }

    static bool IComparisonOperators<b32m2x2_mt8, b32m2x2_mt8, bool>.operator <(b32m2x2_mt8 left, b32m2x2_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m2x2_mt8, b32m2x2_mt8, bool>.operator >(b32m2x2_mt8 left, b32m2x2_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m2x2_mt8, b32m2x2_mt8, bool>.operator <=(b32m2x2_mt8 left, b32m2x2_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m2x2_mt8, b32m2x2_mt8, bool>.operator >=(b32m2x2_mt8 left, b32m2x2_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b32m2x2_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m2x2_mt8 operator <(b32m2x2_mt8 left, b32m2x2_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b32m2x2_mt8 operator >(b32m2x2_mt8 left, b32m2x2_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b32m2x2_mt8 operator <=(b32m2x2_mt8 left, b32m2x2_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b32m2x2_mt8 operator >=(b32m2x2_mt8 left, b32m2x2_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b32m2x2_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b32m2x2_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b32m2x2_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b32m2x2_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b32m2x2_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b32m2x2_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b32m2x2_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b32m2x2_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // b32m2x2_mt8

#region b32m2x2_mt16

public partial struct b32m2x2_mt16 : IComparable<b32m2x2_mt16>, IComparable
    , IComparisonOperators<b32m2x2_mt16, b32m2x2_mt16, bool>
    , IComparisonOperators<b32m2x2_mt16, b32m2x2_mt16, b32m2x2_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b32m2x2_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b32m2x2_mt16)}");
    }

    static bool IComparisonOperators<b32m2x2_mt16, b32m2x2_mt16, bool>.operator <(b32m2x2_mt16 left, b32m2x2_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m2x2_mt16, b32m2x2_mt16, bool>.operator >(b32m2x2_mt16 left, b32m2x2_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m2x2_mt16, b32m2x2_mt16, bool>.operator <=(b32m2x2_mt16 left, b32m2x2_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m2x2_mt16, b32m2x2_mt16, bool>.operator >=(b32m2x2_mt16 left, b32m2x2_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b32m2x2_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m2x2_mt16 operator <(b32m2x2_mt16 left, b32m2x2_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b32m2x2_mt16 operator >(b32m2x2_mt16 left, b32m2x2_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b32m2x2_mt16 operator <=(b32m2x2_mt16 left, b32m2x2_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b32m2x2_mt16 operator >=(b32m2x2_mt16 left, b32m2x2_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b32m2x2_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b32m2x2_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b32m2x2_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b32m2x2_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b32m2x2_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b32m2x2_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b32m2x2_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b32m2x2_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // b32m2x2_mt16

#region b32m2x3_mt4

public partial struct b32m2x3_mt4 : IComparable<b32m2x3_mt4>, IComparable
    , IComparisonOperators<b32m2x3_mt4, b32m2x3_mt4, bool>
    , IComparisonOperators<b32m2x3_mt4, b32m2x3_mt4, b32m2x3_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b32m2x3_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b32m2x3_mt4)}");
    }

    static bool IComparisonOperators<b32m2x3_mt4, b32m2x3_mt4, bool>.operator <(b32m2x3_mt4 left, b32m2x3_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m2x3_mt4, b32m2x3_mt4, bool>.operator >(b32m2x3_mt4 left, b32m2x3_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m2x3_mt4, b32m2x3_mt4, bool>.operator <=(b32m2x3_mt4 left, b32m2x3_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m2x3_mt4, b32m2x3_mt4, bool>.operator >=(b32m2x3_mt4 left, b32m2x3_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b32m2x3_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m2x3_mt4 operator <(b32m2x3_mt4 left, b32m2x3_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b32m2x3_mt4 operator >(b32m2x3_mt4 left, b32m2x3_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b32m2x3_mt4 operator <=(b32m2x3_mt4 left, b32m2x3_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b32m2x3_mt4 operator >=(b32m2x3_mt4 left, b32m2x3_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b32m2x3_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b32m2x3_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b32m2x3_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b32m2x3_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b32m2x3_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b32m2x3_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b32m2x3_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b32m2x3_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // b32m2x3_mt4

#region b32m2x3_mt8

public partial struct b32m2x3_mt8 : IComparable<b32m2x3_mt8>, IComparable
    , IComparisonOperators<b32m2x3_mt8, b32m2x3_mt8, bool>
    , IComparisonOperators<b32m2x3_mt8, b32m2x3_mt8, b32m2x3_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b32m2x3_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b32m2x3_mt8)}");
    }

    static bool IComparisonOperators<b32m2x3_mt8, b32m2x3_mt8, bool>.operator <(b32m2x3_mt8 left, b32m2x3_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m2x3_mt8, b32m2x3_mt8, bool>.operator >(b32m2x3_mt8 left, b32m2x3_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m2x3_mt8, b32m2x3_mt8, bool>.operator <=(b32m2x3_mt8 left, b32m2x3_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m2x3_mt8, b32m2x3_mt8, bool>.operator >=(b32m2x3_mt8 left, b32m2x3_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b32m2x3_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m2x3_mt8 operator <(b32m2x3_mt8 left, b32m2x3_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b32m2x3_mt8 operator >(b32m2x3_mt8 left, b32m2x3_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b32m2x3_mt8 operator <=(b32m2x3_mt8 left, b32m2x3_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b32m2x3_mt8 operator >=(b32m2x3_mt8 left, b32m2x3_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b32m2x3_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b32m2x3_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b32m2x3_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b32m2x3_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b32m2x3_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b32m2x3_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b32m2x3_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b32m2x3_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // b32m2x3_mt8

#region b32m2x3_mt16

public partial struct b32m2x3_mt16 : IComparable<b32m2x3_mt16>, IComparable
    , IComparisonOperators<b32m2x3_mt16, b32m2x3_mt16, bool>
    , IComparisonOperators<b32m2x3_mt16, b32m2x3_mt16, b32m2x3_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b32m2x3_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b32m2x3_mt16)}");
    }

    static bool IComparisonOperators<b32m2x3_mt16, b32m2x3_mt16, bool>.operator <(b32m2x3_mt16 left, b32m2x3_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m2x3_mt16, b32m2x3_mt16, bool>.operator >(b32m2x3_mt16 left, b32m2x3_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m2x3_mt16, b32m2x3_mt16, bool>.operator <=(b32m2x3_mt16 left, b32m2x3_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m2x3_mt16, b32m2x3_mt16, bool>.operator >=(b32m2x3_mt16 left, b32m2x3_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b32m2x3_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m2x3_mt16 operator <(b32m2x3_mt16 left, b32m2x3_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b32m2x3_mt16 operator >(b32m2x3_mt16 left, b32m2x3_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b32m2x3_mt16 operator <=(b32m2x3_mt16 left, b32m2x3_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b32m2x3_mt16 operator >=(b32m2x3_mt16 left, b32m2x3_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b32m2x3_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b32m2x3_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b32m2x3_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b32m2x3_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b32m2x3_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b32m2x3_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b32m2x3_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b32m2x3_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // b32m2x3_mt16

#region b32m2x4_mt4

public partial struct b32m2x4_mt4 : IComparable<b32m2x4_mt4>, IComparable
    , IComparisonOperators<b32m2x4_mt4, b32m2x4_mt4, bool>
    , IComparisonOperators<b32m2x4_mt4, b32m2x4_mt4, b32m2x4_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b32m2x4_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b32m2x4_mt4)}");
    }

    static bool IComparisonOperators<b32m2x4_mt4, b32m2x4_mt4, bool>.operator <(b32m2x4_mt4 left, b32m2x4_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m2x4_mt4, b32m2x4_mt4, bool>.operator >(b32m2x4_mt4 left, b32m2x4_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m2x4_mt4, b32m2x4_mt4, bool>.operator <=(b32m2x4_mt4 left, b32m2x4_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m2x4_mt4, b32m2x4_mt4, bool>.operator >=(b32m2x4_mt4 left, b32m2x4_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b32m2x4_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m2x4_mt4 operator <(b32m2x4_mt4 left, b32m2x4_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b32m2x4_mt4 operator >(b32m2x4_mt4 left, b32m2x4_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b32m2x4_mt4 operator <=(b32m2x4_mt4 left, b32m2x4_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b32m2x4_mt4 operator >=(b32m2x4_mt4 left, b32m2x4_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b32m2x4_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b32m2x4_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b32m2x4_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b32m2x4_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b32m2x4_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b32m2x4_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b32m2x4_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b32m2x4_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // b32m2x4_mt4

#region b32m2x4_mt8

public partial struct b32m2x4_mt8 : IComparable<b32m2x4_mt8>, IComparable
    , IComparisonOperators<b32m2x4_mt8, b32m2x4_mt8, bool>
    , IComparisonOperators<b32m2x4_mt8, b32m2x4_mt8, b32m2x4_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b32m2x4_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b32m2x4_mt8)}");
    }

    static bool IComparisonOperators<b32m2x4_mt8, b32m2x4_mt8, bool>.operator <(b32m2x4_mt8 left, b32m2x4_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m2x4_mt8, b32m2x4_mt8, bool>.operator >(b32m2x4_mt8 left, b32m2x4_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m2x4_mt8, b32m2x4_mt8, bool>.operator <=(b32m2x4_mt8 left, b32m2x4_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m2x4_mt8, b32m2x4_mt8, bool>.operator >=(b32m2x4_mt8 left, b32m2x4_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b32m2x4_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m2x4_mt8 operator <(b32m2x4_mt8 left, b32m2x4_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b32m2x4_mt8 operator >(b32m2x4_mt8 left, b32m2x4_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b32m2x4_mt8 operator <=(b32m2x4_mt8 left, b32m2x4_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b32m2x4_mt8 operator >=(b32m2x4_mt8 left, b32m2x4_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b32m2x4_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b32m2x4_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b32m2x4_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b32m2x4_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b32m2x4_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b32m2x4_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b32m2x4_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b32m2x4_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // b32m2x4_mt8

#region b32m2x4_mt16

public partial struct b32m2x4_mt16 : IComparable<b32m2x4_mt16>, IComparable
    , IComparisonOperators<b32m2x4_mt16, b32m2x4_mt16, bool>
    , IComparisonOperators<b32m2x4_mt16, b32m2x4_mt16, b32m2x4_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b32m2x4_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b32m2x4_mt16)}");
    }

    static bool IComparisonOperators<b32m2x4_mt16, b32m2x4_mt16, bool>.operator <(b32m2x4_mt16 left, b32m2x4_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m2x4_mt16, b32m2x4_mt16, bool>.operator >(b32m2x4_mt16 left, b32m2x4_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m2x4_mt16, b32m2x4_mt16, bool>.operator <=(b32m2x4_mt16 left, b32m2x4_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m2x4_mt16, b32m2x4_mt16, bool>.operator >=(b32m2x4_mt16 left, b32m2x4_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b32m2x4_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m2x4_mt16 operator <(b32m2x4_mt16 left, b32m2x4_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b32m2x4_mt16 operator >(b32m2x4_mt16 left, b32m2x4_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b32m2x4_mt16 operator <=(b32m2x4_mt16 left, b32m2x4_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b32m2x4_mt16 operator >=(b32m2x4_mt16 left, b32m2x4_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b32m2x4_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b32m2x4_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b32m2x4_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b32m2x4_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b32m2x4_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b32m2x4_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b32m2x4_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b32m2x4_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // b32m2x4_mt16

#region b32m3x2_mt4

public partial struct b32m3x2_mt4 : IComparable<b32m3x2_mt4>, IComparable
    , IComparisonOperators<b32m3x2_mt4, b32m3x2_mt4, bool>
    , IComparisonOperators<b32m3x2_mt4, b32m3x2_mt4, b32m3x2_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b32m3x2_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b32m3x2_mt4)}");
    }

    static bool IComparisonOperators<b32m3x2_mt4, b32m3x2_mt4, bool>.operator <(b32m3x2_mt4 left, b32m3x2_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m3x2_mt4, b32m3x2_mt4, bool>.operator >(b32m3x2_mt4 left, b32m3x2_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m3x2_mt4, b32m3x2_mt4, bool>.operator <=(b32m3x2_mt4 left, b32m3x2_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m3x2_mt4, b32m3x2_mt4, bool>.operator >=(b32m3x2_mt4 left, b32m3x2_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b32m3x2_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m3x2_mt4 operator <(b32m3x2_mt4 left, b32m3x2_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b32m3x2_mt4 operator >(b32m3x2_mt4 left, b32m3x2_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b32m3x2_mt4 operator <=(b32m3x2_mt4 left, b32m3x2_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b32m3x2_mt4 operator >=(b32m3x2_mt4 left, b32m3x2_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b32m3x2_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b32m3x2_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b32m3x2_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b32m3x2_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b32m3x2_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b32m3x2_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b32m3x2_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b32m3x2_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // b32m3x2_mt4

#region b32m3x2_mt8

public partial struct b32m3x2_mt8 : IComparable<b32m3x2_mt8>, IComparable
    , IComparisonOperators<b32m3x2_mt8, b32m3x2_mt8, bool>
    , IComparisonOperators<b32m3x2_mt8, b32m3x2_mt8, b32m3x2_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b32m3x2_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b32m3x2_mt8)}");
    }

    static bool IComparisonOperators<b32m3x2_mt8, b32m3x2_mt8, bool>.operator <(b32m3x2_mt8 left, b32m3x2_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m3x2_mt8, b32m3x2_mt8, bool>.operator >(b32m3x2_mt8 left, b32m3x2_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m3x2_mt8, b32m3x2_mt8, bool>.operator <=(b32m3x2_mt8 left, b32m3x2_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m3x2_mt8, b32m3x2_mt8, bool>.operator >=(b32m3x2_mt8 left, b32m3x2_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b32m3x2_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m3x2_mt8 operator <(b32m3x2_mt8 left, b32m3x2_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b32m3x2_mt8 operator >(b32m3x2_mt8 left, b32m3x2_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b32m3x2_mt8 operator <=(b32m3x2_mt8 left, b32m3x2_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b32m3x2_mt8 operator >=(b32m3x2_mt8 left, b32m3x2_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b32m3x2_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b32m3x2_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b32m3x2_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b32m3x2_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b32m3x2_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b32m3x2_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b32m3x2_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b32m3x2_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // b32m3x2_mt8

#region b32m3x2_mt16

public partial struct b32m3x2_mt16 : IComparable<b32m3x2_mt16>, IComparable
    , IComparisonOperators<b32m3x2_mt16, b32m3x2_mt16, bool>
    , IComparisonOperators<b32m3x2_mt16, b32m3x2_mt16, b32m3x2_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b32m3x2_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b32m3x2_mt16)}");
    }

    static bool IComparisonOperators<b32m3x2_mt16, b32m3x2_mt16, bool>.operator <(b32m3x2_mt16 left, b32m3x2_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m3x2_mt16, b32m3x2_mt16, bool>.operator >(b32m3x2_mt16 left, b32m3x2_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m3x2_mt16, b32m3x2_mt16, bool>.operator <=(b32m3x2_mt16 left, b32m3x2_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m3x2_mt16, b32m3x2_mt16, bool>.operator >=(b32m3x2_mt16 left, b32m3x2_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b32m3x2_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m3x2_mt16 operator <(b32m3x2_mt16 left, b32m3x2_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b32m3x2_mt16 operator >(b32m3x2_mt16 left, b32m3x2_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b32m3x2_mt16 operator <=(b32m3x2_mt16 left, b32m3x2_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b32m3x2_mt16 operator >=(b32m3x2_mt16 left, b32m3x2_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b32m3x2_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b32m3x2_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b32m3x2_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b32m3x2_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b32m3x2_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b32m3x2_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b32m3x2_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b32m3x2_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // b32m3x2_mt16

#region b32m3x3_mt4

public partial struct b32m3x3_mt4 : IComparable<b32m3x3_mt4>, IComparable
    , IComparisonOperators<b32m3x3_mt4, b32m3x3_mt4, bool>
    , IComparisonOperators<b32m3x3_mt4, b32m3x3_mt4, b32m3x3_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b32m3x3_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b32m3x3_mt4)}");
    }

    static bool IComparisonOperators<b32m3x3_mt4, b32m3x3_mt4, bool>.operator <(b32m3x3_mt4 left, b32m3x3_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m3x3_mt4, b32m3x3_mt4, bool>.operator >(b32m3x3_mt4 left, b32m3x3_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m3x3_mt4, b32m3x3_mt4, bool>.operator <=(b32m3x3_mt4 left, b32m3x3_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m3x3_mt4, b32m3x3_mt4, bool>.operator >=(b32m3x3_mt4 left, b32m3x3_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b32m3x3_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m3x3_mt4 operator <(b32m3x3_mt4 left, b32m3x3_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b32m3x3_mt4 operator >(b32m3x3_mt4 left, b32m3x3_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b32m3x3_mt4 operator <=(b32m3x3_mt4 left, b32m3x3_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b32m3x3_mt4 operator >=(b32m3x3_mt4 left, b32m3x3_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b32m3x3_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b32m3x3_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b32m3x3_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b32m3x3_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b32m3x3_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b32m3x3_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b32m3x3_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b32m3x3_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // b32m3x3_mt4

#region b32m3x3_mt8

public partial struct b32m3x3_mt8 : IComparable<b32m3x3_mt8>, IComparable
    , IComparisonOperators<b32m3x3_mt8, b32m3x3_mt8, bool>
    , IComparisonOperators<b32m3x3_mt8, b32m3x3_mt8, b32m3x3_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b32m3x3_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b32m3x3_mt8)}");
    }

    static bool IComparisonOperators<b32m3x3_mt8, b32m3x3_mt8, bool>.operator <(b32m3x3_mt8 left, b32m3x3_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m3x3_mt8, b32m3x3_mt8, bool>.operator >(b32m3x3_mt8 left, b32m3x3_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m3x3_mt8, b32m3x3_mt8, bool>.operator <=(b32m3x3_mt8 left, b32m3x3_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m3x3_mt8, b32m3x3_mt8, bool>.operator >=(b32m3x3_mt8 left, b32m3x3_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b32m3x3_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m3x3_mt8 operator <(b32m3x3_mt8 left, b32m3x3_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b32m3x3_mt8 operator >(b32m3x3_mt8 left, b32m3x3_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b32m3x3_mt8 operator <=(b32m3x3_mt8 left, b32m3x3_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b32m3x3_mt8 operator >=(b32m3x3_mt8 left, b32m3x3_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b32m3x3_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b32m3x3_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b32m3x3_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b32m3x3_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b32m3x3_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b32m3x3_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b32m3x3_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b32m3x3_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // b32m3x3_mt8

#region b32m3x3_mt16

public partial struct b32m3x3_mt16 : IComparable<b32m3x3_mt16>, IComparable
    , IComparisonOperators<b32m3x3_mt16, b32m3x3_mt16, bool>
    , IComparisonOperators<b32m3x3_mt16, b32m3x3_mt16, b32m3x3_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b32m3x3_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b32m3x3_mt16)}");
    }

    static bool IComparisonOperators<b32m3x3_mt16, b32m3x3_mt16, bool>.operator <(b32m3x3_mt16 left, b32m3x3_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m3x3_mt16, b32m3x3_mt16, bool>.operator >(b32m3x3_mt16 left, b32m3x3_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m3x3_mt16, b32m3x3_mt16, bool>.operator <=(b32m3x3_mt16 left, b32m3x3_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m3x3_mt16, b32m3x3_mt16, bool>.operator >=(b32m3x3_mt16 left, b32m3x3_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b32m3x3_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m3x3_mt16 operator <(b32m3x3_mt16 left, b32m3x3_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b32m3x3_mt16 operator >(b32m3x3_mt16 left, b32m3x3_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b32m3x3_mt16 operator <=(b32m3x3_mt16 left, b32m3x3_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b32m3x3_mt16 operator >=(b32m3x3_mt16 left, b32m3x3_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b32m3x3_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b32m3x3_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b32m3x3_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b32m3x3_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b32m3x3_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b32m3x3_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b32m3x3_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b32m3x3_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // b32m3x3_mt16

#region b32m3x4_mt4

public partial struct b32m3x4_mt4 : IComparable<b32m3x4_mt4>, IComparable
    , IComparisonOperators<b32m3x4_mt4, b32m3x4_mt4, bool>
    , IComparisonOperators<b32m3x4_mt4, b32m3x4_mt4, b32m3x4_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b32m3x4_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b32m3x4_mt4)}");
    }

    static bool IComparisonOperators<b32m3x4_mt4, b32m3x4_mt4, bool>.operator <(b32m3x4_mt4 left, b32m3x4_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m3x4_mt4, b32m3x4_mt4, bool>.operator >(b32m3x4_mt4 left, b32m3x4_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m3x4_mt4, b32m3x4_mt4, bool>.operator <=(b32m3x4_mt4 left, b32m3x4_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m3x4_mt4, b32m3x4_mt4, bool>.operator >=(b32m3x4_mt4 left, b32m3x4_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b32m3x4_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m3x4_mt4 operator <(b32m3x4_mt4 left, b32m3x4_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b32m3x4_mt4 operator >(b32m3x4_mt4 left, b32m3x4_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b32m3x4_mt4 operator <=(b32m3x4_mt4 left, b32m3x4_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b32m3x4_mt4 operator >=(b32m3x4_mt4 left, b32m3x4_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b32m3x4_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b32m3x4_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b32m3x4_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b32m3x4_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b32m3x4_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b32m3x4_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b32m3x4_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b32m3x4_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // b32m3x4_mt4

#region b32m3x4_mt8

public partial struct b32m3x4_mt8 : IComparable<b32m3x4_mt8>, IComparable
    , IComparisonOperators<b32m3x4_mt8, b32m3x4_mt8, bool>
    , IComparisonOperators<b32m3x4_mt8, b32m3x4_mt8, b32m3x4_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b32m3x4_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b32m3x4_mt8)}");
    }

    static bool IComparisonOperators<b32m3x4_mt8, b32m3x4_mt8, bool>.operator <(b32m3x4_mt8 left, b32m3x4_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m3x4_mt8, b32m3x4_mt8, bool>.operator >(b32m3x4_mt8 left, b32m3x4_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m3x4_mt8, b32m3x4_mt8, bool>.operator <=(b32m3x4_mt8 left, b32m3x4_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m3x4_mt8, b32m3x4_mt8, bool>.operator >=(b32m3x4_mt8 left, b32m3x4_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b32m3x4_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m3x4_mt8 operator <(b32m3x4_mt8 left, b32m3x4_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b32m3x4_mt8 operator >(b32m3x4_mt8 left, b32m3x4_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b32m3x4_mt8 operator <=(b32m3x4_mt8 left, b32m3x4_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b32m3x4_mt8 operator >=(b32m3x4_mt8 left, b32m3x4_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b32m3x4_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b32m3x4_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b32m3x4_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b32m3x4_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b32m3x4_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b32m3x4_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b32m3x4_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b32m3x4_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // b32m3x4_mt8

#region b32m3x4_mt16

public partial struct b32m3x4_mt16 : IComparable<b32m3x4_mt16>, IComparable
    , IComparisonOperators<b32m3x4_mt16, b32m3x4_mt16, bool>
    , IComparisonOperators<b32m3x4_mt16, b32m3x4_mt16, b32m3x4_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b32m3x4_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b32m3x4_mt16)}");
    }

    static bool IComparisonOperators<b32m3x4_mt16, b32m3x4_mt16, bool>.operator <(b32m3x4_mt16 left, b32m3x4_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m3x4_mt16, b32m3x4_mt16, bool>.operator >(b32m3x4_mt16 left, b32m3x4_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m3x4_mt16, b32m3x4_mt16, bool>.operator <=(b32m3x4_mt16 left, b32m3x4_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m3x4_mt16, b32m3x4_mt16, bool>.operator >=(b32m3x4_mt16 left, b32m3x4_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b32m3x4_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m3x4_mt16 operator <(b32m3x4_mt16 left, b32m3x4_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b32m3x4_mt16 operator >(b32m3x4_mt16 left, b32m3x4_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b32m3x4_mt16 operator <=(b32m3x4_mt16 left, b32m3x4_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b32m3x4_mt16 operator >=(b32m3x4_mt16 left, b32m3x4_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b32m3x4_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b32m3x4_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b32m3x4_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b32m3x4_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b32m3x4_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b32m3x4_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b32m3x4_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b32m3x4_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // b32m3x4_mt16

#region b32m4x2_mt4

public partial struct b32m4x2_mt4 : IComparable<b32m4x2_mt4>, IComparable
    , IComparisonOperators<b32m4x2_mt4, b32m4x2_mt4, bool>
    , IComparisonOperators<b32m4x2_mt4, b32m4x2_mt4, b32m4x2_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b32m4x2_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b32m4x2_mt4)}");
    }

    static bool IComparisonOperators<b32m4x2_mt4, b32m4x2_mt4, bool>.operator <(b32m4x2_mt4 left, b32m4x2_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m4x2_mt4, b32m4x2_mt4, bool>.operator >(b32m4x2_mt4 left, b32m4x2_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m4x2_mt4, b32m4x2_mt4, bool>.operator <=(b32m4x2_mt4 left, b32m4x2_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m4x2_mt4, b32m4x2_mt4, bool>.operator >=(b32m4x2_mt4 left, b32m4x2_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b32m4x2_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m4x2_mt4 operator <(b32m4x2_mt4 left, b32m4x2_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b32m4x2_mt4 operator >(b32m4x2_mt4 left, b32m4x2_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b32m4x2_mt4 operator <=(b32m4x2_mt4 left, b32m4x2_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b32m4x2_mt4 operator >=(b32m4x2_mt4 left, b32m4x2_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b32m4x2_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b32m4x2_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b32m4x2_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b32m4x2_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b32m4x2_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b32m4x2_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b32m4x2_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b32m4x2_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // b32m4x2_mt4

#region b32m4x2_mt8

public partial struct b32m4x2_mt8 : IComparable<b32m4x2_mt8>, IComparable
    , IComparisonOperators<b32m4x2_mt8, b32m4x2_mt8, bool>
    , IComparisonOperators<b32m4x2_mt8, b32m4x2_mt8, b32m4x2_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b32m4x2_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b32m4x2_mt8)}");
    }

    static bool IComparisonOperators<b32m4x2_mt8, b32m4x2_mt8, bool>.operator <(b32m4x2_mt8 left, b32m4x2_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m4x2_mt8, b32m4x2_mt8, bool>.operator >(b32m4x2_mt8 left, b32m4x2_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m4x2_mt8, b32m4x2_mt8, bool>.operator <=(b32m4x2_mt8 left, b32m4x2_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m4x2_mt8, b32m4x2_mt8, bool>.operator >=(b32m4x2_mt8 left, b32m4x2_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b32m4x2_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m4x2_mt8 operator <(b32m4x2_mt8 left, b32m4x2_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b32m4x2_mt8 operator >(b32m4x2_mt8 left, b32m4x2_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b32m4x2_mt8 operator <=(b32m4x2_mt8 left, b32m4x2_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b32m4x2_mt8 operator >=(b32m4x2_mt8 left, b32m4x2_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b32m4x2_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b32m4x2_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b32m4x2_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b32m4x2_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b32m4x2_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b32m4x2_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b32m4x2_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b32m4x2_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // b32m4x2_mt8

#region b32m4x2_mt16

public partial struct b32m4x2_mt16 : IComparable<b32m4x2_mt16>, IComparable
    , IComparisonOperators<b32m4x2_mt16, b32m4x2_mt16, bool>
    , IComparisonOperators<b32m4x2_mt16, b32m4x2_mt16, b32m4x2_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b32m4x2_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b32m4x2_mt16)}");
    }

    static bool IComparisonOperators<b32m4x2_mt16, b32m4x2_mt16, bool>.operator <(b32m4x2_mt16 left, b32m4x2_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m4x2_mt16, b32m4x2_mt16, bool>.operator >(b32m4x2_mt16 left, b32m4x2_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m4x2_mt16, b32m4x2_mt16, bool>.operator <=(b32m4x2_mt16 left, b32m4x2_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m4x2_mt16, b32m4x2_mt16, bool>.operator >=(b32m4x2_mt16 left, b32m4x2_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b32m4x2_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m4x2_mt16 operator <(b32m4x2_mt16 left, b32m4x2_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b32m4x2_mt16 operator >(b32m4x2_mt16 left, b32m4x2_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b32m4x2_mt16 operator <=(b32m4x2_mt16 left, b32m4x2_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b32m4x2_mt16 operator >=(b32m4x2_mt16 left, b32m4x2_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b32m4x2_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b32m4x2_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b32m4x2_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b32m4x2_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b32m4x2_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b32m4x2_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b32m4x2_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b32m4x2_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // b32m4x2_mt16

#region b32m4x3_mt4

public partial struct b32m4x3_mt4 : IComparable<b32m4x3_mt4>, IComparable
    , IComparisonOperators<b32m4x3_mt4, b32m4x3_mt4, bool>
    , IComparisonOperators<b32m4x3_mt4, b32m4x3_mt4, b32m4x3_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b32m4x3_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b32m4x3_mt4)}");
    }

    static bool IComparisonOperators<b32m4x3_mt4, b32m4x3_mt4, bool>.operator <(b32m4x3_mt4 left, b32m4x3_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m4x3_mt4, b32m4x3_mt4, bool>.operator >(b32m4x3_mt4 left, b32m4x3_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m4x3_mt4, b32m4x3_mt4, bool>.operator <=(b32m4x3_mt4 left, b32m4x3_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m4x3_mt4, b32m4x3_mt4, bool>.operator >=(b32m4x3_mt4 left, b32m4x3_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b32m4x3_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m4x3_mt4 operator <(b32m4x3_mt4 left, b32m4x3_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b32m4x3_mt4 operator >(b32m4x3_mt4 left, b32m4x3_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b32m4x3_mt4 operator <=(b32m4x3_mt4 left, b32m4x3_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b32m4x3_mt4 operator >=(b32m4x3_mt4 left, b32m4x3_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b32m4x3_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b32m4x3_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b32m4x3_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b32m4x3_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b32m4x3_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b32m4x3_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b32m4x3_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b32m4x3_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // b32m4x3_mt4

#region b32m4x3_mt8

public partial struct b32m4x3_mt8 : IComparable<b32m4x3_mt8>, IComparable
    , IComparisonOperators<b32m4x3_mt8, b32m4x3_mt8, bool>
    , IComparisonOperators<b32m4x3_mt8, b32m4x3_mt8, b32m4x3_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b32m4x3_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b32m4x3_mt8)}");
    }

    static bool IComparisonOperators<b32m4x3_mt8, b32m4x3_mt8, bool>.operator <(b32m4x3_mt8 left, b32m4x3_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m4x3_mt8, b32m4x3_mt8, bool>.operator >(b32m4x3_mt8 left, b32m4x3_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m4x3_mt8, b32m4x3_mt8, bool>.operator <=(b32m4x3_mt8 left, b32m4x3_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m4x3_mt8, b32m4x3_mt8, bool>.operator >=(b32m4x3_mt8 left, b32m4x3_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b32m4x3_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m4x3_mt8 operator <(b32m4x3_mt8 left, b32m4x3_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b32m4x3_mt8 operator >(b32m4x3_mt8 left, b32m4x3_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b32m4x3_mt8 operator <=(b32m4x3_mt8 left, b32m4x3_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b32m4x3_mt8 operator >=(b32m4x3_mt8 left, b32m4x3_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b32m4x3_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b32m4x3_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b32m4x3_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b32m4x3_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b32m4x3_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b32m4x3_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b32m4x3_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b32m4x3_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // b32m4x3_mt8

#region b32m4x3_mt16

public partial struct b32m4x3_mt16 : IComparable<b32m4x3_mt16>, IComparable
    , IComparisonOperators<b32m4x3_mt16, b32m4x3_mt16, bool>
    , IComparisonOperators<b32m4x3_mt16, b32m4x3_mt16, b32m4x3_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b32m4x3_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b32m4x3_mt16)}");
    }

    static bool IComparisonOperators<b32m4x3_mt16, b32m4x3_mt16, bool>.operator <(b32m4x3_mt16 left, b32m4x3_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m4x3_mt16, b32m4x3_mt16, bool>.operator >(b32m4x3_mt16 left, b32m4x3_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m4x3_mt16, b32m4x3_mt16, bool>.operator <=(b32m4x3_mt16 left, b32m4x3_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m4x3_mt16, b32m4x3_mt16, bool>.operator >=(b32m4x3_mt16 left, b32m4x3_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b32m4x3_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m4x3_mt16 operator <(b32m4x3_mt16 left, b32m4x3_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b32m4x3_mt16 operator >(b32m4x3_mt16 left, b32m4x3_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b32m4x3_mt16 operator <=(b32m4x3_mt16 left, b32m4x3_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b32m4x3_mt16 operator >=(b32m4x3_mt16 left, b32m4x3_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b32m4x3_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b32m4x3_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b32m4x3_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b32m4x3_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b32m4x3_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b32m4x3_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b32m4x3_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b32m4x3_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // b32m4x3_mt16

#region b32m4x4_mt4

public partial struct b32m4x4_mt4 : IComparable<b32m4x4_mt4>, IComparable
    , IComparisonOperators<b32m4x4_mt4, b32m4x4_mt4, bool>
    , IComparisonOperators<b32m4x4_mt4, b32m4x4_mt4, b32m4x4_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b32m4x4_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b32m4x4_mt4)}");
    }

    static bool IComparisonOperators<b32m4x4_mt4, b32m4x4_mt4, bool>.operator <(b32m4x4_mt4 left, b32m4x4_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m4x4_mt4, b32m4x4_mt4, bool>.operator >(b32m4x4_mt4 left, b32m4x4_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m4x4_mt4, b32m4x4_mt4, bool>.operator <=(b32m4x4_mt4 left, b32m4x4_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m4x4_mt4, b32m4x4_mt4, bool>.operator >=(b32m4x4_mt4 left, b32m4x4_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b32m4x4_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m4x4_mt4 operator <(b32m4x4_mt4 left, b32m4x4_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b32m4x4_mt4 operator >(b32m4x4_mt4 left, b32m4x4_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b32m4x4_mt4 operator <=(b32m4x4_mt4 left, b32m4x4_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b32m4x4_mt4 operator >=(b32m4x4_mt4 left, b32m4x4_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b32m4x4_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b32m4x4_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b32m4x4_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b32m4x4_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b32m4x4_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b32m4x4_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b32m4x4_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b32m4x4_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // b32m4x4_mt4

#region b32m4x4_mt8

public partial struct b32m4x4_mt8 : IComparable<b32m4x4_mt8>, IComparable
    , IComparisonOperators<b32m4x4_mt8, b32m4x4_mt8, bool>
    , IComparisonOperators<b32m4x4_mt8, b32m4x4_mt8, b32m4x4_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b32m4x4_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b32m4x4_mt8)}");
    }

    static bool IComparisonOperators<b32m4x4_mt8, b32m4x4_mt8, bool>.operator <(b32m4x4_mt8 left, b32m4x4_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m4x4_mt8, b32m4x4_mt8, bool>.operator >(b32m4x4_mt8 left, b32m4x4_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m4x4_mt8, b32m4x4_mt8, bool>.operator <=(b32m4x4_mt8 left, b32m4x4_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m4x4_mt8, b32m4x4_mt8, bool>.operator >=(b32m4x4_mt8 left, b32m4x4_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b32m4x4_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m4x4_mt8 operator <(b32m4x4_mt8 left, b32m4x4_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b32m4x4_mt8 operator >(b32m4x4_mt8 left, b32m4x4_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b32m4x4_mt8 operator <=(b32m4x4_mt8 left, b32m4x4_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b32m4x4_mt8 operator >=(b32m4x4_mt8 left, b32m4x4_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b32m4x4_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b32m4x4_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b32m4x4_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b32m4x4_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b32m4x4_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b32m4x4_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b32m4x4_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b32m4x4_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // b32m4x4_mt8

#region b32m4x4_mt16

public partial struct b32m4x4_mt16 : IComparable<b32m4x4_mt16>, IComparable
    , IComparisonOperators<b32m4x4_mt16, b32m4x4_mt16, bool>
    , IComparisonOperators<b32m4x4_mt16, b32m4x4_mt16, b32m4x4_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b32m4x4_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b32m4x4_mt16)}");
    }

    static bool IComparisonOperators<b32m4x4_mt16, b32m4x4_mt16, bool>.operator <(b32m4x4_mt16 left, b32m4x4_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m4x4_mt16, b32m4x4_mt16, bool>.operator >(b32m4x4_mt16 left, b32m4x4_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m4x4_mt16, b32m4x4_mt16, bool>.operator <=(b32m4x4_mt16 left, b32m4x4_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m4x4_mt16, b32m4x4_mt16, bool>.operator >=(b32m4x4_mt16 left, b32m4x4_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b32m4x4_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m4x4_mt16 operator <(b32m4x4_mt16 left, b32m4x4_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b32m4x4_mt16 operator >(b32m4x4_mt16 left, b32m4x4_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b32m4x4_mt16 operator <=(b32m4x4_mt16 left, b32m4x4_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b32m4x4_mt16 operator >=(b32m4x4_mt16 left, b32m4x4_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b32m4x4_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b32m4x4_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b32m4x4_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b32m4x4_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b32m4x4_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b32m4x4_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b32m4x4_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b32m4x4_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // b32m4x4_mt16

#region b64m2x2_mt4

public partial struct b64m2x2_mt4 : IComparable<b64m2x2_mt4>, IComparable
    , IComparisonOperators<b64m2x2_mt4, b64m2x2_mt4, bool>
    , IComparisonOperators<b64m2x2_mt4, b64m2x2_mt4, b64m2x2_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b64m2x2_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b64m2x2_mt4)}");
    }

    static bool IComparisonOperators<b64m2x2_mt4, b64m2x2_mt4, bool>.operator <(b64m2x2_mt4 left, b64m2x2_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m2x2_mt4, b64m2x2_mt4, bool>.operator >(b64m2x2_mt4 left, b64m2x2_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m2x2_mt4, b64m2x2_mt4, bool>.operator <=(b64m2x2_mt4 left, b64m2x2_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m2x2_mt4, b64m2x2_mt4, bool>.operator >=(b64m2x2_mt4 left, b64m2x2_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b64m2x2_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m2x2_mt4 operator <(b64m2x2_mt4 left, b64m2x2_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b64m2x2_mt4 operator >(b64m2x2_mt4 left, b64m2x2_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b64m2x2_mt4 operator <=(b64m2x2_mt4 left, b64m2x2_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b64m2x2_mt4 operator >=(b64m2x2_mt4 left, b64m2x2_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b64m2x2_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b64m2x2_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b64m2x2_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b64m2x2_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b64m2x2_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b64m2x2_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b64m2x2_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b64m2x2_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // b64m2x2_mt4

#region b64m2x2_mt8

public partial struct b64m2x2_mt8 : IComparable<b64m2x2_mt8>, IComparable
    , IComparisonOperators<b64m2x2_mt8, b64m2x2_mt8, bool>
    , IComparisonOperators<b64m2x2_mt8, b64m2x2_mt8, b64m2x2_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b64m2x2_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b64m2x2_mt8)}");
    }

    static bool IComparisonOperators<b64m2x2_mt8, b64m2x2_mt8, bool>.operator <(b64m2x2_mt8 left, b64m2x2_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m2x2_mt8, b64m2x2_mt8, bool>.operator >(b64m2x2_mt8 left, b64m2x2_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m2x2_mt8, b64m2x2_mt8, bool>.operator <=(b64m2x2_mt8 left, b64m2x2_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m2x2_mt8, b64m2x2_mt8, bool>.operator >=(b64m2x2_mt8 left, b64m2x2_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b64m2x2_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m2x2_mt8 operator <(b64m2x2_mt8 left, b64m2x2_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b64m2x2_mt8 operator >(b64m2x2_mt8 left, b64m2x2_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b64m2x2_mt8 operator <=(b64m2x2_mt8 left, b64m2x2_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b64m2x2_mt8 operator >=(b64m2x2_mt8 left, b64m2x2_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b64m2x2_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b64m2x2_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b64m2x2_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b64m2x2_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b64m2x2_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b64m2x2_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b64m2x2_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b64m2x2_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // b64m2x2_mt8

#region b64m2x2_mt16

public partial struct b64m2x2_mt16 : IComparable<b64m2x2_mt16>, IComparable
    , IComparisonOperators<b64m2x2_mt16, b64m2x2_mt16, bool>
    , IComparisonOperators<b64m2x2_mt16, b64m2x2_mt16, b64m2x2_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b64m2x2_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b64m2x2_mt16)}");
    }

    static bool IComparisonOperators<b64m2x2_mt16, b64m2x2_mt16, bool>.operator <(b64m2x2_mt16 left, b64m2x2_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m2x2_mt16, b64m2x2_mt16, bool>.operator >(b64m2x2_mt16 left, b64m2x2_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m2x2_mt16, b64m2x2_mt16, bool>.operator <=(b64m2x2_mt16 left, b64m2x2_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m2x2_mt16, b64m2x2_mt16, bool>.operator >=(b64m2x2_mt16 left, b64m2x2_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b64m2x2_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m2x2_mt16 operator <(b64m2x2_mt16 left, b64m2x2_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b64m2x2_mt16 operator >(b64m2x2_mt16 left, b64m2x2_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b64m2x2_mt16 operator <=(b64m2x2_mt16 left, b64m2x2_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b64m2x2_mt16 operator >=(b64m2x2_mt16 left, b64m2x2_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b64m2x2_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b64m2x2_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b64m2x2_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b64m2x2_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b64m2x2_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b64m2x2_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b64m2x2_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b64m2x2_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // b64m2x2_mt16

#region b64m2x3_mt4

public partial struct b64m2x3_mt4 : IComparable<b64m2x3_mt4>, IComparable
    , IComparisonOperators<b64m2x3_mt4, b64m2x3_mt4, bool>
    , IComparisonOperators<b64m2x3_mt4, b64m2x3_mt4, b64m2x3_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b64m2x3_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b64m2x3_mt4)}");
    }

    static bool IComparisonOperators<b64m2x3_mt4, b64m2x3_mt4, bool>.operator <(b64m2x3_mt4 left, b64m2x3_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m2x3_mt4, b64m2x3_mt4, bool>.operator >(b64m2x3_mt4 left, b64m2x3_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m2x3_mt4, b64m2x3_mt4, bool>.operator <=(b64m2x3_mt4 left, b64m2x3_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m2x3_mt4, b64m2x3_mt4, bool>.operator >=(b64m2x3_mt4 left, b64m2x3_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b64m2x3_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m2x3_mt4 operator <(b64m2x3_mt4 left, b64m2x3_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b64m2x3_mt4 operator >(b64m2x3_mt4 left, b64m2x3_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b64m2x3_mt4 operator <=(b64m2x3_mt4 left, b64m2x3_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b64m2x3_mt4 operator >=(b64m2x3_mt4 left, b64m2x3_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b64m2x3_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b64m2x3_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b64m2x3_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b64m2x3_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b64m2x3_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b64m2x3_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b64m2x3_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b64m2x3_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // b64m2x3_mt4

#region b64m2x3_mt8

public partial struct b64m2x3_mt8 : IComparable<b64m2x3_mt8>, IComparable
    , IComparisonOperators<b64m2x3_mt8, b64m2x3_mt8, bool>
    , IComparisonOperators<b64m2x3_mt8, b64m2x3_mt8, b64m2x3_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b64m2x3_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b64m2x3_mt8)}");
    }

    static bool IComparisonOperators<b64m2x3_mt8, b64m2x3_mt8, bool>.operator <(b64m2x3_mt8 left, b64m2x3_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m2x3_mt8, b64m2x3_mt8, bool>.operator >(b64m2x3_mt8 left, b64m2x3_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m2x3_mt8, b64m2x3_mt8, bool>.operator <=(b64m2x3_mt8 left, b64m2x3_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m2x3_mt8, b64m2x3_mt8, bool>.operator >=(b64m2x3_mt8 left, b64m2x3_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b64m2x3_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m2x3_mt8 operator <(b64m2x3_mt8 left, b64m2x3_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b64m2x3_mt8 operator >(b64m2x3_mt8 left, b64m2x3_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b64m2x3_mt8 operator <=(b64m2x3_mt8 left, b64m2x3_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b64m2x3_mt8 operator >=(b64m2x3_mt8 left, b64m2x3_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b64m2x3_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b64m2x3_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b64m2x3_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b64m2x3_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b64m2x3_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b64m2x3_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b64m2x3_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b64m2x3_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // b64m2x3_mt8

#region b64m2x3_mt16

public partial struct b64m2x3_mt16 : IComparable<b64m2x3_mt16>, IComparable
    , IComparisonOperators<b64m2x3_mt16, b64m2x3_mt16, bool>
    , IComparisonOperators<b64m2x3_mt16, b64m2x3_mt16, b64m2x3_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b64m2x3_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b64m2x3_mt16)}");
    }

    static bool IComparisonOperators<b64m2x3_mt16, b64m2x3_mt16, bool>.operator <(b64m2x3_mt16 left, b64m2x3_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m2x3_mt16, b64m2x3_mt16, bool>.operator >(b64m2x3_mt16 left, b64m2x3_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m2x3_mt16, b64m2x3_mt16, bool>.operator <=(b64m2x3_mt16 left, b64m2x3_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m2x3_mt16, b64m2x3_mt16, bool>.operator >=(b64m2x3_mt16 left, b64m2x3_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b64m2x3_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m2x3_mt16 operator <(b64m2x3_mt16 left, b64m2x3_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b64m2x3_mt16 operator >(b64m2x3_mt16 left, b64m2x3_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b64m2x3_mt16 operator <=(b64m2x3_mt16 left, b64m2x3_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b64m2x3_mt16 operator >=(b64m2x3_mt16 left, b64m2x3_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b64m2x3_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b64m2x3_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b64m2x3_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b64m2x3_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b64m2x3_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b64m2x3_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b64m2x3_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b64m2x3_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // b64m2x3_mt16

#region b64m2x4_mt4

public partial struct b64m2x4_mt4 : IComparable<b64m2x4_mt4>, IComparable
    , IComparisonOperators<b64m2x4_mt4, b64m2x4_mt4, bool>
    , IComparisonOperators<b64m2x4_mt4, b64m2x4_mt4, b64m2x4_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b64m2x4_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b64m2x4_mt4)}");
    }

    static bool IComparisonOperators<b64m2x4_mt4, b64m2x4_mt4, bool>.operator <(b64m2x4_mt4 left, b64m2x4_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m2x4_mt4, b64m2x4_mt4, bool>.operator >(b64m2x4_mt4 left, b64m2x4_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m2x4_mt4, b64m2x4_mt4, bool>.operator <=(b64m2x4_mt4 left, b64m2x4_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m2x4_mt4, b64m2x4_mt4, bool>.operator >=(b64m2x4_mt4 left, b64m2x4_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b64m2x4_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m2x4_mt4 operator <(b64m2x4_mt4 left, b64m2x4_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b64m2x4_mt4 operator >(b64m2x4_mt4 left, b64m2x4_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b64m2x4_mt4 operator <=(b64m2x4_mt4 left, b64m2x4_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b64m2x4_mt4 operator >=(b64m2x4_mt4 left, b64m2x4_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b64m2x4_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b64m2x4_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b64m2x4_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b64m2x4_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b64m2x4_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b64m2x4_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b64m2x4_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b64m2x4_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // b64m2x4_mt4

#region b64m2x4_mt8

public partial struct b64m2x4_mt8 : IComparable<b64m2x4_mt8>, IComparable
    , IComparisonOperators<b64m2x4_mt8, b64m2x4_mt8, bool>
    , IComparisonOperators<b64m2x4_mt8, b64m2x4_mt8, b64m2x4_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b64m2x4_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b64m2x4_mt8)}");
    }

    static bool IComparisonOperators<b64m2x4_mt8, b64m2x4_mt8, bool>.operator <(b64m2x4_mt8 left, b64m2x4_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m2x4_mt8, b64m2x4_mt8, bool>.operator >(b64m2x4_mt8 left, b64m2x4_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m2x4_mt8, b64m2x4_mt8, bool>.operator <=(b64m2x4_mt8 left, b64m2x4_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m2x4_mt8, b64m2x4_mt8, bool>.operator >=(b64m2x4_mt8 left, b64m2x4_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b64m2x4_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m2x4_mt8 operator <(b64m2x4_mt8 left, b64m2x4_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b64m2x4_mt8 operator >(b64m2x4_mt8 left, b64m2x4_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b64m2x4_mt8 operator <=(b64m2x4_mt8 left, b64m2x4_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b64m2x4_mt8 operator >=(b64m2x4_mt8 left, b64m2x4_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b64m2x4_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b64m2x4_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b64m2x4_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b64m2x4_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b64m2x4_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b64m2x4_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b64m2x4_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b64m2x4_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // b64m2x4_mt8

#region b64m2x4_mt16

public partial struct b64m2x4_mt16 : IComparable<b64m2x4_mt16>, IComparable
    , IComparisonOperators<b64m2x4_mt16, b64m2x4_mt16, bool>
    , IComparisonOperators<b64m2x4_mt16, b64m2x4_mt16, b64m2x4_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b64m2x4_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b64m2x4_mt16)}");
    }

    static bool IComparisonOperators<b64m2x4_mt16, b64m2x4_mt16, bool>.operator <(b64m2x4_mt16 left, b64m2x4_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m2x4_mt16, b64m2x4_mt16, bool>.operator >(b64m2x4_mt16 left, b64m2x4_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m2x4_mt16, b64m2x4_mt16, bool>.operator <=(b64m2x4_mt16 left, b64m2x4_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m2x4_mt16, b64m2x4_mt16, bool>.operator >=(b64m2x4_mt16 left, b64m2x4_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b64m2x4_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m2x4_mt16 operator <(b64m2x4_mt16 left, b64m2x4_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b64m2x4_mt16 operator >(b64m2x4_mt16 left, b64m2x4_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b64m2x4_mt16 operator <=(b64m2x4_mt16 left, b64m2x4_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b64m2x4_mt16 operator >=(b64m2x4_mt16 left, b64m2x4_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b64m2x4_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b64m2x4_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b64m2x4_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b64m2x4_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b64m2x4_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b64m2x4_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b64m2x4_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b64m2x4_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // b64m2x4_mt16

#region b64m3x2_mt4

public partial struct b64m3x2_mt4 : IComparable<b64m3x2_mt4>, IComparable
    , IComparisonOperators<b64m3x2_mt4, b64m3x2_mt4, bool>
    , IComparisonOperators<b64m3x2_mt4, b64m3x2_mt4, b64m3x2_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b64m3x2_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b64m3x2_mt4)}");
    }

    static bool IComparisonOperators<b64m3x2_mt4, b64m3x2_mt4, bool>.operator <(b64m3x2_mt4 left, b64m3x2_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m3x2_mt4, b64m3x2_mt4, bool>.operator >(b64m3x2_mt4 left, b64m3x2_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m3x2_mt4, b64m3x2_mt4, bool>.operator <=(b64m3x2_mt4 left, b64m3x2_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m3x2_mt4, b64m3x2_mt4, bool>.operator >=(b64m3x2_mt4 left, b64m3x2_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b64m3x2_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m3x2_mt4 operator <(b64m3x2_mt4 left, b64m3x2_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b64m3x2_mt4 operator >(b64m3x2_mt4 left, b64m3x2_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b64m3x2_mt4 operator <=(b64m3x2_mt4 left, b64m3x2_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b64m3x2_mt4 operator >=(b64m3x2_mt4 left, b64m3x2_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b64m3x2_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b64m3x2_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b64m3x2_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b64m3x2_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b64m3x2_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b64m3x2_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b64m3x2_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b64m3x2_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // b64m3x2_mt4

#region b64m3x2_mt8

public partial struct b64m3x2_mt8 : IComparable<b64m3x2_mt8>, IComparable
    , IComparisonOperators<b64m3x2_mt8, b64m3x2_mt8, bool>
    , IComparisonOperators<b64m3x2_mt8, b64m3x2_mt8, b64m3x2_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b64m3x2_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b64m3x2_mt8)}");
    }

    static bool IComparisonOperators<b64m3x2_mt8, b64m3x2_mt8, bool>.operator <(b64m3x2_mt8 left, b64m3x2_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m3x2_mt8, b64m3x2_mt8, bool>.operator >(b64m3x2_mt8 left, b64m3x2_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m3x2_mt8, b64m3x2_mt8, bool>.operator <=(b64m3x2_mt8 left, b64m3x2_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m3x2_mt8, b64m3x2_mt8, bool>.operator >=(b64m3x2_mt8 left, b64m3x2_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b64m3x2_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m3x2_mt8 operator <(b64m3x2_mt8 left, b64m3x2_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b64m3x2_mt8 operator >(b64m3x2_mt8 left, b64m3x2_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b64m3x2_mt8 operator <=(b64m3x2_mt8 left, b64m3x2_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b64m3x2_mt8 operator >=(b64m3x2_mt8 left, b64m3x2_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b64m3x2_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b64m3x2_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b64m3x2_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b64m3x2_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b64m3x2_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b64m3x2_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b64m3x2_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b64m3x2_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // b64m3x2_mt8

#region b64m3x2_mt16

public partial struct b64m3x2_mt16 : IComparable<b64m3x2_mt16>, IComparable
    , IComparisonOperators<b64m3x2_mt16, b64m3x2_mt16, bool>
    , IComparisonOperators<b64m3x2_mt16, b64m3x2_mt16, b64m3x2_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b64m3x2_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b64m3x2_mt16)}");
    }

    static bool IComparisonOperators<b64m3x2_mt16, b64m3x2_mt16, bool>.operator <(b64m3x2_mt16 left, b64m3x2_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m3x2_mt16, b64m3x2_mt16, bool>.operator >(b64m3x2_mt16 left, b64m3x2_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m3x2_mt16, b64m3x2_mt16, bool>.operator <=(b64m3x2_mt16 left, b64m3x2_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m3x2_mt16, b64m3x2_mt16, bool>.operator >=(b64m3x2_mt16 left, b64m3x2_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b64m3x2_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m3x2_mt16 operator <(b64m3x2_mt16 left, b64m3x2_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b64m3x2_mt16 operator >(b64m3x2_mt16 left, b64m3x2_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b64m3x2_mt16 operator <=(b64m3x2_mt16 left, b64m3x2_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b64m3x2_mt16 operator >=(b64m3x2_mt16 left, b64m3x2_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b64m3x2_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b64m3x2_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b64m3x2_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b64m3x2_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b64m3x2_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b64m3x2_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b64m3x2_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b64m3x2_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // b64m3x2_mt16

#region b64m3x3_mt4

public partial struct b64m3x3_mt4 : IComparable<b64m3x3_mt4>, IComparable
    , IComparisonOperators<b64m3x3_mt4, b64m3x3_mt4, bool>
    , IComparisonOperators<b64m3x3_mt4, b64m3x3_mt4, b64m3x3_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b64m3x3_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b64m3x3_mt4)}");
    }

    static bool IComparisonOperators<b64m3x3_mt4, b64m3x3_mt4, bool>.operator <(b64m3x3_mt4 left, b64m3x3_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m3x3_mt4, b64m3x3_mt4, bool>.operator >(b64m3x3_mt4 left, b64m3x3_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m3x3_mt4, b64m3x3_mt4, bool>.operator <=(b64m3x3_mt4 left, b64m3x3_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m3x3_mt4, b64m3x3_mt4, bool>.operator >=(b64m3x3_mt4 left, b64m3x3_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b64m3x3_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m3x3_mt4 operator <(b64m3x3_mt4 left, b64m3x3_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b64m3x3_mt4 operator >(b64m3x3_mt4 left, b64m3x3_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b64m3x3_mt4 operator <=(b64m3x3_mt4 left, b64m3x3_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b64m3x3_mt4 operator >=(b64m3x3_mt4 left, b64m3x3_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b64m3x3_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b64m3x3_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b64m3x3_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b64m3x3_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b64m3x3_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b64m3x3_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b64m3x3_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b64m3x3_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // b64m3x3_mt4

#region b64m3x3_mt8

public partial struct b64m3x3_mt8 : IComparable<b64m3x3_mt8>, IComparable
    , IComparisonOperators<b64m3x3_mt8, b64m3x3_mt8, bool>
    , IComparisonOperators<b64m3x3_mt8, b64m3x3_mt8, b64m3x3_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b64m3x3_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b64m3x3_mt8)}");
    }

    static bool IComparisonOperators<b64m3x3_mt8, b64m3x3_mt8, bool>.operator <(b64m3x3_mt8 left, b64m3x3_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m3x3_mt8, b64m3x3_mt8, bool>.operator >(b64m3x3_mt8 left, b64m3x3_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m3x3_mt8, b64m3x3_mt8, bool>.operator <=(b64m3x3_mt8 left, b64m3x3_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m3x3_mt8, b64m3x3_mt8, bool>.operator >=(b64m3x3_mt8 left, b64m3x3_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b64m3x3_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m3x3_mt8 operator <(b64m3x3_mt8 left, b64m3x3_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b64m3x3_mt8 operator >(b64m3x3_mt8 left, b64m3x3_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b64m3x3_mt8 operator <=(b64m3x3_mt8 left, b64m3x3_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b64m3x3_mt8 operator >=(b64m3x3_mt8 left, b64m3x3_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b64m3x3_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b64m3x3_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b64m3x3_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b64m3x3_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b64m3x3_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b64m3x3_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b64m3x3_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b64m3x3_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // b64m3x3_mt8

#region b64m3x3_mt16

public partial struct b64m3x3_mt16 : IComparable<b64m3x3_mt16>, IComparable
    , IComparisonOperators<b64m3x3_mt16, b64m3x3_mt16, bool>
    , IComparisonOperators<b64m3x3_mt16, b64m3x3_mt16, b64m3x3_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b64m3x3_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b64m3x3_mt16)}");
    }

    static bool IComparisonOperators<b64m3x3_mt16, b64m3x3_mt16, bool>.operator <(b64m3x3_mt16 left, b64m3x3_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m3x3_mt16, b64m3x3_mt16, bool>.operator >(b64m3x3_mt16 left, b64m3x3_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m3x3_mt16, b64m3x3_mt16, bool>.operator <=(b64m3x3_mt16 left, b64m3x3_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m3x3_mt16, b64m3x3_mt16, bool>.operator >=(b64m3x3_mt16 left, b64m3x3_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b64m3x3_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m3x3_mt16 operator <(b64m3x3_mt16 left, b64m3x3_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b64m3x3_mt16 operator >(b64m3x3_mt16 left, b64m3x3_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b64m3x3_mt16 operator <=(b64m3x3_mt16 left, b64m3x3_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b64m3x3_mt16 operator >=(b64m3x3_mt16 left, b64m3x3_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b64m3x3_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b64m3x3_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b64m3x3_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b64m3x3_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b64m3x3_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b64m3x3_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b64m3x3_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b64m3x3_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // b64m3x3_mt16

#region b64m3x4_mt4

public partial struct b64m3x4_mt4 : IComparable<b64m3x4_mt4>, IComparable
    , IComparisonOperators<b64m3x4_mt4, b64m3x4_mt4, bool>
    , IComparisonOperators<b64m3x4_mt4, b64m3x4_mt4, b64m3x4_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b64m3x4_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b64m3x4_mt4)}");
    }

    static bool IComparisonOperators<b64m3x4_mt4, b64m3x4_mt4, bool>.operator <(b64m3x4_mt4 left, b64m3x4_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m3x4_mt4, b64m3x4_mt4, bool>.operator >(b64m3x4_mt4 left, b64m3x4_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m3x4_mt4, b64m3x4_mt4, bool>.operator <=(b64m3x4_mt4 left, b64m3x4_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m3x4_mt4, b64m3x4_mt4, bool>.operator >=(b64m3x4_mt4 left, b64m3x4_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b64m3x4_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m3x4_mt4 operator <(b64m3x4_mt4 left, b64m3x4_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b64m3x4_mt4 operator >(b64m3x4_mt4 left, b64m3x4_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b64m3x4_mt4 operator <=(b64m3x4_mt4 left, b64m3x4_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b64m3x4_mt4 operator >=(b64m3x4_mt4 left, b64m3x4_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b64m3x4_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b64m3x4_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b64m3x4_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b64m3x4_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b64m3x4_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b64m3x4_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b64m3x4_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b64m3x4_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // b64m3x4_mt4

#region b64m3x4_mt8

public partial struct b64m3x4_mt8 : IComparable<b64m3x4_mt8>, IComparable
    , IComparisonOperators<b64m3x4_mt8, b64m3x4_mt8, bool>
    , IComparisonOperators<b64m3x4_mt8, b64m3x4_mt8, b64m3x4_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b64m3x4_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b64m3x4_mt8)}");
    }

    static bool IComparisonOperators<b64m3x4_mt8, b64m3x4_mt8, bool>.operator <(b64m3x4_mt8 left, b64m3x4_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m3x4_mt8, b64m3x4_mt8, bool>.operator >(b64m3x4_mt8 left, b64m3x4_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m3x4_mt8, b64m3x4_mt8, bool>.operator <=(b64m3x4_mt8 left, b64m3x4_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m3x4_mt8, b64m3x4_mt8, bool>.operator >=(b64m3x4_mt8 left, b64m3x4_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b64m3x4_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m3x4_mt8 operator <(b64m3x4_mt8 left, b64m3x4_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b64m3x4_mt8 operator >(b64m3x4_mt8 left, b64m3x4_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b64m3x4_mt8 operator <=(b64m3x4_mt8 left, b64m3x4_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b64m3x4_mt8 operator >=(b64m3x4_mt8 left, b64m3x4_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b64m3x4_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b64m3x4_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b64m3x4_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b64m3x4_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b64m3x4_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b64m3x4_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b64m3x4_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b64m3x4_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // b64m3x4_mt8

#region b64m3x4_mt16

public partial struct b64m3x4_mt16 : IComparable<b64m3x4_mt16>, IComparable
    , IComparisonOperators<b64m3x4_mt16, b64m3x4_mt16, bool>
    , IComparisonOperators<b64m3x4_mt16, b64m3x4_mt16, b64m3x4_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b64m3x4_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b64m3x4_mt16)}");
    }

    static bool IComparisonOperators<b64m3x4_mt16, b64m3x4_mt16, bool>.operator <(b64m3x4_mt16 left, b64m3x4_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m3x4_mt16, b64m3x4_mt16, bool>.operator >(b64m3x4_mt16 left, b64m3x4_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m3x4_mt16, b64m3x4_mt16, bool>.operator <=(b64m3x4_mt16 left, b64m3x4_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m3x4_mt16, b64m3x4_mt16, bool>.operator >=(b64m3x4_mt16 left, b64m3x4_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b64m3x4_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m3x4_mt16 operator <(b64m3x4_mt16 left, b64m3x4_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b64m3x4_mt16 operator >(b64m3x4_mt16 left, b64m3x4_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b64m3x4_mt16 operator <=(b64m3x4_mt16 left, b64m3x4_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b64m3x4_mt16 operator >=(b64m3x4_mt16 left, b64m3x4_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b64m3x4_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b64m3x4_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b64m3x4_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b64m3x4_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b64m3x4_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b64m3x4_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b64m3x4_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b64m3x4_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // b64m3x4_mt16

#region b64m4x2_mt4

public partial struct b64m4x2_mt4 : IComparable<b64m4x2_mt4>, IComparable
    , IComparisonOperators<b64m4x2_mt4, b64m4x2_mt4, bool>
    , IComparisonOperators<b64m4x2_mt4, b64m4x2_mt4, b64m4x2_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b64m4x2_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b64m4x2_mt4)}");
    }

    static bool IComparisonOperators<b64m4x2_mt4, b64m4x2_mt4, bool>.operator <(b64m4x2_mt4 left, b64m4x2_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m4x2_mt4, b64m4x2_mt4, bool>.operator >(b64m4x2_mt4 left, b64m4x2_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m4x2_mt4, b64m4x2_mt4, bool>.operator <=(b64m4x2_mt4 left, b64m4x2_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m4x2_mt4, b64m4x2_mt4, bool>.operator >=(b64m4x2_mt4 left, b64m4x2_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b64m4x2_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m4x2_mt4 operator <(b64m4x2_mt4 left, b64m4x2_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b64m4x2_mt4 operator >(b64m4x2_mt4 left, b64m4x2_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b64m4x2_mt4 operator <=(b64m4x2_mt4 left, b64m4x2_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b64m4x2_mt4 operator >=(b64m4x2_mt4 left, b64m4x2_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b64m4x2_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b64m4x2_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b64m4x2_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b64m4x2_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b64m4x2_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b64m4x2_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b64m4x2_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b64m4x2_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // b64m4x2_mt4

#region b64m4x2_mt8

public partial struct b64m4x2_mt8 : IComparable<b64m4x2_mt8>, IComparable
    , IComparisonOperators<b64m4x2_mt8, b64m4x2_mt8, bool>
    , IComparisonOperators<b64m4x2_mt8, b64m4x2_mt8, b64m4x2_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b64m4x2_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b64m4x2_mt8)}");
    }

    static bool IComparisonOperators<b64m4x2_mt8, b64m4x2_mt8, bool>.operator <(b64m4x2_mt8 left, b64m4x2_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m4x2_mt8, b64m4x2_mt8, bool>.operator >(b64m4x2_mt8 left, b64m4x2_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m4x2_mt8, b64m4x2_mt8, bool>.operator <=(b64m4x2_mt8 left, b64m4x2_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m4x2_mt8, b64m4x2_mt8, bool>.operator >=(b64m4x2_mt8 left, b64m4x2_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b64m4x2_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m4x2_mt8 operator <(b64m4x2_mt8 left, b64m4x2_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b64m4x2_mt8 operator >(b64m4x2_mt8 left, b64m4x2_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b64m4x2_mt8 operator <=(b64m4x2_mt8 left, b64m4x2_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b64m4x2_mt8 operator >=(b64m4x2_mt8 left, b64m4x2_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b64m4x2_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b64m4x2_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b64m4x2_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b64m4x2_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b64m4x2_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b64m4x2_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b64m4x2_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b64m4x2_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // b64m4x2_mt8

#region b64m4x2_mt16

public partial struct b64m4x2_mt16 : IComparable<b64m4x2_mt16>, IComparable
    , IComparisonOperators<b64m4x2_mt16, b64m4x2_mt16, bool>
    , IComparisonOperators<b64m4x2_mt16, b64m4x2_mt16, b64m4x2_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b64m4x2_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b64m4x2_mt16)}");
    }

    static bool IComparisonOperators<b64m4x2_mt16, b64m4x2_mt16, bool>.operator <(b64m4x2_mt16 left, b64m4x2_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m4x2_mt16, b64m4x2_mt16, bool>.operator >(b64m4x2_mt16 left, b64m4x2_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m4x2_mt16, b64m4x2_mt16, bool>.operator <=(b64m4x2_mt16 left, b64m4x2_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m4x2_mt16, b64m4x2_mt16, bool>.operator >=(b64m4x2_mt16 left, b64m4x2_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b64m4x2_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m4x2_mt16 operator <(b64m4x2_mt16 left, b64m4x2_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b64m4x2_mt16 operator >(b64m4x2_mt16 left, b64m4x2_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b64m4x2_mt16 operator <=(b64m4x2_mt16 left, b64m4x2_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b64m4x2_mt16 operator >=(b64m4x2_mt16 left, b64m4x2_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b64m4x2_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b64m4x2_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b64m4x2_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b64m4x2_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b64m4x2_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b64m4x2_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b64m4x2_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b64m4x2_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1);
}

#endregion // b64m4x2_mt16

#region b64m4x3_mt4

public partial struct b64m4x3_mt4 : IComparable<b64m4x3_mt4>, IComparable
    , IComparisonOperators<b64m4x3_mt4, b64m4x3_mt4, bool>
    , IComparisonOperators<b64m4x3_mt4, b64m4x3_mt4, b64m4x3_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b64m4x3_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b64m4x3_mt4)}");
    }

    static bool IComparisonOperators<b64m4x3_mt4, b64m4x3_mt4, bool>.operator <(b64m4x3_mt4 left, b64m4x3_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m4x3_mt4, b64m4x3_mt4, bool>.operator >(b64m4x3_mt4 left, b64m4x3_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m4x3_mt4, b64m4x3_mt4, bool>.operator <=(b64m4x3_mt4 left, b64m4x3_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m4x3_mt4, b64m4x3_mt4, bool>.operator >=(b64m4x3_mt4 left, b64m4x3_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b64m4x3_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m4x3_mt4 operator <(b64m4x3_mt4 left, b64m4x3_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b64m4x3_mt4 operator >(b64m4x3_mt4 left, b64m4x3_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b64m4x3_mt4 operator <=(b64m4x3_mt4 left, b64m4x3_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b64m4x3_mt4 operator >=(b64m4x3_mt4 left, b64m4x3_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b64m4x3_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b64m4x3_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b64m4x3_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b64m4x3_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b64m4x3_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b64m4x3_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b64m4x3_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b64m4x3_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // b64m4x3_mt4

#region b64m4x3_mt8

public partial struct b64m4x3_mt8 : IComparable<b64m4x3_mt8>, IComparable
    , IComparisonOperators<b64m4x3_mt8, b64m4x3_mt8, bool>
    , IComparisonOperators<b64m4x3_mt8, b64m4x3_mt8, b64m4x3_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b64m4x3_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b64m4x3_mt8)}");
    }

    static bool IComparisonOperators<b64m4x3_mt8, b64m4x3_mt8, bool>.operator <(b64m4x3_mt8 left, b64m4x3_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m4x3_mt8, b64m4x3_mt8, bool>.operator >(b64m4x3_mt8 left, b64m4x3_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m4x3_mt8, b64m4x3_mt8, bool>.operator <=(b64m4x3_mt8 left, b64m4x3_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m4x3_mt8, b64m4x3_mt8, bool>.operator >=(b64m4x3_mt8 left, b64m4x3_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b64m4x3_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m4x3_mt8 operator <(b64m4x3_mt8 left, b64m4x3_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b64m4x3_mt8 operator >(b64m4x3_mt8 left, b64m4x3_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b64m4x3_mt8 operator <=(b64m4x3_mt8 left, b64m4x3_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b64m4x3_mt8 operator >=(b64m4x3_mt8 left, b64m4x3_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b64m4x3_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b64m4x3_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b64m4x3_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b64m4x3_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b64m4x3_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b64m4x3_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b64m4x3_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b64m4x3_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // b64m4x3_mt8

#region b64m4x3_mt16

public partial struct b64m4x3_mt16 : IComparable<b64m4x3_mt16>, IComparable
    , IComparisonOperators<b64m4x3_mt16, b64m4x3_mt16, bool>
    , IComparisonOperators<b64m4x3_mt16, b64m4x3_mt16, b64m4x3_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b64m4x3_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b64m4x3_mt16)}");
    }

    static bool IComparisonOperators<b64m4x3_mt16, b64m4x3_mt16, bool>.operator <(b64m4x3_mt16 left, b64m4x3_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m4x3_mt16, b64m4x3_mt16, bool>.operator >(b64m4x3_mt16 left, b64m4x3_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m4x3_mt16, b64m4x3_mt16, bool>.operator <=(b64m4x3_mt16 left, b64m4x3_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m4x3_mt16, b64m4x3_mt16, bool>.operator >=(b64m4x3_mt16 left, b64m4x3_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b64m4x3_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m4x3_mt16 operator <(b64m4x3_mt16 left, b64m4x3_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b64m4x3_mt16 operator >(b64m4x3_mt16 left, b64m4x3_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b64m4x3_mt16 operator <=(b64m4x3_mt16 left, b64m4x3_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b64m4x3_mt16 operator >=(b64m4x3_mt16 left, b64m4x3_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b64m4x3_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b64m4x3_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b64m4x3_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b64m4x3_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b64m4x3_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b64m4x3_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b64m4x3_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b64m4x3_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2);
}

#endregion // b64m4x3_mt16

#region b64m4x4_mt4

public partial struct b64m4x4_mt4 : IComparable<b64m4x4_mt4>, IComparable
    , IComparisonOperators<b64m4x4_mt4, b64m4x4_mt4, bool>
    , IComparisonOperators<b64m4x4_mt4, b64m4x4_mt4, b64m4x4_mt4>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b64m4x4_mt4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b64m4x4_mt4)}");
    }

    static bool IComparisonOperators<b64m4x4_mt4, b64m4x4_mt4, bool>.operator <(b64m4x4_mt4 left, b64m4x4_mt4 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m4x4_mt4, b64m4x4_mt4, bool>.operator >(b64m4x4_mt4 left, b64m4x4_mt4 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m4x4_mt4, b64m4x4_mt4, bool>.operator <=(b64m4x4_mt4 left, b64m4x4_mt4 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m4x4_mt4, b64m4x4_mt4, bool>.operator >=(b64m4x4_mt4 left, b64m4x4_mt4 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b64m4x4_mt4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m4x4_mt4 operator <(b64m4x4_mt4 left, b64m4x4_mt4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b64m4x4_mt4 operator >(b64m4x4_mt4 left, b64m4x4_mt4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b64m4x4_mt4 operator <=(b64m4x4_mt4 left, b64m4x4_mt4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b64m4x4_mt4 operator >=(b64m4x4_mt4 left, b64m4x4_mt4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b64m4x4_mt4 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b64m4x4_mt4 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b64m4x4_mt4 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b64m4x4_mt4 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b64m4x4_mt4 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b64m4x4_mt4 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b64m4x4_mt4 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b64m4x4_mt4 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // b64m4x4_mt4

#region b64m4x4_mt8

public partial struct b64m4x4_mt8 : IComparable<b64m4x4_mt8>, IComparable
    , IComparisonOperators<b64m4x4_mt8, b64m4x4_mt8, bool>
    , IComparisonOperators<b64m4x4_mt8, b64m4x4_mt8, b64m4x4_mt8>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b64m4x4_mt8 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b64m4x4_mt8)}");
    }

    static bool IComparisonOperators<b64m4x4_mt8, b64m4x4_mt8, bool>.operator <(b64m4x4_mt8 left, b64m4x4_mt8 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m4x4_mt8, b64m4x4_mt8, bool>.operator >(b64m4x4_mt8 left, b64m4x4_mt8 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m4x4_mt8, b64m4x4_mt8, bool>.operator <=(b64m4x4_mt8 left, b64m4x4_mt8 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m4x4_mt8, b64m4x4_mt8, bool>.operator >=(b64m4x4_mt8 left, b64m4x4_mt8 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b64m4x4_mt8 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m4x4_mt8 operator <(b64m4x4_mt8 left, b64m4x4_mt8 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b64m4x4_mt8 operator >(b64m4x4_mt8 left, b64m4x4_mt8 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b64m4x4_mt8 operator <=(b64m4x4_mt8 left, b64m4x4_mt8 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b64m4x4_mt8 operator >=(b64m4x4_mt8 left, b64m4x4_mt8 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b64m4x4_mt8 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b64m4x4_mt8 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b64m4x4_mt8 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b64m4x4_mt8 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b64m4x4_mt8 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b64m4x4_mt8 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b64m4x4_mt8 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b64m4x4_mt8 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // b64m4x4_mt8

#region b64m4x4_mt16

public partial struct b64m4x4_mt16 : IComparable<b64m4x4_mt16>, IComparable
    , IComparisonOperators<b64m4x4_mt16, b64m4x4_mt16, bool>
    , IComparisonOperators<b64m4x4_mt16, b64m4x4_mt16, b64m4x4_mt16>
{
    [MethodImpl(256 | 512)]
    public readonly int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b64m4x4_mt16 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b64m4x4_mt16)}");
    }

    static bool IComparisonOperators<b64m4x4_mt16, b64m4x4_mt16, bool>.operator <(b64m4x4_mt16 left, b64m4x4_mt16 right) => 
        left.LaneLessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m4x4_mt16, b64m4x4_mt16, bool>.operator >(b64m4x4_mt16 left, b64m4x4_mt16 right) => 
        left.LaneGreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m4x4_mt16, b64m4x4_mt16, bool>.operator <=(b64m4x4_mt16 left, b64m4x4_mt16 right) => 
        left.LaneLessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m4x4_mt16, b64m4x4_mt16, bool>.operator >=(b64m4x4_mt16 left, b64m4x4_mt16 right) => 
        left.LaneGreaterThanOrEqualAll(right);

    [MethodImpl(256 | 512)]
    public readonly int CompareTo(b64m4x4_mt16 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m4x4_mt16 operator <(b64m4x4_mt16 left, b64m4x4_mt16 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b64m4x4_mt16 operator >(b64m4x4_mt16 left, b64m4x4_mt16 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b64m4x4_mt16 operator <=(b64m4x4_mt16 left, b64m4x4_mt16 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b64m4x4_mt16 operator >=(b64m4x4_mt16 left, b64m4x4_mt16 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAll(b64m4x4_mt16 other) => c0.LaneLessThanAll(other.c0) && c1.LaneLessThanAll(other.c1) && c2.LaneLessThanAll(other.c2) && c3.LaneLessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAll(b64m4x4_mt16 other) => c0.LaneGreaterThanAll(other.c0) && c1.LaneGreaterThanAll(other.c1) && c2.LaneGreaterThanAll(other.c2) && c3.LaneGreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAll(b64m4x4_mt16 other) => c0.LaneLessThanOrEqualAll(other.c0) && c1.LaneLessThanOrEqualAll(other.c1) && c2.LaneLessThanOrEqualAll(other.c2) && c3.LaneLessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAll(b64m4x4_mt16 other) => c0.LaneGreaterThanOrEqualAll(other.c0) && c1.LaneGreaterThanOrEqualAll(other.c1) && c2.LaneGreaterThanOrEqualAll(other.c2) && c3.LaneGreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanAny(b64m4x4_mt16 other) => c0.LaneLessThanAny(other.c0) || c1.LaneLessThanAny(other.c1) || c2.LaneLessThanAny(other.c2) || c3.LaneLessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanAny(b64m4x4_mt16 other) => c0.LaneGreaterThanAny(other.c0) || c1.LaneGreaterThanAny(other.c1) || c2.LaneGreaterThanAny(other.c2) || c3.LaneGreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneLessThanOrEqualAny(b64m4x4_mt16 other) => c0.LaneLessThanOrEqualAny(other.c0) || c1.LaneLessThanOrEqualAny(other.c1) || c2.LaneLessThanOrEqualAny(other.c2) || c3.LaneLessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public readonly bool LaneGreaterThanOrEqualAny(b64m4x4_mt16 other) => c0.LaneGreaterThanOrEqualAny(other.c0) || c1.LaneGreaterThanOrEqualAny(other.c1) || c2.LaneGreaterThanOrEqualAny(other.c2) || c3.LaneGreaterThanOrEqualAny(other.c3);
}

#endregion // b64m4x4_mt16
