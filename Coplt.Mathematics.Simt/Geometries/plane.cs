// generated by template, do not modify manually
using Coplt.Mathematics.Simt.Geometries;


#region plane_mt

namespace Coplt.Mathematics.Simt.Geometries
{

    /// <summary>
    /// A plane represented by a normal vector and a distance along the normal from the origin.
    /// </summary>
    /// <remarks>
    /// A plane splits the 3D space in half.  The normal vector points to the positive half and the other half is considered negative.
    /// </remarks>
    [CpuOnly]
    public partial struct plane_mt
    {
        /// <summary>
        /// A plane in the form Ax + By + Cz + Dw = 0.
        /// </summary>
        /// <remarks>
        /// Stores the plane coefficients A, B, C, D where (A, B, C) is a unit normal vector and D is the distance from the origin.
        /// A plane stored with a unit normal vector is called a normalized plane.
        /// </remarks>
        public float4_mt normal_and_distance;

        /// <summary>
        /// Get/set the normal vector of the plane.
        /// </summary>
        /// <remarks>
        /// It is assumed that the normal is unit length.  If you set a new plane such that Ax + By + Cz + Dw = 0 but
        /// (A, B, C) is not unit length, then you must normalize the plane by calling <see cref="math_mt.normalize(plane_mt)"/>.
        /// </remarks>
        public float3_mt normal
        {
            [MethodImpl(256 | 512)]
            readonly get => normal_and_distance.xyz;
            [MethodImpl(256 | 512)]
            set => normal_and_distance.xyz = value;
        }

        /// <summary>
        /// Get/set the distance of the plane from the origin.  May be a negative value.
        /// </summary>
        /// <remarks>
        /// It is assumed that the normal is unit length.  If you set a new plane such that Ax + By + Cz + Dw = 0 but
        /// (A, B, C) is not unit length, then you must normalize the plane by calling <see cref="math_mt.normalize(plane_mt)"/>.
        /// </remarks>
        public float_mt distance
        {
            [MethodImpl(256 | 512)]
            readonly get => normal_and_distance.w;
            [MethodImpl(256 | 512)]
            set => normal_and_distance.w = value;
        }

        /// <summary>
        /// Flips the plane so the normal points in the opposite direction.
        /// </summary>
        public readonly plane_mt flipped
        {
            [MethodImpl(256 | 512)]
            get => new() { normal_and_distance = -normal_and_distance };
        }

        /// <summary>
        /// A plane represented by a normal vector and a distance along the normal from the origin.
        /// </summary>
        /// <remarks>
        /// A plane splits the 3D space in half.  The normal vector points to the positive half and the other half is considered negative.
        /// </remarks>
        [MethodImpl(256 | 512)]
        public plane_mt(float4_mt normal_and_distance) =>
            this.normal_and_distance = normal_and_distance;

        /// <summary>
        /// Constructs a Plane from arbitrary coefficients A, B, C, D of the plane equation Ax + By + Cz + Dw = 0.
        /// </summary>
        /// <remarks>
        /// The constructed plane will be the normalized form of the plane specified by the given coefficients.
        /// </remarks>
        /// <param name="coefficientA">Coefficient A from plane equation.</param>
        /// <param name="coefficientB">Coefficient B from plane equation.</param>
        /// <param name="coefficientC">Coefficient C from plane equation.</param>
        /// <param name="coefficientD">Coefficient D from plane equation.</param>
        [MethodImpl(256 | 512)]
        public plane_mt(float_mt coefficientA, float_mt coefficientB, float_mt coefficientC, float_mt coefficientD) =>
            normal_and_distance = normalize(new float4_mt(coefficientA, coefficientB, coefficientC, coefficientD));

        /// <summary>
        /// Constructs a plane with a normal vector and distance from the origin.
        /// </summary>
        /// <remarks>
        /// The constructed plane will be the normalized form of the plane specified by the inputs.
        /// </remarks>
        /// <param name="normal">A non-zero vector that is perpendicular to the plane.  It may be any length.</param>
        /// <param name="distance">
        /// Distance from the origin along the normal.
        /// A negative value moves the plane in the same direction as the normal while a positive value moves it in the opposite direction.
        /// </param>
        [MethodImpl(256 | 512)]
        public plane_mt(float3_mt normal, float_mt distance) =>
            normal_and_distance = normalize(new float4_mt(normal, distance));

        /// <summary>
        /// Constructs a plane with a normal vector and a point that lies in the plane.
        /// </summary>
        /// <remarks>
        /// The constructed plane will be the normalized form of the plane specified by the inputs.
        /// </remarks>
        /// <param name="normal">A non-zero vector that is perpendicular to the plane.  It may be any length.</param>
        /// <param name="pointInPlane">A point that lies in the plane.</param>
        [MethodImpl(256 | 512)]
        public plane_mt(float3_mt normal, float3_mt pointInPlane) : this(normal, -normal.dot(pointInPlane)) { }

        /// <summary>
        /// Constructs a plane with two vectors and a point that all lie in the plane.
        /// </summary>
        /// <remarks>
        /// The constructed plane will be the normalized form of the plane specified by the inputs.
        /// </remarks>
        /// <param name="vector1InPlane">A non-zero vector that lies in the plane.  It may be any length.</param>
        /// <param name="vector2InPlane">A non-zero vector that lies in the plane.  It may be any length and must not be a scalar multiple of <paramref name="vector1InPlane"/>.</param>
        /// <param name="pointInPlane">A point that lies in the plane.</param>
        [MethodImpl(256 | 512)]
        public plane_mt(float3_mt vector1InPlane, float3_mt vector2InPlane, float3_mt pointInPlane)
            : this(vector1InPlane.cross(vector2InPlane), pointInPlane) { }

        /// <summary>
        /// Creates a normalized Plane directly without normalization cost.
        /// </summary>
        /// <remarks>
        /// If you have a unit length normal vector, you can create a Plane faster than using one of its constructors
        /// by calling this function.
        /// </remarks>
        /// <param name="unitNormal">A non-zero vector that is perpendicular to the plane.  It must be unit length.</param>
        /// <param name="distance">Distance from the origin along the normal.  A negative value moves the plane in the
        /// same direction as the normal while a positive value moves it in the opposite direction.</param>
        /// <returns>Normalized Plane constructed from given inputs.</returns>
        [MethodImpl(256 | 512)]
        public static plane_mt CreateFromUnitNormalAndDistance(float3_mt unitNormal, float_mt distance) =>
            new() { normal_and_distance = new float4_mt(unitNormal, distance) };

        /// <summary>
        /// Creates a normalized Plane without normalization cost.
        /// </summary>
        /// <remarks>
        /// If you have a unit length normal vector, you can create a Plane faster than using one of its constructors
        /// by calling this function.
        /// </remarks>
        /// <param name="unitNormal">A non-zero vector that is perpendicular to the plane.  It must be unit length.</param>
        /// <param name="pointInPlane">A point that lies in the plane.</param>
        /// <returns>Normalized Plane constructed from given inputs.</returns>
        [MethodImpl(256 | 512)]
        public static plane_mt CreateFromUnitNormalAndPointInPlane(float3_mt unitNormal, float3_mt pointInPlane) =>
            new() { normal_and_distance = new float4_mt(unitNormal, -unitNormal.dot(pointInPlane)) };

        /// <summary>
        /// Normalizes the plane represented by the given plane coefficients.
        /// </summary>
        /// <remarks>
        /// The plane coefficients are A, B, C, D and stored in that order in the <see cref="float4"/>.
        /// </remarks>
        /// <param name="planeCoefficients">Plane coefficients A, B, C, D stored in x, y, z, w (respectively).</param>
        /// <returns>Normalized plane coefficients.</returns>
        [MethodImpl(256 | 512)]
        public static float4_mt normalize(float4_mt planeCoefficients)
        {
            var recipLength = planeCoefficients.xyz.lengthsq().rsqrt();
            return planeCoefficients * recipLength;
        }

        /// <summary>
        /// Implicitly converts a <see cref="plane"/> to <see cref="float4"/>.
        /// </summary>
        /// <param name="plane">Plane to convert.</param>
        /// <returns>A <see cref="float4"/> representing the plane.</returns>
        [MethodImpl(256 | 512)]
        public static implicit operator float4_mt(plane_mt plane) => plane.normal_and_distance;

        /// <summary>
        /// Get the signed distance from the point to the plane.
        /// </summary>
        /// <remarks>
        /// Plane must be normalized prior to calling this function.  Distance is positive if point is on side of the plane the normal points to,
        /// negative if on the opposite side and zero if the point lies in the plane.
        /// Avoid comparing equality with 0.0f when testing if a point lies exactly in the plane and use an approximate comparison instead.
        /// </remarks>
        /// <param name="point">Point to find the signed distance with.</param>
        /// <returns>Signed distance of the point from the plane.</returns>
        [MethodImpl(256 | 512)]
        public readonly float_mt distance_to_point(float3_mt point) => normal_and_distance.dot(new float4_mt(point, 1.0f));

        /// <summary>
        /// Projects the given point onto the plane.
        /// </summary>
        /// <remarks>
        /// Plane must be normalized prior to calling this function.  The result is the position closest to the point
        /// that still lies in the plane.
        /// </remarks>
        /// <param name="point">Point to project onto the plane.</param>
        /// <returns>Projected point that's inside the plane.</returns>
        [MethodImpl(256 | 512)]
        public readonly float3_mt projection(float3_mt point) => point - normal * distance_to_point(point);

        /// <summary>
        /// Ray cast to the plane
        /// </summary>
        /// <param name="ray">The ray</param>
        /// <param name="distance">Intersection distance</param>
        /// <returns>Is intersect</returns>
        [MethodImpl(256 | 512)]
        public readonly b32_mt ray_cast(ray_mt ray, out float_mt distance)
        {
            var normal = this.normal;
            var de_nom = normal.dot(ray.direction);
            distance = (this.distance - normal.dot(ray.origin)) / de_nom;
            return de_nom.abs() > 0.0001f & distance >= 0.0f;
        }

        /// <summary>
        /// Ray cast to the plane
        /// </summary>
        /// <param name="ray">The ray</param>
        /// <param name="distance">Intersection distance</param>
        /// <param name="point">Intersection</param>
        /// <returns>Is intersect</returns>
        [MethodImpl(256 | 512)]
        public readonly b32_mt ray_cast(ray_mt ray, out float_mt distance, out float3_mt point)
        {
            var normal = this.normal;
            var de_nom = normal.dot(ray.direction);
            distance = (this.distance - normal.dot(ray.origin)) / de_nom;
            var intersects = de_nom.abs() > 0.0001f & distance >= 0.0f;
            point = ray.point_at(distance) * math_mt.select(intersects, float3_mt.One, default);
            return intersects;
        }

        /// <summary>
        /// For a given point returns the closest point on the plane.
        /// </summary>
        /// <param name="point">The point to project onto the plane.</param>
        /// <returns>A point on the plane that is closest to point.</returns>
        [MethodImpl(256 | 512)]
        public readonly float3_mt closest_point(float3_mt point)
        {
            var normal = this.normal;
            return point - normal * (normal.dot(point) + distance);
        }

        #region Misc

        #region Eq

        [MethodImpl(256 | 512)]
        public readonly override bool Equals(object? obj) => obj is plane_mt other && Equals(other);

        public readonly bool Equals(plane_mt other) => normal_and_distance.Equals(other.normal_and_distance);

        public readonly bool NotEquals(plane_mt other) => normal_and_distance.NotEquals(other.normal_and_distance);

        public readonly override int GetHashCode() => normal_and_distance.GetHashCode();

        public static b32_mt operator ==(plane_mt left, plane_mt right) => math_mt.all(left.normal_and_distance == right.normal_and_distance);

        public static b32_mt operator !=(plane_mt left, plane_mt right) => math_mt.any(left.normal_and_distance != right.normal_and_distance);

        #endregion

        public readonly override string ToString() => $"plane_mt {{ normal = {normal}, distance = {distance} }}";

        #endregion
    }

} // namespace Coplt.Mathematics.Simt.Geometries

namespace Coplt.Mathematics.Simt
{
    [Ex]
    public static partial class math_mt
    {
        /// <summary>
        /// Normalizes the plane represented by the given plane coefficients.
        /// </summary>
        public static plane_mt normalize([This] plane_mt plane) => new(plane_mt.normalize(plane.normal_and_distance));
    }
}

#endregion // plane_mt

#region plane_d_mt

namespace Coplt.Mathematics.Simt.Geometries
{

    /// <summary>
    /// A plane represented by a normal vector and a distance along the normal from the origin.
    /// </summary>
    /// <remarks>
    /// A plane splits the 3D space in half.  The normal vector points to the positive half and the other half is considered negative.
    /// </remarks>
    [CpuOnly]
    public partial struct plane_d_mt
    {
        /// <summary>
        /// A plane in the form Ax + By + Cz + Dw = 0.
        /// </summary>
        /// <remarks>
        /// Stores the plane coefficients A, B, C, D where (A, B, C) is a unit normal vector and D is the distance from the origin.
        /// A plane stored with a unit normal vector is called a normalized plane.
        /// </remarks>
        public double4_mt normal_and_distance;

        /// <summary>
        /// Get/set the normal vector of the plane.
        /// </summary>
        /// <remarks>
        /// It is assumed that the normal is unit length.  If you set a new plane such that Ax + By + Cz + Dw = 0 but
        /// (A, B, C) is not unit length, then you must normalize the plane by calling <see cref="math_mt.normalize(plane_d_mt)"/>.
        /// </remarks>
        public double3_mt normal
        {
            [MethodImpl(256 | 512)]
            readonly get => normal_and_distance.xyz;
            [MethodImpl(256 | 512)]
            set => normal_and_distance.xyz = value;
        }

        /// <summary>
        /// Get/set the distance of the plane from the origin.  May be a negative value.
        /// </summary>
        /// <remarks>
        /// It is assumed that the normal is unit length.  If you set a new plane such that Ax + By + Cz + Dw = 0 but
        /// (A, B, C) is not unit length, then you must normalize the plane by calling <see cref="math_mt.normalize(plane_d_mt)"/>.
        /// </remarks>
        public double_mt distance
        {
            [MethodImpl(256 | 512)]
            readonly get => normal_and_distance.w;
            [MethodImpl(256 | 512)]
            set => normal_and_distance.w = value;
        }

        /// <summary>
        /// Flips the plane so the normal points in the opposite direction.
        /// </summary>
        public readonly plane_d_mt flipped
        {
            [MethodImpl(256 | 512)]
            get => new() { normal_and_distance = -normal_and_distance };
        }

        /// <summary>
        /// A plane represented by a normal vector and a distance along the normal from the origin.
        /// </summary>
        /// <remarks>
        /// A plane splits the 3D space in half.  The normal vector points to the positive half and the other half is considered negative.
        /// </remarks>
        [MethodImpl(256 | 512)]
        public plane_d_mt(double4_mt normal_and_distance) =>
            this.normal_and_distance = normal_and_distance;

        /// <summary>
        /// Constructs a Plane from arbitrary coefficients A, B, C, D of the plane equation Ax + By + Cz + Dw = 0.
        /// </summary>
        /// <remarks>
        /// The constructed plane will be the normalized form of the plane specified by the given coefficients.
        /// </remarks>
        /// <param name="coefficientA">Coefficient A from plane equation.</param>
        /// <param name="coefficientB">Coefficient B from plane equation.</param>
        /// <param name="coefficientC">Coefficient C from plane equation.</param>
        /// <param name="coefficientD">Coefficient D from plane equation.</param>
        [MethodImpl(256 | 512)]
        public plane_d_mt(double_mt coefficientA, double_mt coefficientB, double_mt coefficientC, double_mt coefficientD) =>
            normal_and_distance = normalize(new double4_mt(coefficientA, coefficientB, coefficientC, coefficientD));

        /// <summary>
        /// Constructs a plane with a normal vector and distance from the origin.
        /// </summary>
        /// <remarks>
        /// The constructed plane will be the normalized form of the plane specified by the inputs.
        /// </remarks>
        /// <param name="normal">A non-zero vector that is perpendicular to the plane.  It may be any length.</param>
        /// <param name="distance">
        /// Distance from the origin along the normal.
        /// A negative value moves the plane in the same direction as the normal while a positive value moves it in the opposite direction.
        /// </param>
        [MethodImpl(256 | 512)]
        public plane_d_mt(double3_mt normal, double_mt distance) =>
            normal_and_distance = normalize(new double4_mt(normal, distance));

        /// <summary>
        /// Constructs a plane with a normal vector and a point that lies in the plane.
        /// </summary>
        /// <remarks>
        /// The constructed plane will be the normalized form of the plane specified by the inputs.
        /// </remarks>
        /// <param name="normal">A non-zero vector that is perpendicular to the plane.  It may be any length.</param>
        /// <param name="pointInPlane">A point that lies in the plane.</param>
        [MethodImpl(256 | 512)]
        public plane_d_mt(double3_mt normal, double3_mt pointInPlane) : this(normal, -normal.dot(pointInPlane)) { }

        /// <summary>
        /// Constructs a plane with two vectors and a point that all lie in the plane.
        /// </summary>
        /// <remarks>
        /// The constructed plane will be the normalized form of the plane specified by the inputs.
        /// </remarks>
        /// <param name="vector1InPlane">A non-zero vector that lies in the plane.  It may be any length.</param>
        /// <param name="vector2InPlane">A non-zero vector that lies in the plane.  It may be any length and must not be a scalar multiple of <paramref name="vector1InPlane"/>.</param>
        /// <param name="pointInPlane">A point that lies in the plane.</param>
        [MethodImpl(256 | 512)]
        public plane_d_mt(double3_mt vector1InPlane, double3_mt vector2InPlane, double3_mt pointInPlane)
            : this(vector1InPlane.cross(vector2InPlane), pointInPlane) { }

        /// <summary>
        /// Creates a normalized Plane directly without normalization cost.
        /// </summary>
        /// <remarks>
        /// If you have a unit length normal vector, you can create a Plane faster than using one of its constructors
        /// by calling this function.
        /// </remarks>
        /// <param name="unitNormal">A non-zero vector that is perpendicular to the plane.  It must be unit length.</param>
        /// <param name="distance">Distance from the origin along the normal.  A negative value moves the plane in the
        /// same direction as the normal while a positive value moves it in the opposite direction.</param>
        /// <returns>Normalized Plane constructed from given inputs.</returns>
        [MethodImpl(256 | 512)]
        public static plane_d_mt CreateFromUnitNormalAndDistance(double3_mt unitNormal, double_mt distance) =>
            new() { normal_and_distance = new double4_mt(unitNormal, distance) };

        /// <summary>
        /// Creates a normalized Plane without normalization cost.
        /// </summary>
        /// <remarks>
        /// If you have a unit length normal vector, you can create a Plane faster than using one of its constructors
        /// by calling this function.
        /// </remarks>
        /// <param name="unitNormal">A non-zero vector that is perpendicular to the plane.  It must be unit length.</param>
        /// <param name="pointInPlane">A point that lies in the plane.</param>
        /// <returns>Normalized Plane constructed from given inputs.</returns>
        [MethodImpl(256 | 512)]
        public static plane_d_mt CreateFromUnitNormalAndPointInPlane(double3_mt unitNormal, double3_mt pointInPlane) =>
            new() { normal_and_distance = new double4_mt(unitNormal, -unitNormal.dot(pointInPlane)) };

        /// <summary>
        /// Normalizes the plane represented by the given plane coefficients.
        /// </summary>
        /// <remarks>
        /// The plane coefficients are A, B, C, D and stored in that order in the <see cref="float4"/>.
        /// </remarks>
        /// <param name="planeCoefficients">Plane coefficients A, B, C, D stored in x, y, z, w (respectively).</param>
        /// <returns>Normalized plane coefficients.</returns>
        [MethodImpl(256 | 512)]
        public static double4_mt normalize(double4_mt planeCoefficients)
        {
            var recipLength = planeCoefficients.xyz.lengthsq().rsqrt();
            return planeCoefficients * recipLength;
        }

        /// <summary>
        /// Implicitly converts a <see cref="plane"/> to <see cref="float4"/>.
        /// </summary>
        /// <param name="plane">Plane to convert.</param>
        /// <returns>A <see cref="float4"/> representing the plane.</returns>
        [MethodImpl(256 | 512)]
        public static implicit operator double4_mt(plane_d_mt plane) => plane.normal_and_distance;

        /// <summary>
        /// Get the signed distance from the point to the plane.
        /// </summary>
        /// <remarks>
        /// Plane must be normalized prior to calling this function.  Distance is positive if point is on side of the plane the normal points to,
        /// negative if on the opposite side and zero if the point lies in the plane.
        /// Avoid comparing equality with 0.0f when testing if a point lies exactly in the plane and use an approximate comparison instead.
        /// </remarks>
        /// <param name="point">Point to find the signed distance with.</param>
        /// <returns>Signed distance of the point from the plane.</returns>
        [MethodImpl(256 | 512)]
        public readonly double_mt distance_to_point(double3_mt point) => normal_and_distance.dot(new double4_mt(point, 1.0f));

        /// <summary>
        /// Projects the given point onto the plane.
        /// </summary>
        /// <remarks>
        /// Plane must be normalized prior to calling this function.  The result is the position closest to the point
        /// that still lies in the plane.
        /// </remarks>
        /// <param name="point">Point to project onto the plane.</param>
        /// <returns>Projected point that's inside the plane.</returns>
        [MethodImpl(256 | 512)]
        public readonly double3_mt projection(double3_mt point) => point - normal * distance_to_point(point);

        /// <summary>
        /// Ray cast to the plane
        /// </summary>
        /// <param name="ray">The ray</param>
        /// <param name="distance">Intersection distance</param>
        /// <returns>Is intersect</returns>
        [MethodImpl(256 | 512)]
        public readonly b64_mt ray_cast(ray_d_mt ray, out double_mt distance)
        {
            var normal = this.normal;
            var de_nom = normal.dot(ray.direction);
            distance = (this.distance - normal.dot(ray.origin)) / de_nom;
            return de_nom.abs() > 0.0001f & distance >= 0.0f;
        }

        /// <summary>
        /// Ray cast to the plane
        /// </summary>
        /// <param name="ray">The ray</param>
        /// <param name="distance">Intersection distance</param>
        /// <param name="point">Intersection</param>
        /// <returns>Is intersect</returns>
        [MethodImpl(256 | 512)]
        public readonly b64_mt ray_cast(ray_d_mt ray, out double_mt distance, out double3_mt point)
        {
            var normal = this.normal;
            var de_nom = normal.dot(ray.direction);
            distance = (this.distance - normal.dot(ray.origin)) / de_nom;
            var intersects = de_nom.abs() > 0.0001f & distance >= 0.0f;
            point = ray.point_at(distance) * math_mt.select(intersects, double3_mt.One, default);
            return intersects;
        }

        /// <summary>
        /// For a given point returns the closest point on the plane.
        /// </summary>
        /// <param name="point">The point to project onto the plane.</param>
        /// <returns>A point on the plane that is closest to point.</returns>
        [MethodImpl(256 | 512)]
        public readonly double3_mt closest_point(double3_mt point)
        {
            var normal = this.normal;
            return point - normal * (normal.dot(point) + distance);
        }

        #region Misc

        #region Eq

        [MethodImpl(256 | 512)]
        public readonly override bool Equals(object? obj) => obj is plane_d_mt other && Equals(other);

        public readonly bool Equals(plane_d_mt other) => normal_and_distance.Equals(other.normal_and_distance);

        public readonly bool NotEquals(plane_d_mt other) => normal_and_distance.NotEquals(other.normal_and_distance);

        public readonly override int GetHashCode() => normal_and_distance.GetHashCode();

        public static b64_mt operator ==(plane_d_mt left, plane_d_mt right) => math_mt.all(left.normal_and_distance == right.normal_and_distance);

        public static b64_mt operator !=(plane_d_mt left, plane_d_mt right) => math_mt.any(left.normal_and_distance != right.normal_and_distance);

        #endregion

        public readonly override string ToString() => $"plane_d_mt {{ normal = {normal}, distance = {distance} }}";

        #endregion
    }

} // namespace Coplt.Mathematics.Simt.Geometries

namespace Coplt.Mathematics.Simt
{
    [Ex]
    public static partial class math_mt
    {
        /// <summary>
        /// Normalizes the plane represented by the given plane coefficients.
        /// </summary>
        public static plane_d_mt normalize([This] plane_d_mt plane) => new(plane_d_mt.normalize(plane.normal_and_distance));
    }
}

#endregion // plane_d_mt
