<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="../../Coplt.Mathematics/types.ttinclude" #><#@ import namespace="System.Linq" #>// generated by template, do not modify manually

namespace Coplt.Mathematics.Simt;
<#
    var sizes = new[] { 4, 8, 16 };
    foreach (var typ in Typ.Typs)
    {
        if (!typ.simd) continue;
        if (typ.size < 4) continue;
        if (!typ.f || !typ.bin) continue;

        foreach (var size in sizes)
        {
            var typeBitSize = typ.size * 8;

            var scalarName = $"{typ.compType}_mt{size}";
            var maskName = $"{typ.maskType}_mt{size}";
            var mask4Name = $"{typ.maskType}4_mt{size}";
            var sigMaskName = $"{typ.sigMaskType}_mt{size}";
            var sigMask4Name = $"{typ.sigMaskType}4_mt{size}";
            var vecTypeName = $"{typ.name}{4}_mt{size}";
            var vecTypeName3 = $"{typ.name}{3}_mt{size}";
            var vecTypeName2 = $"{typ.name}{2}_mt{size}";
            var matTypeName3x3 = $"{typ.name}{3}x{3}_mt{size}";
            var matTypeName4x4 = $"{typ.name}{4}x{4}_mt{size}";
            var typeName = $"quaternion{typ.structSuffix}_mt{size}";
            var bType = $"b{typ.size * 8}v";
            var bTyp = Typ.Typs.FirstOrDefault(a => a.name == bType);
            var bTypeName = $"{bType}{4}_mt{size}";
            var scalar_bType = $"b{typ.size * 8}";
            var scalar_bTypeName = $"{scalar_bType}_mt{size}";
#>

#region <#= typeName #>

public partial record struct <#= typeName #>
{
    public <#= vecTypeName #> value;

    public readonly override string ToString() => $"{nameof(<#= typeName #>)}({value.x}, {value.y}, {value.z}, {value.w})";

    public static <#= typeName #> Identity
    {
        [MethodImpl(256 | 512)]
        get => new(default, default, default, <#= typ.one #>);
    }
    
    [MethodImpl(256 | 512)]
    public <#= typeName #>(<#= string.Join(", ", Enumerable.Range(0, 4).Select(i => $"{scalarName} {Typ.xyzw[i]}")) #>) => 
        value = new(<#= string.Join(", ", Enumerable.Range(0, 4).Select(i => $"{Typ.xyzw[i]}")) #>); 

    [MethodImpl(256 | 512)]
    public <#= typeName #>(<#= vecTypeName #> value) => this.value = value; 

    [MethodImpl(256 | 512)]
    public static implicit operator <#= typeName #>(<#= vecTypeName #> value) => new(value); 

    /// <summary>Constructs a unit quaternion from a <#= matTypeName3x3 #> rotation matrix. The matrix must be orthonormal</summary>
    /// <param name="m">The <#= matTypeName3x3 #> orthonormal rotation matrix</param>
    [MethodImpl(256 | 512)]
    public <#= typeName #>(<#= matTypeName3x3 #> m)
    {
        var u = m.c0;
        var v = m.c1;
        var w = m.c2;

        var u_sign = (<#= maskName #>)(u.x.asu() & <#= typ.maskNeg #>);
        var t = <#= typ.arithCast #>(v.y + ((<#= maskName #>)(w.z.asu() ^ u_sign)).asf());
        var u_mask = new <#= mask4Name #>((<#= maskName #>)(u_sign >> <#= typeBitSize - 1 #>)).asf();
        var t_mask = new <#= sigMask4Name #>((<#= sigMaskName #>)(t.asi() >> <#= typeBitSize - 1 #>)).asf();

        var tr = <#= typ.one #> + u.x.abs();

        var sign_flips =
            new <#= mask4Name #>(default, <#= typ.maskNeg #>, <#= typ.maskNeg #>, <#= typ.maskNeg #>).asf()
            ^ (u_mask & new <#= mask4Name #>(default, <#= typ.maskNeg #>, default, <#= typ.maskNeg #>).asf())
            ^ (t_mask & new <#= mask4Name #>(<#= typ.maskNeg #>, <#= typ.maskNeg #>, <#= typ.maskNeg #>, default).asf());

        value = new <#= vecTypeName #>(tr, u.y, w.x, v.z) + (new <#= vecTypeName #>(t, v.x, u.z, w.y) ^ sign_flips); // +---, +++-, ++-+, +-++

        value = (value & ~u_mask) | (value.zwxy & u_mask);
        value = (value.wzyx & ~t_mask) | (value & t_mask);
        value = value.normalize();
    }

    /// <summary>Constructs a unit quaternion from an orthonormal <#= matTypeName4x4 #> matrix</summary>
    /// <param name="m">The <#= matTypeName4x4 #> orthonormal rotation matrix</param>
    [MethodImpl(256 | 512)]
    public <#= typeName #>(<#= matTypeName4x4 #> m)
    {
        var u = m.c0;
        var v = m.c1;
        var w = m.c2;

        var u_sign = (<#= maskName #>)(u.x.asu() & <#= typ.maskNeg #>);
        var t = v.y + ((<#= maskName #>)(w.z.asu() ^ u_sign)).asf();
        var u_mask = new <#= mask4Name #>((<#= maskName #>)(u_sign >> <#= typeBitSize - 1 #>)).asf();
        var t_mask = new <#= sigMask4Name #>((<#= sigMaskName #>)(t.asi() >> <#= typeBitSize - 1 #>)).asf();

        var tr = <#= typ.arithCast #>(<#= typ.one #> + u.x.abs());

        var sign_flips =
            new <#= mask4Name #>(default, <#= typ.maskNeg #>, <#= typ.maskNeg #>, <#= typ.maskNeg #>).asf()
            ^ (u_mask & new <#= mask4Name #>(default, <#= typ.maskNeg #>, default, <#= typ.maskNeg #>).asf())
            ^ (t_mask & new <#= mask4Name #>(<#= typ.maskNeg #>, <#= typ.maskNeg #>, <#= typ.maskNeg #>, default).asf());

        value = new <#= vecTypeName #>(tr, u.y, w.x, v.z) + (new <#= vecTypeName #>(t, v.x, u.z, w.y) ^ sign_flips); // +---, +++-, ++-+, +-++

        value = (value & ~u_mask) | (value.zwxy & u_mask);
        value = (value.wzyx & ~t_mask) | (value & t_mask);
        value = value.normalize();
    }

    /// <summary>
    /// Returns a quaternion representing a rotation around a unit axis by an angle in radians.
    /// The rotation direction is clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="axis">The axis of rotation</param>
    /// <param name="angle">The angle of rotation in radians</param>
    /// <returns>The quaternion representing a rotation around an axis</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> AxisAngle(<#= vecTypeName3 #> axis, <#= scalarName #> angle)
    {
        math_mt.sincos(<#= typ.half #> * angle, out var sina, out var cosa);
        return new(new <#= vecTypeName #>(axis * sina, cosa));
    }

    /// <summary>
    /// Returns a quaternion representing a rotation around a unit axis by an angle in radians.
    /// The rotation direction is clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="axis">The axis of rotation</param>
    /// <param name="angle">The angle of rotation in radians</param>
    /// <returns>The quaternion representing a rotation around an axis</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> AxisAngle(<#= vecTypeName3 #> axis, <#= typ.compType #> angle)
    {
        math.sincos(<#= typ.half #> * angle, out var sina, out var cosa);
        return new(new <#= vecTypeName #>(axis * sina, cosa));
    }

    /// <summary>
    /// Returns a quaternion constructed by first performing 3 rotations around the principal axes in a given order.
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin.
    /// When the rotation order is known at compile time, it is recommended for performance reasons to use specific
    /// Euler rotation constructors such as EulerZXY(...).
    /// </summary>
    /// <param name="xyz">A float3 vector containing the rotation angles around the x-, y- and z-axis measures in radians.</param>
    /// <param name="order">The order in which the rotations are applied.</param>
    /// <returns>The quaternion representing the Euler angle rotation in the specified order.</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> Euler(<#= vecTypeName3 #> xyz, RotationOrder order = RotationOrder.Default) => order switch
    {
        RotationOrder.XYZ => EulerXYZ(xyz),
        RotationOrder.XZY => EulerXZY(xyz),
        RotationOrder.YXZ => EulerYXZ(xyz),
        RotationOrder.YZX => EulerYZX(xyz),
        RotationOrder.ZXY => EulerZXY(xyz),
        RotationOrder.ZYX => EulerZYX(xyz),
        _ => Identity,
    };
    
    /// <summary>
    /// Returns a quaternion constructed by first performing a rotation around the x-axis, then the y-axis and finally the z-axis.
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="xyz">A <#= vecTypeName3 #> vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The quaternion representing the Euler angle rotation in x-y-z order</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> EulerXYZ(<#= vecTypeName3 #> xyz)
    {
        var (s, c) = (xyz * 0.5<#= typ.suffix #>).sincos();
        return new(
            new <#= vecTypeName #>(s.xyz, c.x) * c.yxxy * c.zzyz + s.yxxy * s.zzyz * new <#= vecTypeName #>(c.xyz, s.x) * new <#= vecTypeName #>(-1.0<#= typ.suffix #>, 1.0<#= typ.suffix #>, -1.0<#= typ.suffix #>, 1.0<#= typ.suffix #>)
        );
    }

    /// <summary>
    /// Returns a quaternion constructed by first performing a rotation around the x-axis, then the z-axis and finally the y-axis.
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="xyz">A <#= vecTypeName3 #> vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The quaternion representing the Euler angle rotation in x-z-y order</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> EulerXZY(<#= vecTypeName3 #> xyz)
    {
        var (s, c) = (xyz * 0.5<#= typ.suffix #>).sincos();
        return new(
            new <#= vecTypeName #>(s.xyz, c.x) * c.yxxy * c.zzyz + s.yxxy * s.zzyz * new <#= vecTypeName #>(c.xyz, s.x) * new <#= vecTypeName #>(1.0<#= typ.suffix #>, 1.0<#= typ.suffix #>, -1.0<#= typ.suffix #>, -1.0<#= typ.suffix #>)
        );
    }

    /// <summary>
    /// Returns a quaternion constructed by first performing a rotation around the y-axis, then the x-axis and finally the z-axis.
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="xyz">A <#= vecTypeName3 #> vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The quaternion representing the Euler angle rotation in y-x-z order</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> EulerYXZ(<#= vecTypeName3 #> xyz)
    {
        var (s, c) = (xyz * 0.5<#= typ.suffix #>).sincos();
        return new(
            new <#= vecTypeName #>(s.xyz, c.x) * c.yxxy * c.zzyz + s.yxxy * s.zzyz * new <#= vecTypeName #>(c.xyz, s.x) * new <#= vecTypeName #>(-1.0<#= typ.suffix #>, 1.0<#= typ.suffix #>, 1.0<#= typ.suffix #>, -1.0<#= typ.suffix #>)
        );
    }

    /// <summary>
    /// Returns a quaternion constructed by first performing a rotation around the y-axis, then the z-axis and finally the x-axis.
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="xyz">A <#= vecTypeName3 #> vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The quaternion representing the Euler angle rotation in y-z-x order</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> EulerYZX(<#= vecTypeName3 #> xyz)
    {
        var (s, c) = (xyz * 0.5<#= typ.suffix #>).sincos();
        return new(
            new <#= vecTypeName #>(s.xyz, c.x) * c.yxxy * c.zzyz + s.yxxy * s.zzyz * new <#= vecTypeName #>(c.xyz, s.x) * new <#= vecTypeName #>(-1.0<#= typ.suffix #>, -1.0<#= typ.suffix #>, 1.0<#= typ.suffix #>, 1.0<#= typ.suffix #>)
        );
    }

    /// <summary>
    /// Returns a quaternion constructed by first performing a rotation around the z-axis, then the x-axis and finally the y-axis.
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="xyz">A <#= vecTypeName3 #> vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The quaternion representing the Euler angle rotation in z-x-y order</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> EulerZXY(<#= vecTypeName3 #> xyz)
    {
        var (s, c) = (xyz * 0.5<#= typ.suffix #>).sincos();
        return new(
            new <#= vecTypeName #>(s.xyz, c.x) * c.yxxy * c.zzyz + s.yxxy * s.zzyz * new <#= vecTypeName #>(c.xyz, s.x) * new <#= vecTypeName #>(1.0<#= typ.suffix #>, -1.0<#= typ.suffix #>, -1.0<#= typ.suffix #>, 1.0<#= typ.suffix #>)
        );
    }

    /// <summary>
    /// Returns a quaternion constructed by first performing a rotation around the z-axis, then the y-axis and finally the x-axis.
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="xyz">A <#= vecTypeName3 #> vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The quaternion representing the Euler angle rotation in z-y-x order</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> EulerZYX(<#= vecTypeName3 #> xyz)
    {
        var (s, c) = (xyz * 0.5<#= typ.suffix #>).sincos();
        return new(
            new <#= vecTypeName #>(s.xyz, c.x) * c.yxxy * c.zzyz + s.yxxy * s.zzyz * new <#= vecTypeName #>(c.xyz, s.x) * new <#= vecTypeName #>(1.0<#= typ.suffix #>, -1.0<#= typ.suffix #>, 1.0<#= typ.suffix #>, -1.0<#= typ.suffix #>)
        );
    }

    /// <summary>Returns a quaternion that rotates around the x-axis by a given number of radians</summary>
    /// <param name="angle">The clockwise rotation angle when looking along the x-axis towards the origin in radians</param>
    /// <returns>The quaternion representing a rotation around the x-axis</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> RotateX(<#= scalarName #> angle)
    {
        var (sina, cosa) = math_mt.sincos(angle * 0.5<#= typ.suffix #>);
        return new(sina, default, default, cosa);
    }

    /// <summary>Returns a quaternion that rotates around the x-axis by a given number of radians</summary>
    /// <param name="angle">The clockwise rotation angle when looking along the x-axis towards the origin in radians</param>
    /// <returns>The quaternion representing a rotation around the x-axis</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> RotateX(<#= typ.compType #> angle)
    {
        var (sina, cosa) = math.sincos(angle * 0.5<#= typ.suffix #>);
        return new(sina, default, default, cosa);
    }

    /// <summary>Returns a quaternion that rotates around the y-axis by a given number of radians</summary>
    /// <param name="angle">The clockwise rotation angle when looking along the y-axis towards the origin in radians</param>
    /// <returns>The quaternion representing a rotation around the y-axis</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> RotateY(<#= scalarName #> angle)
    {
        var (sina, cosa) = math_mt.sincos(angle * 0.5<#= typ.suffix #>);
        return new(default, sina, default, cosa);
    }

    /// <summary>Returns a quaternion that rotates around the y-axis by a given number of radians</summary>
    /// <param name="angle">The clockwise rotation angle when looking along the y-axis towards the origin in radians</param>
    /// <returns>The quaternion representing a rotation around the y-axis</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> RotateY(<#= typ.compType #> angle)
    {
        var (sina, cosa) = math.sincos(angle * 0.5<#= typ.suffix #>);
        return new(default, sina, default, cosa);
    }

    /// <summary>Returns a quaternion that rotates around the z-axis by a given number of radians.</summary>
    /// <param name="angle">The clockwise rotation angle when looking along the z-axis towards the origin in radians</param>
    /// <returns>The quaternion representing a rotation around the z-axis</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> RotateZ(<#= scalarName #> angle)
    {
        var (sina, cosa) = math_mt.sincos(angle * 0.5<#= typ.suffix #>);
        return new(default, default, sina, cosa);
    }

    /// <summary>Returns a quaternion that rotates around the z-axis by a given number of radians.</summary>
    /// <param name="angle">The clockwise rotation angle when looking along the z-axis towards the origin in radians</param>
    /// <returns>The quaternion representing a rotation around the z-axis</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> RotateZ(<#= typ.compType #> angle)
    {
        var (sina, cosa) = math.sincos(angle * 0.5<#= typ.suffix #>);
        return new(default, default, sina, cosa);
    }

    /// <summary>
    /// Returns a quaternion view rotation given a unit length forward vector and a unit length up vector.
    /// The two input vectors are assumed to be unit length and not collinear.
    /// If these assumptions are not met use <see cref="<#= typeName #>.LookRotationSafe" /> instead.
    /// </summary>
    /// <param name="forward">The view forward direction</param>
    /// <param name="up">The view up direction</param>
    /// <returns>The quaternion view rotation</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> LookRotation(<#= vecTypeName3 #> forward, <#= vecTypeName3 #> up)
    {
        var t = up.cross(forward).normalize();
        return new(new <#= matTypeName3x3 #>(t, forward.cross(t), forward));
    }

    /// <summary>
    /// Returns a quaternion view rotation given a forward vector and an up vector.
    /// The two input vectors are not assumed to be unit length.
    /// If the magnitude of either of the vectors is so extreme that the calculation cannot be carried out reliably or the vectors are collinear,
    /// the identity will be returned instead.
    /// </summary>
    /// <param name="forward">The view forward direction</param>
    /// <param name="up">The view up direction</param>
    /// <returns>The quaternion view rotation or the identity quaternion</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> LookRotationSafe(<#= vecTypeName3 #> forward, <#= vecTypeName3 #> up)
    {
        var forwardLengthSq = forward.dot(forward);
        var upLengthSq = up.dot(up);

        forward *= forwardLengthSq.rsqrt();
        up *= upLengthSq.rsqrt();

        var t = up.cross(forward);
        var tLengthSq = t.dot(t);
        t *= tLengthSq.rsqrt();

        var mn = forwardLengthSq.min(upLengthSq).min(tLengthSq);
        var mx = forwardLengthSq.max(upLengthSq).max(tLengthSq);

        var accept = mn > math_mt.MinRotateSafe<<#= typ.compType #>>() & mx < math_mt.MaxRotateSafe<<#= typ.compType #>>()
             & forwardLengthSq.isFinite() & upLengthSq.isFinite() & tLengthSq.isFinite();
        return math_mt.select(
            accept,
            new <#= typeName #>(new <#= matTypeName3x3 #>(t, forward.cross(t), forward)),
            new <#= typeName #>(default, default, default, <#= typ.one #>)
        );
    }

    #region Record

    public readonly bool Equals(<#= typeName #> other) => value.Equals(other.value);

    public readonly override int GetHashCode() => value.GetHashCode();

    private bool PrintMembers(System.Text.StringBuilder sb)
    {
        sb.Append($"x = {value.x}, y = {value.y}, z = {value.z}, w = {value.w}");
        return true;
    }

    #endregion
}

[Ex]
public static partial class math_mt
{
    [MethodImpl(256 | 512)]
    public static <#= typeName #> select([This] <#= bTypeName #> c, <#= typeName #> t, <#= typeName #> f) =>
        new(select(c, t.value, f.value));

    /// <summary>Returns the conjugate of a quaternion value</summary>
    /// <param name="q">The quaternion to conjugate</param>
    /// <returns>The conjugate of the input quaternion</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> conjugate([This] <#= typeName #> q) => 
        new(q.value * new <#= vecTypeName #>(-1.0<#= typ.suffix #>, -1.0<#= typ.suffix #>, -1.0<#= typ.suffix #>, 1.0<#= typ.suffix #>));

    /// <summary>Returns the inverse of a quaternion value</summary>
    /// <param name="q">The quaternion to invert</param>
    /// <returns>The quaternion inverse of the input quaternion</returns>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> inverse([This] <#= typeName #> q) => 
        new(q.dot(q).rcp() * q.value *  new <#= vecTypeName #>(-1.0<#= typ.suffix #>, -1.0<#= typ.suffix #>, -1.0<#= typ.suffix #>, 1.0<#= typ.suffix #>));

    [MethodImpl(256 | 512)]
    public static <#= scalarName #> dot([This] <#= typeName #> a, <#= typeName #> b) => a.value.dot(b.value);

    [MethodImpl(256 | 512)]
    public static <#= scalarName #> length([This] <#= typeName #> q) => q.lengthsq().sqrt();

    [MethodImpl(256 | 512)]
    public static <#= scalarName #> lengthsq([This] <#= typeName #> q) => q.dot(q);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> normalize([This] <#= typeName #> q) => new(q.dot(q).rsqrt() * q.value);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> normalizeSafe([This] <#= typeName #> q)
    {
        var len = q.lengthsq();
        return select(len > MinNormal<<#= typ.compType #>>(), <#= typeName #>.Identity, new(len.rsqrt() * q.value));
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> normalizeSafe([This] <#= typeName #> q, <#= typeName #> defaultValue)
    {
        var len = q.lengthsq();
        return select(len > MinNormal<<#= typ.compType #>>(), defaultValue, new(len.rsqrt() * q.value));
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> unitExp([This] <#= typeName #> q)
    {
        var v_rcp_len = q.value.xyz.lengthsq().rsqrt();
        var v_len = v_rcp_len.rcp();
        v_len.sincos(out var sin_v_len, out var cos_v_len);
        return new(new <#= vecTypeName #>(q.value.xyz * v_rcp_len * sin_v_len, cos_v_len));
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> exp([This] <#= typeName #> q)
    {
        var v_rcp_len = q.value.xyz.lengthsq().rsqrt();
        var v_len = v_rcp_len.rcp();
        v_len.sincos(out var sin_v_len, out var cos_v_len);
        return new(new <#= vecTypeName #>(q.value.xyz * v_rcp_len * sin_v_len, cos_v_len) * q.value.w.exp());
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> unitLog([This] <#= typeName #> q)
    {
        var w = q.value.w.clamp(-1.0<#= typ.suffix #>, 1.0<#= typ.suffix #>);
        var s = <#= typ.arithCast #>(acos(w) * rsqrt(1.0<#= typ.suffix #> - w*w));
        return new(new <#= vecTypeName #>(q.value.xyz * s, default));
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> log([This] <#= typeName #> q)
    {
        var v_len_sq = q.value.xyz.lengthsq();
        var q_len_sq = v_len_sq + q.value.w * q.value.w;

        var s = <#= typ.arithCast #>(acos(clamp(q.value.w * q_len_sq.rsqrt(), -1.0<#= typ.suffix #>, 1.0<#= typ.suffix #>)) * v_len_sq.rsqrt());
        return new(new <#= vecTypeName #>(q.value.xyz * s, <#= typ.arithCast #>(0.5<#= typ.suffix #> * q_len_sq.log())));
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> mul([This] <#= typeName #> a, <#= typeName #> b) => new(
        a.value.wwww * b.value + (a.value.xyzx * b.value.wwwx + a.value.yzxy * b.value.zxyy) 
        * new <#= vecTypeName #>(1.0<#= typ.suffix #>, 1.0<#= typ.suffix #>, 1.0<#= typ.suffix #>, -1.0<#= typ.suffix #>) - a.value.zxyz * b.value.yzxz
    );

    [MethodImpl(256 | 512)]
    public static <#= vecTypeName3 #> mul([This] <#= typeName #> q, <#= vecTypeName3 #> v)
    {
        var t = <#= typ.two #> * q.value.xyz.cross(v);
        return v + q.value.w * t + q.value.xyz.cross(t);
    }

    [MethodImpl(256 | 512)]
    public static <#= vecTypeName3 #> rotate([This] <#= typeName #> q, <#= vecTypeName3 #> v) => mul(q, v);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> nlerp([This] <#= scalarName #> t, <#= typeName #> q1, <#= typeName #> q2) => 
        normalize(q1.value + t * (chgsign(q2.value, dot(q1, q2)) - q1.value));
    
    [MethodImpl(256 | 512)]
    public static <#= typeName #> slerp([This] <#= scalarName #> t, <#= typeName #> q1, <#= typeName #> q2)
    {
        var dt = dot(q1, q2);
        
        var sig1 = select(dt < 0.0<#= typ.suffix #>, <#= typ.maskNeg #>.asf(), default);
        dt ^= sig1;
        q2.value ^= sig1;

        var cond1 = dt < 0.9995<#= typ.suffix #>;
        var f_branch = t.nlerp(q1, q2); // if the angle is small, use linear interpolation
        <#= typeName #> t_branch;
        {
            var angle = dt.acos();
            var s = <#= typ.arithCast #>(rsqrt(1.0<#= typ.suffix #> - dt * dt));    // 1.0f / sin(angle)
            var w1 = <#= typ.arithCast #>(sin(angle * (1.0<#= typ.suffix #> - t)) * s);
            var w2 = <#= typ.arithCast #>(sin(angle * t) * s);
            t_branch = new <#= typeName #>(q1.value * w1 + q2.value * w2);
        }
        return math_mt.select(cond1, t_branch, f_branch);
    }
    
    [MethodImpl(256 | 512)]
    public static <#= scalarName #> angle([This] <#= typeName #> q1, <#= typeName #> q2)
    {
        var diff = q1.conjugate().mul(q2).normalize().value.xyz.length().asin();
        return diff + diff;
    }
    
    [MethodImpl(256 | 512)]
    public static <#= matTypeName3x3 #> adj([This] <#= matTypeName3x3 #> m, out <#= scalarName #> det)
    {
        <#= matTypeName3x3 #> adjT;
        adjT.c0 = m.c1.cross(m.c2);
        adjT.c1 = m.c2.cross(m.c0);
        adjT.c2 = m.c0.cross(m.c1);
        det = m.c0.dot(adjT.c0);

        return adjT.transpose();
    }
    
    [MethodImpl(256 | 512)]
    public static <#= bTypeName #> adj([This] <#= matTypeName3x3 #> m, out <#= matTypeName3x3 #> i)
    {
        var epsilon = <#= typ.compType switch { "half" => "1e-5", "float" => "1e-30", "double" => "1e-300", _ => "0" } #><#= typ.suffix #>;
        return m.adj(out i, epsilon);
    }

    [MethodImpl(256 | 512)]
    public static <#= bTypeName #> adj([This] <#= matTypeName3x3 #> m, out <#= matTypeName3x3 #> i, <#= scalarName #> epsilon)
    {
        i = adj(m, out <#= scalarName #> det);
        var c = det.abs() > epsilon;
        var detInv = select(c, det.rcp(), new <#= vecTypeName3 #>(<#= typ.one #>));
        i = detInv * i;
        return c;
    }
}

#endregion // <#= typeName #>
<#
        }
    }
#>
