// generated by template, do not modify manually

namespace Coplt.Mathematics;

#region float2

public partial struct float2 : IVectorBitops
    , IBitwiseOperators<float2, float2, float2>
    , IShiftOperators<float2, int, float2>
{
    [MethodImpl(256 | 512)]
    public static float2 operator ~(float2 a)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(~a.vector);
        return new(a.x.BitNot(), a.y.BitNot());
    }

    [MethodImpl(256 | 512)]
    public static float2 operator |(float2 a, float2 b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(a.vector | b.vector);
        return new(a.x.BitOr(b.x), a.y.BitOr(b.y));
    }

    [MethodImpl(256 | 512)]
    public static float2 operator &(float2 a, float2 b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(a.vector & b.vector);
        return new(a.x.BitAnd(b.x), a.y.BitAnd(b.y));
    }

    [MethodImpl(256 | 512)]
    public static float2 operator ^(float2 a, float2 b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(a.vector ^ b.vector);
        return new(a.x.BitXor(b.x), a.y.BitXor(b.y));
    }

    [MethodImpl(256 | 512)]
    public static float2 operator <<(float2 a, int b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(a.vector << b);
        return new(a.x.BitShiftLeft(b), a.y.BitShiftLeft(b));
    }

    [MethodImpl(256 | 512)]
    public static float2 operator >>(float2 a, int b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(a.vector >> b);
        return new(a.x.BitShiftRight(b), a.y.BitShiftRight(b));
    }

    [MethodImpl(256 | 512)]
    public static float2 operator >>>(float2 a, int b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(a.vector >>> b);
        return new(a.x.BitShiftRightUnsigned(b), a.y.BitShiftRightUnsigned(b));
    }

    [MethodImpl(256 | 512)]
    public static float2 operator <<(float2 a, uint2 b)
    {
        return new(a.x.BitShiftLeft((int)b.x), a.y.BitShiftLeft((int)b.y));
    }

    [MethodImpl(256 | 512)]
    public static float2 operator >>(float2 a, uint2 b)
    {
        return new(a.x.BitShiftRight((int)b.x), a.y.BitShiftRight((int)b.y));
    }

    [MethodImpl(256 | 512)]
    public static float2 operator >>>(float2 a, uint2 b)
    {
        return new(a.x.BitShiftRightUnsigned((int)b.x), a.y.BitShiftRightUnsigned((int)b.y));
    }
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static float2 andnot(this float2 a, float2 b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(Vector64.AndNot(a.vector, b.vector));
        return new(a.x.andnot(b.x), a.y.andnot(b.y));
    }

    [MethodImpl(256 | 512)]
    public static int2 popcnt(this float2 a)
    {
        return new(a.x.asu().popcnt(), a.y.asu().popcnt());
    }

    [MethodImpl(256 | 512)]
    public static int2 lzcnt(this float2 a)
    {
        return new(a.x.asu().lzcnt(), a.y.asu().lzcnt());
    }

    [MethodImpl(256 | 512)]
    public static int2 tzcnt(this float2 a)
    {
        return new(a.x.asu().tzcnt(), a.y.asu().tzcnt());
    }
}

#endregion // float2

#region float3

public partial struct float3 : IVectorBitops
    , IBitwiseOperators<float3, float3, float3>
    , IShiftOperators<float3, int, float3>
{
    [MethodImpl(256 | 512)]
    public static float3 operator ~(float3 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(~a.vector & Vector128.Create(-1, -1, -1, 0).AsSingle());
        return new(a.x.BitNot(), a.y.BitNot(), a.z.BitNot());
    }

    [MethodImpl(256 | 512)]
    public static float3 operator |(float3 a, float3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector | b.vector);
        return new(a.x.BitOr(b.x), a.y.BitOr(b.y), a.z.BitOr(b.z));
    }

    [MethodImpl(256 | 512)]
    public static float3 operator &(float3 a, float3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector & b.vector);
        return new(a.x.BitAnd(b.x), a.y.BitAnd(b.y), a.z.BitAnd(b.z));
    }

    [MethodImpl(256 | 512)]
    public static float3 operator ^(float3 a, float3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector ^ b.vector);
        return new(a.x.BitXor(b.x), a.y.BitXor(b.y), a.z.BitXor(b.z));
    }

    [MethodImpl(256 | 512)]
    public static float3 operator <<(float3 a, int b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector << b);
        return new(a.x.BitShiftLeft(b), a.y.BitShiftLeft(b), a.z.BitShiftLeft(b));
    }

    [MethodImpl(256 | 512)]
    public static float3 operator >>(float3 a, int b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector >> b);
        return new(a.x.BitShiftRight(b), a.y.BitShiftRight(b), a.z.BitShiftRight(b));
    }

    [MethodImpl(256 | 512)]
    public static float3 operator >>>(float3 a, int b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector >>> b);
        return new(a.x.BitShiftRightUnsigned(b), a.y.BitShiftRightUnsigned(b), a.z.BitShiftRightUnsigned(b));
    }

    [MethodImpl(256 | 512)]
    public static float3 operator <<(float3 a, uint3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.ShiftLeft(a.vector.AsUInt32(), b.vector, true).AsSingle());
        return new(a.x.BitShiftLeft((int)b.x), a.y.BitShiftLeft((int)b.y), a.z.BitShiftLeft((int)b.z));
    }

    [MethodImpl(256 | 512)]
    public static float3 operator >>(float3 a, uint3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.ShiftRight(a.vector.AsUInt32(), b.vector, true).AsSingle());
        return new(a.x.BitShiftRight((int)b.x), a.y.BitShiftRight((int)b.y), a.z.BitShiftRight((int)b.z));
    }

    [MethodImpl(256 | 512)]
    public static float3 operator >>>(float3 a, uint3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.ShiftRight(a.vector.AsUInt32(), b.vector, true).AsSingle());
        return new(a.x.BitShiftRightUnsigned((int)b.x), a.y.BitShiftRightUnsigned((int)b.y), a.z.BitShiftRightUnsigned((int)b.z));
    }
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static float3 andnot(this float3 a, float3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.AndNot(a.vector, b.vector) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        return new(a.x.andnot(b.x), a.y.andnot(b.y), a.z.andnot(b.z));
    }

    [MethodImpl(256 | 512)]
    public static int3 popcnt(this float3 a)
    {
        return new(a.x.asu().popcnt(), a.y.asu().popcnt(), a.z.asu().popcnt());
    }

    [MethodImpl(256 | 512)]
    public static int3 lzcnt(this float3 a)
    {
        return new(a.x.asu().lzcnt(), a.y.asu().lzcnt(), a.z.asu().lzcnt());
    }

    [MethodImpl(256 | 512)]
    public static int3 tzcnt(this float3 a)
    {
        return new(a.x.asu().tzcnt(), a.y.asu().tzcnt(), a.z.asu().tzcnt());
    }
}

#endregion // float3

#region float4

public partial struct float4 : IVectorBitops
    , IBitwiseOperators<float4, float4, float4>
    , IShiftOperators<float4, int, float4>
{
    [MethodImpl(256 | 512)]
    public static float4 operator ~(float4 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(~a.vector);
        return new(a.x.BitNot(), a.y.BitNot(), a.z.BitNot(), a.w.BitNot());
    }

    [MethodImpl(256 | 512)]
    public static float4 operator |(float4 a, float4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector | b.vector);
        return new(a.x.BitOr(b.x), a.y.BitOr(b.y), a.z.BitOr(b.z), a.w.BitOr(b.w));
    }

    [MethodImpl(256 | 512)]
    public static float4 operator &(float4 a, float4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector & b.vector);
        return new(a.x.BitAnd(b.x), a.y.BitAnd(b.y), a.z.BitAnd(b.z), a.w.BitAnd(b.w));
    }

    [MethodImpl(256 | 512)]
    public static float4 operator ^(float4 a, float4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector ^ b.vector);
        return new(a.x.BitXor(b.x), a.y.BitXor(b.y), a.z.BitXor(b.z), a.w.BitXor(b.w));
    }

    [MethodImpl(256 | 512)]
    public static float4 operator <<(float4 a, int b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector << b);
        return new(a.x.BitShiftLeft(b), a.y.BitShiftLeft(b), a.z.BitShiftLeft(b), a.w.BitShiftLeft(b));
    }

    [MethodImpl(256 | 512)]
    public static float4 operator >>(float4 a, int b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector >> b);
        return new(a.x.BitShiftRight(b), a.y.BitShiftRight(b), a.z.BitShiftRight(b), a.w.BitShiftRight(b));
    }

    [MethodImpl(256 | 512)]
    public static float4 operator >>>(float4 a, int b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector >>> b);
        return new(a.x.BitShiftRightUnsigned(b), a.y.BitShiftRightUnsigned(b), a.z.BitShiftRightUnsigned(b), a.w.BitShiftRightUnsigned(b));
    }

    [MethodImpl(256 | 512)]
    public static float4 operator <<(float4 a, uint4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.ShiftLeft(a.vector.AsUInt32(), b.vector).AsSingle());
        return new(a.x.BitShiftLeft((int)b.x), a.y.BitShiftLeft((int)b.y), a.z.BitShiftLeft((int)b.z), a.w.BitShiftLeft((int)b.w));
    }

    [MethodImpl(256 | 512)]
    public static float4 operator >>(float4 a, uint4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.ShiftRight(a.vector.AsUInt32(), b.vector).AsSingle());
        return new(a.x.BitShiftRight((int)b.x), a.y.BitShiftRight((int)b.y), a.z.BitShiftRight((int)b.z), a.w.BitShiftRight((int)b.w));
    }

    [MethodImpl(256 | 512)]
    public static float4 operator >>>(float4 a, uint4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.ShiftRight(a.vector.AsUInt32(), b.vector).AsSingle());
        return new(a.x.BitShiftRightUnsigned((int)b.x), a.y.BitShiftRightUnsigned((int)b.y), a.z.BitShiftRightUnsigned((int)b.z), a.w.BitShiftRightUnsigned((int)b.w));
    }
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static float4 andnot(this float4 a, float4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.AndNot(a.vector, b.vector));
        return new(a.x.andnot(b.x), a.y.andnot(b.y), a.z.andnot(b.z), a.w.andnot(b.w));
    }

    [MethodImpl(256 | 512)]
    public static int4 popcnt(this float4 a)
    {
        return new(a.x.asu().popcnt(), a.y.asu().popcnt(), a.z.asu().popcnt(), a.w.asu().popcnt());
    }

    [MethodImpl(256 | 512)]
    public static int4 lzcnt(this float4 a)
    {
        return new(a.x.asu().lzcnt(), a.y.asu().lzcnt(), a.z.asu().lzcnt(), a.w.asu().lzcnt());
    }

    [MethodImpl(256 | 512)]
    public static int4 tzcnt(this float4 a)
    {
        return new(a.x.asu().tzcnt(), a.y.asu().tzcnt(), a.z.asu().tzcnt(), a.w.asu().tzcnt());
    }
}

#endregion // float4

#region double2

public partial struct double2 : IVectorBitops
    , IBitwiseOperators<double2, double2, double2>
    , IShiftOperators<double2, int, double2>
{
    [MethodImpl(256 | 512)]
    public static double2 operator ~(double2 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(~a.vector);
        return new(a.x.BitNot(), a.y.BitNot());
    }

    [MethodImpl(256 | 512)]
    public static double2 operator |(double2 a, double2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector | b.vector);
        return new(a.x.BitOr(b.x), a.y.BitOr(b.y));
    }

    [MethodImpl(256 | 512)]
    public static double2 operator &(double2 a, double2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector & b.vector);
        return new(a.x.BitAnd(b.x), a.y.BitAnd(b.y));
    }

    [MethodImpl(256 | 512)]
    public static double2 operator ^(double2 a, double2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector ^ b.vector);
        return new(a.x.BitXor(b.x), a.y.BitXor(b.y));
    }

    [MethodImpl(256 | 512)]
    public static double2 operator <<(double2 a, int b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector << b);
        return new(a.x.BitShiftLeft(b), a.y.BitShiftLeft(b));
    }

    [MethodImpl(256 | 512)]
    public static double2 operator >>(double2 a, int b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector >> b);
        return new(a.x.BitShiftRight(b), a.y.BitShiftRight(b));
    }

    [MethodImpl(256 | 512)]
    public static double2 operator >>>(double2 a, int b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector >>> b);
        return new(a.x.BitShiftRightUnsigned(b), a.y.BitShiftRightUnsigned(b));
    }

    [MethodImpl(256 | 512)]
    public static double2 operator <<(double2 a, ulong2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.ShiftLeft(a.vector.AsUInt64(), b.vector).AsDouble());
        return new(a.x.BitShiftLeft((int)b.x), a.y.BitShiftLeft((int)b.y));
    }

    [MethodImpl(256 | 512)]
    public static double2 operator >>(double2 a, ulong2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.ShiftRight(a.vector.AsUInt64(), b.vector).AsDouble());
        return new(a.x.BitShiftRight((int)b.x), a.y.BitShiftRight((int)b.y));
    }

    [MethodImpl(256 | 512)]
    public static double2 operator >>>(double2 a, ulong2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.ShiftRight(a.vector.AsUInt64(), b.vector).AsDouble());
        return new(a.x.BitShiftRightUnsigned((int)b.x), a.y.BitShiftRightUnsigned((int)b.y));
    }
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static double2 andnot(this double2 a, double2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.AndNot(a.vector, b.vector));
        return new(a.x.andnot(b.x), a.y.andnot(b.y));
    }

    [MethodImpl(256 | 512)]
    public static long2 popcnt(this double2 a)
    {
        return new(a.x.asu().popcnt(), a.y.asu().popcnt());
    }

    [MethodImpl(256 | 512)]
    public static long2 lzcnt(this double2 a)
    {
        return new(a.x.asu().lzcnt(), a.y.asu().lzcnt());
    }

    [MethodImpl(256 | 512)]
    public static long2 tzcnt(this double2 a)
    {
        return new(a.x.asu().tzcnt(), a.y.asu().tzcnt());
    }
}

#endregion // double2

#region double3

public partial struct double3 : IVectorBitops
    , IBitwiseOperators<double3, double3, double3>
    , IShiftOperators<double3, int, double3>
{
    [MethodImpl(256 | 512)]
    public static double3 operator ~(double3 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(~a.vector & Vector256.Create(-1, -1, -1, 0).AsDouble());
        return new(a.x.BitNot(), a.y.BitNot(), a.z.BitNot());
    }

    [MethodImpl(256 | 512)]
    public static double3 operator |(double3 a, double3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector | b.vector);
        return new(a.x.BitOr(b.x), a.y.BitOr(b.y), a.z.BitOr(b.z));
    }

    [MethodImpl(256 | 512)]
    public static double3 operator &(double3 a, double3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector & b.vector);
        return new(a.x.BitAnd(b.x), a.y.BitAnd(b.y), a.z.BitAnd(b.z));
    }

    [MethodImpl(256 | 512)]
    public static double3 operator ^(double3 a, double3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector ^ b.vector);
        return new(a.x.BitXor(b.x), a.y.BitXor(b.y), a.z.BitXor(b.z));
    }

    [MethodImpl(256 | 512)]
    public static double3 operator <<(double3 a, int b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector << b);
        return new(a.x.BitShiftLeft(b), a.y.BitShiftLeft(b), a.z.BitShiftLeft(b));
    }

    [MethodImpl(256 | 512)]
    public static double3 operator >>(double3 a, int b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector >> b);
        return new(a.x.BitShiftRight(b), a.y.BitShiftRight(b), a.z.BitShiftRight(b));
    }

    [MethodImpl(256 | 512)]
    public static double3 operator >>>(double3 a, int b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector >>> b);
        return new(a.x.BitShiftRightUnsigned(b), a.y.BitShiftRightUnsigned(b), a.z.BitShiftRightUnsigned(b));
    }

    [MethodImpl(256 | 512)]
    public static double3 operator <<(double3 a, ulong3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.ShiftLeft(a.vector.AsUInt64(), b.vector, true).AsDouble());
        return new(a.x.BitShiftLeft((int)b.x), a.y.BitShiftLeft((int)b.y), a.z.BitShiftLeft((int)b.z));
    }

    [MethodImpl(256 | 512)]
    public static double3 operator >>(double3 a, ulong3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.ShiftRight(a.vector.AsUInt64(), b.vector, true).AsDouble());
        return new(a.x.BitShiftRight((int)b.x), a.y.BitShiftRight((int)b.y), a.z.BitShiftRight((int)b.z));
    }

    [MethodImpl(256 | 512)]
    public static double3 operator >>>(double3 a, ulong3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.ShiftRight(a.vector.AsUInt64(), b.vector, true).AsDouble());
        return new(a.x.BitShiftRightUnsigned((int)b.x), a.y.BitShiftRightUnsigned((int)b.y), a.z.BitShiftRightUnsigned((int)b.z));
    }
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static double3 andnot(this double3 a, double3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(Vector256.AndNot(a.vector, b.vector) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        return new(a.x.andnot(b.x), a.y.andnot(b.y), a.z.andnot(b.z));
    }

    [MethodImpl(256 | 512)]
    public static long3 popcnt(this double3 a)
    {
        return new(a.x.asu().popcnt(), a.y.asu().popcnt(), a.z.asu().popcnt());
    }

    [MethodImpl(256 | 512)]
    public static long3 lzcnt(this double3 a)
    {
        return new(a.x.asu().lzcnt(), a.y.asu().lzcnt(), a.z.asu().lzcnt());
    }

    [MethodImpl(256 | 512)]
    public static long3 tzcnt(this double3 a)
    {
        return new(a.x.asu().tzcnt(), a.y.asu().tzcnt(), a.z.asu().tzcnt());
    }
}

#endregion // double3

#region double4

public partial struct double4 : IVectorBitops
    , IBitwiseOperators<double4, double4, double4>
    , IShiftOperators<double4, int, double4>
{
    [MethodImpl(256 | 512)]
    public static double4 operator ~(double4 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(~a.vector);
        return new(a.x.BitNot(), a.y.BitNot(), a.z.BitNot(), a.w.BitNot());
    }

    [MethodImpl(256 | 512)]
    public static double4 operator |(double4 a, double4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector | b.vector);
        return new(a.x.BitOr(b.x), a.y.BitOr(b.y), a.z.BitOr(b.z), a.w.BitOr(b.w));
    }

    [MethodImpl(256 | 512)]
    public static double4 operator &(double4 a, double4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector & b.vector);
        return new(a.x.BitAnd(b.x), a.y.BitAnd(b.y), a.z.BitAnd(b.z), a.w.BitAnd(b.w));
    }

    [MethodImpl(256 | 512)]
    public static double4 operator ^(double4 a, double4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector ^ b.vector);
        return new(a.x.BitXor(b.x), a.y.BitXor(b.y), a.z.BitXor(b.z), a.w.BitXor(b.w));
    }

    [MethodImpl(256 | 512)]
    public static double4 operator <<(double4 a, int b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector << b);
        return new(a.x.BitShiftLeft(b), a.y.BitShiftLeft(b), a.z.BitShiftLeft(b), a.w.BitShiftLeft(b));
    }

    [MethodImpl(256 | 512)]
    public static double4 operator >>(double4 a, int b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector >> b);
        return new(a.x.BitShiftRight(b), a.y.BitShiftRight(b), a.z.BitShiftRight(b), a.w.BitShiftRight(b));
    }

    [MethodImpl(256 | 512)]
    public static double4 operator >>>(double4 a, int b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector >>> b);
        return new(a.x.BitShiftRightUnsigned(b), a.y.BitShiftRightUnsigned(b), a.z.BitShiftRightUnsigned(b), a.w.BitShiftRightUnsigned(b));
    }

    [MethodImpl(256 | 512)]
    public static double4 operator <<(double4 a, ulong4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.ShiftLeft(a.vector.AsUInt64(), b.vector).AsDouble());
        return new(a.x.BitShiftLeft((int)b.x), a.y.BitShiftLeft((int)b.y), a.z.BitShiftLeft((int)b.z), a.w.BitShiftLeft((int)b.w));
    }

    [MethodImpl(256 | 512)]
    public static double4 operator >>(double4 a, ulong4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.ShiftRight(a.vector.AsUInt64(), b.vector).AsDouble());
        return new(a.x.BitShiftRight((int)b.x), a.y.BitShiftRight((int)b.y), a.z.BitShiftRight((int)b.z), a.w.BitShiftRight((int)b.w));
    }

    [MethodImpl(256 | 512)]
    public static double4 operator >>>(double4 a, ulong4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.ShiftRight(a.vector.AsUInt64(), b.vector).AsDouble());
        return new(a.x.BitShiftRightUnsigned((int)b.x), a.y.BitShiftRightUnsigned((int)b.y), a.z.BitShiftRightUnsigned((int)b.z), a.w.BitShiftRightUnsigned((int)b.w));
    }
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static double4 andnot(this double4 a, double4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(Vector256.AndNot(a.vector, b.vector));
        return new(a.x.andnot(b.x), a.y.andnot(b.y), a.z.andnot(b.z), a.w.andnot(b.w));
    }

    [MethodImpl(256 | 512)]
    public static long4 popcnt(this double4 a)
    {
        return new(a.x.asu().popcnt(), a.y.asu().popcnt(), a.z.asu().popcnt(), a.w.asu().popcnt());
    }

    [MethodImpl(256 | 512)]
    public static long4 lzcnt(this double4 a)
    {
        return new(a.x.asu().lzcnt(), a.y.asu().lzcnt(), a.z.asu().lzcnt(), a.w.asu().lzcnt());
    }

    [MethodImpl(256 | 512)]
    public static long4 tzcnt(this double4 a)
    {
        return new(a.x.asu().tzcnt(), a.y.asu().tzcnt(), a.z.asu().tzcnt(), a.w.asu().tzcnt());
    }
}

#endregion // double4

#region short2

public partial struct short2 : IVectorBitops
    , IBitwiseOperators<short2, short2, short2>
    , IShiftOperators<short2, int, short2>
{
    [MethodImpl(256 | 512)]
    public static short2 operator ~(short2 a)
    {
        return new(a.x.BitNot(), a.y.BitNot());
    }

    [MethodImpl(256 | 512)]
    public static short2 operator |(short2 a, short2 b)
    {
        return new(a.x.BitOr(b.x), a.y.BitOr(b.y));
    }

    [MethodImpl(256 | 512)]
    public static short2 operator &(short2 a, short2 b)
    {
        return new(a.x.BitAnd(b.x), a.y.BitAnd(b.y));
    }

    [MethodImpl(256 | 512)]
    public static short2 operator ^(short2 a, short2 b)
    {
        return new(a.x.BitXor(b.x), a.y.BitXor(b.y));
    }

    [MethodImpl(256 | 512)]
    public static short2 operator <<(short2 a, int b)
    {
        return new(a.x.BitShiftLeft(b), a.y.BitShiftLeft(b));
    }

    [MethodImpl(256 | 512)]
    public static short2 operator >>(short2 a, int b)
    {
        return new(a.x.BitShiftRight(b), a.y.BitShiftRight(b));
    }

    [MethodImpl(256 | 512)]
    public static short2 operator >>>(short2 a, int b)
    {
        return new(a.x.BitShiftRightUnsigned(b), a.y.BitShiftRightUnsigned(b));
    }

    [MethodImpl(256 | 512)]
    public static short2 operator <<(short2 a, uint2 b)
    {
        return new(a.x.BitShiftLeft((int)b.x), a.y.BitShiftLeft((int)b.y));
    }

    [MethodImpl(256 | 512)]
    public static short2 operator >>(short2 a, uint2 b)
    {
        return new(a.x.BitShiftRight((int)b.x), a.y.BitShiftRight((int)b.y));
    }

    [MethodImpl(256 | 512)]
    public static short2 operator >>>(short2 a, uint2 b)
    {
        return new(a.x.BitShiftRightUnsigned((int)b.x), a.y.BitShiftRightUnsigned((int)b.y));
    }
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static short2 andnot(this short2 a, short2 b)
    {
        return new(a.x.andnot(b.x), a.y.andnot(b.y));
    }

    [MethodImpl(256 | 512)]
    public static short2 popcnt(this short2 a)
    {
        return new(a.x.asu().popcnt(), a.y.asu().popcnt());
    }

    [MethodImpl(256 | 512)]
    public static short2 lzcnt(this short2 a)
    {
        return new(a.x.asu().lzcnt(), a.y.asu().lzcnt());
    }

    [MethodImpl(256 | 512)]
    public static short2 tzcnt(this short2 a)
    {
        return new(a.x.asu().tzcnt(), a.y.asu().tzcnt());
    }
}

#endregion // short2

#region short3

public partial struct short3 : IVectorBitops
    , IBitwiseOperators<short3, short3, short3>
    , IShiftOperators<short3, int, short3>
{
    [MethodImpl(256 | 512)]
    public static short3 operator ~(short3 a)
    {
        return new(a.x.BitNot(), a.y.BitNot(), a.z.BitNot());
    }

    [MethodImpl(256 | 512)]
    public static short3 operator |(short3 a, short3 b)
    {
        return new(a.x.BitOr(b.x), a.y.BitOr(b.y), a.z.BitOr(b.z));
    }

    [MethodImpl(256 | 512)]
    public static short3 operator &(short3 a, short3 b)
    {
        return new(a.x.BitAnd(b.x), a.y.BitAnd(b.y), a.z.BitAnd(b.z));
    }

    [MethodImpl(256 | 512)]
    public static short3 operator ^(short3 a, short3 b)
    {
        return new(a.x.BitXor(b.x), a.y.BitXor(b.y), a.z.BitXor(b.z));
    }

    [MethodImpl(256 | 512)]
    public static short3 operator <<(short3 a, int b)
    {
        return new(a.x.BitShiftLeft(b), a.y.BitShiftLeft(b), a.z.BitShiftLeft(b));
    }

    [MethodImpl(256 | 512)]
    public static short3 operator >>(short3 a, int b)
    {
        return new(a.x.BitShiftRight(b), a.y.BitShiftRight(b), a.z.BitShiftRight(b));
    }

    [MethodImpl(256 | 512)]
    public static short3 operator >>>(short3 a, int b)
    {
        return new(a.x.BitShiftRightUnsigned(b), a.y.BitShiftRightUnsigned(b), a.z.BitShiftRightUnsigned(b));
    }

    [MethodImpl(256 | 512)]
    public static short3 operator <<(short3 a, uint3 b)
    {
        return new(a.x.BitShiftLeft((int)b.x), a.y.BitShiftLeft((int)b.y), a.z.BitShiftLeft((int)b.z));
    }

    [MethodImpl(256 | 512)]
    public static short3 operator >>(short3 a, uint3 b)
    {
        return new(a.x.BitShiftRight((int)b.x), a.y.BitShiftRight((int)b.y), a.z.BitShiftRight((int)b.z));
    }

    [MethodImpl(256 | 512)]
    public static short3 operator >>>(short3 a, uint3 b)
    {
        return new(a.x.BitShiftRightUnsigned((int)b.x), a.y.BitShiftRightUnsigned((int)b.y), a.z.BitShiftRightUnsigned((int)b.z));
    }
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static short3 andnot(this short3 a, short3 b)
    {
        return new(a.x.andnot(b.x), a.y.andnot(b.y), a.z.andnot(b.z));
    }

    [MethodImpl(256 | 512)]
    public static short3 popcnt(this short3 a)
    {
        return new(a.x.asu().popcnt(), a.y.asu().popcnt(), a.z.asu().popcnt());
    }

    [MethodImpl(256 | 512)]
    public static short3 lzcnt(this short3 a)
    {
        return new(a.x.asu().lzcnt(), a.y.asu().lzcnt(), a.z.asu().lzcnt());
    }

    [MethodImpl(256 | 512)]
    public static short3 tzcnt(this short3 a)
    {
        return new(a.x.asu().tzcnt(), a.y.asu().tzcnt(), a.z.asu().tzcnt());
    }
}

#endregion // short3

#region short4

public partial struct short4 : IVectorBitops
    , IBitwiseOperators<short4, short4, short4>
    , IShiftOperators<short4, int, short4>
{
    [MethodImpl(256 | 512)]
    public static short4 operator ~(short4 a)
    {
        return new(a.x.BitNot(), a.y.BitNot(), a.z.BitNot(), a.w.BitNot());
    }

    [MethodImpl(256 | 512)]
    public static short4 operator |(short4 a, short4 b)
    {
        return new(a.x.BitOr(b.x), a.y.BitOr(b.y), a.z.BitOr(b.z), a.w.BitOr(b.w));
    }

    [MethodImpl(256 | 512)]
    public static short4 operator &(short4 a, short4 b)
    {
        return new(a.x.BitAnd(b.x), a.y.BitAnd(b.y), a.z.BitAnd(b.z), a.w.BitAnd(b.w));
    }

    [MethodImpl(256 | 512)]
    public static short4 operator ^(short4 a, short4 b)
    {
        return new(a.x.BitXor(b.x), a.y.BitXor(b.y), a.z.BitXor(b.z), a.w.BitXor(b.w));
    }

    [MethodImpl(256 | 512)]
    public static short4 operator <<(short4 a, int b)
    {
        return new(a.x.BitShiftLeft(b), a.y.BitShiftLeft(b), a.z.BitShiftLeft(b), a.w.BitShiftLeft(b));
    }

    [MethodImpl(256 | 512)]
    public static short4 operator >>(short4 a, int b)
    {
        return new(a.x.BitShiftRight(b), a.y.BitShiftRight(b), a.z.BitShiftRight(b), a.w.BitShiftRight(b));
    }

    [MethodImpl(256 | 512)]
    public static short4 operator >>>(short4 a, int b)
    {
        return new(a.x.BitShiftRightUnsigned(b), a.y.BitShiftRightUnsigned(b), a.z.BitShiftRightUnsigned(b), a.w.BitShiftRightUnsigned(b));
    }

    [MethodImpl(256 | 512)]
    public static short4 operator <<(short4 a, uint4 b)
    {
        return new(a.x.BitShiftLeft((int)b.x), a.y.BitShiftLeft((int)b.y), a.z.BitShiftLeft((int)b.z), a.w.BitShiftLeft((int)b.w));
    }

    [MethodImpl(256 | 512)]
    public static short4 operator >>(short4 a, uint4 b)
    {
        return new(a.x.BitShiftRight((int)b.x), a.y.BitShiftRight((int)b.y), a.z.BitShiftRight((int)b.z), a.w.BitShiftRight((int)b.w));
    }

    [MethodImpl(256 | 512)]
    public static short4 operator >>>(short4 a, uint4 b)
    {
        return new(a.x.BitShiftRightUnsigned((int)b.x), a.y.BitShiftRightUnsigned((int)b.y), a.z.BitShiftRightUnsigned((int)b.z), a.w.BitShiftRightUnsigned((int)b.w));
    }
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static short4 andnot(this short4 a, short4 b)
    {
        return new(a.x.andnot(b.x), a.y.andnot(b.y), a.z.andnot(b.z), a.w.andnot(b.w));
    }

    [MethodImpl(256 | 512)]
    public static short4 popcnt(this short4 a)
    {
        return new(a.x.asu().popcnt(), a.y.asu().popcnt(), a.z.asu().popcnt(), a.w.asu().popcnt());
    }

    [MethodImpl(256 | 512)]
    public static short4 lzcnt(this short4 a)
    {
        return new(a.x.asu().lzcnt(), a.y.asu().lzcnt(), a.z.asu().lzcnt(), a.w.asu().lzcnt());
    }

    [MethodImpl(256 | 512)]
    public static short4 tzcnt(this short4 a)
    {
        return new(a.x.asu().tzcnt(), a.y.asu().tzcnt(), a.z.asu().tzcnt(), a.w.asu().tzcnt());
    }
}

#endregion // short4

#region ushort2

public partial struct ushort2 : IVectorBitops
    , IBitwiseOperators<ushort2, ushort2, ushort2>
    , IShiftOperators<ushort2, int, ushort2>
{
    [MethodImpl(256 | 512)]
    public static ushort2 operator ~(ushort2 a)
    {
        return new(a.x.BitNot(), a.y.BitNot());
    }

    [MethodImpl(256 | 512)]
    public static ushort2 operator |(ushort2 a, ushort2 b)
    {
        return new(a.x.BitOr(b.x), a.y.BitOr(b.y));
    }

    [MethodImpl(256 | 512)]
    public static ushort2 operator &(ushort2 a, ushort2 b)
    {
        return new(a.x.BitAnd(b.x), a.y.BitAnd(b.y));
    }

    [MethodImpl(256 | 512)]
    public static ushort2 operator ^(ushort2 a, ushort2 b)
    {
        return new(a.x.BitXor(b.x), a.y.BitXor(b.y));
    }

    [MethodImpl(256 | 512)]
    public static ushort2 operator <<(ushort2 a, int b)
    {
        return new(a.x.BitShiftLeft(b), a.y.BitShiftLeft(b));
    }

    [MethodImpl(256 | 512)]
    public static ushort2 operator >>(ushort2 a, int b)
    {
        return new(a.x.BitShiftRight(b), a.y.BitShiftRight(b));
    }

    [MethodImpl(256 | 512)]
    public static ushort2 operator >>>(ushort2 a, int b)
    {
        return new(a.x.BitShiftRightUnsigned(b), a.y.BitShiftRightUnsigned(b));
    }

    [MethodImpl(256 | 512)]
    public static ushort2 operator <<(ushort2 a, uint2 b)
    {
        return new(a.x.BitShiftLeft((int)b.x), a.y.BitShiftLeft((int)b.y));
    }

    [MethodImpl(256 | 512)]
    public static ushort2 operator >>(ushort2 a, uint2 b)
    {
        return new(a.x.BitShiftRight((int)b.x), a.y.BitShiftRight((int)b.y));
    }

    [MethodImpl(256 | 512)]
    public static ushort2 operator >>>(ushort2 a, uint2 b)
    {
        return new(a.x.BitShiftRightUnsigned((int)b.x), a.y.BitShiftRightUnsigned((int)b.y));
    }
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ushort2 andnot(this ushort2 a, ushort2 b)
    {
        return new(a.x.andnot(b.x), a.y.andnot(b.y));
    }

    [MethodImpl(256 | 512)]
    public static short2 popcnt(this ushort2 a)
    {
        return new(a.x.asu().popcnt(), a.y.asu().popcnt());
    }

    [MethodImpl(256 | 512)]
    public static short2 lzcnt(this ushort2 a)
    {
        return new(a.x.asu().lzcnt(), a.y.asu().lzcnt());
    }

    [MethodImpl(256 | 512)]
    public static short2 tzcnt(this ushort2 a)
    {
        return new(a.x.asu().tzcnt(), a.y.asu().tzcnt());
    }
}

#endregion // ushort2

#region ushort3

public partial struct ushort3 : IVectorBitops
    , IBitwiseOperators<ushort3, ushort3, ushort3>
    , IShiftOperators<ushort3, int, ushort3>
{
    [MethodImpl(256 | 512)]
    public static ushort3 operator ~(ushort3 a)
    {
        return new(a.x.BitNot(), a.y.BitNot(), a.z.BitNot());
    }

    [MethodImpl(256 | 512)]
    public static ushort3 operator |(ushort3 a, ushort3 b)
    {
        return new(a.x.BitOr(b.x), a.y.BitOr(b.y), a.z.BitOr(b.z));
    }

    [MethodImpl(256 | 512)]
    public static ushort3 operator &(ushort3 a, ushort3 b)
    {
        return new(a.x.BitAnd(b.x), a.y.BitAnd(b.y), a.z.BitAnd(b.z));
    }

    [MethodImpl(256 | 512)]
    public static ushort3 operator ^(ushort3 a, ushort3 b)
    {
        return new(a.x.BitXor(b.x), a.y.BitXor(b.y), a.z.BitXor(b.z));
    }

    [MethodImpl(256 | 512)]
    public static ushort3 operator <<(ushort3 a, int b)
    {
        return new(a.x.BitShiftLeft(b), a.y.BitShiftLeft(b), a.z.BitShiftLeft(b));
    }

    [MethodImpl(256 | 512)]
    public static ushort3 operator >>(ushort3 a, int b)
    {
        return new(a.x.BitShiftRight(b), a.y.BitShiftRight(b), a.z.BitShiftRight(b));
    }

    [MethodImpl(256 | 512)]
    public static ushort3 operator >>>(ushort3 a, int b)
    {
        return new(a.x.BitShiftRightUnsigned(b), a.y.BitShiftRightUnsigned(b), a.z.BitShiftRightUnsigned(b));
    }

    [MethodImpl(256 | 512)]
    public static ushort3 operator <<(ushort3 a, uint3 b)
    {
        return new(a.x.BitShiftLeft((int)b.x), a.y.BitShiftLeft((int)b.y), a.z.BitShiftLeft((int)b.z));
    }

    [MethodImpl(256 | 512)]
    public static ushort3 operator >>(ushort3 a, uint3 b)
    {
        return new(a.x.BitShiftRight((int)b.x), a.y.BitShiftRight((int)b.y), a.z.BitShiftRight((int)b.z));
    }

    [MethodImpl(256 | 512)]
    public static ushort3 operator >>>(ushort3 a, uint3 b)
    {
        return new(a.x.BitShiftRightUnsigned((int)b.x), a.y.BitShiftRightUnsigned((int)b.y), a.z.BitShiftRightUnsigned((int)b.z));
    }
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ushort3 andnot(this ushort3 a, ushort3 b)
    {
        return new(a.x.andnot(b.x), a.y.andnot(b.y), a.z.andnot(b.z));
    }

    [MethodImpl(256 | 512)]
    public static short3 popcnt(this ushort3 a)
    {
        return new(a.x.asu().popcnt(), a.y.asu().popcnt(), a.z.asu().popcnt());
    }

    [MethodImpl(256 | 512)]
    public static short3 lzcnt(this ushort3 a)
    {
        return new(a.x.asu().lzcnt(), a.y.asu().lzcnt(), a.z.asu().lzcnt());
    }

    [MethodImpl(256 | 512)]
    public static short3 tzcnt(this ushort3 a)
    {
        return new(a.x.asu().tzcnt(), a.y.asu().tzcnt(), a.z.asu().tzcnt());
    }
}

#endregion // ushort3

#region ushort4

public partial struct ushort4 : IVectorBitops
    , IBitwiseOperators<ushort4, ushort4, ushort4>
    , IShiftOperators<ushort4, int, ushort4>
{
    [MethodImpl(256 | 512)]
    public static ushort4 operator ~(ushort4 a)
    {
        return new(a.x.BitNot(), a.y.BitNot(), a.z.BitNot(), a.w.BitNot());
    }

    [MethodImpl(256 | 512)]
    public static ushort4 operator |(ushort4 a, ushort4 b)
    {
        return new(a.x.BitOr(b.x), a.y.BitOr(b.y), a.z.BitOr(b.z), a.w.BitOr(b.w));
    }

    [MethodImpl(256 | 512)]
    public static ushort4 operator &(ushort4 a, ushort4 b)
    {
        return new(a.x.BitAnd(b.x), a.y.BitAnd(b.y), a.z.BitAnd(b.z), a.w.BitAnd(b.w));
    }

    [MethodImpl(256 | 512)]
    public static ushort4 operator ^(ushort4 a, ushort4 b)
    {
        return new(a.x.BitXor(b.x), a.y.BitXor(b.y), a.z.BitXor(b.z), a.w.BitXor(b.w));
    }

    [MethodImpl(256 | 512)]
    public static ushort4 operator <<(ushort4 a, int b)
    {
        return new(a.x.BitShiftLeft(b), a.y.BitShiftLeft(b), a.z.BitShiftLeft(b), a.w.BitShiftLeft(b));
    }

    [MethodImpl(256 | 512)]
    public static ushort4 operator >>(ushort4 a, int b)
    {
        return new(a.x.BitShiftRight(b), a.y.BitShiftRight(b), a.z.BitShiftRight(b), a.w.BitShiftRight(b));
    }

    [MethodImpl(256 | 512)]
    public static ushort4 operator >>>(ushort4 a, int b)
    {
        return new(a.x.BitShiftRightUnsigned(b), a.y.BitShiftRightUnsigned(b), a.z.BitShiftRightUnsigned(b), a.w.BitShiftRightUnsigned(b));
    }

    [MethodImpl(256 | 512)]
    public static ushort4 operator <<(ushort4 a, uint4 b)
    {
        return new(a.x.BitShiftLeft((int)b.x), a.y.BitShiftLeft((int)b.y), a.z.BitShiftLeft((int)b.z), a.w.BitShiftLeft((int)b.w));
    }

    [MethodImpl(256 | 512)]
    public static ushort4 operator >>(ushort4 a, uint4 b)
    {
        return new(a.x.BitShiftRight((int)b.x), a.y.BitShiftRight((int)b.y), a.z.BitShiftRight((int)b.z), a.w.BitShiftRight((int)b.w));
    }

    [MethodImpl(256 | 512)]
    public static ushort4 operator >>>(ushort4 a, uint4 b)
    {
        return new(a.x.BitShiftRightUnsigned((int)b.x), a.y.BitShiftRightUnsigned((int)b.y), a.z.BitShiftRightUnsigned((int)b.z), a.w.BitShiftRightUnsigned((int)b.w));
    }
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ushort4 andnot(this ushort4 a, ushort4 b)
    {
        return new(a.x.andnot(b.x), a.y.andnot(b.y), a.z.andnot(b.z), a.w.andnot(b.w));
    }

    [MethodImpl(256 | 512)]
    public static short4 popcnt(this ushort4 a)
    {
        return new(a.x.asu().popcnt(), a.y.asu().popcnt(), a.z.asu().popcnt(), a.w.asu().popcnt());
    }

    [MethodImpl(256 | 512)]
    public static short4 lzcnt(this ushort4 a)
    {
        return new(a.x.asu().lzcnt(), a.y.asu().lzcnt(), a.z.asu().lzcnt(), a.w.asu().lzcnt());
    }

    [MethodImpl(256 | 512)]
    public static short4 tzcnt(this ushort4 a)
    {
        return new(a.x.asu().tzcnt(), a.y.asu().tzcnt(), a.z.asu().tzcnt(), a.w.asu().tzcnt());
    }
}

#endregion // ushort4

#region int2

public partial struct int2 : IVectorBitops
    , IBitwiseOperators<int2, int2, int2>
    , IShiftOperators<int2, int, int2>
{
    [MethodImpl(256 | 512)]
    public static int2 operator ~(int2 a)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(~a.vector);
        return new(a.x.BitNot(), a.y.BitNot());
    }

    [MethodImpl(256 | 512)]
    public static int2 operator |(int2 a, int2 b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(a.vector | b.vector);
        return new(a.x.BitOr(b.x), a.y.BitOr(b.y));
    }

    [MethodImpl(256 | 512)]
    public static int2 operator &(int2 a, int2 b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(a.vector & b.vector);
        return new(a.x.BitAnd(b.x), a.y.BitAnd(b.y));
    }

    [MethodImpl(256 | 512)]
    public static int2 operator ^(int2 a, int2 b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(a.vector ^ b.vector);
        return new(a.x.BitXor(b.x), a.y.BitXor(b.y));
    }

    [MethodImpl(256 | 512)]
    public static int2 operator <<(int2 a, int b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(a.vector << b);
        return new(a.x.BitShiftLeft(b), a.y.BitShiftLeft(b));
    }

    [MethodImpl(256 | 512)]
    public static int2 operator >>(int2 a, int b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(a.vector >> b);
        return new(a.x.BitShiftRight(b), a.y.BitShiftRight(b));
    }

    [MethodImpl(256 | 512)]
    public static int2 operator >>>(int2 a, int b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(a.vector >>> b);
        return new(a.x.BitShiftRightUnsigned(b), a.y.BitShiftRightUnsigned(b));
    }

    [MethodImpl(256 | 512)]
    public static int2 operator <<(int2 a, uint2 b)
    {
        return new(a.x.BitShiftLeft((int)b.x), a.y.BitShiftLeft((int)b.y));
    }

    [MethodImpl(256 | 512)]
    public static int2 operator >>(int2 a, uint2 b)
    {
        return new(a.x.BitShiftRight((int)b.x), a.y.BitShiftRight((int)b.y));
    }

    [MethodImpl(256 | 512)]
    public static int2 operator >>>(int2 a, uint2 b)
    {
        return new(a.x.BitShiftRightUnsigned((int)b.x), a.y.BitShiftRightUnsigned((int)b.y));
    }
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static int2 andnot(this int2 a, int2 b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(Vector64.AndNot(a.vector, b.vector));
        return new(a.x.andnot(b.x), a.y.andnot(b.y));
    }

    [MethodImpl(256 | 512)]
    public static int2 popcnt(this int2 a)
    {
        return new(a.x.asu().popcnt(), a.y.asu().popcnt());
    }

    [MethodImpl(256 | 512)]
    public static int2 lzcnt(this int2 a)
    {
        return new(a.x.asu().lzcnt(), a.y.asu().lzcnt());
    }

    [MethodImpl(256 | 512)]
    public static int2 tzcnt(this int2 a)
    {
        return new(a.x.asu().tzcnt(), a.y.asu().tzcnt());
    }
}

#endregion // int2

#region int3

public partial struct int3 : IVectorBitops
    , IBitwiseOperators<int3, int3, int3>
    , IShiftOperators<int3, int, int3>
{
    [MethodImpl(256 | 512)]
    public static int3 operator ~(int3 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(~a.vector & Vector128.Create(-1, -1, -1, 0).AsInt32());
        return new(a.x.BitNot(), a.y.BitNot(), a.z.BitNot());
    }

    [MethodImpl(256 | 512)]
    public static int3 operator |(int3 a, int3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector | b.vector);
        return new(a.x.BitOr(b.x), a.y.BitOr(b.y), a.z.BitOr(b.z));
    }

    [MethodImpl(256 | 512)]
    public static int3 operator &(int3 a, int3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector & b.vector);
        return new(a.x.BitAnd(b.x), a.y.BitAnd(b.y), a.z.BitAnd(b.z));
    }

    [MethodImpl(256 | 512)]
    public static int3 operator ^(int3 a, int3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector ^ b.vector);
        return new(a.x.BitXor(b.x), a.y.BitXor(b.y), a.z.BitXor(b.z));
    }

    [MethodImpl(256 | 512)]
    public static int3 operator <<(int3 a, int b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector << b);
        return new(a.x.BitShiftLeft(b), a.y.BitShiftLeft(b), a.z.BitShiftLeft(b));
    }

    [MethodImpl(256 | 512)]
    public static int3 operator >>(int3 a, int b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector >> b);
        return new(a.x.BitShiftRight(b), a.y.BitShiftRight(b), a.z.BitShiftRight(b));
    }

    [MethodImpl(256 | 512)]
    public static int3 operator >>>(int3 a, int b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector >>> b);
        return new(a.x.BitShiftRightUnsigned(b), a.y.BitShiftRightUnsigned(b), a.z.BitShiftRightUnsigned(b));
    }

    [MethodImpl(256 | 512)]
    public static int3 operator <<(int3 a, uint3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.ShiftLeft(a.vector.AsUInt32(), b.vector, true).AsInt32());
        return new(a.x.BitShiftLeft((int)b.x), a.y.BitShiftLeft((int)b.y), a.z.BitShiftLeft((int)b.z));
    }

    [MethodImpl(256 | 512)]
    public static int3 operator >>(int3 a, uint3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.ShiftRight(a.vector.AsInt32(), b.vector, true).AsInt32());
        return new(a.x.BitShiftRight((int)b.x), a.y.BitShiftRight((int)b.y), a.z.BitShiftRight((int)b.z));
    }

    [MethodImpl(256 | 512)]
    public static int3 operator >>>(int3 a, uint3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.ShiftRight(a.vector.AsUInt32(), b.vector, true).AsInt32());
        return new(a.x.BitShiftRightUnsigned((int)b.x), a.y.BitShiftRightUnsigned((int)b.y), a.z.BitShiftRightUnsigned((int)b.z));
    }
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static int3 andnot(this int3 a, int3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.AndNot(a.vector, b.vector) & Vector128.Create(-1, -1, -1, 0).AsInt32());
        return new(a.x.andnot(b.x), a.y.andnot(b.y), a.z.andnot(b.z));
    }

    [MethodImpl(256 | 512)]
    public static int3 popcnt(this int3 a)
    {
        return new(a.x.asu().popcnt(), a.y.asu().popcnt(), a.z.asu().popcnt());
    }

    [MethodImpl(256 | 512)]
    public static int3 lzcnt(this int3 a)
    {
        return new(a.x.asu().lzcnt(), a.y.asu().lzcnt(), a.z.asu().lzcnt());
    }

    [MethodImpl(256 | 512)]
    public static int3 tzcnt(this int3 a)
    {
        return new(a.x.asu().tzcnt(), a.y.asu().tzcnt(), a.z.asu().tzcnt());
    }
}

#endregion // int3

#region int4

public partial struct int4 : IVectorBitops
    , IBitwiseOperators<int4, int4, int4>
    , IShiftOperators<int4, int, int4>
{
    [MethodImpl(256 | 512)]
    public static int4 operator ~(int4 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(~a.vector);
        return new(a.x.BitNot(), a.y.BitNot(), a.z.BitNot(), a.w.BitNot());
    }

    [MethodImpl(256 | 512)]
    public static int4 operator |(int4 a, int4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector | b.vector);
        return new(a.x.BitOr(b.x), a.y.BitOr(b.y), a.z.BitOr(b.z), a.w.BitOr(b.w));
    }

    [MethodImpl(256 | 512)]
    public static int4 operator &(int4 a, int4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector & b.vector);
        return new(a.x.BitAnd(b.x), a.y.BitAnd(b.y), a.z.BitAnd(b.z), a.w.BitAnd(b.w));
    }

    [MethodImpl(256 | 512)]
    public static int4 operator ^(int4 a, int4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector ^ b.vector);
        return new(a.x.BitXor(b.x), a.y.BitXor(b.y), a.z.BitXor(b.z), a.w.BitXor(b.w));
    }

    [MethodImpl(256 | 512)]
    public static int4 operator <<(int4 a, int b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector << b);
        return new(a.x.BitShiftLeft(b), a.y.BitShiftLeft(b), a.z.BitShiftLeft(b), a.w.BitShiftLeft(b));
    }

    [MethodImpl(256 | 512)]
    public static int4 operator >>(int4 a, int b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector >> b);
        return new(a.x.BitShiftRight(b), a.y.BitShiftRight(b), a.z.BitShiftRight(b), a.w.BitShiftRight(b));
    }

    [MethodImpl(256 | 512)]
    public static int4 operator >>>(int4 a, int b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector >>> b);
        return new(a.x.BitShiftRightUnsigned(b), a.y.BitShiftRightUnsigned(b), a.z.BitShiftRightUnsigned(b), a.w.BitShiftRightUnsigned(b));
    }

    [MethodImpl(256 | 512)]
    public static int4 operator <<(int4 a, uint4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.ShiftLeft(a.vector.AsUInt32(), b.vector).AsInt32());
        return new(a.x.BitShiftLeft((int)b.x), a.y.BitShiftLeft((int)b.y), a.z.BitShiftLeft((int)b.z), a.w.BitShiftLeft((int)b.w));
    }

    [MethodImpl(256 | 512)]
    public static int4 operator >>(int4 a, uint4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.ShiftRight(a.vector.AsInt32(), b.vector).AsInt32());
        return new(a.x.BitShiftRight((int)b.x), a.y.BitShiftRight((int)b.y), a.z.BitShiftRight((int)b.z), a.w.BitShiftRight((int)b.w));
    }

    [MethodImpl(256 | 512)]
    public static int4 operator >>>(int4 a, uint4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.ShiftRight(a.vector.AsUInt32(), b.vector).AsInt32());
        return new(a.x.BitShiftRightUnsigned((int)b.x), a.y.BitShiftRightUnsigned((int)b.y), a.z.BitShiftRightUnsigned((int)b.z), a.w.BitShiftRightUnsigned((int)b.w));
    }
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static int4 andnot(this int4 a, int4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.AndNot(a.vector, b.vector));
        return new(a.x.andnot(b.x), a.y.andnot(b.y), a.z.andnot(b.z), a.w.andnot(b.w));
    }

    [MethodImpl(256 | 512)]
    public static int4 popcnt(this int4 a)
    {
        return new(a.x.asu().popcnt(), a.y.asu().popcnt(), a.z.asu().popcnt(), a.w.asu().popcnt());
    }

    [MethodImpl(256 | 512)]
    public static int4 lzcnt(this int4 a)
    {
        return new(a.x.asu().lzcnt(), a.y.asu().lzcnt(), a.z.asu().lzcnt(), a.w.asu().lzcnt());
    }

    [MethodImpl(256 | 512)]
    public static int4 tzcnt(this int4 a)
    {
        return new(a.x.asu().tzcnt(), a.y.asu().tzcnt(), a.z.asu().tzcnt(), a.w.asu().tzcnt());
    }
}

#endregion // int4

#region uint2

public partial struct uint2 : IVectorBitops
    , IBitwiseOperators<uint2, uint2, uint2>
    , IShiftOperators<uint2, int, uint2>
{
    [MethodImpl(256 | 512)]
    public static uint2 operator ~(uint2 a)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(~a.vector);
        return new(a.x.BitNot(), a.y.BitNot());
    }

    [MethodImpl(256 | 512)]
    public static uint2 operator |(uint2 a, uint2 b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(a.vector | b.vector);
        return new(a.x.BitOr(b.x), a.y.BitOr(b.y));
    }

    [MethodImpl(256 | 512)]
    public static uint2 operator &(uint2 a, uint2 b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(a.vector & b.vector);
        return new(a.x.BitAnd(b.x), a.y.BitAnd(b.y));
    }

    [MethodImpl(256 | 512)]
    public static uint2 operator ^(uint2 a, uint2 b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(a.vector ^ b.vector);
        return new(a.x.BitXor(b.x), a.y.BitXor(b.y));
    }

    [MethodImpl(256 | 512)]
    public static uint2 operator <<(uint2 a, int b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(a.vector << b);
        return new(a.x.BitShiftLeft(b), a.y.BitShiftLeft(b));
    }

    [MethodImpl(256 | 512)]
    public static uint2 operator >>(uint2 a, int b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(a.vector >> b);
        return new(a.x.BitShiftRight(b), a.y.BitShiftRight(b));
    }

    [MethodImpl(256 | 512)]
    public static uint2 operator >>>(uint2 a, int b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(a.vector >>> b);
        return new(a.x.BitShiftRightUnsigned(b), a.y.BitShiftRightUnsigned(b));
    }

    [MethodImpl(256 | 512)]
    public static uint2 operator <<(uint2 a, uint2 b)
    {
        return new(a.x.BitShiftLeft((int)b.x), a.y.BitShiftLeft((int)b.y));
    }

    [MethodImpl(256 | 512)]
    public static uint2 operator >>(uint2 a, uint2 b)
    {
        return new(a.x.BitShiftRight((int)b.x), a.y.BitShiftRight((int)b.y));
    }

    [MethodImpl(256 | 512)]
    public static uint2 operator >>>(uint2 a, uint2 b)
    {
        return new(a.x.BitShiftRightUnsigned((int)b.x), a.y.BitShiftRightUnsigned((int)b.y));
    }
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static uint2 andnot(this uint2 a, uint2 b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(Vector64.AndNot(a.vector, b.vector));
        return new(a.x.andnot(b.x), a.y.andnot(b.y));
    }

    [MethodImpl(256 | 512)]
    public static int2 popcnt(this uint2 a)
    {
        return new(a.x.asu().popcnt(), a.y.asu().popcnt());
    }

    [MethodImpl(256 | 512)]
    public static int2 lzcnt(this uint2 a)
    {
        return new(a.x.asu().lzcnt(), a.y.asu().lzcnt());
    }

    [MethodImpl(256 | 512)]
    public static int2 tzcnt(this uint2 a)
    {
        return new(a.x.asu().tzcnt(), a.y.asu().tzcnt());
    }
}

#endregion // uint2

#region uint3

public partial struct uint3 : IVectorBitops
    , IBitwiseOperators<uint3, uint3, uint3>
    , IShiftOperators<uint3, int, uint3>
{
    [MethodImpl(256 | 512)]
    public static uint3 operator ~(uint3 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(~a.vector & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        return new(a.x.BitNot(), a.y.BitNot(), a.z.BitNot());
    }

    [MethodImpl(256 | 512)]
    public static uint3 operator |(uint3 a, uint3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector | b.vector);
        return new(a.x.BitOr(b.x), a.y.BitOr(b.y), a.z.BitOr(b.z));
    }

    [MethodImpl(256 | 512)]
    public static uint3 operator &(uint3 a, uint3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector & b.vector);
        return new(a.x.BitAnd(b.x), a.y.BitAnd(b.y), a.z.BitAnd(b.z));
    }

    [MethodImpl(256 | 512)]
    public static uint3 operator ^(uint3 a, uint3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector ^ b.vector);
        return new(a.x.BitXor(b.x), a.y.BitXor(b.y), a.z.BitXor(b.z));
    }

    [MethodImpl(256 | 512)]
    public static uint3 operator <<(uint3 a, int b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector << b);
        return new(a.x.BitShiftLeft(b), a.y.BitShiftLeft(b), a.z.BitShiftLeft(b));
    }

    [MethodImpl(256 | 512)]
    public static uint3 operator >>(uint3 a, int b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector >> b);
        return new(a.x.BitShiftRight(b), a.y.BitShiftRight(b), a.z.BitShiftRight(b));
    }

    [MethodImpl(256 | 512)]
    public static uint3 operator >>>(uint3 a, int b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector >>> b);
        return new(a.x.BitShiftRightUnsigned(b), a.y.BitShiftRightUnsigned(b), a.z.BitShiftRightUnsigned(b));
    }

    [MethodImpl(256 | 512)]
    public static uint3 operator <<(uint3 a, uint3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.ShiftLeft(a.vector.AsUInt32(), b.vector, true).AsUInt32());
        return new(a.x.BitShiftLeft((int)b.x), a.y.BitShiftLeft((int)b.y), a.z.BitShiftLeft((int)b.z));
    }

    [MethodImpl(256 | 512)]
    public static uint3 operator >>(uint3 a, uint3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.ShiftRight(a.vector.AsUInt32(), b.vector, true).AsUInt32());
        return new(a.x.BitShiftRight((int)b.x), a.y.BitShiftRight((int)b.y), a.z.BitShiftRight((int)b.z));
    }

    [MethodImpl(256 | 512)]
    public static uint3 operator >>>(uint3 a, uint3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.ShiftRight(a.vector.AsUInt32(), b.vector, true).AsUInt32());
        return new(a.x.BitShiftRightUnsigned((int)b.x), a.y.BitShiftRightUnsigned((int)b.y), a.z.BitShiftRightUnsigned((int)b.z));
    }
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static uint3 andnot(this uint3 a, uint3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.AndNot(a.vector, b.vector) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        return new(a.x.andnot(b.x), a.y.andnot(b.y), a.z.andnot(b.z));
    }

    [MethodImpl(256 | 512)]
    public static int3 popcnt(this uint3 a)
    {
        return new(a.x.asu().popcnt(), a.y.asu().popcnt(), a.z.asu().popcnt());
    }

    [MethodImpl(256 | 512)]
    public static int3 lzcnt(this uint3 a)
    {
        return new(a.x.asu().lzcnt(), a.y.asu().lzcnt(), a.z.asu().lzcnt());
    }

    [MethodImpl(256 | 512)]
    public static int3 tzcnt(this uint3 a)
    {
        return new(a.x.asu().tzcnt(), a.y.asu().tzcnt(), a.z.asu().tzcnt());
    }
}

#endregion // uint3

#region uint4

public partial struct uint4 : IVectorBitops
    , IBitwiseOperators<uint4, uint4, uint4>
    , IShiftOperators<uint4, int, uint4>
{
    [MethodImpl(256 | 512)]
    public static uint4 operator ~(uint4 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(~a.vector);
        return new(a.x.BitNot(), a.y.BitNot(), a.z.BitNot(), a.w.BitNot());
    }

    [MethodImpl(256 | 512)]
    public static uint4 operator |(uint4 a, uint4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector | b.vector);
        return new(a.x.BitOr(b.x), a.y.BitOr(b.y), a.z.BitOr(b.z), a.w.BitOr(b.w));
    }

    [MethodImpl(256 | 512)]
    public static uint4 operator &(uint4 a, uint4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector & b.vector);
        return new(a.x.BitAnd(b.x), a.y.BitAnd(b.y), a.z.BitAnd(b.z), a.w.BitAnd(b.w));
    }

    [MethodImpl(256 | 512)]
    public static uint4 operator ^(uint4 a, uint4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector ^ b.vector);
        return new(a.x.BitXor(b.x), a.y.BitXor(b.y), a.z.BitXor(b.z), a.w.BitXor(b.w));
    }

    [MethodImpl(256 | 512)]
    public static uint4 operator <<(uint4 a, int b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector << b);
        return new(a.x.BitShiftLeft(b), a.y.BitShiftLeft(b), a.z.BitShiftLeft(b), a.w.BitShiftLeft(b));
    }

    [MethodImpl(256 | 512)]
    public static uint4 operator >>(uint4 a, int b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector >> b);
        return new(a.x.BitShiftRight(b), a.y.BitShiftRight(b), a.z.BitShiftRight(b), a.w.BitShiftRight(b));
    }

    [MethodImpl(256 | 512)]
    public static uint4 operator >>>(uint4 a, int b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector >>> b);
        return new(a.x.BitShiftRightUnsigned(b), a.y.BitShiftRightUnsigned(b), a.z.BitShiftRightUnsigned(b), a.w.BitShiftRightUnsigned(b));
    }

    [MethodImpl(256 | 512)]
    public static uint4 operator <<(uint4 a, uint4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.ShiftLeft(a.vector.AsUInt32(), b.vector).AsUInt32());
        return new(a.x.BitShiftLeft((int)b.x), a.y.BitShiftLeft((int)b.y), a.z.BitShiftLeft((int)b.z), a.w.BitShiftLeft((int)b.w));
    }

    [MethodImpl(256 | 512)]
    public static uint4 operator >>(uint4 a, uint4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.ShiftRight(a.vector.AsUInt32(), b.vector).AsUInt32());
        return new(a.x.BitShiftRight((int)b.x), a.y.BitShiftRight((int)b.y), a.z.BitShiftRight((int)b.z), a.w.BitShiftRight((int)b.w));
    }

    [MethodImpl(256 | 512)]
    public static uint4 operator >>>(uint4 a, uint4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.ShiftRight(a.vector.AsUInt32(), b.vector).AsUInt32());
        return new(a.x.BitShiftRightUnsigned((int)b.x), a.y.BitShiftRightUnsigned((int)b.y), a.z.BitShiftRightUnsigned((int)b.z), a.w.BitShiftRightUnsigned((int)b.w));
    }
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static uint4 andnot(this uint4 a, uint4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.AndNot(a.vector, b.vector));
        return new(a.x.andnot(b.x), a.y.andnot(b.y), a.z.andnot(b.z), a.w.andnot(b.w));
    }

    [MethodImpl(256 | 512)]
    public static int4 popcnt(this uint4 a)
    {
        return new(a.x.asu().popcnt(), a.y.asu().popcnt(), a.z.asu().popcnt(), a.w.asu().popcnt());
    }

    [MethodImpl(256 | 512)]
    public static int4 lzcnt(this uint4 a)
    {
        return new(a.x.asu().lzcnt(), a.y.asu().lzcnt(), a.z.asu().lzcnt(), a.w.asu().lzcnt());
    }

    [MethodImpl(256 | 512)]
    public static int4 tzcnt(this uint4 a)
    {
        return new(a.x.asu().tzcnt(), a.y.asu().tzcnt(), a.z.asu().tzcnt(), a.w.asu().tzcnt());
    }
}

#endregion // uint4

#region long2

public partial struct long2 : IVectorBitops
    , IBitwiseOperators<long2, long2, long2>
    , IShiftOperators<long2, int, long2>
{
    [MethodImpl(256 | 512)]
    public static long2 operator ~(long2 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(~a.vector);
        return new(a.x.BitNot(), a.y.BitNot());
    }

    [MethodImpl(256 | 512)]
    public static long2 operator |(long2 a, long2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector | b.vector);
        return new(a.x.BitOr(b.x), a.y.BitOr(b.y));
    }

    [MethodImpl(256 | 512)]
    public static long2 operator &(long2 a, long2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector & b.vector);
        return new(a.x.BitAnd(b.x), a.y.BitAnd(b.y));
    }

    [MethodImpl(256 | 512)]
    public static long2 operator ^(long2 a, long2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector ^ b.vector);
        return new(a.x.BitXor(b.x), a.y.BitXor(b.y));
    }

    [MethodImpl(256 | 512)]
    public static long2 operator <<(long2 a, int b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector << b);
        return new(a.x.BitShiftLeft(b), a.y.BitShiftLeft(b));
    }

    [MethodImpl(256 | 512)]
    public static long2 operator >>(long2 a, int b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector >> b);
        return new(a.x.BitShiftRight(b), a.y.BitShiftRight(b));
    }

    [MethodImpl(256 | 512)]
    public static long2 operator >>>(long2 a, int b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector >>> b);
        return new(a.x.BitShiftRightUnsigned(b), a.y.BitShiftRightUnsigned(b));
    }

    [MethodImpl(256 | 512)]
    public static long2 operator <<(long2 a, ulong2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.ShiftLeft(a.vector.AsUInt64(), b.vector).AsInt64());
        return new(a.x.BitShiftLeft((int)b.x), a.y.BitShiftLeft((int)b.y));
    }

    [MethodImpl(256 | 512)]
    public static long2 operator >>(long2 a, ulong2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.ShiftRight(a.vector.AsInt64(), b.vector).AsInt64());
        return new(a.x.BitShiftRight((int)b.x), a.y.BitShiftRight((int)b.y));
    }

    [MethodImpl(256 | 512)]
    public static long2 operator >>>(long2 a, ulong2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.ShiftRight(a.vector.AsUInt64(), b.vector).AsInt64());
        return new(a.x.BitShiftRightUnsigned((int)b.x), a.y.BitShiftRightUnsigned((int)b.y));
    }
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static long2 andnot(this long2 a, long2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.AndNot(a.vector, b.vector));
        return new(a.x.andnot(b.x), a.y.andnot(b.y));
    }

    [MethodImpl(256 | 512)]
    public static long2 popcnt(this long2 a)
    {
        return new(a.x.asu().popcnt(), a.y.asu().popcnt());
    }

    [MethodImpl(256 | 512)]
    public static long2 lzcnt(this long2 a)
    {
        return new(a.x.asu().lzcnt(), a.y.asu().lzcnt());
    }

    [MethodImpl(256 | 512)]
    public static long2 tzcnt(this long2 a)
    {
        return new(a.x.asu().tzcnt(), a.y.asu().tzcnt());
    }
}

#endregion // long2

#region long3

public partial struct long3 : IVectorBitops
    , IBitwiseOperators<long3, long3, long3>
    , IShiftOperators<long3, int, long3>
{
    [MethodImpl(256 | 512)]
    public static long3 operator ~(long3 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(~a.vector & Vector256.Create(-1, -1, -1, 0).AsInt64());
        return new(a.x.BitNot(), a.y.BitNot(), a.z.BitNot());
    }

    [MethodImpl(256 | 512)]
    public static long3 operator |(long3 a, long3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector | b.vector);
        return new(a.x.BitOr(b.x), a.y.BitOr(b.y), a.z.BitOr(b.z));
    }

    [MethodImpl(256 | 512)]
    public static long3 operator &(long3 a, long3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector & b.vector);
        return new(a.x.BitAnd(b.x), a.y.BitAnd(b.y), a.z.BitAnd(b.z));
    }

    [MethodImpl(256 | 512)]
    public static long3 operator ^(long3 a, long3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector ^ b.vector);
        return new(a.x.BitXor(b.x), a.y.BitXor(b.y), a.z.BitXor(b.z));
    }

    [MethodImpl(256 | 512)]
    public static long3 operator <<(long3 a, int b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector << b);
        return new(a.x.BitShiftLeft(b), a.y.BitShiftLeft(b), a.z.BitShiftLeft(b));
    }

    [MethodImpl(256 | 512)]
    public static long3 operator >>(long3 a, int b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector >> b);
        return new(a.x.BitShiftRight(b), a.y.BitShiftRight(b), a.z.BitShiftRight(b));
    }

    [MethodImpl(256 | 512)]
    public static long3 operator >>>(long3 a, int b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector >>> b);
        return new(a.x.BitShiftRightUnsigned(b), a.y.BitShiftRightUnsigned(b), a.z.BitShiftRightUnsigned(b));
    }

    [MethodImpl(256 | 512)]
    public static long3 operator <<(long3 a, ulong3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.ShiftLeft(a.vector.AsUInt64(), b.vector, true).AsInt64());
        return new(a.x.BitShiftLeft((int)b.x), a.y.BitShiftLeft((int)b.y), a.z.BitShiftLeft((int)b.z));
    }

    [MethodImpl(256 | 512)]
    public static long3 operator >>(long3 a, ulong3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.ShiftRight(a.vector.AsInt64(), b.vector, true).AsInt64());
        return new(a.x.BitShiftRight((int)b.x), a.y.BitShiftRight((int)b.y), a.z.BitShiftRight((int)b.z));
    }

    [MethodImpl(256 | 512)]
    public static long3 operator >>>(long3 a, ulong3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.ShiftRight(a.vector.AsUInt64(), b.vector, true).AsInt64());
        return new(a.x.BitShiftRightUnsigned((int)b.x), a.y.BitShiftRightUnsigned((int)b.y), a.z.BitShiftRightUnsigned((int)b.z));
    }
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static long3 andnot(this long3 a, long3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(Vector256.AndNot(a.vector, b.vector) & Vector256.Create(-1, -1, -1, 0).AsInt64());
        return new(a.x.andnot(b.x), a.y.andnot(b.y), a.z.andnot(b.z));
    }

    [MethodImpl(256 | 512)]
    public static long3 popcnt(this long3 a)
    {
        return new(a.x.asu().popcnt(), a.y.asu().popcnt(), a.z.asu().popcnt());
    }

    [MethodImpl(256 | 512)]
    public static long3 lzcnt(this long3 a)
    {
        return new(a.x.asu().lzcnt(), a.y.asu().lzcnt(), a.z.asu().lzcnt());
    }

    [MethodImpl(256 | 512)]
    public static long3 tzcnt(this long3 a)
    {
        return new(a.x.asu().tzcnt(), a.y.asu().tzcnt(), a.z.asu().tzcnt());
    }
}

#endregion // long3

#region long4

public partial struct long4 : IVectorBitops
    , IBitwiseOperators<long4, long4, long4>
    , IShiftOperators<long4, int, long4>
{
    [MethodImpl(256 | 512)]
    public static long4 operator ~(long4 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(~a.vector);
        return new(a.x.BitNot(), a.y.BitNot(), a.z.BitNot(), a.w.BitNot());
    }

    [MethodImpl(256 | 512)]
    public static long4 operator |(long4 a, long4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector | b.vector);
        return new(a.x.BitOr(b.x), a.y.BitOr(b.y), a.z.BitOr(b.z), a.w.BitOr(b.w));
    }

    [MethodImpl(256 | 512)]
    public static long4 operator &(long4 a, long4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector & b.vector);
        return new(a.x.BitAnd(b.x), a.y.BitAnd(b.y), a.z.BitAnd(b.z), a.w.BitAnd(b.w));
    }

    [MethodImpl(256 | 512)]
    public static long4 operator ^(long4 a, long4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector ^ b.vector);
        return new(a.x.BitXor(b.x), a.y.BitXor(b.y), a.z.BitXor(b.z), a.w.BitXor(b.w));
    }

    [MethodImpl(256 | 512)]
    public static long4 operator <<(long4 a, int b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector << b);
        return new(a.x.BitShiftLeft(b), a.y.BitShiftLeft(b), a.z.BitShiftLeft(b), a.w.BitShiftLeft(b));
    }

    [MethodImpl(256 | 512)]
    public static long4 operator >>(long4 a, int b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector >> b);
        return new(a.x.BitShiftRight(b), a.y.BitShiftRight(b), a.z.BitShiftRight(b), a.w.BitShiftRight(b));
    }

    [MethodImpl(256 | 512)]
    public static long4 operator >>>(long4 a, int b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector >>> b);
        return new(a.x.BitShiftRightUnsigned(b), a.y.BitShiftRightUnsigned(b), a.z.BitShiftRightUnsigned(b), a.w.BitShiftRightUnsigned(b));
    }

    [MethodImpl(256 | 512)]
    public static long4 operator <<(long4 a, ulong4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.ShiftLeft(a.vector.AsUInt64(), b.vector).AsInt64());
        return new(a.x.BitShiftLeft((int)b.x), a.y.BitShiftLeft((int)b.y), a.z.BitShiftLeft((int)b.z), a.w.BitShiftLeft((int)b.w));
    }

    [MethodImpl(256 | 512)]
    public static long4 operator >>(long4 a, ulong4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.ShiftRight(a.vector.AsInt64(), b.vector).AsInt64());
        return new(a.x.BitShiftRight((int)b.x), a.y.BitShiftRight((int)b.y), a.z.BitShiftRight((int)b.z), a.w.BitShiftRight((int)b.w));
    }

    [MethodImpl(256 | 512)]
    public static long4 operator >>>(long4 a, ulong4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.ShiftRight(a.vector.AsUInt64(), b.vector).AsInt64());
        return new(a.x.BitShiftRightUnsigned((int)b.x), a.y.BitShiftRightUnsigned((int)b.y), a.z.BitShiftRightUnsigned((int)b.z), a.w.BitShiftRightUnsigned((int)b.w));
    }
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static long4 andnot(this long4 a, long4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(Vector256.AndNot(a.vector, b.vector));
        return new(a.x.andnot(b.x), a.y.andnot(b.y), a.z.andnot(b.z), a.w.andnot(b.w));
    }

    [MethodImpl(256 | 512)]
    public static long4 popcnt(this long4 a)
    {
        return new(a.x.asu().popcnt(), a.y.asu().popcnt(), a.z.asu().popcnt(), a.w.asu().popcnt());
    }

    [MethodImpl(256 | 512)]
    public static long4 lzcnt(this long4 a)
    {
        return new(a.x.asu().lzcnt(), a.y.asu().lzcnt(), a.z.asu().lzcnt(), a.w.asu().lzcnt());
    }

    [MethodImpl(256 | 512)]
    public static long4 tzcnt(this long4 a)
    {
        return new(a.x.asu().tzcnt(), a.y.asu().tzcnt(), a.z.asu().tzcnt(), a.w.asu().tzcnt());
    }
}

#endregion // long4

#region ulong2

public partial struct ulong2 : IVectorBitops
    , IBitwiseOperators<ulong2, ulong2, ulong2>
    , IShiftOperators<ulong2, int, ulong2>
{
    [MethodImpl(256 | 512)]
    public static ulong2 operator ~(ulong2 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(~a.vector);
        return new(a.x.BitNot(), a.y.BitNot());
    }

    [MethodImpl(256 | 512)]
    public static ulong2 operator |(ulong2 a, ulong2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector | b.vector);
        return new(a.x.BitOr(b.x), a.y.BitOr(b.y));
    }

    [MethodImpl(256 | 512)]
    public static ulong2 operator &(ulong2 a, ulong2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector & b.vector);
        return new(a.x.BitAnd(b.x), a.y.BitAnd(b.y));
    }

    [MethodImpl(256 | 512)]
    public static ulong2 operator ^(ulong2 a, ulong2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector ^ b.vector);
        return new(a.x.BitXor(b.x), a.y.BitXor(b.y));
    }

    [MethodImpl(256 | 512)]
    public static ulong2 operator <<(ulong2 a, int b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector << b);
        return new(a.x.BitShiftLeft(b), a.y.BitShiftLeft(b));
    }

    [MethodImpl(256 | 512)]
    public static ulong2 operator >>(ulong2 a, int b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector >> b);
        return new(a.x.BitShiftRight(b), a.y.BitShiftRight(b));
    }

    [MethodImpl(256 | 512)]
    public static ulong2 operator >>>(ulong2 a, int b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector >>> b);
        return new(a.x.BitShiftRightUnsigned(b), a.y.BitShiftRightUnsigned(b));
    }

    [MethodImpl(256 | 512)]
    public static ulong2 operator <<(ulong2 a, ulong2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.ShiftLeft(a.vector.AsUInt64(), b.vector).AsUInt64());
        return new(a.x.BitShiftLeft((int)b.x), a.y.BitShiftLeft((int)b.y));
    }

    [MethodImpl(256 | 512)]
    public static ulong2 operator >>(ulong2 a, ulong2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.ShiftRight(a.vector.AsUInt64(), b.vector).AsUInt64());
        return new(a.x.BitShiftRight((int)b.x), a.y.BitShiftRight((int)b.y));
    }

    [MethodImpl(256 | 512)]
    public static ulong2 operator >>>(ulong2 a, ulong2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.ShiftRight(a.vector.AsUInt64(), b.vector).AsUInt64());
        return new(a.x.BitShiftRightUnsigned((int)b.x), a.y.BitShiftRightUnsigned((int)b.y));
    }
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ulong2 andnot(this ulong2 a, ulong2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.AndNot(a.vector, b.vector));
        return new(a.x.andnot(b.x), a.y.andnot(b.y));
    }

    [MethodImpl(256 | 512)]
    public static long2 popcnt(this ulong2 a)
    {
        return new(a.x.asu().popcnt(), a.y.asu().popcnt());
    }

    [MethodImpl(256 | 512)]
    public static long2 lzcnt(this ulong2 a)
    {
        return new(a.x.asu().lzcnt(), a.y.asu().lzcnt());
    }

    [MethodImpl(256 | 512)]
    public static long2 tzcnt(this ulong2 a)
    {
        return new(a.x.asu().tzcnt(), a.y.asu().tzcnt());
    }
}

#endregion // ulong2

#region ulong3

public partial struct ulong3 : IVectorBitops
    , IBitwiseOperators<ulong3, ulong3, ulong3>
    , IShiftOperators<ulong3, int, ulong3>
{
    [MethodImpl(256 | 512)]
    public static ulong3 operator ~(ulong3 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(~a.vector & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        return new(a.x.BitNot(), a.y.BitNot(), a.z.BitNot());
    }

    [MethodImpl(256 | 512)]
    public static ulong3 operator |(ulong3 a, ulong3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector | b.vector);
        return new(a.x.BitOr(b.x), a.y.BitOr(b.y), a.z.BitOr(b.z));
    }

    [MethodImpl(256 | 512)]
    public static ulong3 operator &(ulong3 a, ulong3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector & b.vector);
        return new(a.x.BitAnd(b.x), a.y.BitAnd(b.y), a.z.BitAnd(b.z));
    }

    [MethodImpl(256 | 512)]
    public static ulong3 operator ^(ulong3 a, ulong3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector ^ b.vector);
        return new(a.x.BitXor(b.x), a.y.BitXor(b.y), a.z.BitXor(b.z));
    }

    [MethodImpl(256 | 512)]
    public static ulong3 operator <<(ulong3 a, int b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector << b);
        return new(a.x.BitShiftLeft(b), a.y.BitShiftLeft(b), a.z.BitShiftLeft(b));
    }

    [MethodImpl(256 | 512)]
    public static ulong3 operator >>(ulong3 a, int b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector >> b);
        return new(a.x.BitShiftRight(b), a.y.BitShiftRight(b), a.z.BitShiftRight(b));
    }

    [MethodImpl(256 | 512)]
    public static ulong3 operator >>>(ulong3 a, int b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector >>> b);
        return new(a.x.BitShiftRightUnsigned(b), a.y.BitShiftRightUnsigned(b), a.z.BitShiftRightUnsigned(b));
    }

    [MethodImpl(256 | 512)]
    public static ulong3 operator <<(ulong3 a, ulong3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.ShiftLeft(a.vector.AsUInt64(), b.vector, true).AsUInt64());
        return new(a.x.BitShiftLeft((int)b.x), a.y.BitShiftLeft((int)b.y), a.z.BitShiftLeft((int)b.z));
    }

    [MethodImpl(256 | 512)]
    public static ulong3 operator >>(ulong3 a, ulong3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.ShiftRight(a.vector.AsUInt64(), b.vector, true).AsUInt64());
        return new(a.x.BitShiftRight((int)b.x), a.y.BitShiftRight((int)b.y), a.z.BitShiftRight((int)b.z));
    }

    [MethodImpl(256 | 512)]
    public static ulong3 operator >>>(ulong3 a, ulong3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.ShiftRight(a.vector.AsUInt64(), b.vector, true).AsUInt64());
        return new(a.x.BitShiftRightUnsigned((int)b.x), a.y.BitShiftRightUnsigned((int)b.y), a.z.BitShiftRightUnsigned((int)b.z));
    }
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ulong3 andnot(this ulong3 a, ulong3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(Vector256.AndNot(a.vector, b.vector) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        return new(a.x.andnot(b.x), a.y.andnot(b.y), a.z.andnot(b.z));
    }

    [MethodImpl(256 | 512)]
    public static long3 popcnt(this ulong3 a)
    {
        return new(a.x.asu().popcnt(), a.y.asu().popcnt(), a.z.asu().popcnt());
    }

    [MethodImpl(256 | 512)]
    public static long3 lzcnt(this ulong3 a)
    {
        return new(a.x.asu().lzcnt(), a.y.asu().lzcnt(), a.z.asu().lzcnt());
    }

    [MethodImpl(256 | 512)]
    public static long3 tzcnt(this ulong3 a)
    {
        return new(a.x.asu().tzcnt(), a.y.asu().tzcnt(), a.z.asu().tzcnt());
    }
}

#endregion // ulong3

#region ulong4

public partial struct ulong4 : IVectorBitops
    , IBitwiseOperators<ulong4, ulong4, ulong4>
    , IShiftOperators<ulong4, int, ulong4>
{
    [MethodImpl(256 | 512)]
    public static ulong4 operator ~(ulong4 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(~a.vector);
        return new(a.x.BitNot(), a.y.BitNot(), a.z.BitNot(), a.w.BitNot());
    }

    [MethodImpl(256 | 512)]
    public static ulong4 operator |(ulong4 a, ulong4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector | b.vector);
        return new(a.x.BitOr(b.x), a.y.BitOr(b.y), a.z.BitOr(b.z), a.w.BitOr(b.w));
    }

    [MethodImpl(256 | 512)]
    public static ulong4 operator &(ulong4 a, ulong4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector & b.vector);
        return new(a.x.BitAnd(b.x), a.y.BitAnd(b.y), a.z.BitAnd(b.z), a.w.BitAnd(b.w));
    }

    [MethodImpl(256 | 512)]
    public static ulong4 operator ^(ulong4 a, ulong4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector ^ b.vector);
        return new(a.x.BitXor(b.x), a.y.BitXor(b.y), a.z.BitXor(b.z), a.w.BitXor(b.w));
    }

    [MethodImpl(256 | 512)]
    public static ulong4 operator <<(ulong4 a, int b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector << b);
        return new(a.x.BitShiftLeft(b), a.y.BitShiftLeft(b), a.z.BitShiftLeft(b), a.w.BitShiftLeft(b));
    }

    [MethodImpl(256 | 512)]
    public static ulong4 operator >>(ulong4 a, int b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector >> b);
        return new(a.x.BitShiftRight(b), a.y.BitShiftRight(b), a.z.BitShiftRight(b), a.w.BitShiftRight(b));
    }

    [MethodImpl(256 | 512)]
    public static ulong4 operator >>>(ulong4 a, int b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector >>> b);
        return new(a.x.BitShiftRightUnsigned(b), a.y.BitShiftRightUnsigned(b), a.z.BitShiftRightUnsigned(b), a.w.BitShiftRightUnsigned(b));
    }

    [MethodImpl(256 | 512)]
    public static ulong4 operator <<(ulong4 a, ulong4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.ShiftLeft(a.vector.AsUInt64(), b.vector).AsUInt64());
        return new(a.x.BitShiftLeft((int)b.x), a.y.BitShiftLeft((int)b.y), a.z.BitShiftLeft((int)b.z), a.w.BitShiftLeft((int)b.w));
    }

    [MethodImpl(256 | 512)]
    public static ulong4 operator >>(ulong4 a, ulong4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.ShiftRight(a.vector.AsUInt64(), b.vector).AsUInt64());
        return new(a.x.BitShiftRight((int)b.x), a.y.BitShiftRight((int)b.y), a.z.BitShiftRight((int)b.z), a.w.BitShiftRight((int)b.w));
    }

    [MethodImpl(256 | 512)]
    public static ulong4 operator >>>(ulong4 a, ulong4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.ShiftRight(a.vector.AsUInt64(), b.vector).AsUInt64());
        return new(a.x.BitShiftRightUnsigned((int)b.x), a.y.BitShiftRightUnsigned((int)b.y), a.z.BitShiftRightUnsigned((int)b.z), a.w.BitShiftRightUnsigned((int)b.w));
    }
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ulong4 andnot(this ulong4 a, ulong4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(Vector256.AndNot(a.vector, b.vector));
        return new(a.x.andnot(b.x), a.y.andnot(b.y), a.z.andnot(b.z), a.w.andnot(b.w));
    }

    [MethodImpl(256 | 512)]
    public static long4 popcnt(this ulong4 a)
    {
        return new(a.x.asu().popcnt(), a.y.asu().popcnt(), a.z.asu().popcnt(), a.w.asu().popcnt());
    }

    [MethodImpl(256 | 512)]
    public static long4 lzcnt(this ulong4 a)
    {
        return new(a.x.asu().lzcnt(), a.y.asu().lzcnt(), a.z.asu().lzcnt(), a.w.asu().lzcnt());
    }

    [MethodImpl(256 | 512)]
    public static long4 tzcnt(this ulong4 a)
    {
        return new(a.x.asu().tzcnt(), a.y.asu().tzcnt(), a.z.asu().tzcnt(), a.w.asu().tzcnt());
    }
}

#endregion // ulong4

#region half2

public partial struct half2 : IVectorBitops
    , IBitwiseOperators<half2, half2, half2>
    , IShiftOperators<half2, int, half2>
{
    [MethodImpl(256 | 512)]
    public static half2 operator ~(half2 a)
    {
        return new(a.x.BitNot(), a.y.BitNot());
    }

    [MethodImpl(256 | 512)]
    public static half2 operator |(half2 a, half2 b)
    {
        return new(a.x.BitOr(b.x), a.y.BitOr(b.y));
    }

    [MethodImpl(256 | 512)]
    public static half2 operator &(half2 a, half2 b)
    {
        return new(a.x.BitAnd(b.x), a.y.BitAnd(b.y));
    }

    [MethodImpl(256 | 512)]
    public static half2 operator ^(half2 a, half2 b)
    {
        return new(a.x.BitXor(b.x), a.y.BitXor(b.y));
    }

    [MethodImpl(256 | 512)]
    public static half2 operator <<(half2 a, int b)
    {
        return new(a.x.BitShiftLeft(b), a.y.BitShiftLeft(b));
    }

    [MethodImpl(256 | 512)]
    public static half2 operator >>(half2 a, int b)
    {
        return new(a.x.BitShiftRight(b), a.y.BitShiftRight(b));
    }

    [MethodImpl(256 | 512)]
    public static half2 operator >>>(half2 a, int b)
    {
        return new(a.x.BitShiftRightUnsigned(b), a.y.BitShiftRightUnsigned(b));
    }

    [MethodImpl(256 | 512)]
    public static half2 operator <<(half2 a, uint2 b)
    {
        return new(a.x.BitShiftLeft((int)b.x), a.y.BitShiftLeft((int)b.y));
    }

    [MethodImpl(256 | 512)]
    public static half2 operator >>(half2 a, uint2 b)
    {
        return new(a.x.BitShiftRight((int)b.x), a.y.BitShiftRight((int)b.y));
    }

    [MethodImpl(256 | 512)]
    public static half2 operator >>>(half2 a, uint2 b)
    {
        return new(a.x.BitShiftRightUnsigned((int)b.x), a.y.BitShiftRightUnsigned((int)b.y));
    }
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static half2 andnot(this half2 a, half2 b)
    {
        return new(a.x.andnot(b.x), a.y.andnot(b.y));
    }

    [MethodImpl(256 | 512)]
    public static short2 popcnt(this half2 a)
    {
        return new(a.x.asu().popcnt(), a.y.asu().popcnt());
    }

    [MethodImpl(256 | 512)]
    public static short2 lzcnt(this half2 a)
    {
        return new(a.x.asu().lzcnt(), a.y.asu().lzcnt());
    }

    [MethodImpl(256 | 512)]
    public static short2 tzcnt(this half2 a)
    {
        return new(a.x.asu().tzcnt(), a.y.asu().tzcnt());
    }
}

#endregion // half2

#region half3

public partial struct half3 : IVectorBitops
    , IBitwiseOperators<half3, half3, half3>
    , IShiftOperators<half3, int, half3>
{
    [MethodImpl(256 | 512)]
    public static half3 operator ~(half3 a)
    {
        return new(a.x.BitNot(), a.y.BitNot(), a.z.BitNot());
    }

    [MethodImpl(256 | 512)]
    public static half3 operator |(half3 a, half3 b)
    {
        return new(a.x.BitOr(b.x), a.y.BitOr(b.y), a.z.BitOr(b.z));
    }

    [MethodImpl(256 | 512)]
    public static half3 operator &(half3 a, half3 b)
    {
        return new(a.x.BitAnd(b.x), a.y.BitAnd(b.y), a.z.BitAnd(b.z));
    }

    [MethodImpl(256 | 512)]
    public static half3 operator ^(half3 a, half3 b)
    {
        return new(a.x.BitXor(b.x), a.y.BitXor(b.y), a.z.BitXor(b.z));
    }

    [MethodImpl(256 | 512)]
    public static half3 operator <<(half3 a, int b)
    {
        return new(a.x.BitShiftLeft(b), a.y.BitShiftLeft(b), a.z.BitShiftLeft(b));
    }

    [MethodImpl(256 | 512)]
    public static half3 operator >>(half3 a, int b)
    {
        return new(a.x.BitShiftRight(b), a.y.BitShiftRight(b), a.z.BitShiftRight(b));
    }

    [MethodImpl(256 | 512)]
    public static half3 operator >>>(half3 a, int b)
    {
        return new(a.x.BitShiftRightUnsigned(b), a.y.BitShiftRightUnsigned(b), a.z.BitShiftRightUnsigned(b));
    }

    [MethodImpl(256 | 512)]
    public static half3 operator <<(half3 a, uint3 b)
    {
        return new(a.x.BitShiftLeft((int)b.x), a.y.BitShiftLeft((int)b.y), a.z.BitShiftLeft((int)b.z));
    }

    [MethodImpl(256 | 512)]
    public static half3 operator >>(half3 a, uint3 b)
    {
        return new(a.x.BitShiftRight((int)b.x), a.y.BitShiftRight((int)b.y), a.z.BitShiftRight((int)b.z));
    }

    [MethodImpl(256 | 512)]
    public static half3 operator >>>(half3 a, uint3 b)
    {
        return new(a.x.BitShiftRightUnsigned((int)b.x), a.y.BitShiftRightUnsigned((int)b.y), a.z.BitShiftRightUnsigned((int)b.z));
    }
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static half3 andnot(this half3 a, half3 b)
    {
        return new(a.x.andnot(b.x), a.y.andnot(b.y), a.z.andnot(b.z));
    }

    [MethodImpl(256 | 512)]
    public static short3 popcnt(this half3 a)
    {
        return new(a.x.asu().popcnt(), a.y.asu().popcnt(), a.z.asu().popcnt());
    }

    [MethodImpl(256 | 512)]
    public static short3 lzcnt(this half3 a)
    {
        return new(a.x.asu().lzcnt(), a.y.asu().lzcnt(), a.z.asu().lzcnt());
    }

    [MethodImpl(256 | 512)]
    public static short3 tzcnt(this half3 a)
    {
        return new(a.x.asu().tzcnt(), a.y.asu().tzcnt(), a.z.asu().tzcnt());
    }
}

#endregion // half3

#region half4

public partial struct half4 : IVectorBitops
    , IBitwiseOperators<half4, half4, half4>
    , IShiftOperators<half4, int, half4>
{
    [MethodImpl(256 | 512)]
    public static half4 operator ~(half4 a)
    {
        return new(a.x.BitNot(), a.y.BitNot(), a.z.BitNot(), a.w.BitNot());
    }

    [MethodImpl(256 | 512)]
    public static half4 operator |(half4 a, half4 b)
    {
        return new(a.x.BitOr(b.x), a.y.BitOr(b.y), a.z.BitOr(b.z), a.w.BitOr(b.w));
    }

    [MethodImpl(256 | 512)]
    public static half4 operator &(half4 a, half4 b)
    {
        return new(a.x.BitAnd(b.x), a.y.BitAnd(b.y), a.z.BitAnd(b.z), a.w.BitAnd(b.w));
    }

    [MethodImpl(256 | 512)]
    public static half4 operator ^(half4 a, half4 b)
    {
        return new(a.x.BitXor(b.x), a.y.BitXor(b.y), a.z.BitXor(b.z), a.w.BitXor(b.w));
    }

    [MethodImpl(256 | 512)]
    public static half4 operator <<(half4 a, int b)
    {
        return new(a.x.BitShiftLeft(b), a.y.BitShiftLeft(b), a.z.BitShiftLeft(b), a.w.BitShiftLeft(b));
    }

    [MethodImpl(256 | 512)]
    public static half4 operator >>(half4 a, int b)
    {
        return new(a.x.BitShiftRight(b), a.y.BitShiftRight(b), a.z.BitShiftRight(b), a.w.BitShiftRight(b));
    }

    [MethodImpl(256 | 512)]
    public static half4 operator >>>(half4 a, int b)
    {
        return new(a.x.BitShiftRightUnsigned(b), a.y.BitShiftRightUnsigned(b), a.z.BitShiftRightUnsigned(b), a.w.BitShiftRightUnsigned(b));
    }

    [MethodImpl(256 | 512)]
    public static half4 operator <<(half4 a, uint4 b)
    {
        return new(a.x.BitShiftLeft((int)b.x), a.y.BitShiftLeft((int)b.y), a.z.BitShiftLeft((int)b.z), a.w.BitShiftLeft((int)b.w));
    }

    [MethodImpl(256 | 512)]
    public static half4 operator >>(half4 a, uint4 b)
    {
        return new(a.x.BitShiftRight((int)b.x), a.y.BitShiftRight((int)b.y), a.z.BitShiftRight((int)b.z), a.w.BitShiftRight((int)b.w));
    }

    [MethodImpl(256 | 512)]
    public static half4 operator >>>(half4 a, uint4 b)
    {
        return new(a.x.BitShiftRightUnsigned((int)b.x), a.y.BitShiftRightUnsigned((int)b.y), a.z.BitShiftRightUnsigned((int)b.z), a.w.BitShiftRightUnsigned((int)b.w));
    }
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static half4 andnot(this half4 a, half4 b)
    {
        return new(a.x.andnot(b.x), a.y.andnot(b.y), a.z.andnot(b.z), a.w.andnot(b.w));
    }

    [MethodImpl(256 | 512)]
    public static short4 popcnt(this half4 a)
    {
        return new(a.x.asu().popcnt(), a.y.asu().popcnt(), a.z.asu().popcnt(), a.w.asu().popcnt());
    }

    [MethodImpl(256 | 512)]
    public static short4 lzcnt(this half4 a)
    {
        return new(a.x.asu().lzcnt(), a.y.asu().lzcnt(), a.z.asu().lzcnt(), a.w.asu().lzcnt());
    }

    [MethodImpl(256 | 512)]
    public static short4 tzcnt(this half4 a)
    {
        return new(a.x.asu().tzcnt(), a.y.asu().tzcnt(), a.z.asu().tzcnt(), a.w.asu().tzcnt());
    }
}

#endregion // half4

#region b16v2

public partial struct b16v2 : IVectorBitops
    , IBitwiseOperators<b16v2, b16v2, b16v2>
{
    [MethodImpl(256 | 512)]
    public static b16v2 operator ~(b16v2 a)
    {
        return new(a.x.BitNot(), a.y.BitNot());
    }

    [MethodImpl(256 | 512)]
    public static b16v2 operator |(b16v2 a, b16v2 b)
    {
        return new(a.x.BitOr(b.x), a.y.BitOr(b.y));
    }

    [MethodImpl(256 | 512)]
    public static b16v2 operator &(b16v2 a, b16v2 b)
    {
        return new(a.x.BitAnd(b.x), a.y.BitAnd(b.y));
    }

    [MethodImpl(256 | 512)]
    public static b16v2 operator ^(b16v2 a, b16v2 b)
    {
        return new(a.x.BitXor(b.x), a.y.BitXor(b.y));
    }
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static b16v2 andnot(this b16v2 a, b16v2 b)
    {
        return new(a.x.andnot(b.x), a.y.andnot(b.y));
    }

    [MethodImpl(256 | 512)]
    public static short2 popcnt(this b16v2 a)
    {
        return new(a.x.asu().popcnt(), a.y.asu().popcnt());
    }

    [MethodImpl(256 | 512)]
    public static short2 lzcnt(this b16v2 a)
    {
        return new(a.x.asu().lzcnt(), a.y.asu().lzcnt());
    }

    [MethodImpl(256 | 512)]
    public static short2 tzcnt(this b16v2 a)
    {
        return new(a.x.asu().tzcnt(), a.y.asu().tzcnt());
    }
}

#endregion // b16v2

#region b16v3

public partial struct b16v3 : IVectorBitops
    , IBitwiseOperators<b16v3, b16v3, b16v3>
{
    [MethodImpl(256 | 512)]
    public static b16v3 operator ~(b16v3 a)
    {
        return new(a.x.BitNot(), a.y.BitNot(), a.z.BitNot());
    }

    [MethodImpl(256 | 512)]
    public static b16v3 operator |(b16v3 a, b16v3 b)
    {
        return new(a.x.BitOr(b.x), a.y.BitOr(b.y), a.z.BitOr(b.z));
    }

    [MethodImpl(256 | 512)]
    public static b16v3 operator &(b16v3 a, b16v3 b)
    {
        return new(a.x.BitAnd(b.x), a.y.BitAnd(b.y), a.z.BitAnd(b.z));
    }

    [MethodImpl(256 | 512)]
    public static b16v3 operator ^(b16v3 a, b16v3 b)
    {
        return new(a.x.BitXor(b.x), a.y.BitXor(b.y), a.z.BitXor(b.z));
    }
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static b16v3 andnot(this b16v3 a, b16v3 b)
    {
        return new(a.x.andnot(b.x), a.y.andnot(b.y), a.z.andnot(b.z));
    }

    [MethodImpl(256 | 512)]
    public static short3 popcnt(this b16v3 a)
    {
        return new(a.x.asu().popcnt(), a.y.asu().popcnt(), a.z.asu().popcnt());
    }

    [MethodImpl(256 | 512)]
    public static short3 lzcnt(this b16v3 a)
    {
        return new(a.x.asu().lzcnt(), a.y.asu().lzcnt(), a.z.asu().lzcnt());
    }

    [MethodImpl(256 | 512)]
    public static short3 tzcnt(this b16v3 a)
    {
        return new(a.x.asu().tzcnt(), a.y.asu().tzcnt(), a.z.asu().tzcnt());
    }
}

#endregion // b16v3

#region b16v4

public partial struct b16v4 : IVectorBitops
    , IBitwiseOperators<b16v4, b16v4, b16v4>
{
    [MethodImpl(256 | 512)]
    public static b16v4 operator ~(b16v4 a)
    {
        return new(a.x.BitNot(), a.y.BitNot(), a.z.BitNot(), a.w.BitNot());
    }

    [MethodImpl(256 | 512)]
    public static b16v4 operator |(b16v4 a, b16v4 b)
    {
        return new(a.x.BitOr(b.x), a.y.BitOr(b.y), a.z.BitOr(b.z), a.w.BitOr(b.w));
    }

    [MethodImpl(256 | 512)]
    public static b16v4 operator &(b16v4 a, b16v4 b)
    {
        return new(a.x.BitAnd(b.x), a.y.BitAnd(b.y), a.z.BitAnd(b.z), a.w.BitAnd(b.w));
    }

    [MethodImpl(256 | 512)]
    public static b16v4 operator ^(b16v4 a, b16v4 b)
    {
        return new(a.x.BitXor(b.x), a.y.BitXor(b.y), a.z.BitXor(b.z), a.w.BitXor(b.w));
    }
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static b16v4 andnot(this b16v4 a, b16v4 b)
    {
        return new(a.x.andnot(b.x), a.y.andnot(b.y), a.z.andnot(b.z), a.w.andnot(b.w));
    }

    [MethodImpl(256 | 512)]
    public static short4 popcnt(this b16v4 a)
    {
        return new(a.x.asu().popcnt(), a.y.asu().popcnt(), a.z.asu().popcnt(), a.w.asu().popcnt());
    }

    [MethodImpl(256 | 512)]
    public static short4 lzcnt(this b16v4 a)
    {
        return new(a.x.asu().lzcnt(), a.y.asu().lzcnt(), a.z.asu().lzcnt(), a.w.asu().lzcnt());
    }

    [MethodImpl(256 | 512)]
    public static short4 tzcnt(this b16v4 a)
    {
        return new(a.x.asu().tzcnt(), a.y.asu().tzcnt(), a.z.asu().tzcnt(), a.w.asu().tzcnt());
    }
}

#endregion // b16v4

#region b32v2

public partial struct b32v2 : IVectorBitops
    , IBitwiseOperators<b32v2, b32v2, b32v2>
{
    [MethodImpl(256 | 512)]
    public static b32v2 operator ~(b32v2 a)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(~a.vector);
        return new(a.x.BitNot(), a.y.BitNot());
    }

    [MethodImpl(256 | 512)]
    public static b32v2 operator |(b32v2 a, b32v2 b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(a.vector | b.vector);
        return new(a.x.BitOr(b.x), a.y.BitOr(b.y));
    }

    [MethodImpl(256 | 512)]
    public static b32v2 operator &(b32v2 a, b32v2 b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(a.vector & b.vector);
        return new(a.x.BitAnd(b.x), a.y.BitAnd(b.y));
    }

    [MethodImpl(256 | 512)]
    public static b32v2 operator ^(b32v2 a, b32v2 b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(a.vector ^ b.vector);
        return new(a.x.BitXor(b.x), a.y.BitXor(b.y));
    }
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static b32v2 andnot(this b32v2 a, b32v2 b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(Vector64.AndNot(a.vector, b.vector));
        return new(a.x.andnot(b.x), a.y.andnot(b.y));
    }

    [MethodImpl(256 | 512)]
    public static int2 popcnt(this b32v2 a)
    {
        return new(a.x.asu().popcnt(), a.y.asu().popcnt());
    }

    [MethodImpl(256 | 512)]
    public static int2 lzcnt(this b32v2 a)
    {
        return new(a.x.asu().lzcnt(), a.y.asu().lzcnt());
    }

    [MethodImpl(256 | 512)]
    public static int2 tzcnt(this b32v2 a)
    {
        return new(a.x.asu().tzcnt(), a.y.asu().tzcnt());
    }
}

#endregion // b32v2

#region b32v3

public partial struct b32v3 : IVectorBitops
    , IBitwiseOperators<b32v3, b32v3, b32v3>
{
    [MethodImpl(256 | 512)]
    public static b32v3 operator ~(b32v3 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(~a.vector & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        return new(a.x.BitNot(), a.y.BitNot(), a.z.BitNot());
    }

    [MethodImpl(256 | 512)]
    public static b32v3 operator |(b32v3 a, b32v3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector | b.vector);
        return new(a.x.BitOr(b.x), a.y.BitOr(b.y), a.z.BitOr(b.z));
    }

    [MethodImpl(256 | 512)]
    public static b32v3 operator &(b32v3 a, b32v3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector & b.vector);
        return new(a.x.BitAnd(b.x), a.y.BitAnd(b.y), a.z.BitAnd(b.z));
    }

    [MethodImpl(256 | 512)]
    public static b32v3 operator ^(b32v3 a, b32v3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector ^ b.vector);
        return new(a.x.BitXor(b.x), a.y.BitXor(b.y), a.z.BitXor(b.z));
    }
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static b32v3 andnot(this b32v3 a, b32v3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.AndNot(a.vector, b.vector) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        return new(a.x.andnot(b.x), a.y.andnot(b.y), a.z.andnot(b.z));
    }

    [MethodImpl(256 | 512)]
    public static int3 popcnt(this b32v3 a)
    {
        return new(a.x.asu().popcnt(), a.y.asu().popcnt(), a.z.asu().popcnt());
    }

    [MethodImpl(256 | 512)]
    public static int3 lzcnt(this b32v3 a)
    {
        return new(a.x.asu().lzcnt(), a.y.asu().lzcnt(), a.z.asu().lzcnt());
    }

    [MethodImpl(256 | 512)]
    public static int3 tzcnt(this b32v3 a)
    {
        return new(a.x.asu().tzcnt(), a.y.asu().tzcnt(), a.z.asu().tzcnt());
    }
}

#endregion // b32v3

#region b32v4

public partial struct b32v4 : IVectorBitops
    , IBitwiseOperators<b32v4, b32v4, b32v4>
{
    [MethodImpl(256 | 512)]
    public static b32v4 operator ~(b32v4 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(~a.vector);
        return new(a.x.BitNot(), a.y.BitNot(), a.z.BitNot(), a.w.BitNot());
    }

    [MethodImpl(256 | 512)]
    public static b32v4 operator |(b32v4 a, b32v4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector | b.vector);
        return new(a.x.BitOr(b.x), a.y.BitOr(b.y), a.z.BitOr(b.z), a.w.BitOr(b.w));
    }

    [MethodImpl(256 | 512)]
    public static b32v4 operator &(b32v4 a, b32v4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector & b.vector);
        return new(a.x.BitAnd(b.x), a.y.BitAnd(b.y), a.z.BitAnd(b.z), a.w.BitAnd(b.w));
    }

    [MethodImpl(256 | 512)]
    public static b32v4 operator ^(b32v4 a, b32v4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector ^ b.vector);
        return new(a.x.BitXor(b.x), a.y.BitXor(b.y), a.z.BitXor(b.z), a.w.BitXor(b.w));
    }
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static b32v4 andnot(this b32v4 a, b32v4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.AndNot(a.vector, b.vector));
        return new(a.x.andnot(b.x), a.y.andnot(b.y), a.z.andnot(b.z), a.w.andnot(b.w));
    }

    [MethodImpl(256 | 512)]
    public static int4 popcnt(this b32v4 a)
    {
        return new(a.x.asu().popcnt(), a.y.asu().popcnt(), a.z.asu().popcnt(), a.w.asu().popcnt());
    }

    [MethodImpl(256 | 512)]
    public static int4 lzcnt(this b32v4 a)
    {
        return new(a.x.asu().lzcnt(), a.y.asu().lzcnt(), a.z.asu().lzcnt(), a.w.asu().lzcnt());
    }

    [MethodImpl(256 | 512)]
    public static int4 tzcnt(this b32v4 a)
    {
        return new(a.x.asu().tzcnt(), a.y.asu().tzcnt(), a.z.asu().tzcnt(), a.w.asu().tzcnt());
    }
}

#endregion // b32v4

#region b64v2

public partial struct b64v2 : IVectorBitops
    , IBitwiseOperators<b64v2, b64v2, b64v2>
{
    [MethodImpl(256 | 512)]
    public static b64v2 operator ~(b64v2 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(~a.vector);
        return new(a.x.BitNot(), a.y.BitNot());
    }

    [MethodImpl(256 | 512)]
    public static b64v2 operator |(b64v2 a, b64v2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector | b.vector);
        return new(a.x.BitOr(b.x), a.y.BitOr(b.y));
    }

    [MethodImpl(256 | 512)]
    public static b64v2 operator &(b64v2 a, b64v2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector & b.vector);
        return new(a.x.BitAnd(b.x), a.y.BitAnd(b.y));
    }

    [MethodImpl(256 | 512)]
    public static b64v2 operator ^(b64v2 a, b64v2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector ^ b.vector);
        return new(a.x.BitXor(b.x), a.y.BitXor(b.y));
    }
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static b64v2 andnot(this b64v2 a, b64v2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.AndNot(a.vector, b.vector));
        return new(a.x.andnot(b.x), a.y.andnot(b.y));
    }

    [MethodImpl(256 | 512)]
    public static long2 popcnt(this b64v2 a)
    {
        return new(a.x.asu().popcnt(), a.y.asu().popcnt());
    }

    [MethodImpl(256 | 512)]
    public static long2 lzcnt(this b64v2 a)
    {
        return new(a.x.asu().lzcnt(), a.y.asu().lzcnt());
    }

    [MethodImpl(256 | 512)]
    public static long2 tzcnt(this b64v2 a)
    {
        return new(a.x.asu().tzcnt(), a.y.asu().tzcnt());
    }
}

#endregion // b64v2

#region b64v3

public partial struct b64v3 : IVectorBitops
    , IBitwiseOperators<b64v3, b64v3, b64v3>
{
    [MethodImpl(256 | 512)]
    public static b64v3 operator ~(b64v3 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(~a.vector & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        return new(a.x.BitNot(), a.y.BitNot(), a.z.BitNot());
    }

    [MethodImpl(256 | 512)]
    public static b64v3 operator |(b64v3 a, b64v3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector | b.vector);
        return new(a.x.BitOr(b.x), a.y.BitOr(b.y), a.z.BitOr(b.z));
    }

    [MethodImpl(256 | 512)]
    public static b64v3 operator &(b64v3 a, b64v3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector & b.vector);
        return new(a.x.BitAnd(b.x), a.y.BitAnd(b.y), a.z.BitAnd(b.z));
    }

    [MethodImpl(256 | 512)]
    public static b64v3 operator ^(b64v3 a, b64v3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector ^ b.vector);
        return new(a.x.BitXor(b.x), a.y.BitXor(b.y), a.z.BitXor(b.z));
    }
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static b64v3 andnot(this b64v3 a, b64v3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(Vector256.AndNot(a.vector, b.vector) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        return new(a.x.andnot(b.x), a.y.andnot(b.y), a.z.andnot(b.z));
    }

    [MethodImpl(256 | 512)]
    public static long3 popcnt(this b64v3 a)
    {
        return new(a.x.asu().popcnt(), a.y.asu().popcnt(), a.z.asu().popcnt());
    }

    [MethodImpl(256 | 512)]
    public static long3 lzcnt(this b64v3 a)
    {
        return new(a.x.asu().lzcnt(), a.y.asu().lzcnt(), a.z.asu().lzcnt());
    }

    [MethodImpl(256 | 512)]
    public static long3 tzcnt(this b64v3 a)
    {
        return new(a.x.asu().tzcnt(), a.y.asu().tzcnt(), a.z.asu().tzcnt());
    }
}

#endregion // b64v3

#region b64v4

public partial struct b64v4 : IVectorBitops
    , IBitwiseOperators<b64v4, b64v4, b64v4>
{
    [MethodImpl(256 | 512)]
    public static b64v4 operator ~(b64v4 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(~a.vector);
        return new(a.x.BitNot(), a.y.BitNot(), a.z.BitNot(), a.w.BitNot());
    }

    [MethodImpl(256 | 512)]
    public static b64v4 operator |(b64v4 a, b64v4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector | b.vector);
        return new(a.x.BitOr(b.x), a.y.BitOr(b.y), a.z.BitOr(b.z), a.w.BitOr(b.w));
    }

    [MethodImpl(256 | 512)]
    public static b64v4 operator &(b64v4 a, b64v4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector & b.vector);
        return new(a.x.BitAnd(b.x), a.y.BitAnd(b.y), a.z.BitAnd(b.z), a.w.BitAnd(b.w));
    }

    [MethodImpl(256 | 512)]
    public static b64v4 operator ^(b64v4 a, b64v4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector ^ b.vector);
        return new(a.x.BitXor(b.x), a.y.BitXor(b.y), a.z.BitXor(b.z), a.w.BitXor(b.w));
    }
}

public static partial class math
{
    [MethodImpl(256 | 512)]
    public static b64v4 andnot(this b64v4 a, b64v4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(Vector256.AndNot(a.vector, b.vector));
        return new(a.x.andnot(b.x), a.y.andnot(b.y), a.z.andnot(b.z), a.w.andnot(b.w));
    }

    [MethodImpl(256 | 512)]
    public static long4 popcnt(this b64v4 a)
    {
        return new(a.x.asu().popcnt(), a.y.asu().popcnt(), a.z.asu().popcnt(), a.w.asu().popcnt());
    }

    [MethodImpl(256 | 512)]
    public static long4 lzcnt(this b64v4 a)
    {
        return new(a.x.asu().lzcnt(), a.y.asu().lzcnt(), a.z.asu().lzcnt(), a.w.asu().lzcnt());
    }

    [MethodImpl(256 | 512)]
    public static long4 tzcnt(this b64v4 a)
    {
        return new(a.x.asu().tzcnt(), a.y.asu().tzcnt(), a.z.asu().tzcnt(), a.w.asu().tzcnt());
    }
}

#endregion // b64v4

