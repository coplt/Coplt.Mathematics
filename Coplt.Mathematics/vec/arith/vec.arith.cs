// generated by template, do not modify manually

namespace Coplt.Mathematics;

#region float2

public partial struct float2
{
    [MethodImpl(256 | 512)]
    public static float2 operator +(float2 a) => a;
    [MethodImpl(256 | 512)]
    public static float2 operator -(float2 a)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(-a.vector);
        return new((-a.x), (-a.y));
    }

    [MethodImpl(256 | 512)]
    public static float2 operator +(float2 a, float2 b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(a.vector + b.vector);
        return new((float)(a.x + b.x), (float)(a.y + b.y));
    }

    [MethodImpl(256 | 512)]
    public static float2 operator +(float2 a, float b) => a + new float2(b);

    [MethodImpl(256 | 512)]
    public static float2 operator +(float a, float2 b) => new float2(a) + b;

    [MethodImpl(256 | 512)]
    public static float2 operator -(float2 a, float2 b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(a.vector - b.vector);
        return new((float)(a.x - b.x), (float)(a.y - b.y));
    }

    [MethodImpl(256 | 512)]
    public static float2 operator -(float2 a, float b) => a - new float2(b);

    [MethodImpl(256 | 512)]
    public static float2 operator -(float a, float2 b) => new float2(a) - b;

    [MethodImpl(256 | 512)]
    public static float2 operator *(float2 a, float2 b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(a.vector * b.vector);
        return new((float)(a.x * b.x), (float)(a.y * b.y));
    }

    [MethodImpl(256 | 512)]
    public static float2 operator *(float a, float2 b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(a * b.vector);
        return new((float)(a * b.x), (float)(a * b.y));
    }

    [MethodImpl(256 | 512)]
    public static float2 operator *(float2 a, float b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(a.vector * b);
        return new((float)(a.x * b), (float)(a.y * b));
    }

    [MethodImpl(256 | 512)]
    public static float2 operator /(float2 a, float2 b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new((a.vector / b.vector));
        return new((float)(a.x / b.x), (float)(a.y / b.y));
    }

    [MethodImpl(256 | 512)]
    public static float2 operator /(float2 a, float b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new((a.vector / b));
        return new((float)(a.x / b), (float)(a.y / b));
    }

    [MethodImpl(256 | 512)]
    public static float2 operator /(float a, float2 b) => new float2(a) / b;

    [MethodImpl(256 | 512)]
    public static float2 operator %(float2 a, float2 b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(simd.Rem(a.vector, b.vector));
        return new((float)(a.x % b.x), (float)(a.y % b.y));
    }

    [MethodImpl(256 | 512)]
    public static float2 operator %(float2 a, float b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(simd.Rem(a.vector, b));
        return new((float)(a.x % b), (float)(a.y % b));
    }

    [MethodImpl(256 | 512)]
    public static float2 operator %(float a, float2 b) => new float2(a) % b;

    [MethodImpl(256 | 512)]
    public static float2 operator --(float2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static float2 operator ++(float2 a) => a + One;
}

[Ex]
public static partial class math
{
    [MethodImpl(256 | 512)]
    public static float2 abs([This] float2 a)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(Vector64.Abs(a.vector));
        return new(a.x.abs(), a.y.abs());
    }

    [MethodImpl(256 | 512)]
    public static float2 sign([This] float2 a)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(simd.SignFloat(a.vector));
        return new(a.x.sign(), a.y.sign());
    }

    [MethodImpl(256 | 512)]
    public static float2 min([This] float2 a, float2 b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(Vector64.Min(a.vector, b.vector));
        return new(a.x.min(b.x), a.y.min(b.y));
    }

    [MethodImpl(256 | 512)]
    public static float2 max([This] float2 a, float2 b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(Vector64.Max(a.vector, b.vector));
        return new(a.x.max(b.x), a.y.max(b.y));
    }

    [MethodImpl(256 | 512)]
    public static float2 clamp([This] float2 v, float2 min, float2 max)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(Vector64.Max(min.vector, Vector64.Min(max.vector, v.vector)));
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y));
    }

    [MethodImpl(256 | 512)]
    public static float2 clamp([This] float2 v, float min, float max) => v.clamp(new float2(min), new float2(max));

    [MethodImpl(256 | 512)]
    public static float2 lerp(float2 start, float2 end, [This] float2 t)
    {
        if (Vector64.IsHardwareAccelerated)
            return fma(t, end - start, start);
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static float2 lerp(float2 start, float2 end, [This] float t)
    {
        if (Vector64.IsHardwareAccelerated)
            return fma(new(t), end - start, start);
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static float2 lerp(float start, float end, [This] float2 t)
    {
        if (Vector64.IsHardwareAccelerated)
            return fma(t, (end - start), new(start));
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static float2 unlerp([This] float2 a, float2 start, float2 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static float2 unlerp([This] float a, float2 start, float2 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static float2 unlerp([This] float2 a, float start, float end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static float2 remap([This] float2 a, float2 srcStart, float2 srcEnd, float2 dstStart, float2 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static float2 remap([This] float2 a, float srcStart, float srcEnd, float dstStart, float dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static float dot([This] float2 a, float2 b)
    {
        if (Vector64.IsHardwareAccelerated)
            return Vector64.Dot(a.vector, b.vector);
        return (float)(a.x * b.x + a.y * b.y);
    }

    [MethodImpl(256 | 512)]
    public static float lengthsq([This] float2 a)
    {
        if (Vector64.IsHardwareAccelerated)
            return Vector64.Dot(a.vector, a.vector);
        return (float)(a.x * a.x + a.y * a.y);
    }

    [MethodImpl(256 | 512)]
    public static float distancesq([This] float2 a, float2 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static float2 square([This] float2 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float2 fma([This] float2 a, float2 b, float2 c)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(simd.Fma(a.vector, b.vector, c.vector));
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static float2 fms([This] float2 a, float2 b, float2 c)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(simd.Fms(a.vector, b.vector, c.vector));
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static float2 fnma([This] float2 a, float2 b, float2 c)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(simd.Fnma(a.vector, b.vector, c.vector));
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static float2 fsm([This] float2 c, float2 a, float2 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float2 fam([This] float2 c, float2 a, float2 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float2 mad([This] float2 a, float2 b, float2 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static float csum([This] float2 a)
    {
        if (Vector64.IsHardwareAccelerated)
            return Vector64.Sum(a.vector);
        return (a.x + a.y);
    }

    [MethodImpl(256 | 512)]
    public static float cmin([This] float2 a)
    {
        if (Vector128.IsHardwareAccelerated || Vector64.IsHardwareAccelerated)
            return simd.CMin(a.vector);
        return a.x.min(a.y);
    }

    [MethodImpl(256 | 512)]
    public static float cmax([This] float2 a)
    {
        if (Vector128.IsHardwareAccelerated || Vector64.IsHardwareAccelerated)
            return simd.CMax(a.vector);
        return a.x.max(a.y);
    }

    [MethodImpl(256 | 512)]
    public static float cminsafe([This] float2 a)
    {
        return a.x.min(a.y);
    }

    [MethodImpl(256 | 512)]
    public static float cmaxsafe([This] float2 a)
    {
        return a.x.max(a.y);
    }
}

#endregion // float2

#region float3

public partial struct float3
{
    [MethodImpl(256 | 512)]
    public static float3 operator +(float3 a) => a;
    [MethodImpl(256 | 512)]
    public static float3 operator -(float3 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(-a.vector & Vector128.Create(-1, -1, -1, 0).AsSingle());
        return new((-a.x), (-a.y), (-a.z));
    }

    [MethodImpl(256 | 512)]
    public static float3 operator +(float3 a, float3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector + b.vector);
        return new((float)(a.x + b.x), (float)(a.y + b.y), (float)(a.z + b.z));
    }

    [MethodImpl(256 | 512)]
    public static float3 operator +(float3 a, float b) => a + new float3(b);

    [MethodImpl(256 | 512)]
    public static float3 operator +(float a, float3 b) => new float3(a) + b;

    [MethodImpl(256 | 512)]
    public static float3 operator -(float3 a, float3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector - b.vector);
        return new((float)(a.x - b.x), (float)(a.y - b.y), (float)(a.z - b.z));
    }

    [MethodImpl(256 | 512)]
    public static float3 operator -(float3 a, float b) => a - new float3(b);

    [MethodImpl(256 | 512)]
    public static float3 operator -(float a, float3 b) => new float3(a) - b;

    [MethodImpl(256 | 512)]
    public static float3 operator *(float3 a, float3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector * b.vector);
        return new((float)(a.x * b.x), (float)(a.y * b.y), (float)(a.z * b.z));
    }

    [MethodImpl(256 | 512)]
    public static float3 operator *(float a, float3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a * b.vector);
        return new((float)(a * b.x), (float)(a * b.y), (float)(a * b.z));
    }

    [MethodImpl(256 | 512)]
    public static float3 operator *(float3 a, float b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector * b);
        return new((float)(a.x * b), (float)(a.y * b), (float)(a.z * b));
    }

    [MethodImpl(256 | 512)]
    public static float3 operator /(float3 a, float3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new((a.vector / b.vector) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        return new((float)(a.x / b.x), (float)(a.y / b.y), (float)(a.z / b.z));
    }

    [MethodImpl(256 | 512)]
    public static float3 operator /(float3 a, float b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new((a.vector / b) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        return new((float)(a.x / b), (float)(a.y / b), (float)(a.z / b));
    }

    [MethodImpl(256 | 512)]
    public static float3 operator /(float a, float3 b) => new float3(a) / b;

    [MethodImpl(256 | 512)]
    public static float3 operator %(float3 a, float3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Rem(a.vector, b.vector) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        return new((float)(a.x % b.x), (float)(a.y % b.y), (float)(a.z % b.z));
    }

    [MethodImpl(256 | 512)]
    public static float3 operator %(float3 a, float b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Rem(a.vector, b) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        return new((float)(a.x % b), (float)(a.y % b), (float)(a.z % b));
    }

    [MethodImpl(256 | 512)]
    public static float3 operator %(float a, float3 b) => new float3(a) % b;

    [MethodImpl(256 | 512)]
    public static float3 operator --(float3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static float3 operator ++(float3 a) => a + One;
}

[Ex]
public static partial class math
{
    [MethodImpl(256 | 512)]
    public static float3 abs([This] float3 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.Abs(a.vector));
        return new(a.x.abs(), a.y.abs(), a.z.abs());
    }

    [MethodImpl(256 | 512)]
    public static float3 sign([This] float3 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.SignFloat(a.vector) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        return new(a.x.sign(), a.y.sign(), a.z.sign());
    }

    [MethodImpl(256 | 512)]
    public static float3 min([This] float3 a, float3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.Min(a.vector, b.vector));
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z));
    }

    [MethodImpl(256 | 512)]
    public static float3 max([This] float3 a, float3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.Max(a.vector, b.vector));
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z));
    }

    [MethodImpl(256 | 512)]
    public static float3 clamp([This] float3 v, float3 min, float3 max)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.Max(min.vector, Vector128.Min(max.vector, v.vector)));
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z));
    }

    [MethodImpl(256 | 512)]
    public static float3 clamp([This] float3 v, float min, float max) => v.clamp(new float3(min), new float3(max));

    [MethodImpl(256 | 512)]
    public static float3 lerp(float3 start, float3 end, [This] float3 t)
    {
        if (Vector128.IsHardwareAccelerated)
            return fma(t, end - start, start);
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static float3 lerp(float3 start, float3 end, [This] float t)
    {
        if (Vector128.IsHardwareAccelerated)
            return fma(new(t), end - start, start);
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static float3 lerp(float start, float end, [This] float3 t)
    {
        if (Vector128.IsHardwareAccelerated)
            return fma(t, (end - start), new(start));
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static float3 unlerp([This] float3 a, float3 start, float3 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static float3 unlerp([This] float a, float3 start, float3 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static float3 unlerp([This] float3 a, float start, float end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static float3 remap([This] float3 a, float3 srcStart, float3 srcEnd, float3 dstStart, float3 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static float3 remap([This] float3 a, float srcStart, float srcEnd, float dstStart, float dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static float dot([This] float3 a, float3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return Vector128.Dot(a.vector, b.vector);
        return (float)(a.x * b.x + a.y * b.y + a.z * b.z);
    }

    [MethodImpl(256 | 512)]
    public static float3 cross([This] float3 a, float3 b)
    {
        // (a * b.yzx - a.yzx * b).yzx;
        return fnma(a.yzx, b, a * b.yzx).yzx;
    }

    [MethodImpl(256 | 512)]
    public static float lengthsq([This] float3 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return Vector128.Dot(a.vector, a.vector);
        return (float)(a.x * a.x + a.y * a.y + a.z * a.z);
    }

    [MethodImpl(256 | 512)]
    public static float distancesq([This] float3 a, float3 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static float3 square([This] float3 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float3 fma([This] float3 a, float3 b, float3 c)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Fma(a.vector, b.vector, c.vector));
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y), a.z.fma(b.z, c.z));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static float3 fms([This] float3 a, float3 b, float3 c)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Fms(a.vector, b.vector, c.vector));
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y), a.z.fms(b.z, c.z));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static float3 fnma([This] float3 a, float3 b, float3 c)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Fnma(a.vector, b.vector, c.vector));
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y), a.z.fnma(b.z, c.z));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static float3 fsm([This] float3 c, float3 a, float3 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float3 fam([This] float3 c, float3 a, float3 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float3 mad([This] float3 a, float3 b, float3 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static float csum([This] float3 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return Vector128.Sum(a.vector);
        return (a.x + a.y + a.z);
    }

    [MethodImpl(256 | 512)]
    public static float cmin([This] float3 a)
    {
        if (Vector128.IsHardwareAccelerated || Vector64.IsHardwareAccelerated)
            return simd.CMin3(a.vector);
        return a.x.min(a.y).min(a.z);
    }

    [MethodImpl(256 | 512)]
    public static float cmax([This] float3 a)
    {
        if (Vector128.IsHardwareAccelerated || Vector64.IsHardwareAccelerated)
            return simd.CMax3(a.vector);
        return a.x.max(a.y).max(a.z);
    }

    [MethodImpl(256 | 512)]
    public static float cminsafe([This] float3 a)
    {
        return a.x.min(a.y).min(a.z);
    }

    [MethodImpl(256 | 512)]
    public static float cmaxsafe([This] float3 a)
    {
        return a.x.max(a.y).max(a.z);
    }
}

#endregion // float3

#region float4

public partial struct float4
{
    [MethodImpl(256 | 512)]
    public static float4 operator +(float4 a) => a;
    [MethodImpl(256 | 512)]
    public static float4 operator -(float4 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(-a.vector);
        return new((-a.x), (-a.y), (-a.z), (-a.w));
    }

    [MethodImpl(256 | 512)]
    public static float4 operator +(float4 a, float4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector + b.vector);
        return new((float)(a.x + b.x), (float)(a.y + b.y), (float)(a.z + b.z), (float)(a.w + b.w));
    }

    [MethodImpl(256 | 512)]
    public static float4 operator +(float4 a, float b) => a + new float4(b);

    [MethodImpl(256 | 512)]
    public static float4 operator +(float a, float4 b) => new float4(a) + b;

    [MethodImpl(256 | 512)]
    public static float4 operator -(float4 a, float4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector - b.vector);
        return new((float)(a.x - b.x), (float)(a.y - b.y), (float)(a.z - b.z), (float)(a.w - b.w));
    }

    [MethodImpl(256 | 512)]
    public static float4 operator -(float4 a, float b) => a - new float4(b);

    [MethodImpl(256 | 512)]
    public static float4 operator -(float a, float4 b) => new float4(a) - b;

    [MethodImpl(256 | 512)]
    public static float4 operator *(float4 a, float4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector * b.vector);
        return new((float)(a.x * b.x), (float)(a.y * b.y), (float)(a.z * b.z), (float)(a.w * b.w));
    }

    [MethodImpl(256 | 512)]
    public static float4 operator *(float a, float4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a * b.vector);
        return new((float)(a * b.x), (float)(a * b.y), (float)(a * b.z), (float)(a * b.w));
    }

    [MethodImpl(256 | 512)]
    public static float4 operator *(float4 a, float b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector * b);
        return new((float)(a.x * b), (float)(a.y * b), (float)(a.z * b), (float)(a.w * b));
    }

    [MethodImpl(256 | 512)]
    public static float4 operator /(float4 a, float4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new((a.vector / b.vector));
        return new((float)(a.x / b.x), (float)(a.y / b.y), (float)(a.z / b.z), (float)(a.w / b.w));
    }

    [MethodImpl(256 | 512)]
    public static float4 operator /(float4 a, float b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new((a.vector / b));
        return new((float)(a.x / b), (float)(a.y / b), (float)(a.z / b), (float)(a.w / b));
    }

    [MethodImpl(256 | 512)]
    public static float4 operator /(float a, float4 b) => new float4(a) / b;

    [MethodImpl(256 | 512)]
    public static float4 operator %(float4 a, float4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Rem(a.vector, b.vector));
        return new((float)(a.x % b.x), (float)(a.y % b.y), (float)(a.z % b.z), (float)(a.w % b.w));
    }

    [MethodImpl(256 | 512)]
    public static float4 operator %(float4 a, float b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Rem(a.vector, b));
        return new((float)(a.x % b), (float)(a.y % b), (float)(a.z % b), (float)(a.w % b));
    }

    [MethodImpl(256 | 512)]
    public static float4 operator %(float a, float4 b) => new float4(a) % b;

    [MethodImpl(256 | 512)]
    public static float4 operator --(float4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static float4 operator ++(float4 a) => a + One;
}

[Ex]
public static partial class math
{
    [MethodImpl(256 | 512)]
    public static float4 abs([This] float4 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.Abs(a.vector));
        return new(a.x.abs(), a.y.abs(), a.z.abs(), a.w.abs());
    }

    [MethodImpl(256 | 512)]
    public static float4 sign([This] float4 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.SignFloat(a.vector));
        return new(a.x.sign(), a.y.sign(), a.z.sign(), a.w.sign());
    }

    [MethodImpl(256 | 512)]
    public static float4 min([This] float4 a, float4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.Min(a.vector, b.vector));
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z), a.w.min(b.w));
    }

    [MethodImpl(256 | 512)]
    public static float4 max([This] float4 a, float4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.Max(a.vector, b.vector));
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z), a.w.max(b.w));
    }

    [MethodImpl(256 | 512)]
    public static float4 clamp([This] float4 v, float4 min, float4 max)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.Max(min.vector, Vector128.Min(max.vector, v.vector)));
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z), v.w.clamp(min.w, max.w));
    }

    [MethodImpl(256 | 512)]
    public static float4 clamp([This] float4 v, float min, float max) => v.clamp(new float4(min), new float4(max));

    [MethodImpl(256 | 512)]
    public static float4 lerp(float4 start, float4 end, [This] float4 t)
    {
        if (Vector128.IsHardwareAccelerated)
            return fma(t, end - start, start);
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static float4 lerp(float4 start, float4 end, [This] float t)
    {
        if (Vector128.IsHardwareAccelerated)
            return fma(new(t), end - start, start);
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static float4 lerp(float start, float end, [This] float4 t)
    {
        if (Vector128.IsHardwareAccelerated)
            return fma(t, (end - start), new(start));
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static float4 unlerp([This] float4 a, float4 start, float4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static float4 unlerp([This] float a, float4 start, float4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static float4 unlerp([This] float4 a, float start, float end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static float4 remap([This] float4 a, float4 srcStart, float4 srcEnd, float4 dstStart, float4 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static float4 remap([This] float4 a, float srcStart, float srcEnd, float dstStart, float dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static float dot([This] float4 a, float4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return Vector128.Dot(a.vector, b.vector);
        return (float)(a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w);
    }

    [MethodImpl(256 | 512)]
    public static float lengthsq([This] float4 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return Vector128.Dot(a.vector, a.vector);
        return (float)(a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w);
    }

    [MethodImpl(256 | 512)]
    public static float distancesq([This] float4 a, float4 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static float4 square([This] float4 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float4 fma([This] float4 a, float4 b, float4 c)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Fma(a.vector, b.vector, c.vector));
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y), a.z.fma(b.z, c.z), a.w.fma(b.w, c.w));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static float4 fms([This] float4 a, float4 b, float4 c)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Fms(a.vector, b.vector, c.vector));
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y), a.z.fms(b.z, c.z), a.w.fms(b.w, c.w));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static float4 fnma([This] float4 a, float4 b, float4 c)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Fnma(a.vector, b.vector, c.vector));
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y), a.z.fnma(b.z, c.z), a.w.fnma(b.w, c.w));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static float4 fsm([This] float4 c, float4 a, float4 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float4 fam([This] float4 c, float4 a, float4 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static float4 mad([This] float4 a, float4 b, float4 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static float csum([This] float4 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return Vector128.Sum(a.vector);
        return (a.x + a.y + a.z + a.w);
    }

    [MethodImpl(256 | 512)]
    public static float cmin([This] float4 a)
    {
        if (Vector128.IsHardwareAccelerated || Vector64.IsHardwareAccelerated)
            return simd.CMin(a.vector);
        return a.x.min(a.y).min(a.z).min(a.w);
    }

    [MethodImpl(256 | 512)]
    public static float cmax([This] float4 a)
    {
        if (Vector128.IsHardwareAccelerated || Vector64.IsHardwareAccelerated)
            return simd.CMax(a.vector);
        return a.x.max(a.y).max(a.z).max(a.w);
    }

    [MethodImpl(256 | 512)]
    public static float cminsafe([This] float4 a)
    {
        return a.x.min(a.y).min(a.z).min(a.w);
    }

    [MethodImpl(256 | 512)]
    public static float cmaxsafe([This] float4 a)
    {
        return a.x.max(a.y).max(a.z).max(a.w);
    }
}

#endregion // float4

#region double2

public partial struct double2
{
    [MethodImpl(256 | 512)]
    public static double2 operator +(double2 a) => a;
    [MethodImpl(256 | 512)]
    public static double2 operator -(double2 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(-a.vector);
        return new((-a.x), (-a.y));
    }

    [MethodImpl(256 | 512)]
    public static double2 operator +(double2 a, double2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector + b.vector);
        return new((double)(a.x + b.x), (double)(a.y + b.y));
    }

    [MethodImpl(256 | 512)]
    public static double2 operator +(double2 a, double b) => a + new double2(b);

    [MethodImpl(256 | 512)]
    public static double2 operator +(double a, double2 b) => new double2(a) + b;

    [MethodImpl(256 | 512)]
    public static double2 operator -(double2 a, double2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector - b.vector);
        return new((double)(a.x - b.x), (double)(a.y - b.y));
    }

    [MethodImpl(256 | 512)]
    public static double2 operator -(double2 a, double b) => a - new double2(b);

    [MethodImpl(256 | 512)]
    public static double2 operator -(double a, double2 b) => new double2(a) - b;

    [MethodImpl(256 | 512)]
    public static double2 operator *(double2 a, double2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector * b.vector);
        return new((double)(a.x * b.x), (double)(a.y * b.y));
    }

    [MethodImpl(256 | 512)]
    public static double2 operator *(double a, double2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a * b.vector);
        return new((double)(a * b.x), (double)(a * b.y));
    }

    [MethodImpl(256 | 512)]
    public static double2 operator *(double2 a, double b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector * b);
        return new((double)(a.x * b), (double)(a.y * b));
    }

    [MethodImpl(256 | 512)]
    public static double2 operator /(double2 a, double2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new((a.vector / b.vector));
        return new((double)(a.x / b.x), (double)(a.y / b.y));
    }

    [MethodImpl(256 | 512)]
    public static double2 operator /(double2 a, double b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new((a.vector / b));
        return new((double)(a.x / b), (double)(a.y / b));
    }

    [MethodImpl(256 | 512)]
    public static double2 operator /(double a, double2 b) => new double2(a) / b;

    [MethodImpl(256 | 512)]
    public static double2 operator %(double2 a, double2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Rem(a.vector, b.vector));
        return new((double)(a.x % b.x), (double)(a.y % b.y));
    }

    [MethodImpl(256 | 512)]
    public static double2 operator %(double2 a, double b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Rem(a.vector, b));
        return new((double)(a.x % b), (double)(a.y % b));
    }

    [MethodImpl(256 | 512)]
    public static double2 operator %(double a, double2 b) => new double2(a) % b;

    [MethodImpl(256 | 512)]
    public static double2 operator --(double2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static double2 operator ++(double2 a) => a + One;
}

[Ex]
public static partial class math
{
    [MethodImpl(256 | 512)]
    public static double2 abs([This] double2 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.Abs(a.vector));
        return new(a.x.abs(), a.y.abs());
    }

    [MethodImpl(256 | 512)]
    public static double2 sign([This] double2 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.SignFloat(a.vector));
        return new(a.x.sign(), a.y.sign());
    }

    [MethodImpl(256 | 512)]
    public static double2 min([This] double2 a, double2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.Min(a.vector, b.vector));
        return new(a.x.min(b.x), a.y.min(b.y));
    }

    [MethodImpl(256 | 512)]
    public static double2 max([This] double2 a, double2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.Max(a.vector, b.vector));
        return new(a.x.max(b.x), a.y.max(b.y));
    }

    [MethodImpl(256 | 512)]
    public static double2 clamp([This] double2 v, double2 min, double2 max)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.Max(min.vector, Vector128.Min(max.vector, v.vector)));
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y));
    }

    [MethodImpl(256 | 512)]
    public static double2 clamp([This] double2 v, double min, double max) => v.clamp(new double2(min), new double2(max));

    [MethodImpl(256 | 512)]
    public static double2 lerp(double2 start, double2 end, [This] double2 t)
    {
        if (Vector128.IsHardwareAccelerated)
            return fma(t, end - start, start);
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static double2 lerp(double2 start, double2 end, [This] double t)
    {
        if (Vector128.IsHardwareAccelerated)
            return fma(new(t), end - start, start);
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static double2 lerp(double start, double end, [This] double2 t)
    {
        if (Vector128.IsHardwareAccelerated)
            return fma(t, (end - start), new(start));
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static double2 unlerp([This] double2 a, double2 start, double2 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static double2 unlerp([This] double a, double2 start, double2 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static double2 unlerp([This] double2 a, double start, double end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static double2 remap([This] double2 a, double2 srcStart, double2 srcEnd, double2 dstStart, double2 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static double2 remap([This] double2 a, double srcStart, double srcEnd, double dstStart, double dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static double dot([This] double2 a, double2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return Vector128.Dot(a.vector, b.vector);
        return (double)(a.x * b.x + a.y * b.y);
    }

    [MethodImpl(256 | 512)]
    public static double lengthsq([This] double2 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return Vector128.Dot(a.vector, a.vector);
        return (double)(a.x * a.x + a.y * a.y);
    }

    [MethodImpl(256 | 512)]
    public static double distancesq([This] double2 a, double2 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static double2 square([This] double2 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double2 fma([This] double2 a, double2 b, double2 c)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Fma(a.vector, b.vector, c.vector));
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static double2 fms([This] double2 a, double2 b, double2 c)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Fms(a.vector, b.vector, c.vector));
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static double2 fnma([This] double2 a, double2 b, double2 c)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Fnma(a.vector, b.vector, c.vector));
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static double2 fsm([This] double2 c, double2 a, double2 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double2 fam([This] double2 c, double2 a, double2 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double2 mad([This] double2 a, double2 b, double2 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static double csum([This] double2 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return Vector128.Sum(a.vector);
        return (a.x + a.y);
    }

    [MethodImpl(256 | 512)]
    public static double cmin([This] double2 a)
    {
        if (Vector256.IsHardwareAccelerated || Vector128.IsHardwareAccelerated)
            return simd.CMin(a.vector);
        return a.x.min(a.y);
    }

    [MethodImpl(256 | 512)]
    public static double cmax([This] double2 a)
    {
        if (Vector256.IsHardwareAccelerated || Vector128.IsHardwareAccelerated)
            return simd.CMax(a.vector);
        return a.x.max(a.y);
    }

    [MethodImpl(256 | 512)]
    public static double cminsafe([This] double2 a)
    {
        return a.x.min(a.y);
    }

    [MethodImpl(256 | 512)]
    public static double cmaxsafe([This] double2 a)
    {
        return a.x.max(a.y);
    }
}

#endregion // double2

#region double3

public partial struct double3
{
    [MethodImpl(256 | 512)]
    public static double3 operator +(double3 a) => a;
    [MethodImpl(256 | 512)]
    public static double3 operator -(double3 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(-a.vector & Vector256.Create(-1, -1, -1, 0).AsDouble());
        return new((-a.x), (-a.y), (-a.z));
    }

    [MethodImpl(256 | 512)]
    public static double3 operator +(double3 a, double3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector + b.vector);
        return new((double)(a.x + b.x), (double)(a.y + b.y), (double)(a.z + b.z));
    }

    [MethodImpl(256 | 512)]
    public static double3 operator +(double3 a, double b) => a + new double3(b);

    [MethodImpl(256 | 512)]
    public static double3 operator +(double a, double3 b) => new double3(a) + b;

    [MethodImpl(256 | 512)]
    public static double3 operator -(double3 a, double3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector - b.vector);
        return new((double)(a.x - b.x), (double)(a.y - b.y), (double)(a.z - b.z));
    }

    [MethodImpl(256 | 512)]
    public static double3 operator -(double3 a, double b) => a - new double3(b);

    [MethodImpl(256 | 512)]
    public static double3 operator -(double a, double3 b) => new double3(a) - b;

    [MethodImpl(256 | 512)]
    public static double3 operator *(double3 a, double3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector * b.vector);
        return new((double)(a.x * b.x), (double)(a.y * b.y), (double)(a.z * b.z));
    }

    [MethodImpl(256 | 512)]
    public static double3 operator *(double a, double3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a * b.vector);
        return new((double)(a * b.x), (double)(a * b.y), (double)(a * b.z));
    }

    [MethodImpl(256 | 512)]
    public static double3 operator *(double3 a, double b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector * b);
        return new((double)(a.x * b), (double)(a.y * b), (double)(a.z * b));
    }

    [MethodImpl(256 | 512)]
    public static double3 operator /(double3 a, double3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new((a.vector / b.vector) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        return new((double)(a.x / b.x), (double)(a.y / b.y), (double)(a.z / b.z));
    }

    [MethodImpl(256 | 512)]
    public static double3 operator /(double3 a, double b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new((a.vector / b) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        return new((double)(a.x / b), (double)(a.y / b), (double)(a.z / b));
    }

    [MethodImpl(256 | 512)]
    public static double3 operator /(double a, double3 b) => new double3(a) / b;

    [MethodImpl(256 | 512)]
    public static double3 operator %(double3 a, double3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Rem(a.vector, b.vector) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        return new((double)(a.x % b.x), (double)(a.y % b.y), (double)(a.z % b.z));
    }

    [MethodImpl(256 | 512)]
    public static double3 operator %(double3 a, double b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Rem(a.vector, b) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        return new((double)(a.x % b), (double)(a.y % b), (double)(a.z % b));
    }

    [MethodImpl(256 | 512)]
    public static double3 operator %(double a, double3 b) => new double3(a) % b;

    [MethodImpl(256 | 512)]
    public static double3 operator --(double3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static double3 operator ++(double3 a) => a + One;
}

[Ex]
public static partial class math
{
    [MethodImpl(256 | 512)]
    public static double3 abs([This] double3 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(Vector256.Abs(a.vector));
        return new(a.x.abs(), a.y.abs(), a.z.abs());
    }

    [MethodImpl(256 | 512)]
    public static double3 sign([This] double3 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.SignFloat(a.vector) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        return new(a.x.sign(), a.y.sign(), a.z.sign());
    }

    [MethodImpl(256 | 512)]
    public static double3 min([This] double3 a, double3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(Vector256.Min(a.vector, b.vector));
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z));
    }

    [MethodImpl(256 | 512)]
    public static double3 max([This] double3 a, double3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(Vector256.Max(a.vector, b.vector));
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z));
    }

    [MethodImpl(256 | 512)]
    public static double3 clamp([This] double3 v, double3 min, double3 max)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(Vector256.Max(min.vector, Vector256.Min(max.vector, v.vector)));
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z));
    }

    [MethodImpl(256 | 512)]
    public static double3 clamp([This] double3 v, double min, double max) => v.clamp(new double3(min), new double3(max));

    [MethodImpl(256 | 512)]
    public static double3 lerp(double3 start, double3 end, [This] double3 t)
    {
        if (Vector256.IsHardwareAccelerated)
            return fma(t, end - start, start);
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static double3 lerp(double3 start, double3 end, [This] double t)
    {
        if (Vector256.IsHardwareAccelerated)
            return fma(new(t), end - start, start);
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static double3 lerp(double start, double end, [This] double3 t)
    {
        if (Vector256.IsHardwareAccelerated)
            return fma(t, (end - start), new(start));
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static double3 unlerp([This] double3 a, double3 start, double3 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static double3 unlerp([This] double a, double3 start, double3 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static double3 unlerp([This] double3 a, double start, double end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static double3 remap([This] double3 a, double3 srcStart, double3 srcEnd, double3 dstStart, double3 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static double3 remap([This] double3 a, double srcStart, double srcEnd, double dstStart, double dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static double dot([This] double3 a, double3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return Vector256.Dot(a.vector, b.vector);
        return (double)(a.x * b.x + a.y * b.y + a.z * b.z);
    }

    [MethodImpl(256 | 512)]
    public static double3 cross([This] double3 a, double3 b)
    {
        // (a * b.yzx - a.yzx * b).yzx;
        return fnma(a.yzx, b, a * b.yzx).yzx;
    }

    [MethodImpl(256 | 512)]
    public static double lengthsq([This] double3 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return Vector256.Dot(a.vector, a.vector);
        return (double)(a.x * a.x + a.y * a.y + a.z * a.z);
    }

    [MethodImpl(256 | 512)]
    public static double distancesq([This] double3 a, double3 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static double3 square([This] double3 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double3 fma([This] double3 a, double3 b, double3 c)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Fma(a.vector, b.vector, c.vector));
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y), a.z.fma(b.z, c.z));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static double3 fms([This] double3 a, double3 b, double3 c)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Fms(a.vector, b.vector, c.vector));
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y), a.z.fms(b.z, c.z));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static double3 fnma([This] double3 a, double3 b, double3 c)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Fnma(a.vector, b.vector, c.vector));
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y), a.z.fnma(b.z, c.z));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static double3 fsm([This] double3 c, double3 a, double3 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double3 fam([This] double3 c, double3 a, double3 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double3 mad([This] double3 a, double3 b, double3 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static double csum([This] double3 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return Vector256.Sum(a.vector);
        return (a.x + a.y + a.z);
    }

    [MethodImpl(256 | 512)]
    public static double cmin([This] double3 a)
    {
        if (Vector256.IsHardwareAccelerated || Vector128.IsHardwareAccelerated)
            return simd.CMin3(a.vector);
        return a.x.min(a.y).min(a.z);
    }

    [MethodImpl(256 | 512)]
    public static double cmax([This] double3 a)
    {
        if (Vector256.IsHardwareAccelerated || Vector128.IsHardwareAccelerated)
            return simd.CMax3(a.vector);
        return a.x.max(a.y).max(a.z);
    }

    [MethodImpl(256 | 512)]
    public static double cminsafe([This] double3 a)
    {
        return a.x.min(a.y).min(a.z);
    }

    [MethodImpl(256 | 512)]
    public static double cmaxsafe([This] double3 a)
    {
        return a.x.max(a.y).max(a.z);
    }
}

#endregion // double3

#region double4

public partial struct double4
{
    [MethodImpl(256 | 512)]
    public static double4 operator +(double4 a) => a;
    [MethodImpl(256 | 512)]
    public static double4 operator -(double4 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(-a.vector);
        return new((-a.x), (-a.y), (-a.z), (-a.w));
    }

    [MethodImpl(256 | 512)]
    public static double4 operator +(double4 a, double4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector + b.vector);
        return new((double)(a.x + b.x), (double)(a.y + b.y), (double)(a.z + b.z), (double)(a.w + b.w));
    }

    [MethodImpl(256 | 512)]
    public static double4 operator +(double4 a, double b) => a + new double4(b);

    [MethodImpl(256 | 512)]
    public static double4 operator +(double a, double4 b) => new double4(a) + b;

    [MethodImpl(256 | 512)]
    public static double4 operator -(double4 a, double4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector - b.vector);
        return new((double)(a.x - b.x), (double)(a.y - b.y), (double)(a.z - b.z), (double)(a.w - b.w));
    }

    [MethodImpl(256 | 512)]
    public static double4 operator -(double4 a, double b) => a - new double4(b);

    [MethodImpl(256 | 512)]
    public static double4 operator -(double a, double4 b) => new double4(a) - b;

    [MethodImpl(256 | 512)]
    public static double4 operator *(double4 a, double4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector * b.vector);
        return new((double)(a.x * b.x), (double)(a.y * b.y), (double)(a.z * b.z), (double)(a.w * b.w));
    }

    [MethodImpl(256 | 512)]
    public static double4 operator *(double a, double4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a * b.vector);
        return new((double)(a * b.x), (double)(a * b.y), (double)(a * b.z), (double)(a * b.w));
    }

    [MethodImpl(256 | 512)]
    public static double4 operator *(double4 a, double b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector * b);
        return new((double)(a.x * b), (double)(a.y * b), (double)(a.z * b), (double)(a.w * b));
    }

    [MethodImpl(256 | 512)]
    public static double4 operator /(double4 a, double4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new((a.vector / b.vector));
        return new((double)(a.x / b.x), (double)(a.y / b.y), (double)(a.z / b.z), (double)(a.w / b.w));
    }

    [MethodImpl(256 | 512)]
    public static double4 operator /(double4 a, double b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new((a.vector / b));
        return new((double)(a.x / b), (double)(a.y / b), (double)(a.z / b), (double)(a.w / b));
    }

    [MethodImpl(256 | 512)]
    public static double4 operator /(double a, double4 b) => new double4(a) / b;

    [MethodImpl(256 | 512)]
    public static double4 operator %(double4 a, double4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Rem(a.vector, b.vector));
        return new((double)(a.x % b.x), (double)(a.y % b.y), (double)(a.z % b.z), (double)(a.w % b.w));
    }

    [MethodImpl(256 | 512)]
    public static double4 operator %(double4 a, double b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Rem(a.vector, b));
        return new((double)(a.x % b), (double)(a.y % b), (double)(a.z % b), (double)(a.w % b));
    }

    [MethodImpl(256 | 512)]
    public static double4 operator %(double a, double4 b) => new double4(a) % b;

    [MethodImpl(256 | 512)]
    public static double4 operator --(double4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static double4 operator ++(double4 a) => a + One;
}

[Ex]
public static partial class math
{
    [MethodImpl(256 | 512)]
    public static double4 abs([This] double4 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(Vector256.Abs(a.vector));
        return new(a.x.abs(), a.y.abs(), a.z.abs(), a.w.abs());
    }

    [MethodImpl(256 | 512)]
    public static double4 sign([This] double4 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.SignFloat(a.vector));
        return new(a.x.sign(), a.y.sign(), a.z.sign(), a.w.sign());
    }

    [MethodImpl(256 | 512)]
    public static double4 min([This] double4 a, double4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(Vector256.Min(a.vector, b.vector));
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z), a.w.min(b.w));
    }

    [MethodImpl(256 | 512)]
    public static double4 max([This] double4 a, double4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(Vector256.Max(a.vector, b.vector));
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z), a.w.max(b.w));
    }

    [MethodImpl(256 | 512)]
    public static double4 clamp([This] double4 v, double4 min, double4 max)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(Vector256.Max(min.vector, Vector256.Min(max.vector, v.vector)));
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z), v.w.clamp(min.w, max.w));
    }

    [MethodImpl(256 | 512)]
    public static double4 clamp([This] double4 v, double min, double max) => v.clamp(new double4(min), new double4(max));

    [MethodImpl(256 | 512)]
    public static double4 lerp(double4 start, double4 end, [This] double4 t)
    {
        if (Vector256.IsHardwareAccelerated)
            return fma(t, end - start, start);
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static double4 lerp(double4 start, double4 end, [This] double t)
    {
        if (Vector256.IsHardwareAccelerated)
            return fma(new(t), end - start, start);
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static double4 lerp(double start, double end, [This] double4 t)
    {
        if (Vector256.IsHardwareAccelerated)
            return fma(t, (end - start), new(start));
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static double4 unlerp([This] double4 a, double4 start, double4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static double4 unlerp([This] double a, double4 start, double4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static double4 unlerp([This] double4 a, double start, double end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static double4 remap([This] double4 a, double4 srcStart, double4 srcEnd, double4 dstStart, double4 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static double4 remap([This] double4 a, double srcStart, double srcEnd, double dstStart, double dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static double dot([This] double4 a, double4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return Vector256.Dot(a.vector, b.vector);
        return (double)(a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w);
    }

    [MethodImpl(256 | 512)]
    public static double lengthsq([This] double4 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return Vector256.Dot(a.vector, a.vector);
        return (double)(a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w);
    }

    [MethodImpl(256 | 512)]
    public static double distancesq([This] double4 a, double4 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static double4 square([This] double4 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double4 fma([This] double4 a, double4 b, double4 c)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Fma(a.vector, b.vector, c.vector));
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y), a.z.fma(b.z, c.z), a.w.fma(b.w, c.w));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static double4 fms([This] double4 a, double4 b, double4 c)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Fms(a.vector, b.vector, c.vector));
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y), a.z.fms(b.z, c.z), a.w.fms(b.w, c.w));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static double4 fnma([This] double4 a, double4 b, double4 c)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Fnma(a.vector, b.vector, c.vector));
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y), a.z.fnma(b.z, c.z), a.w.fnma(b.w, c.w));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static double4 fsm([This] double4 c, double4 a, double4 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double4 fam([This] double4 c, double4 a, double4 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static double4 mad([This] double4 a, double4 b, double4 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static double csum([This] double4 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return Vector256.Sum(a.vector);
        return (a.x + a.y + a.z + a.w);
    }

    [MethodImpl(256 | 512)]
    public static double cmin([This] double4 a)
    {
        if (Vector256.IsHardwareAccelerated || Vector128.IsHardwareAccelerated)
            return simd.CMin(a.vector);
        return a.x.min(a.y).min(a.z).min(a.w);
    }

    [MethodImpl(256 | 512)]
    public static double cmax([This] double4 a)
    {
        if (Vector256.IsHardwareAccelerated || Vector128.IsHardwareAccelerated)
            return simd.CMax(a.vector);
        return a.x.max(a.y).max(a.z).max(a.w);
    }

    [MethodImpl(256 | 512)]
    public static double cminsafe([This] double4 a)
    {
        return a.x.min(a.y).min(a.z).min(a.w);
    }

    [MethodImpl(256 | 512)]
    public static double cmaxsafe([This] double4 a)
    {
        return a.x.max(a.y).max(a.z).max(a.w);
    }
}

#endregion // double4

#region short2

public partial struct short2
{
    [MethodImpl(256 | 512)]
    public static short2 operator +(short2 a) => a;
    [MethodImpl(256 | 512)]
    public static short2 operator -(short2 a)
    {
        return new((short)(-a.x), (short)(-a.y));
    }

    [MethodImpl(256 | 512)]
    public static short2 operator +(short2 a, short2 b)
    {
        return new((short)(a.x + b.x), (short)(a.y + b.y));
    }

    [MethodImpl(256 | 512)]
    public static short2 operator +(short2 a, short b) => a + new short2(b);

    [MethodImpl(256 | 512)]
    public static short2 operator +(short a, short2 b) => new short2(a) + b;

    [MethodImpl(256 | 512)]
    public static short2 operator -(short2 a, short2 b)
    {
        return new((short)(a.x - b.x), (short)(a.y - b.y));
    }

    [MethodImpl(256 | 512)]
    public static short2 operator -(short2 a, short b) => a - new short2(b);

    [MethodImpl(256 | 512)]
    public static short2 operator -(short a, short2 b) => new short2(a) - b;

    [MethodImpl(256 | 512)]
    public static short2 operator *(short2 a, short2 b)
    {
        return new((short)(a.x * b.x), (short)(a.y * b.y));
    }

    [MethodImpl(256 | 512)]
    public static short2 operator *(short a, short2 b)
    {
        return new((short)(a * b.x), (short)(a * b.y));
    }

    [MethodImpl(256 | 512)]
    public static short2 operator *(short2 a, short b)
    {
        return new((short)(a.x * b), (short)(a.y * b));
    }

    [MethodImpl(256 | 512)]
    public static short2 operator /(short2 a, short2 b)
    {
        return new((short)(a.x / b.x), (short)(a.y / b.y));
    }

    [MethodImpl(256 | 512)]
    public static short2 operator /(short2 a, short b)
    {
        return new((short)(a.x / b), (short)(a.y / b));
    }

    [MethodImpl(256 | 512)]
    public static short2 operator /(short a, short2 b) => new short2(a) / b;

    [MethodImpl(256 | 512)]
    public static short2 operator %(short2 a, short2 b)
    {
        return new((short)(a.x % b.x), (short)(a.y % b.y));
    }

    [MethodImpl(256 | 512)]
    public static short2 operator %(short2 a, short b)
    {
        return new((short)(a.x % b), (short)(a.y % b));
    }

    [MethodImpl(256 | 512)]
    public static short2 operator %(short a, short2 b) => new short2(a) % b;

    [MethodImpl(256 | 512)]
    public static short2 operator --(short2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static short2 operator ++(short2 a) => a + One;
}

[Ex]
public static partial class math
{
    [MethodImpl(256 | 512)]
    public static short2 abs([This] short2 a)
    {
        return new(a.x.abs(), a.y.abs());
    }

    [MethodImpl(256 | 512)]
    public static short2 sign([This] short2 a)
    {
        return new(a.x.sign(), a.y.sign());
    }

    [MethodImpl(256 | 512)]
    public static short2 min([This] short2 a, short2 b)
    {
        return new(a.x.min(b.x), a.y.min(b.y));
    }

    [MethodImpl(256 | 512)]
    public static short2 max([This] short2 a, short2 b)
    {
        return new(a.x.max(b.x), a.y.max(b.y));
    }

    [MethodImpl(256 | 512)]
    public static short2 clamp([This] short2 v, short2 min, short2 max)
    {
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y));
    }

    [MethodImpl(256 | 512)]
    public static short2 clamp([This] short2 v, short min, short max) => v.clamp(new short2(min), new short2(max));

    [MethodImpl(256 | 512)]
    public static short2 lerp(short2 start, short2 end, [This] short2 t)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static short2 lerp(short2 start, short2 end, [This] short t)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static short2 lerp(short start, short end, [This] short2 t)
    {
        return start + t * (short)(end - start);
    }

    [MethodImpl(256 | 512)]
    public static short2 unlerp([This] short2 a, short2 start, short2 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static short2 unlerp([This] short a, short2 start, short2 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static short2 unlerp([This] short2 a, short start, short end) => (a - start) / (short)(end - start);

    [MethodImpl(256 | 512)]
    public static short2 remap([This] short2 a, short2 srcStart, short2 srcEnd, short2 dstStart, short2 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static short2 remap([This] short2 a, short srcStart, short srcEnd, short dstStart, short dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static short dot([This] short2 a, short2 b)
    {
        return (short)(a.x * b.x + a.y * b.y);
    }

    [MethodImpl(256 | 512)]
    public static short lengthsq([This] short2 a)
    {
        return (short)(a.x * a.x + a.y * a.y);
    }

    [MethodImpl(256 | 512)]
    public static short distancesq([This] short2 a, short2 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static short2 square([This] short2 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static short2 fma([This] short2 a, short2 b, short2 c)
    {
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static short2 fms([This] short2 a, short2 b, short2 c)
    {
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static short2 fnma([This] short2 a, short2 b, short2 c)
    {
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static short2 fsm([This] short2 c, short2 a, short2 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static short2 fam([This] short2 c, short2 a, short2 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static short2 mad([This] short2 a, short2 b, short2 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static short csum([This] short2 a)
    {
        return (short)(a.x + a.y);
    }

    [MethodImpl(256 | 512)]
    public static short cmin([This] short2 a)
    {
        return a.x.min(a.y);
    }

    [MethodImpl(256 | 512)]
    public static short cmax([This] short2 a)
    {
        return a.x.max(a.y);
    }

    [MethodImpl(256 | 512)]
    public static short cminsafe([This] short2 a)
    {
        return a.x.min(a.y);
    }

    [MethodImpl(256 | 512)]
    public static short cmaxsafe([This] short2 a)
    {
        return a.x.max(a.y);
    }
}

#endregion // short2

#region short3

public partial struct short3
{
    [MethodImpl(256 | 512)]
    public static short3 operator +(short3 a) => a;
    [MethodImpl(256 | 512)]
    public static short3 operator -(short3 a)
    {
        return new((short)(-a.x), (short)(-a.y), (short)(-a.z));
    }

    [MethodImpl(256 | 512)]
    public static short3 operator +(short3 a, short3 b)
    {
        return new((short)(a.x + b.x), (short)(a.y + b.y), (short)(a.z + b.z));
    }

    [MethodImpl(256 | 512)]
    public static short3 operator +(short3 a, short b) => a + new short3(b);

    [MethodImpl(256 | 512)]
    public static short3 operator +(short a, short3 b) => new short3(a) + b;

    [MethodImpl(256 | 512)]
    public static short3 operator -(short3 a, short3 b)
    {
        return new((short)(a.x - b.x), (short)(a.y - b.y), (short)(a.z - b.z));
    }

    [MethodImpl(256 | 512)]
    public static short3 operator -(short3 a, short b) => a - new short3(b);

    [MethodImpl(256 | 512)]
    public static short3 operator -(short a, short3 b) => new short3(a) - b;

    [MethodImpl(256 | 512)]
    public static short3 operator *(short3 a, short3 b)
    {
        return new((short)(a.x * b.x), (short)(a.y * b.y), (short)(a.z * b.z));
    }

    [MethodImpl(256 | 512)]
    public static short3 operator *(short a, short3 b)
    {
        return new((short)(a * b.x), (short)(a * b.y), (short)(a * b.z));
    }

    [MethodImpl(256 | 512)]
    public static short3 operator *(short3 a, short b)
    {
        return new((short)(a.x * b), (short)(a.y * b), (short)(a.z * b));
    }

    [MethodImpl(256 | 512)]
    public static short3 operator /(short3 a, short3 b)
    {
        return new((short)(a.x / b.x), (short)(a.y / b.y), (short)(a.z / b.z));
    }

    [MethodImpl(256 | 512)]
    public static short3 operator /(short3 a, short b)
    {
        return new((short)(a.x / b), (short)(a.y / b), (short)(a.z / b));
    }

    [MethodImpl(256 | 512)]
    public static short3 operator /(short a, short3 b) => new short3(a) / b;

    [MethodImpl(256 | 512)]
    public static short3 operator %(short3 a, short3 b)
    {
        return new((short)(a.x % b.x), (short)(a.y % b.y), (short)(a.z % b.z));
    }

    [MethodImpl(256 | 512)]
    public static short3 operator %(short3 a, short b)
    {
        return new((short)(a.x % b), (short)(a.y % b), (short)(a.z % b));
    }

    [MethodImpl(256 | 512)]
    public static short3 operator %(short a, short3 b) => new short3(a) % b;

    [MethodImpl(256 | 512)]
    public static short3 operator --(short3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static short3 operator ++(short3 a) => a + One;
}

[Ex]
public static partial class math
{
    [MethodImpl(256 | 512)]
    public static short3 abs([This] short3 a)
    {
        return new(a.x.abs(), a.y.abs(), a.z.abs());
    }

    [MethodImpl(256 | 512)]
    public static short3 sign([This] short3 a)
    {
        return new(a.x.sign(), a.y.sign(), a.z.sign());
    }

    [MethodImpl(256 | 512)]
    public static short3 min([This] short3 a, short3 b)
    {
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z));
    }

    [MethodImpl(256 | 512)]
    public static short3 max([This] short3 a, short3 b)
    {
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z));
    }

    [MethodImpl(256 | 512)]
    public static short3 clamp([This] short3 v, short3 min, short3 max)
    {
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z));
    }

    [MethodImpl(256 | 512)]
    public static short3 clamp([This] short3 v, short min, short max) => v.clamp(new short3(min), new short3(max));

    [MethodImpl(256 | 512)]
    public static short3 lerp(short3 start, short3 end, [This] short3 t)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static short3 lerp(short3 start, short3 end, [This] short t)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static short3 lerp(short start, short end, [This] short3 t)
    {
        return start + t * (short)(end - start);
    }

    [MethodImpl(256 | 512)]
    public static short3 unlerp([This] short3 a, short3 start, short3 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static short3 unlerp([This] short a, short3 start, short3 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static short3 unlerp([This] short3 a, short start, short end) => (a - start) / (short)(end - start);

    [MethodImpl(256 | 512)]
    public static short3 remap([This] short3 a, short3 srcStart, short3 srcEnd, short3 dstStart, short3 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static short3 remap([This] short3 a, short srcStart, short srcEnd, short dstStart, short dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static short dot([This] short3 a, short3 b)
    {
        return (short)(a.x * b.x + a.y * b.y + a.z * b.z);
    }

    [MethodImpl(256 | 512)]
    public static short3 cross([This] short3 a, short3 b)
    {
        // (a * b.yzx - a.yzx * b).yzx;
        return fnma(a.yzx, b, a * b.yzx).yzx;
    }

    [MethodImpl(256 | 512)]
    public static short lengthsq([This] short3 a)
    {
        return (short)(a.x * a.x + a.y * a.y + a.z * a.z);
    }

    [MethodImpl(256 | 512)]
    public static short distancesq([This] short3 a, short3 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static short3 square([This] short3 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static short3 fma([This] short3 a, short3 b, short3 c)
    {
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y), a.z.fma(b.z, c.z));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static short3 fms([This] short3 a, short3 b, short3 c)
    {
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y), a.z.fms(b.z, c.z));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static short3 fnma([This] short3 a, short3 b, short3 c)
    {
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y), a.z.fnma(b.z, c.z));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static short3 fsm([This] short3 c, short3 a, short3 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static short3 fam([This] short3 c, short3 a, short3 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static short3 mad([This] short3 a, short3 b, short3 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static short csum([This] short3 a)
    {
        return (short)(a.x + a.y + a.z);
    }

    [MethodImpl(256 | 512)]
    public static short cmin([This] short3 a)
    {
        return a.x.min(a.y).min(a.z);
    }

    [MethodImpl(256 | 512)]
    public static short cmax([This] short3 a)
    {
        return a.x.max(a.y).max(a.z);
    }

    [MethodImpl(256 | 512)]
    public static short cminsafe([This] short3 a)
    {
        return a.x.min(a.y).min(a.z);
    }

    [MethodImpl(256 | 512)]
    public static short cmaxsafe([This] short3 a)
    {
        return a.x.max(a.y).max(a.z);
    }
}

#endregion // short3

#region short4

public partial struct short4
{
    [MethodImpl(256 | 512)]
    public static short4 operator +(short4 a) => a;
    [MethodImpl(256 | 512)]
    public static short4 operator -(short4 a)
    {
        return new((short)(-a.x), (short)(-a.y), (short)(-a.z), (short)(-a.w));
    }

    [MethodImpl(256 | 512)]
    public static short4 operator +(short4 a, short4 b)
    {
        return new((short)(a.x + b.x), (short)(a.y + b.y), (short)(a.z + b.z), (short)(a.w + b.w));
    }

    [MethodImpl(256 | 512)]
    public static short4 operator +(short4 a, short b) => a + new short4(b);

    [MethodImpl(256 | 512)]
    public static short4 operator +(short a, short4 b) => new short4(a) + b;

    [MethodImpl(256 | 512)]
    public static short4 operator -(short4 a, short4 b)
    {
        return new((short)(a.x - b.x), (short)(a.y - b.y), (short)(a.z - b.z), (short)(a.w - b.w));
    }

    [MethodImpl(256 | 512)]
    public static short4 operator -(short4 a, short b) => a - new short4(b);

    [MethodImpl(256 | 512)]
    public static short4 operator -(short a, short4 b) => new short4(a) - b;

    [MethodImpl(256 | 512)]
    public static short4 operator *(short4 a, short4 b)
    {
        return new((short)(a.x * b.x), (short)(a.y * b.y), (short)(a.z * b.z), (short)(a.w * b.w));
    }

    [MethodImpl(256 | 512)]
    public static short4 operator *(short a, short4 b)
    {
        return new((short)(a * b.x), (short)(a * b.y), (short)(a * b.z), (short)(a * b.w));
    }

    [MethodImpl(256 | 512)]
    public static short4 operator *(short4 a, short b)
    {
        return new((short)(a.x * b), (short)(a.y * b), (short)(a.z * b), (short)(a.w * b));
    }

    [MethodImpl(256 | 512)]
    public static short4 operator /(short4 a, short4 b)
    {
        return new((short)(a.x / b.x), (short)(a.y / b.y), (short)(a.z / b.z), (short)(a.w / b.w));
    }

    [MethodImpl(256 | 512)]
    public static short4 operator /(short4 a, short b)
    {
        return new((short)(a.x / b), (short)(a.y / b), (short)(a.z / b), (short)(a.w / b));
    }

    [MethodImpl(256 | 512)]
    public static short4 operator /(short a, short4 b) => new short4(a) / b;

    [MethodImpl(256 | 512)]
    public static short4 operator %(short4 a, short4 b)
    {
        return new((short)(a.x % b.x), (short)(a.y % b.y), (short)(a.z % b.z), (short)(a.w % b.w));
    }

    [MethodImpl(256 | 512)]
    public static short4 operator %(short4 a, short b)
    {
        return new((short)(a.x % b), (short)(a.y % b), (short)(a.z % b), (short)(a.w % b));
    }

    [MethodImpl(256 | 512)]
    public static short4 operator %(short a, short4 b) => new short4(a) % b;

    [MethodImpl(256 | 512)]
    public static short4 operator --(short4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static short4 operator ++(short4 a) => a + One;
}

[Ex]
public static partial class math
{
    [MethodImpl(256 | 512)]
    public static short4 abs([This] short4 a)
    {
        return new(a.x.abs(), a.y.abs(), a.z.abs(), a.w.abs());
    }

    [MethodImpl(256 | 512)]
    public static short4 sign([This] short4 a)
    {
        return new(a.x.sign(), a.y.sign(), a.z.sign(), a.w.sign());
    }

    [MethodImpl(256 | 512)]
    public static short4 min([This] short4 a, short4 b)
    {
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z), a.w.min(b.w));
    }

    [MethodImpl(256 | 512)]
    public static short4 max([This] short4 a, short4 b)
    {
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z), a.w.max(b.w));
    }

    [MethodImpl(256 | 512)]
    public static short4 clamp([This] short4 v, short4 min, short4 max)
    {
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z), v.w.clamp(min.w, max.w));
    }

    [MethodImpl(256 | 512)]
    public static short4 clamp([This] short4 v, short min, short max) => v.clamp(new short4(min), new short4(max));

    [MethodImpl(256 | 512)]
    public static short4 lerp(short4 start, short4 end, [This] short4 t)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static short4 lerp(short4 start, short4 end, [This] short t)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static short4 lerp(short start, short end, [This] short4 t)
    {
        return start + t * (short)(end - start);
    }

    [MethodImpl(256 | 512)]
    public static short4 unlerp([This] short4 a, short4 start, short4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static short4 unlerp([This] short a, short4 start, short4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static short4 unlerp([This] short4 a, short start, short end) => (a - start) / (short)(end - start);

    [MethodImpl(256 | 512)]
    public static short4 remap([This] short4 a, short4 srcStart, short4 srcEnd, short4 dstStart, short4 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static short4 remap([This] short4 a, short srcStart, short srcEnd, short dstStart, short dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static short dot([This] short4 a, short4 b)
    {
        return (short)(a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w);
    }

    [MethodImpl(256 | 512)]
    public static short lengthsq([This] short4 a)
    {
        return (short)(a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w);
    }

    [MethodImpl(256 | 512)]
    public static short distancesq([This] short4 a, short4 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static short4 square([This] short4 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static short4 fma([This] short4 a, short4 b, short4 c)
    {
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y), a.z.fma(b.z, c.z), a.w.fma(b.w, c.w));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static short4 fms([This] short4 a, short4 b, short4 c)
    {
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y), a.z.fms(b.z, c.z), a.w.fms(b.w, c.w));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static short4 fnma([This] short4 a, short4 b, short4 c)
    {
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y), a.z.fnma(b.z, c.z), a.w.fnma(b.w, c.w));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static short4 fsm([This] short4 c, short4 a, short4 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static short4 fam([This] short4 c, short4 a, short4 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static short4 mad([This] short4 a, short4 b, short4 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static short csum([This] short4 a)
    {
        return (short)(a.x + a.y + a.z + a.w);
    }

    [MethodImpl(256 | 512)]
    public static short cmin([This] short4 a)
    {
        return a.x.min(a.y).min(a.z).min(a.w);
    }

    [MethodImpl(256 | 512)]
    public static short cmax([This] short4 a)
    {
        return a.x.max(a.y).max(a.z).max(a.w);
    }

    [MethodImpl(256 | 512)]
    public static short cminsafe([This] short4 a)
    {
        return a.x.min(a.y).min(a.z).min(a.w);
    }

    [MethodImpl(256 | 512)]
    public static short cmaxsafe([This] short4 a)
    {
        return a.x.max(a.y).max(a.z).max(a.w);
    }
}

#endregion // short4

#region ushort2

public partial struct ushort2
{
    [MethodImpl(256 | 512)]
    public static ushort2 operator +(ushort2 a) => a;

    [MethodImpl(256 | 512)]
    public static ushort2 operator +(ushort2 a, ushort2 b)
    {
        return new((ushort)(a.x + b.x), (ushort)(a.y + b.y));
    }

    [MethodImpl(256 | 512)]
    public static ushort2 operator +(ushort2 a, ushort b) => a + new ushort2(b);

    [MethodImpl(256 | 512)]
    public static ushort2 operator +(ushort a, ushort2 b) => new ushort2(a) + b;

    [MethodImpl(256 | 512)]
    public static ushort2 operator -(ushort2 a, ushort2 b)
    {
        return new((ushort)(a.x - b.x), (ushort)(a.y - b.y));
    }

    [MethodImpl(256 | 512)]
    public static ushort2 operator -(ushort2 a, ushort b) => a - new ushort2(b);

    [MethodImpl(256 | 512)]
    public static ushort2 operator -(ushort a, ushort2 b) => new ushort2(a) - b;

    [MethodImpl(256 | 512)]
    public static ushort2 operator *(ushort2 a, ushort2 b)
    {
        return new((ushort)(a.x * b.x), (ushort)(a.y * b.y));
    }

    [MethodImpl(256 | 512)]
    public static ushort2 operator *(ushort a, ushort2 b)
    {
        return new((ushort)(a * b.x), (ushort)(a * b.y));
    }

    [MethodImpl(256 | 512)]
    public static ushort2 operator *(ushort2 a, ushort b)
    {
        return new((ushort)(a.x * b), (ushort)(a.y * b));
    }

    [MethodImpl(256 | 512)]
    public static ushort2 operator /(ushort2 a, ushort2 b)
    {
        return new((ushort)(a.x / b.x), (ushort)(a.y / b.y));
    }

    [MethodImpl(256 | 512)]
    public static ushort2 operator /(ushort2 a, ushort b)
    {
        return new((ushort)(a.x / b), (ushort)(a.y / b));
    }

    [MethodImpl(256 | 512)]
    public static ushort2 operator /(ushort a, ushort2 b) => new ushort2(a) / b;

    [MethodImpl(256 | 512)]
    public static ushort2 operator %(ushort2 a, ushort2 b)
    {
        return new((ushort)(a.x % b.x), (ushort)(a.y % b.y));
    }

    [MethodImpl(256 | 512)]
    public static ushort2 operator %(ushort2 a, ushort b)
    {
        return new((ushort)(a.x % b), (ushort)(a.y % b));
    }

    [MethodImpl(256 | 512)]
    public static ushort2 operator %(ushort a, ushort2 b) => new ushort2(a) % b;

    [MethodImpl(256 | 512)]
    public static ushort2 operator --(ushort2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static ushort2 operator ++(ushort2 a) => a + One;
}

[Ex]
public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ushort2 abs([This] ushort2 a)
    {
        return new(a.x.abs(), a.y.abs());
    }

    [MethodImpl(256 | 512)]
    public static ushort2 sign([This] ushort2 a)
    {
        return new(a.x.sign(), a.y.sign());
    }

    [MethodImpl(256 | 512)]
    public static ushort2 min([This] ushort2 a, ushort2 b)
    {
        return new(a.x.min(b.x), a.y.min(b.y));
    }

    [MethodImpl(256 | 512)]
    public static ushort2 max([This] ushort2 a, ushort2 b)
    {
        return new(a.x.max(b.x), a.y.max(b.y));
    }

    [MethodImpl(256 | 512)]
    public static ushort2 clamp([This] ushort2 v, ushort2 min, ushort2 max)
    {
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y));
    }

    [MethodImpl(256 | 512)]
    public static ushort2 clamp([This] ushort2 v, ushort min, ushort max) => v.clamp(new ushort2(min), new ushort2(max));

    [MethodImpl(256 | 512)]
    public static ushort2 lerp(ushort2 start, ushort2 end, [This] ushort2 t)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static ushort2 lerp(ushort2 start, ushort2 end, [This] ushort t)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static ushort2 lerp(ushort start, ushort end, [This] ushort2 t)
    {
        return start + t * (ushort)(end - start);
    }

    [MethodImpl(256 | 512)]
    public static ushort2 unlerp([This] ushort2 a, ushort2 start, ushort2 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ushort2 unlerp([This] ushort a, ushort2 start, ushort2 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ushort2 unlerp([This] ushort2 a, ushort start, ushort end) => (a - start) / (ushort)(end - start);

    [MethodImpl(256 | 512)]
    public static ushort2 remap([This] ushort2 a, ushort2 srcStart, ushort2 srcEnd, ushort2 dstStart, ushort2 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static ushort2 remap([This] ushort2 a, ushort srcStart, ushort srcEnd, ushort dstStart, ushort dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static ushort dot([This] ushort2 a, ushort2 b)
    {
        return (ushort)(a.x * b.x + a.y * b.y);
    }

    [MethodImpl(256 | 512)]
    public static ushort lengthsq([This] ushort2 a)
    {
        return (ushort)(a.x * a.x + a.y * a.y);
    }

    [MethodImpl(256 | 512)]
    public static ushort distancesq([This] ushort2 a, ushort2 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static ushort2 square([This] ushort2 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ushort2 fma([This] ushort2 a, ushort2 b, ushort2 c)
    {
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static ushort2 fms([This] ushort2 a, ushort2 b, ushort2 c)
    {
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static ushort2 fnma([This] ushort2 a, ushort2 b, ushort2 c)
    {
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static ushort2 fsm([This] ushort2 c, ushort2 a, ushort2 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ushort2 fam([This] ushort2 c, ushort2 a, ushort2 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ushort2 mad([This] ushort2 a, ushort2 b, ushort2 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static ushort csum([This] ushort2 a)
    {
        return (ushort)(a.x + a.y);
    }

    [MethodImpl(256 | 512)]
    public static ushort cmin([This] ushort2 a)
    {
        return a.x.min(a.y);
    }

    [MethodImpl(256 | 512)]
    public static ushort cmax([This] ushort2 a)
    {
        return a.x.max(a.y);
    }

    [MethodImpl(256 | 512)]
    public static ushort cminsafe([This] ushort2 a)
    {
        return a.x.min(a.y);
    }

    [MethodImpl(256 | 512)]
    public static ushort cmaxsafe([This] ushort2 a)
    {
        return a.x.max(a.y);
    }
}

#endregion // ushort2

#region ushort3

public partial struct ushort3
{
    [MethodImpl(256 | 512)]
    public static ushort3 operator +(ushort3 a) => a;

    [MethodImpl(256 | 512)]
    public static ushort3 operator +(ushort3 a, ushort3 b)
    {
        return new((ushort)(a.x + b.x), (ushort)(a.y + b.y), (ushort)(a.z + b.z));
    }

    [MethodImpl(256 | 512)]
    public static ushort3 operator +(ushort3 a, ushort b) => a + new ushort3(b);

    [MethodImpl(256 | 512)]
    public static ushort3 operator +(ushort a, ushort3 b) => new ushort3(a) + b;

    [MethodImpl(256 | 512)]
    public static ushort3 operator -(ushort3 a, ushort3 b)
    {
        return new((ushort)(a.x - b.x), (ushort)(a.y - b.y), (ushort)(a.z - b.z));
    }

    [MethodImpl(256 | 512)]
    public static ushort3 operator -(ushort3 a, ushort b) => a - new ushort3(b);

    [MethodImpl(256 | 512)]
    public static ushort3 operator -(ushort a, ushort3 b) => new ushort3(a) - b;

    [MethodImpl(256 | 512)]
    public static ushort3 operator *(ushort3 a, ushort3 b)
    {
        return new((ushort)(a.x * b.x), (ushort)(a.y * b.y), (ushort)(a.z * b.z));
    }

    [MethodImpl(256 | 512)]
    public static ushort3 operator *(ushort a, ushort3 b)
    {
        return new((ushort)(a * b.x), (ushort)(a * b.y), (ushort)(a * b.z));
    }

    [MethodImpl(256 | 512)]
    public static ushort3 operator *(ushort3 a, ushort b)
    {
        return new((ushort)(a.x * b), (ushort)(a.y * b), (ushort)(a.z * b));
    }

    [MethodImpl(256 | 512)]
    public static ushort3 operator /(ushort3 a, ushort3 b)
    {
        return new((ushort)(a.x / b.x), (ushort)(a.y / b.y), (ushort)(a.z / b.z));
    }

    [MethodImpl(256 | 512)]
    public static ushort3 operator /(ushort3 a, ushort b)
    {
        return new((ushort)(a.x / b), (ushort)(a.y / b), (ushort)(a.z / b));
    }

    [MethodImpl(256 | 512)]
    public static ushort3 operator /(ushort a, ushort3 b) => new ushort3(a) / b;

    [MethodImpl(256 | 512)]
    public static ushort3 operator %(ushort3 a, ushort3 b)
    {
        return new((ushort)(a.x % b.x), (ushort)(a.y % b.y), (ushort)(a.z % b.z));
    }

    [MethodImpl(256 | 512)]
    public static ushort3 operator %(ushort3 a, ushort b)
    {
        return new((ushort)(a.x % b), (ushort)(a.y % b), (ushort)(a.z % b));
    }

    [MethodImpl(256 | 512)]
    public static ushort3 operator %(ushort a, ushort3 b) => new ushort3(a) % b;

    [MethodImpl(256 | 512)]
    public static ushort3 operator --(ushort3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static ushort3 operator ++(ushort3 a) => a + One;
}

[Ex]
public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ushort3 abs([This] ushort3 a)
    {
        return new(a.x.abs(), a.y.abs(), a.z.abs());
    }

    [MethodImpl(256 | 512)]
    public static ushort3 sign([This] ushort3 a)
    {
        return new(a.x.sign(), a.y.sign(), a.z.sign());
    }

    [MethodImpl(256 | 512)]
    public static ushort3 min([This] ushort3 a, ushort3 b)
    {
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z));
    }

    [MethodImpl(256 | 512)]
    public static ushort3 max([This] ushort3 a, ushort3 b)
    {
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z));
    }

    [MethodImpl(256 | 512)]
    public static ushort3 clamp([This] ushort3 v, ushort3 min, ushort3 max)
    {
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z));
    }

    [MethodImpl(256 | 512)]
    public static ushort3 clamp([This] ushort3 v, ushort min, ushort max) => v.clamp(new ushort3(min), new ushort3(max));

    [MethodImpl(256 | 512)]
    public static ushort3 lerp(ushort3 start, ushort3 end, [This] ushort3 t)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static ushort3 lerp(ushort3 start, ushort3 end, [This] ushort t)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static ushort3 lerp(ushort start, ushort end, [This] ushort3 t)
    {
        return start + t * (ushort)(end - start);
    }

    [MethodImpl(256 | 512)]
    public static ushort3 unlerp([This] ushort3 a, ushort3 start, ushort3 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ushort3 unlerp([This] ushort a, ushort3 start, ushort3 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ushort3 unlerp([This] ushort3 a, ushort start, ushort end) => (a - start) / (ushort)(end - start);

    [MethodImpl(256 | 512)]
    public static ushort3 remap([This] ushort3 a, ushort3 srcStart, ushort3 srcEnd, ushort3 dstStart, ushort3 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static ushort3 remap([This] ushort3 a, ushort srcStart, ushort srcEnd, ushort dstStart, ushort dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static ushort dot([This] ushort3 a, ushort3 b)
    {
        return (ushort)(a.x * b.x + a.y * b.y + a.z * b.z);
    }

    [MethodImpl(256 | 512)]
    public static ushort3 cross([This] ushort3 a, ushort3 b)
    {
        // (a * b.yzx - a.yzx * b).yzx;
        return fnma(a.yzx, b, a * b.yzx).yzx;
    }

    [MethodImpl(256 | 512)]
    public static ushort lengthsq([This] ushort3 a)
    {
        return (ushort)(a.x * a.x + a.y * a.y + a.z * a.z);
    }

    [MethodImpl(256 | 512)]
    public static ushort distancesq([This] ushort3 a, ushort3 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static ushort3 square([This] ushort3 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ushort3 fma([This] ushort3 a, ushort3 b, ushort3 c)
    {
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y), a.z.fma(b.z, c.z));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static ushort3 fms([This] ushort3 a, ushort3 b, ushort3 c)
    {
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y), a.z.fms(b.z, c.z));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static ushort3 fnma([This] ushort3 a, ushort3 b, ushort3 c)
    {
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y), a.z.fnma(b.z, c.z));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static ushort3 fsm([This] ushort3 c, ushort3 a, ushort3 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ushort3 fam([This] ushort3 c, ushort3 a, ushort3 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ushort3 mad([This] ushort3 a, ushort3 b, ushort3 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static ushort csum([This] ushort3 a)
    {
        return (ushort)(a.x + a.y + a.z);
    }

    [MethodImpl(256 | 512)]
    public static ushort cmin([This] ushort3 a)
    {
        return a.x.min(a.y).min(a.z);
    }

    [MethodImpl(256 | 512)]
    public static ushort cmax([This] ushort3 a)
    {
        return a.x.max(a.y).max(a.z);
    }

    [MethodImpl(256 | 512)]
    public static ushort cminsafe([This] ushort3 a)
    {
        return a.x.min(a.y).min(a.z);
    }

    [MethodImpl(256 | 512)]
    public static ushort cmaxsafe([This] ushort3 a)
    {
        return a.x.max(a.y).max(a.z);
    }
}

#endregion // ushort3

#region ushort4

public partial struct ushort4
{
    [MethodImpl(256 | 512)]
    public static ushort4 operator +(ushort4 a) => a;

    [MethodImpl(256 | 512)]
    public static ushort4 operator +(ushort4 a, ushort4 b)
    {
        return new((ushort)(a.x + b.x), (ushort)(a.y + b.y), (ushort)(a.z + b.z), (ushort)(a.w + b.w));
    }

    [MethodImpl(256 | 512)]
    public static ushort4 operator +(ushort4 a, ushort b) => a + new ushort4(b);

    [MethodImpl(256 | 512)]
    public static ushort4 operator +(ushort a, ushort4 b) => new ushort4(a) + b;

    [MethodImpl(256 | 512)]
    public static ushort4 operator -(ushort4 a, ushort4 b)
    {
        return new((ushort)(a.x - b.x), (ushort)(a.y - b.y), (ushort)(a.z - b.z), (ushort)(a.w - b.w));
    }

    [MethodImpl(256 | 512)]
    public static ushort4 operator -(ushort4 a, ushort b) => a - new ushort4(b);

    [MethodImpl(256 | 512)]
    public static ushort4 operator -(ushort a, ushort4 b) => new ushort4(a) - b;

    [MethodImpl(256 | 512)]
    public static ushort4 operator *(ushort4 a, ushort4 b)
    {
        return new((ushort)(a.x * b.x), (ushort)(a.y * b.y), (ushort)(a.z * b.z), (ushort)(a.w * b.w));
    }

    [MethodImpl(256 | 512)]
    public static ushort4 operator *(ushort a, ushort4 b)
    {
        return new((ushort)(a * b.x), (ushort)(a * b.y), (ushort)(a * b.z), (ushort)(a * b.w));
    }

    [MethodImpl(256 | 512)]
    public static ushort4 operator *(ushort4 a, ushort b)
    {
        return new((ushort)(a.x * b), (ushort)(a.y * b), (ushort)(a.z * b), (ushort)(a.w * b));
    }

    [MethodImpl(256 | 512)]
    public static ushort4 operator /(ushort4 a, ushort4 b)
    {
        return new((ushort)(a.x / b.x), (ushort)(a.y / b.y), (ushort)(a.z / b.z), (ushort)(a.w / b.w));
    }

    [MethodImpl(256 | 512)]
    public static ushort4 operator /(ushort4 a, ushort b)
    {
        return new((ushort)(a.x / b), (ushort)(a.y / b), (ushort)(a.z / b), (ushort)(a.w / b));
    }

    [MethodImpl(256 | 512)]
    public static ushort4 operator /(ushort a, ushort4 b) => new ushort4(a) / b;

    [MethodImpl(256 | 512)]
    public static ushort4 operator %(ushort4 a, ushort4 b)
    {
        return new((ushort)(a.x % b.x), (ushort)(a.y % b.y), (ushort)(a.z % b.z), (ushort)(a.w % b.w));
    }

    [MethodImpl(256 | 512)]
    public static ushort4 operator %(ushort4 a, ushort b)
    {
        return new((ushort)(a.x % b), (ushort)(a.y % b), (ushort)(a.z % b), (ushort)(a.w % b));
    }

    [MethodImpl(256 | 512)]
    public static ushort4 operator %(ushort a, ushort4 b) => new ushort4(a) % b;

    [MethodImpl(256 | 512)]
    public static ushort4 operator --(ushort4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static ushort4 operator ++(ushort4 a) => a + One;
}

[Ex]
public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ushort4 abs([This] ushort4 a)
    {
        return new(a.x.abs(), a.y.abs(), a.z.abs(), a.w.abs());
    }

    [MethodImpl(256 | 512)]
    public static ushort4 sign([This] ushort4 a)
    {
        return new(a.x.sign(), a.y.sign(), a.z.sign(), a.w.sign());
    }

    [MethodImpl(256 | 512)]
    public static ushort4 min([This] ushort4 a, ushort4 b)
    {
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z), a.w.min(b.w));
    }

    [MethodImpl(256 | 512)]
    public static ushort4 max([This] ushort4 a, ushort4 b)
    {
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z), a.w.max(b.w));
    }

    [MethodImpl(256 | 512)]
    public static ushort4 clamp([This] ushort4 v, ushort4 min, ushort4 max)
    {
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z), v.w.clamp(min.w, max.w));
    }

    [MethodImpl(256 | 512)]
    public static ushort4 clamp([This] ushort4 v, ushort min, ushort max) => v.clamp(new ushort4(min), new ushort4(max));

    [MethodImpl(256 | 512)]
    public static ushort4 lerp(ushort4 start, ushort4 end, [This] ushort4 t)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static ushort4 lerp(ushort4 start, ushort4 end, [This] ushort t)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static ushort4 lerp(ushort start, ushort end, [This] ushort4 t)
    {
        return start + t * (ushort)(end - start);
    }

    [MethodImpl(256 | 512)]
    public static ushort4 unlerp([This] ushort4 a, ushort4 start, ushort4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ushort4 unlerp([This] ushort a, ushort4 start, ushort4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ushort4 unlerp([This] ushort4 a, ushort start, ushort end) => (a - start) / (ushort)(end - start);

    [MethodImpl(256 | 512)]
    public static ushort4 remap([This] ushort4 a, ushort4 srcStart, ushort4 srcEnd, ushort4 dstStart, ushort4 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static ushort4 remap([This] ushort4 a, ushort srcStart, ushort srcEnd, ushort dstStart, ushort dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static ushort dot([This] ushort4 a, ushort4 b)
    {
        return (ushort)(a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w);
    }

    [MethodImpl(256 | 512)]
    public static ushort lengthsq([This] ushort4 a)
    {
        return (ushort)(a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w);
    }

    [MethodImpl(256 | 512)]
    public static ushort distancesq([This] ushort4 a, ushort4 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static ushort4 square([This] ushort4 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ushort4 fma([This] ushort4 a, ushort4 b, ushort4 c)
    {
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y), a.z.fma(b.z, c.z), a.w.fma(b.w, c.w));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static ushort4 fms([This] ushort4 a, ushort4 b, ushort4 c)
    {
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y), a.z.fms(b.z, c.z), a.w.fms(b.w, c.w));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static ushort4 fnma([This] ushort4 a, ushort4 b, ushort4 c)
    {
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y), a.z.fnma(b.z, c.z), a.w.fnma(b.w, c.w));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static ushort4 fsm([This] ushort4 c, ushort4 a, ushort4 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ushort4 fam([This] ushort4 c, ushort4 a, ushort4 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ushort4 mad([This] ushort4 a, ushort4 b, ushort4 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static ushort csum([This] ushort4 a)
    {
        return (ushort)(a.x + a.y + a.z + a.w);
    }

    [MethodImpl(256 | 512)]
    public static ushort cmin([This] ushort4 a)
    {
        return a.x.min(a.y).min(a.z).min(a.w);
    }

    [MethodImpl(256 | 512)]
    public static ushort cmax([This] ushort4 a)
    {
        return a.x.max(a.y).max(a.z).max(a.w);
    }

    [MethodImpl(256 | 512)]
    public static ushort cminsafe([This] ushort4 a)
    {
        return a.x.min(a.y).min(a.z).min(a.w);
    }

    [MethodImpl(256 | 512)]
    public static ushort cmaxsafe([This] ushort4 a)
    {
        return a.x.max(a.y).max(a.z).max(a.w);
    }
}

#endregion // ushort4

#region int2

public partial struct int2
{
    [MethodImpl(256 | 512)]
    public static int2 operator +(int2 a) => a;
    [MethodImpl(256 | 512)]
    public static int2 operator -(int2 a)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(-a.vector);
        return new((-a.x), (-a.y));
    }

    [MethodImpl(256 | 512)]
    public static int2 operator +(int2 a, int2 b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(a.vector + b.vector);
        return new((int)(a.x + b.x), (int)(a.y + b.y));
    }

    [MethodImpl(256 | 512)]
    public static int2 operator +(int2 a, int b) => a + new int2(b);

    [MethodImpl(256 | 512)]
    public static int2 operator +(int a, int2 b) => new int2(a) + b;

    [MethodImpl(256 | 512)]
    public static int2 operator -(int2 a, int2 b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(a.vector - b.vector);
        return new((int)(a.x - b.x), (int)(a.y - b.y));
    }

    [MethodImpl(256 | 512)]
    public static int2 operator -(int2 a, int b) => a - new int2(b);

    [MethodImpl(256 | 512)]
    public static int2 operator -(int a, int2 b) => new int2(a) - b;

    [MethodImpl(256 | 512)]
    public static int2 operator *(int2 a, int2 b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(a.vector * b.vector);
        return new((int)(a.x * b.x), (int)(a.y * b.y));
    }

    [MethodImpl(256 | 512)]
    public static int2 operator *(int a, int2 b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(a * b.vector);
        return new((int)(a * b.x), (int)(a * b.y));
    }

    [MethodImpl(256 | 512)]
    public static int2 operator *(int2 a, int b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(a.vector * b);
        return new((int)(a.x * b), (int)(a.y * b));
    }

    [MethodImpl(256 | 512)]
    public static int2 operator /(int2 a, int2 b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new((a.vector / b.vector));
        return new((int)(a.x / b.x), (int)(a.y / b.y));
    }

    [MethodImpl(256 | 512)]
    public static int2 operator /(int2 a, int b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new((a.vector / b));
        return new((int)(a.x / b), (int)(a.y / b));
    }

    [MethodImpl(256 | 512)]
    public static int2 operator /(int a, int2 b) => new int2(a) / b;

    [MethodImpl(256 | 512)]
    public static int2 operator %(int2 a, int2 b)
    {
        if (Vector64.IsHardwareAccelerated)
            return a - (a / b) * b;
        return new((int)(a.x % b.x), (int)(a.y % b.y));
    }

    [MethodImpl(256 | 512)]
    public static int2 operator %(int2 a, int b)
    {
        if (Vector64.IsHardwareAccelerated)
            return a - (a / b) * b;
        return new((int)(a.x % b), (int)(a.y % b));
    }

    [MethodImpl(256 | 512)]
    public static int2 operator %(int a, int2 b) => new int2(a) % b;

    [MethodImpl(256 | 512)]
    public static int2 operator --(int2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static int2 operator ++(int2 a) => a + One;
}

[Ex]
public static partial class math
{
    [MethodImpl(256 | 512)]
    public static int2 abs([This] int2 a)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(Vector64.Abs(a.vector));
        return new(a.x.abs(), a.y.abs());
    }

    [MethodImpl(256 | 512)]
    public static int2 sign([This] int2 a)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(simd.SignInt(a.vector));
        return new(a.x.sign(), a.y.sign());
    }

    [MethodImpl(256 | 512)]
    public static int2 min([This] int2 a, int2 b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(Vector64.Min(a.vector, b.vector));
        return new(a.x.min(b.x), a.y.min(b.y));
    }

    [MethodImpl(256 | 512)]
    public static int2 max([This] int2 a, int2 b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(Vector64.Max(a.vector, b.vector));
        return new(a.x.max(b.x), a.y.max(b.y));
    }

    [MethodImpl(256 | 512)]
    public static int2 clamp([This] int2 v, int2 min, int2 max)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(Vector64.Max(min.vector, Vector64.Min(max.vector, v.vector)));
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y));
    }

    [MethodImpl(256 | 512)]
    public static int2 clamp([This] int2 v, int min, int max) => v.clamp(new int2(min), new int2(max));

    [MethodImpl(256 | 512)]
    public static int2 lerp(int2 start, int2 end, [This] int2 t)
    {
        if (Vector64.IsHardwareAccelerated)
            return fma(t, end - start, start);
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static int2 lerp(int2 start, int2 end, [This] int t)
    {
        if (Vector64.IsHardwareAccelerated)
            return fma(new(t), end - start, start);
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static int2 lerp(int start, int end, [This] int2 t)
    {
        if (Vector64.IsHardwareAccelerated)
            return fma(t, (end - start), new(start));
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static int2 unlerp([This] int2 a, int2 start, int2 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static int2 unlerp([This] int a, int2 start, int2 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static int2 unlerp([This] int2 a, int start, int end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static int2 remap([This] int2 a, int2 srcStart, int2 srcEnd, int2 dstStart, int2 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static int2 remap([This] int2 a, int srcStart, int srcEnd, int dstStart, int dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static int dot([This] int2 a, int2 b)
    {
        if (Vector64.IsHardwareAccelerated)
            return Vector64.Dot(a.vector, b.vector);
        return (int)(a.x * b.x + a.y * b.y);
    }

    [MethodImpl(256 | 512)]
    public static int lengthsq([This] int2 a)
    {
        if (Vector64.IsHardwareAccelerated)
            return Vector64.Dot(a.vector, a.vector);
        return (int)(a.x * a.x + a.y * a.y);
    }

    [MethodImpl(256 | 512)]
    public static int distancesq([This] int2 a, int2 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static int2 square([This] int2 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static int2 fma([This] int2 a, int2 b, int2 c)
    {
        if (Vector64.IsHardwareAccelerated)
            return (a * b) + c;
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static int2 fms([This] int2 a, int2 b, int2 c)
    {
        if (Vector64.IsHardwareAccelerated)
            return (a * b) - c;
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static int2 fnma([This] int2 a, int2 b, int2 c)
    {
        if (Vector64.IsHardwareAccelerated)
            return c - (a * b);
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static int2 fsm([This] int2 c, int2 a, int2 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static int2 fam([This] int2 c, int2 a, int2 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static int2 mad([This] int2 a, int2 b, int2 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static int csum([This] int2 a)
    {
        if (Vector64.IsHardwareAccelerated)
            return Vector64.Sum(a.vector);
        return (a.x + a.y);
    }

    [MethodImpl(256 | 512)]
    public static int cmin([This] int2 a)
    {
        if (Vector128.IsHardwareAccelerated || Vector64.IsHardwareAccelerated)
            return simd.CMin(a.vector);
        return a.x.min(a.y);
    }

    [MethodImpl(256 | 512)]
    public static int cmax([This] int2 a)
    {
        if (Vector128.IsHardwareAccelerated || Vector64.IsHardwareAccelerated)
            return simd.CMax(a.vector);
        return a.x.max(a.y);
    }

    [MethodImpl(256 | 512)]
    public static int cminsafe([This] int2 a)
    {
        if (Vector128.IsHardwareAccelerated || Vector64.IsHardwareAccelerated)
            return simd.CMin(a.vector);
        return a.x.min(a.y);
    }

    [MethodImpl(256 | 512)]
    public static int cmaxsafe([This] int2 a)
    {
        if (Vector128.IsHardwareAccelerated || Vector64.IsHardwareAccelerated)
            return simd.CMax(a.vector);
        return a.x.max(a.y);
    }
}

#endregion // int2

#region int3

public partial struct int3
{
    [MethodImpl(256 | 512)]
    public static int3 operator +(int3 a) => a;
    [MethodImpl(256 | 512)]
    public static int3 operator -(int3 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(-a.vector & Vector128.Create(-1, -1, -1, 0).AsInt32());
        return new((-a.x), (-a.y), (-a.z));
    }

    [MethodImpl(256 | 512)]
    public static int3 operator +(int3 a, int3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector + b.vector);
        return new((int)(a.x + b.x), (int)(a.y + b.y), (int)(a.z + b.z));
    }

    [MethodImpl(256 | 512)]
    public static int3 operator +(int3 a, int b) => a + new int3(b);

    [MethodImpl(256 | 512)]
    public static int3 operator +(int a, int3 b) => new int3(a) + b;

    [MethodImpl(256 | 512)]
    public static int3 operator -(int3 a, int3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector - b.vector);
        return new((int)(a.x - b.x), (int)(a.y - b.y), (int)(a.z - b.z));
    }

    [MethodImpl(256 | 512)]
    public static int3 operator -(int3 a, int b) => a - new int3(b);

    [MethodImpl(256 | 512)]
    public static int3 operator -(int a, int3 b) => new int3(a) - b;

    [MethodImpl(256 | 512)]
    public static int3 operator *(int3 a, int3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector * b.vector);
        return new((int)(a.x * b.x), (int)(a.y * b.y), (int)(a.z * b.z));
    }

    [MethodImpl(256 | 512)]
    public static int3 operator *(int a, int3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a * b.vector);
        return new((int)(a * b.x), (int)(a * b.y), (int)(a * b.z));
    }

    [MethodImpl(256 | 512)]
    public static int3 operator *(int3 a, int b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector * b);
        return new((int)(a.x * b), (int)(a.y * b), (int)(a.z * b));
    }

    [MethodImpl(256 | 512)]
    public static int3 operator /(int3 a, int3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new((a.vector / b.vector.WithElement(3, 1)));
        return new((int)(a.x / b.x), (int)(a.y / b.y), (int)(a.z / b.z));
    }

    [MethodImpl(256 | 512)]
    public static int3 operator /(int3 a, int b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new((a.vector / b));
        return new((int)(a.x / b), (int)(a.y / b), (int)(a.z / b));
    }

    [MethodImpl(256 | 512)]
    public static int3 operator /(int a, int3 b) => new int3(a) / b;

    [MethodImpl(256 | 512)]
    public static int3 operator %(int3 a, int3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return a - (a / b) * b;
        return new((int)(a.x % b.x), (int)(a.y % b.y), (int)(a.z % b.z));
    }

    [MethodImpl(256 | 512)]
    public static int3 operator %(int3 a, int b)
    {
        if (Vector128.IsHardwareAccelerated)
            return a - (a / b) * b;
        return new((int)(a.x % b), (int)(a.y % b), (int)(a.z % b));
    }

    [MethodImpl(256 | 512)]
    public static int3 operator %(int a, int3 b) => new int3(a) % b;

    [MethodImpl(256 | 512)]
    public static int3 operator --(int3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static int3 operator ++(int3 a) => a + One;
}

[Ex]
public static partial class math
{
    [MethodImpl(256 | 512)]
    public static int3 abs([This] int3 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.Abs(a.vector));
        return new(a.x.abs(), a.y.abs(), a.z.abs());
    }

    [MethodImpl(256 | 512)]
    public static int3 sign([This] int3 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.SignInt(a.vector) & Vector128.Create(-1, -1, -1, 0).AsInt32());
        return new(a.x.sign(), a.y.sign(), a.z.sign());
    }

    [MethodImpl(256 | 512)]
    public static int3 min([This] int3 a, int3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.Min(a.vector, b.vector));
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z));
    }

    [MethodImpl(256 | 512)]
    public static int3 max([This] int3 a, int3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.Max(a.vector, b.vector));
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z));
    }

    [MethodImpl(256 | 512)]
    public static int3 clamp([This] int3 v, int3 min, int3 max)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.Max(min.vector, Vector128.Min(max.vector, v.vector)));
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z));
    }

    [MethodImpl(256 | 512)]
    public static int3 clamp([This] int3 v, int min, int max) => v.clamp(new int3(min), new int3(max));

    [MethodImpl(256 | 512)]
    public static int3 lerp(int3 start, int3 end, [This] int3 t)
    {
        if (Vector128.IsHardwareAccelerated)
            return fma(t, end - start, start);
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static int3 lerp(int3 start, int3 end, [This] int t)
    {
        if (Vector128.IsHardwareAccelerated)
            return fma(new(t), end - start, start);
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static int3 lerp(int start, int end, [This] int3 t)
    {
        if (Vector128.IsHardwareAccelerated)
            return fma(t, (end - start), new(start));
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static int3 unlerp([This] int3 a, int3 start, int3 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static int3 unlerp([This] int a, int3 start, int3 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static int3 unlerp([This] int3 a, int start, int end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static int3 remap([This] int3 a, int3 srcStart, int3 srcEnd, int3 dstStart, int3 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static int3 remap([This] int3 a, int srcStart, int srcEnd, int dstStart, int dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static int dot([This] int3 a, int3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return Vector128.Dot(a.vector, b.vector);
        return (int)(a.x * b.x + a.y * b.y + a.z * b.z);
    }

    [MethodImpl(256 | 512)]
    public static int3 cross([This] int3 a, int3 b)
    {
        // (a * b.yzx - a.yzx * b).yzx;
        return fnma(a.yzx, b, a * b.yzx).yzx;
    }

    [MethodImpl(256 | 512)]
    public static int lengthsq([This] int3 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return Vector128.Dot(a.vector, a.vector);
        return (int)(a.x * a.x + a.y * a.y + a.z * a.z);
    }

    [MethodImpl(256 | 512)]
    public static int distancesq([This] int3 a, int3 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static int3 square([This] int3 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static int3 fma([This] int3 a, int3 b, int3 c)
    {
        if (Vector128.IsHardwareAccelerated)
            return (a * b) + c;
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y), a.z.fma(b.z, c.z));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static int3 fms([This] int3 a, int3 b, int3 c)
    {
        if (Vector128.IsHardwareAccelerated)
            return (a * b) - c;
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y), a.z.fms(b.z, c.z));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static int3 fnma([This] int3 a, int3 b, int3 c)
    {
        if (Vector128.IsHardwareAccelerated)
            return c - (a * b);
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y), a.z.fnma(b.z, c.z));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static int3 fsm([This] int3 c, int3 a, int3 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static int3 fam([This] int3 c, int3 a, int3 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static int3 mad([This] int3 a, int3 b, int3 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static int csum([This] int3 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return Vector128.Sum(a.vector);
        return (a.x + a.y + a.z);
    }

    [MethodImpl(256 | 512)]
    public static int cmin([This] int3 a)
    {
        if (Vector128.IsHardwareAccelerated || Vector64.IsHardwareAccelerated)
            return simd.CMin3(a.vector);
        return a.x.min(a.y).min(a.z);
    }

    [MethodImpl(256 | 512)]
    public static int cmax([This] int3 a)
    {
        if (Vector128.IsHardwareAccelerated || Vector64.IsHardwareAccelerated)
            return simd.CMax3(a.vector);
        return a.x.max(a.y).max(a.z);
    }

    [MethodImpl(256 | 512)]
    public static int cminsafe([This] int3 a)
    {
        if (Vector128.IsHardwareAccelerated || Vector64.IsHardwareAccelerated)
            return simd.CMin3(a.vector);
        return a.x.min(a.y).min(a.z);
    }

    [MethodImpl(256 | 512)]
    public static int cmaxsafe([This] int3 a)
    {
        if (Vector128.IsHardwareAccelerated || Vector64.IsHardwareAccelerated)
            return simd.CMax3(a.vector);
        return a.x.max(a.y).max(a.z);
    }
}

#endregion // int3

#region int4

public partial struct int4
{
    [MethodImpl(256 | 512)]
    public static int4 operator +(int4 a) => a;
    [MethodImpl(256 | 512)]
    public static int4 operator -(int4 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(-a.vector);
        return new((-a.x), (-a.y), (-a.z), (-a.w));
    }

    [MethodImpl(256 | 512)]
    public static int4 operator +(int4 a, int4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector + b.vector);
        return new((int)(a.x + b.x), (int)(a.y + b.y), (int)(a.z + b.z), (int)(a.w + b.w));
    }

    [MethodImpl(256 | 512)]
    public static int4 operator +(int4 a, int b) => a + new int4(b);

    [MethodImpl(256 | 512)]
    public static int4 operator +(int a, int4 b) => new int4(a) + b;

    [MethodImpl(256 | 512)]
    public static int4 operator -(int4 a, int4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector - b.vector);
        return new((int)(a.x - b.x), (int)(a.y - b.y), (int)(a.z - b.z), (int)(a.w - b.w));
    }

    [MethodImpl(256 | 512)]
    public static int4 operator -(int4 a, int b) => a - new int4(b);

    [MethodImpl(256 | 512)]
    public static int4 operator -(int a, int4 b) => new int4(a) - b;

    [MethodImpl(256 | 512)]
    public static int4 operator *(int4 a, int4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector * b.vector);
        return new((int)(a.x * b.x), (int)(a.y * b.y), (int)(a.z * b.z), (int)(a.w * b.w));
    }

    [MethodImpl(256 | 512)]
    public static int4 operator *(int a, int4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a * b.vector);
        return new((int)(a * b.x), (int)(a * b.y), (int)(a * b.z), (int)(a * b.w));
    }

    [MethodImpl(256 | 512)]
    public static int4 operator *(int4 a, int b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector * b);
        return new((int)(a.x * b), (int)(a.y * b), (int)(a.z * b), (int)(a.w * b));
    }

    [MethodImpl(256 | 512)]
    public static int4 operator /(int4 a, int4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new((a.vector / b.vector));
        return new((int)(a.x / b.x), (int)(a.y / b.y), (int)(a.z / b.z), (int)(a.w / b.w));
    }

    [MethodImpl(256 | 512)]
    public static int4 operator /(int4 a, int b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new((a.vector / b));
        return new((int)(a.x / b), (int)(a.y / b), (int)(a.z / b), (int)(a.w / b));
    }

    [MethodImpl(256 | 512)]
    public static int4 operator /(int a, int4 b) => new int4(a) / b;

    [MethodImpl(256 | 512)]
    public static int4 operator %(int4 a, int4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return a - (a / b) * b;
        return new((int)(a.x % b.x), (int)(a.y % b.y), (int)(a.z % b.z), (int)(a.w % b.w));
    }

    [MethodImpl(256 | 512)]
    public static int4 operator %(int4 a, int b)
    {
        if (Vector128.IsHardwareAccelerated)
            return a - (a / b) * b;
        return new((int)(a.x % b), (int)(a.y % b), (int)(a.z % b), (int)(a.w % b));
    }

    [MethodImpl(256 | 512)]
    public static int4 operator %(int a, int4 b) => new int4(a) % b;

    [MethodImpl(256 | 512)]
    public static int4 operator --(int4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static int4 operator ++(int4 a) => a + One;
}

[Ex]
public static partial class math
{
    [MethodImpl(256 | 512)]
    public static int4 abs([This] int4 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.Abs(a.vector));
        return new(a.x.abs(), a.y.abs(), a.z.abs(), a.w.abs());
    }

    [MethodImpl(256 | 512)]
    public static int4 sign([This] int4 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.SignInt(a.vector));
        return new(a.x.sign(), a.y.sign(), a.z.sign(), a.w.sign());
    }

    [MethodImpl(256 | 512)]
    public static int4 min([This] int4 a, int4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.Min(a.vector, b.vector));
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z), a.w.min(b.w));
    }

    [MethodImpl(256 | 512)]
    public static int4 max([This] int4 a, int4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.Max(a.vector, b.vector));
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z), a.w.max(b.w));
    }

    [MethodImpl(256 | 512)]
    public static int4 clamp([This] int4 v, int4 min, int4 max)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.Max(min.vector, Vector128.Min(max.vector, v.vector)));
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z), v.w.clamp(min.w, max.w));
    }

    [MethodImpl(256 | 512)]
    public static int4 clamp([This] int4 v, int min, int max) => v.clamp(new int4(min), new int4(max));

    [MethodImpl(256 | 512)]
    public static int4 lerp(int4 start, int4 end, [This] int4 t)
    {
        if (Vector128.IsHardwareAccelerated)
            return fma(t, end - start, start);
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static int4 lerp(int4 start, int4 end, [This] int t)
    {
        if (Vector128.IsHardwareAccelerated)
            return fma(new(t), end - start, start);
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static int4 lerp(int start, int end, [This] int4 t)
    {
        if (Vector128.IsHardwareAccelerated)
            return fma(t, (end - start), new(start));
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static int4 unlerp([This] int4 a, int4 start, int4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static int4 unlerp([This] int a, int4 start, int4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static int4 unlerp([This] int4 a, int start, int end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static int4 remap([This] int4 a, int4 srcStart, int4 srcEnd, int4 dstStart, int4 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static int4 remap([This] int4 a, int srcStart, int srcEnd, int dstStart, int dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static int dot([This] int4 a, int4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return Vector128.Dot(a.vector, b.vector);
        return (int)(a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w);
    }

    [MethodImpl(256 | 512)]
    public static int lengthsq([This] int4 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return Vector128.Dot(a.vector, a.vector);
        return (int)(a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w);
    }

    [MethodImpl(256 | 512)]
    public static int distancesq([This] int4 a, int4 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static int4 square([This] int4 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static int4 fma([This] int4 a, int4 b, int4 c)
    {
        if (Vector128.IsHardwareAccelerated)
            return (a * b) + c;
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y), a.z.fma(b.z, c.z), a.w.fma(b.w, c.w));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static int4 fms([This] int4 a, int4 b, int4 c)
    {
        if (Vector128.IsHardwareAccelerated)
            return (a * b) - c;
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y), a.z.fms(b.z, c.z), a.w.fms(b.w, c.w));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static int4 fnma([This] int4 a, int4 b, int4 c)
    {
        if (Vector128.IsHardwareAccelerated)
            return c - (a * b);
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y), a.z.fnma(b.z, c.z), a.w.fnma(b.w, c.w));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static int4 fsm([This] int4 c, int4 a, int4 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static int4 fam([This] int4 c, int4 a, int4 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static int4 mad([This] int4 a, int4 b, int4 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static int csum([This] int4 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return Vector128.Sum(a.vector);
        return (a.x + a.y + a.z + a.w);
    }

    [MethodImpl(256 | 512)]
    public static int cmin([This] int4 a)
    {
        if (Vector128.IsHardwareAccelerated || Vector64.IsHardwareAccelerated)
            return simd.CMin(a.vector);
        return a.x.min(a.y).min(a.z).min(a.w);
    }

    [MethodImpl(256 | 512)]
    public static int cmax([This] int4 a)
    {
        if (Vector128.IsHardwareAccelerated || Vector64.IsHardwareAccelerated)
            return simd.CMax(a.vector);
        return a.x.max(a.y).max(a.z).max(a.w);
    }

    [MethodImpl(256 | 512)]
    public static int cminsafe([This] int4 a)
    {
        if (Vector128.IsHardwareAccelerated || Vector64.IsHardwareAccelerated)
            return simd.CMin(a.vector);
        return a.x.min(a.y).min(a.z).min(a.w);
    }

    [MethodImpl(256 | 512)]
    public static int cmaxsafe([This] int4 a)
    {
        if (Vector128.IsHardwareAccelerated || Vector64.IsHardwareAccelerated)
            return simd.CMax(a.vector);
        return a.x.max(a.y).max(a.z).max(a.w);
    }
}

#endregion // int4

#region uint2

public partial struct uint2
{
    [MethodImpl(256 | 512)]
    public static uint2 operator +(uint2 a) => a;

    [MethodImpl(256 | 512)]
    public static uint2 operator +(uint2 a, uint2 b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(a.vector + b.vector);
        return new((uint)(a.x + b.x), (uint)(a.y + b.y));
    }

    [MethodImpl(256 | 512)]
    public static uint2 operator +(uint2 a, uint b) => a + new uint2(b);

    [MethodImpl(256 | 512)]
    public static uint2 operator +(uint a, uint2 b) => new uint2(a) + b;

    [MethodImpl(256 | 512)]
    public static uint2 operator -(uint2 a, uint2 b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(a.vector - b.vector);
        return new((uint)(a.x - b.x), (uint)(a.y - b.y));
    }

    [MethodImpl(256 | 512)]
    public static uint2 operator -(uint2 a, uint b) => a - new uint2(b);

    [MethodImpl(256 | 512)]
    public static uint2 operator -(uint a, uint2 b) => new uint2(a) - b;

    [MethodImpl(256 | 512)]
    public static uint2 operator *(uint2 a, uint2 b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(a.vector * b.vector);
        return new((uint)(a.x * b.x), (uint)(a.y * b.y));
    }

    [MethodImpl(256 | 512)]
    public static uint2 operator *(uint a, uint2 b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(a * b.vector);
        return new((uint)(a * b.x), (uint)(a * b.y));
    }

    [MethodImpl(256 | 512)]
    public static uint2 operator *(uint2 a, uint b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(a.vector * b);
        return new((uint)(a.x * b), (uint)(a.y * b));
    }

    [MethodImpl(256 | 512)]
    public static uint2 operator /(uint2 a, uint2 b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new((a.vector / b.vector));
        return new((uint)(a.x / b.x), (uint)(a.y / b.y));
    }

    [MethodImpl(256 | 512)]
    public static uint2 operator /(uint2 a, uint b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new((a.vector / b));
        return new((uint)(a.x / b), (uint)(a.y / b));
    }

    [MethodImpl(256 | 512)]
    public static uint2 operator /(uint a, uint2 b) => new uint2(a) / b;

    [MethodImpl(256 | 512)]
    public static uint2 operator %(uint2 a, uint2 b)
    {
        if (Vector64.IsHardwareAccelerated)
            return a - (a / b) * b;
        return new((uint)(a.x % b.x), (uint)(a.y % b.y));
    }

    [MethodImpl(256 | 512)]
    public static uint2 operator %(uint2 a, uint b)
    {
        if (Vector64.IsHardwareAccelerated)
            return a - (a / b) * b;
        return new((uint)(a.x % b), (uint)(a.y % b));
    }

    [MethodImpl(256 | 512)]
    public static uint2 operator %(uint a, uint2 b) => new uint2(a) % b;

    [MethodImpl(256 | 512)]
    public static uint2 operator --(uint2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static uint2 operator ++(uint2 a) => a + One;
}

[Ex]
public static partial class math
{
    [MethodImpl(256 | 512)]
    public static uint2 abs([This] uint2 a)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(Vector64.Abs(a.vector));
        return new(a.x.abs(), a.y.abs());
    }

    [MethodImpl(256 | 512)]
    public static uint2 sign([This] uint2 a)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(simd.SignUInt(a.vector));
        return new(a.x.sign(), a.y.sign());
    }

    [MethodImpl(256 | 512)]
    public static uint2 min([This] uint2 a, uint2 b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(Vector64.Min(a.vector, b.vector));
        return new(a.x.min(b.x), a.y.min(b.y));
    }

    [MethodImpl(256 | 512)]
    public static uint2 max([This] uint2 a, uint2 b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(Vector64.Max(a.vector, b.vector));
        return new(a.x.max(b.x), a.y.max(b.y));
    }

    [MethodImpl(256 | 512)]
    public static uint2 clamp([This] uint2 v, uint2 min, uint2 max)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(Vector64.Max(min.vector, Vector64.Min(max.vector, v.vector)));
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y));
    }

    [MethodImpl(256 | 512)]
    public static uint2 clamp([This] uint2 v, uint min, uint max) => v.clamp(new uint2(min), new uint2(max));

    [MethodImpl(256 | 512)]
    public static uint2 lerp(uint2 start, uint2 end, [This] uint2 t)
    {
        if (Vector64.IsHardwareAccelerated)
            return fma(t, end - start, start);
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static uint2 lerp(uint2 start, uint2 end, [This] uint t)
    {
        if (Vector64.IsHardwareAccelerated)
            return fma(new(t), end - start, start);
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static uint2 lerp(uint start, uint end, [This] uint2 t)
    {
        if (Vector64.IsHardwareAccelerated)
            return fma(t, (end - start), new(start));
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static uint2 unlerp([This] uint2 a, uint2 start, uint2 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static uint2 unlerp([This] uint a, uint2 start, uint2 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static uint2 unlerp([This] uint2 a, uint start, uint end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static uint2 remap([This] uint2 a, uint2 srcStart, uint2 srcEnd, uint2 dstStart, uint2 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static uint2 remap([This] uint2 a, uint srcStart, uint srcEnd, uint dstStart, uint dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static uint dot([This] uint2 a, uint2 b)
    {
        if (Vector64.IsHardwareAccelerated)
            return Vector64.Dot(a.vector, b.vector);
        return (uint)(a.x * b.x + a.y * b.y);
    }

    [MethodImpl(256 | 512)]
    public static uint lengthsq([This] uint2 a)
    {
        if (Vector64.IsHardwareAccelerated)
            return Vector64.Dot(a.vector, a.vector);
        return (uint)(a.x * a.x + a.y * a.y);
    }

    [MethodImpl(256 | 512)]
    public static uint distancesq([This] uint2 a, uint2 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static uint2 square([This] uint2 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static uint2 fma([This] uint2 a, uint2 b, uint2 c)
    {
        if (Vector64.IsHardwareAccelerated)
            return (a * b) + c;
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static uint2 fms([This] uint2 a, uint2 b, uint2 c)
    {
        if (Vector64.IsHardwareAccelerated)
            return (a * b) - c;
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static uint2 fnma([This] uint2 a, uint2 b, uint2 c)
    {
        if (Vector64.IsHardwareAccelerated)
            return c - (a * b);
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static uint2 fsm([This] uint2 c, uint2 a, uint2 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static uint2 fam([This] uint2 c, uint2 a, uint2 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static uint2 mad([This] uint2 a, uint2 b, uint2 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static uint csum([This] uint2 a)
    {
        if (Vector64.IsHardwareAccelerated)
            return Vector64.Sum(a.vector);
        return (a.x + a.y);
    }

    [MethodImpl(256 | 512)]
    public static uint cmin([This] uint2 a)
    {
        if (Vector128.IsHardwareAccelerated || Vector64.IsHardwareAccelerated)
            return simd.CMin(a.vector);
        return a.x.min(a.y);
    }

    [MethodImpl(256 | 512)]
    public static uint cmax([This] uint2 a)
    {
        if (Vector128.IsHardwareAccelerated || Vector64.IsHardwareAccelerated)
            return simd.CMax(a.vector);
        return a.x.max(a.y);
    }

    [MethodImpl(256 | 512)]
    public static uint cminsafe([This] uint2 a)
    {
        if (Vector128.IsHardwareAccelerated || Vector64.IsHardwareAccelerated)
            return simd.CMin(a.vector);
        return a.x.min(a.y);
    }

    [MethodImpl(256 | 512)]
    public static uint cmaxsafe([This] uint2 a)
    {
        if (Vector128.IsHardwareAccelerated || Vector64.IsHardwareAccelerated)
            return simd.CMax(a.vector);
        return a.x.max(a.y);
    }
}

#endregion // uint2

#region uint3

public partial struct uint3
{
    [MethodImpl(256 | 512)]
    public static uint3 operator +(uint3 a) => a;

    [MethodImpl(256 | 512)]
    public static uint3 operator +(uint3 a, uint3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector + b.vector);
        return new((uint)(a.x + b.x), (uint)(a.y + b.y), (uint)(a.z + b.z));
    }

    [MethodImpl(256 | 512)]
    public static uint3 operator +(uint3 a, uint b) => a + new uint3(b);

    [MethodImpl(256 | 512)]
    public static uint3 operator +(uint a, uint3 b) => new uint3(a) + b;

    [MethodImpl(256 | 512)]
    public static uint3 operator -(uint3 a, uint3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector - b.vector);
        return new((uint)(a.x - b.x), (uint)(a.y - b.y), (uint)(a.z - b.z));
    }

    [MethodImpl(256 | 512)]
    public static uint3 operator -(uint3 a, uint b) => a - new uint3(b);

    [MethodImpl(256 | 512)]
    public static uint3 operator -(uint a, uint3 b) => new uint3(a) - b;

    [MethodImpl(256 | 512)]
    public static uint3 operator *(uint3 a, uint3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector * b.vector);
        return new((uint)(a.x * b.x), (uint)(a.y * b.y), (uint)(a.z * b.z));
    }

    [MethodImpl(256 | 512)]
    public static uint3 operator *(uint a, uint3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a * b.vector);
        return new((uint)(a * b.x), (uint)(a * b.y), (uint)(a * b.z));
    }

    [MethodImpl(256 | 512)]
    public static uint3 operator *(uint3 a, uint b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector * b);
        return new((uint)(a.x * b), (uint)(a.y * b), (uint)(a.z * b));
    }

    [MethodImpl(256 | 512)]
    public static uint3 operator /(uint3 a, uint3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new((a.vector / b.vector.WithElement(3, 1u)));
        return new((uint)(a.x / b.x), (uint)(a.y / b.y), (uint)(a.z / b.z));
    }

    [MethodImpl(256 | 512)]
    public static uint3 operator /(uint3 a, uint b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new((a.vector / b));
        return new((uint)(a.x / b), (uint)(a.y / b), (uint)(a.z / b));
    }

    [MethodImpl(256 | 512)]
    public static uint3 operator /(uint a, uint3 b) => new uint3(a) / b;

    [MethodImpl(256 | 512)]
    public static uint3 operator %(uint3 a, uint3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return a - (a / b) * b;
        return new((uint)(a.x % b.x), (uint)(a.y % b.y), (uint)(a.z % b.z));
    }

    [MethodImpl(256 | 512)]
    public static uint3 operator %(uint3 a, uint b)
    {
        if (Vector128.IsHardwareAccelerated)
            return a - (a / b) * b;
        return new((uint)(a.x % b), (uint)(a.y % b), (uint)(a.z % b));
    }

    [MethodImpl(256 | 512)]
    public static uint3 operator %(uint a, uint3 b) => new uint3(a) % b;

    [MethodImpl(256 | 512)]
    public static uint3 operator --(uint3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static uint3 operator ++(uint3 a) => a + One;
}

[Ex]
public static partial class math
{
    [MethodImpl(256 | 512)]
    public static uint3 abs([This] uint3 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.Abs(a.vector));
        return new(a.x.abs(), a.y.abs(), a.z.abs());
    }

    [MethodImpl(256 | 512)]
    public static uint3 sign([This] uint3 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.SignUInt(a.vector) & Vector128.Create(-1, -1, -1, 0).AsUInt32());
        return new(a.x.sign(), a.y.sign(), a.z.sign());
    }

    [MethodImpl(256 | 512)]
    public static uint3 min([This] uint3 a, uint3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.Min(a.vector, b.vector));
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z));
    }

    [MethodImpl(256 | 512)]
    public static uint3 max([This] uint3 a, uint3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.Max(a.vector, b.vector));
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z));
    }

    [MethodImpl(256 | 512)]
    public static uint3 clamp([This] uint3 v, uint3 min, uint3 max)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.Max(min.vector, Vector128.Min(max.vector, v.vector)));
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z));
    }

    [MethodImpl(256 | 512)]
    public static uint3 clamp([This] uint3 v, uint min, uint max) => v.clamp(new uint3(min), new uint3(max));

    [MethodImpl(256 | 512)]
    public static uint3 lerp(uint3 start, uint3 end, [This] uint3 t)
    {
        if (Vector128.IsHardwareAccelerated)
            return fma(t, end - start, start);
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static uint3 lerp(uint3 start, uint3 end, [This] uint t)
    {
        if (Vector128.IsHardwareAccelerated)
            return fma(new(t), end - start, start);
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static uint3 lerp(uint start, uint end, [This] uint3 t)
    {
        if (Vector128.IsHardwareAccelerated)
            return fma(t, (end - start), new(start));
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static uint3 unlerp([This] uint3 a, uint3 start, uint3 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static uint3 unlerp([This] uint a, uint3 start, uint3 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static uint3 unlerp([This] uint3 a, uint start, uint end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static uint3 remap([This] uint3 a, uint3 srcStart, uint3 srcEnd, uint3 dstStart, uint3 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static uint3 remap([This] uint3 a, uint srcStart, uint srcEnd, uint dstStart, uint dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static uint dot([This] uint3 a, uint3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return Vector128.Dot(a.vector, b.vector);
        return (uint)(a.x * b.x + a.y * b.y + a.z * b.z);
    }

    [MethodImpl(256 | 512)]
    public static uint3 cross([This] uint3 a, uint3 b)
    {
        // (a * b.yzx - a.yzx * b).yzx;
        return fnma(a.yzx, b, a * b.yzx).yzx;
    }

    [MethodImpl(256 | 512)]
    public static uint lengthsq([This] uint3 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return Vector128.Dot(a.vector, a.vector);
        return (uint)(a.x * a.x + a.y * a.y + a.z * a.z);
    }

    [MethodImpl(256 | 512)]
    public static uint distancesq([This] uint3 a, uint3 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static uint3 square([This] uint3 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static uint3 fma([This] uint3 a, uint3 b, uint3 c)
    {
        if (Vector128.IsHardwareAccelerated)
            return (a * b) + c;
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y), a.z.fma(b.z, c.z));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static uint3 fms([This] uint3 a, uint3 b, uint3 c)
    {
        if (Vector128.IsHardwareAccelerated)
            return (a * b) - c;
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y), a.z.fms(b.z, c.z));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static uint3 fnma([This] uint3 a, uint3 b, uint3 c)
    {
        if (Vector128.IsHardwareAccelerated)
            return c - (a * b);
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y), a.z.fnma(b.z, c.z));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static uint3 fsm([This] uint3 c, uint3 a, uint3 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static uint3 fam([This] uint3 c, uint3 a, uint3 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static uint3 mad([This] uint3 a, uint3 b, uint3 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static uint csum([This] uint3 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return Vector128.Sum(a.vector);
        return (a.x + a.y + a.z);
    }

    [MethodImpl(256 | 512)]
    public static uint cmin([This] uint3 a)
    {
        if (Vector128.IsHardwareAccelerated || Vector64.IsHardwareAccelerated)
            return simd.CMin3(a.vector);
        return a.x.min(a.y).min(a.z);
    }

    [MethodImpl(256 | 512)]
    public static uint cmax([This] uint3 a)
    {
        if (Vector128.IsHardwareAccelerated || Vector64.IsHardwareAccelerated)
            return simd.CMax3(a.vector);
        return a.x.max(a.y).max(a.z);
    }

    [MethodImpl(256 | 512)]
    public static uint cminsafe([This] uint3 a)
    {
        if (Vector128.IsHardwareAccelerated || Vector64.IsHardwareAccelerated)
            return simd.CMin3(a.vector);
        return a.x.min(a.y).min(a.z);
    }

    [MethodImpl(256 | 512)]
    public static uint cmaxsafe([This] uint3 a)
    {
        if (Vector128.IsHardwareAccelerated || Vector64.IsHardwareAccelerated)
            return simd.CMax3(a.vector);
        return a.x.max(a.y).max(a.z);
    }
}

#endregion // uint3

#region uint4

public partial struct uint4
{
    [MethodImpl(256 | 512)]
    public static uint4 operator +(uint4 a) => a;

    [MethodImpl(256 | 512)]
    public static uint4 operator +(uint4 a, uint4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector + b.vector);
        return new((uint)(a.x + b.x), (uint)(a.y + b.y), (uint)(a.z + b.z), (uint)(a.w + b.w));
    }

    [MethodImpl(256 | 512)]
    public static uint4 operator +(uint4 a, uint b) => a + new uint4(b);

    [MethodImpl(256 | 512)]
    public static uint4 operator +(uint a, uint4 b) => new uint4(a) + b;

    [MethodImpl(256 | 512)]
    public static uint4 operator -(uint4 a, uint4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector - b.vector);
        return new((uint)(a.x - b.x), (uint)(a.y - b.y), (uint)(a.z - b.z), (uint)(a.w - b.w));
    }

    [MethodImpl(256 | 512)]
    public static uint4 operator -(uint4 a, uint b) => a - new uint4(b);

    [MethodImpl(256 | 512)]
    public static uint4 operator -(uint a, uint4 b) => new uint4(a) - b;

    [MethodImpl(256 | 512)]
    public static uint4 operator *(uint4 a, uint4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector * b.vector);
        return new((uint)(a.x * b.x), (uint)(a.y * b.y), (uint)(a.z * b.z), (uint)(a.w * b.w));
    }

    [MethodImpl(256 | 512)]
    public static uint4 operator *(uint a, uint4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a * b.vector);
        return new((uint)(a * b.x), (uint)(a * b.y), (uint)(a * b.z), (uint)(a * b.w));
    }

    [MethodImpl(256 | 512)]
    public static uint4 operator *(uint4 a, uint b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector * b);
        return new((uint)(a.x * b), (uint)(a.y * b), (uint)(a.z * b), (uint)(a.w * b));
    }

    [MethodImpl(256 | 512)]
    public static uint4 operator /(uint4 a, uint4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new((a.vector / b.vector));
        return new((uint)(a.x / b.x), (uint)(a.y / b.y), (uint)(a.z / b.z), (uint)(a.w / b.w));
    }

    [MethodImpl(256 | 512)]
    public static uint4 operator /(uint4 a, uint b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new((a.vector / b));
        return new((uint)(a.x / b), (uint)(a.y / b), (uint)(a.z / b), (uint)(a.w / b));
    }

    [MethodImpl(256 | 512)]
    public static uint4 operator /(uint a, uint4 b) => new uint4(a) / b;

    [MethodImpl(256 | 512)]
    public static uint4 operator %(uint4 a, uint4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return a - (a / b) * b;
        return new((uint)(a.x % b.x), (uint)(a.y % b.y), (uint)(a.z % b.z), (uint)(a.w % b.w));
    }

    [MethodImpl(256 | 512)]
    public static uint4 operator %(uint4 a, uint b)
    {
        if (Vector128.IsHardwareAccelerated)
            return a - (a / b) * b;
        return new((uint)(a.x % b), (uint)(a.y % b), (uint)(a.z % b), (uint)(a.w % b));
    }

    [MethodImpl(256 | 512)]
    public static uint4 operator %(uint a, uint4 b) => new uint4(a) % b;

    [MethodImpl(256 | 512)]
    public static uint4 operator --(uint4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static uint4 operator ++(uint4 a) => a + One;
}

[Ex]
public static partial class math
{
    [MethodImpl(256 | 512)]
    public static uint4 abs([This] uint4 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.Abs(a.vector));
        return new(a.x.abs(), a.y.abs(), a.z.abs(), a.w.abs());
    }

    [MethodImpl(256 | 512)]
    public static uint4 sign([This] uint4 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.SignUInt(a.vector));
        return new(a.x.sign(), a.y.sign(), a.z.sign(), a.w.sign());
    }

    [MethodImpl(256 | 512)]
    public static uint4 min([This] uint4 a, uint4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.Min(a.vector, b.vector));
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z), a.w.min(b.w));
    }

    [MethodImpl(256 | 512)]
    public static uint4 max([This] uint4 a, uint4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.Max(a.vector, b.vector));
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z), a.w.max(b.w));
    }

    [MethodImpl(256 | 512)]
    public static uint4 clamp([This] uint4 v, uint4 min, uint4 max)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.Max(min.vector, Vector128.Min(max.vector, v.vector)));
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z), v.w.clamp(min.w, max.w));
    }

    [MethodImpl(256 | 512)]
    public static uint4 clamp([This] uint4 v, uint min, uint max) => v.clamp(new uint4(min), new uint4(max));

    [MethodImpl(256 | 512)]
    public static uint4 lerp(uint4 start, uint4 end, [This] uint4 t)
    {
        if (Vector128.IsHardwareAccelerated)
            return fma(t, end - start, start);
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static uint4 lerp(uint4 start, uint4 end, [This] uint t)
    {
        if (Vector128.IsHardwareAccelerated)
            return fma(new(t), end - start, start);
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static uint4 lerp(uint start, uint end, [This] uint4 t)
    {
        if (Vector128.IsHardwareAccelerated)
            return fma(t, (end - start), new(start));
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static uint4 unlerp([This] uint4 a, uint4 start, uint4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static uint4 unlerp([This] uint a, uint4 start, uint4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static uint4 unlerp([This] uint4 a, uint start, uint end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static uint4 remap([This] uint4 a, uint4 srcStart, uint4 srcEnd, uint4 dstStart, uint4 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static uint4 remap([This] uint4 a, uint srcStart, uint srcEnd, uint dstStart, uint dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static uint dot([This] uint4 a, uint4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return Vector128.Dot(a.vector, b.vector);
        return (uint)(a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w);
    }

    [MethodImpl(256 | 512)]
    public static uint lengthsq([This] uint4 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return Vector128.Dot(a.vector, a.vector);
        return (uint)(a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w);
    }

    [MethodImpl(256 | 512)]
    public static uint distancesq([This] uint4 a, uint4 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static uint4 square([This] uint4 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static uint4 fma([This] uint4 a, uint4 b, uint4 c)
    {
        if (Vector128.IsHardwareAccelerated)
            return (a * b) + c;
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y), a.z.fma(b.z, c.z), a.w.fma(b.w, c.w));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static uint4 fms([This] uint4 a, uint4 b, uint4 c)
    {
        if (Vector128.IsHardwareAccelerated)
            return (a * b) - c;
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y), a.z.fms(b.z, c.z), a.w.fms(b.w, c.w));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static uint4 fnma([This] uint4 a, uint4 b, uint4 c)
    {
        if (Vector128.IsHardwareAccelerated)
            return c - (a * b);
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y), a.z.fnma(b.z, c.z), a.w.fnma(b.w, c.w));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static uint4 fsm([This] uint4 c, uint4 a, uint4 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static uint4 fam([This] uint4 c, uint4 a, uint4 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static uint4 mad([This] uint4 a, uint4 b, uint4 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static uint csum([This] uint4 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return Vector128.Sum(a.vector);
        return (a.x + a.y + a.z + a.w);
    }

    [MethodImpl(256 | 512)]
    public static uint cmin([This] uint4 a)
    {
        if (Vector128.IsHardwareAccelerated || Vector64.IsHardwareAccelerated)
            return simd.CMin(a.vector);
        return a.x.min(a.y).min(a.z).min(a.w);
    }

    [MethodImpl(256 | 512)]
    public static uint cmax([This] uint4 a)
    {
        if (Vector128.IsHardwareAccelerated || Vector64.IsHardwareAccelerated)
            return simd.CMax(a.vector);
        return a.x.max(a.y).max(a.z).max(a.w);
    }

    [MethodImpl(256 | 512)]
    public static uint cminsafe([This] uint4 a)
    {
        if (Vector128.IsHardwareAccelerated || Vector64.IsHardwareAccelerated)
            return simd.CMin(a.vector);
        return a.x.min(a.y).min(a.z).min(a.w);
    }

    [MethodImpl(256 | 512)]
    public static uint cmaxsafe([This] uint4 a)
    {
        if (Vector128.IsHardwareAccelerated || Vector64.IsHardwareAccelerated)
            return simd.CMax(a.vector);
        return a.x.max(a.y).max(a.z).max(a.w);
    }
}

#endregion // uint4

#region long2

public partial struct long2
{
    [MethodImpl(256 | 512)]
    public static long2 operator +(long2 a) => a;
    [MethodImpl(256 | 512)]
    public static long2 operator -(long2 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(-a.vector);
        return new((-a.x), (-a.y));
    }

    [MethodImpl(256 | 512)]
    public static long2 operator +(long2 a, long2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector + b.vector);
        return new((long)(a.x + b.x), (long)(a.y + b.y));
    }

    [MethodImpl(256 | 512)]
    public static long2 operator +(long2 a, long b) => a + new long2(b);

    [MethodImpl(256 | 512)]
    public static long2 operator +(long a, long2 b) => new long2(a) + b;

    [MethodImpl(256 | 512)]
    public static long2 operator -(long2 a, long2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector - b.vector);
        return new((long)(a.x - b.x), (long)(a.y - b.y));
    }

    [MethodImpl(256 | 512)]
    public static long2 operator -(long2 a, long b) => a - new long2(b);

    [MethodImpl(256 | 512)]
    public static long2 operator -(long a, long2 b) => new long2(a) - b;

    [MethodImpl(256 | 512)]
    public static long2 operator *(long2 a, long2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector * b.vector);
        return new((long)(a.x * b.x), (long)(a.y * b.y));
    }

    [MethodImpl(256 | 512)]
    public static long2 operator *(long a, long2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a * b.vector);
        return new((long)(a * b.x), (long)(a * b.y));
    }

    [MethodImpl(256 | 512)]
    public static long2 operator *(long2 a, long b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector * b);
        return new((long)(a.x * b), (long)(a.y * b));
    }

    [MethodImpl(256 | 512)]
    public static long2 operator /(long2 a, long2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new((a.vector / b.vector));
        return new((long)(a.x / b.x), (long)(a.y / b.y));
    }

    [MethodImpl(256 | 512)]
    public static long2 operator /(long2 a, long b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new((a.vector / b));
        return new((long)(a.x / b), (long)(a.y / b));
    }

    [MethodImpl(256 | 512)]
    public static long2 operator /(long a, long2 b) => new long2(a) / b;

    [MethodImpl(256 | 512)]
    public static long2 operator %(long2 a, long2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return a - (a / b) * b;
        return new((long)(a.x % b.x), (long)(a.y % b.y));
    }

    [MethodImpl(256 | 512)]
    public static long2 operator %(long2 a, long b)
    {
        if (Vector128.IsHardwareAccelerated)
            return a - (a / b) * b;
        return new((long)(a.x % b), (long)(a.y % b));
    }

    [MethodImpl(256 | 512)]
    public static long2 operator %(long a, long2 b) => new long2(a) % b;

    [MethodImpl(256 | 512)]
    public static long2 operator --(long2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static long2 operator ++(long2 a) => a + One;
}

[Ex]
public static partial class math
{
    [MethodImpl(256 | 512)]
    public static long2 abs([This] long2 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.Abs(a.vector));
        return new(a.x.abs(), a.y.abs());
    }

    [MethodImpl(256 | 512)]
    public static long2 sign([This] long2 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.SignInt(a.vector));
        return new(a.x.sign(), a.y.sign());
    }

    [MethodImpl(256 | 512)]
    public static long2 min([This] long2 a, long2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.Min(a.vector, b.vector));
        return new(a.x.min(b.x), a.y.min(b.y));
    }

    [MethodImpl(256 | 512)]
    public static long2 max([This] long2 a, long2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.Max(a.vector, b.vector));
        return new(a.x.max(b.x), a.y.max(b.y));
    }

    [MethodImpl(256 | 512)]
    public static long2 clamp([This] long2 v, long2 min, long2 max)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.Max(min.vector, Vector128.Min(max.vector, v.vector)));
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y));
    }

    [MethodImpl(256 | 512)]
    public static long2 clamp([This] long2 v, long min, long max) => v.clamp(new long2(min), new long2(max));

    [MethodImpl(256 | 512)]
    public static long2 lerp(long2 start, long2 end, [This] long2 t)
    {
        if (Vector128.IsHardwareAccelerated)
            return fma(t, end - start, start);
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static long2 lerp(long2 start, long2 end, [This] long t)
    {
        if (Vector128.IsHardwareAccelerated)
            return fma(new(t), end - start, start);
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static long2 lerp(long start, long end, [This] long2 t)
    {
        if (Vector128.IsHardwareAccelerated)
            return fma(t, (end - start), new(start));
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static long2 unlerp([This] long2 a, long2 start, long2 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static long2 unlerp([This] long a, long2 start, long2 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static long2 unlerp([This] long2 a, long start, long end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static long2 remap([This] long2 a, long2 srcStart, long2 srcEnd, long2 dstStart, long2 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static long2 remap([This] long2 a, long srcStart, long srcEnd, long dstStart, long dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static long dot([This] long2 a, long2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return Vector128.Dot(a.vector, b.vector);
        return (long)(a.x * b.x + a.y * b.y);
    }

    [MethodImpl(256 | 512)]
    public static long lengthsq([This] long2 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return Vector128.Dot(a.vector, a.vector);
        return (long)(a.x * a.x + a.y * a.y);
    }

    [MethodImpl(256 | 512)]
    public static long distancesq([This] long2 a, long2 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static long2 square([This] long2 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static long2 fma([This] long2 a, long2 b, long2 c)
    {
        if (Vector128.IsHardwareAccelerated)
            return (a * b) + c;
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static long2 fms([This] long2 a, long2 b, long2 c)
    {
        if (Vector128.IsHardwareAccelerated)
            return (a * b) - c;
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static long2 fnma([This] long2 a, long2 b, long2 c)
    {
        if (Vector128.IsHardwareAccelerated)
            return c - (a * b);
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static long2 fsm([This] long2 c, long2 a, long2 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static long2 fam([This] long2 c, long2 a, long2 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static long2 mad([This] long2 a, long2 b, long2 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static long csum([This] long2 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return Vector128.Sum(a.vector);
        return (a.x + a.y);
    }

    [MethodImpl(256 | 512)]
    public static long cmin([This] long2 a)
    {
        if (Vector256.IsHardwareAccelerated || Vector128.IsHardwareAccelerated)
            return simd.CMin(a.vector);
        return a.x.min(a.y);
    }

    [MethodImpl(256 | 512)]
    public static long cmax([This] long2 a)
    {
        if (Vector256.IsHardwareAccelerated || Vector128.IsHardwareAccelerated)
            return simd.CMax(a.vector);
        return a.x.max(a.y);
    }

    [MethodImpl(256 | 512)]
    public static long cminsafe([This] long2 a)
    {
        if (Vector256.IsHardwareAccelerated || Vector128.IsHardwareAccelerated)
            return simd.CMin(a.vector);
        return a.x.min(a.y);
    }

    [MethodImpl(256 | 512)]
    public static long cmaxsafe([This] long2 a)
    {
        if (Vector256.IsHardwareAccelerated || Vector128.IsHardwareAccelerated)
            return simd.CMax(a.vector);
        return a.x.max(a.y);
    }
}

#endregion // long2

#region long3

public partial struct long3
{
    [MethodImpl(256 | 512)]
    public static long3 operator +(long3 a) => a;
    [MethodImpl(256 | 512)]
    public static long3 operator -(long3 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(-a.vector & Vector256.Create(-1, -1, -1, 0).AsInt64());
        return new((-a.x), (-a.y), (-a.z));
    }

    [MethodImpl(256 | 512)]
    public static long3 operator +(long3 a, long3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector + b.vector);
        return new((long)(a.x + b.x), (long)(a.y + b.y), (long)(a.z + b.z));
    }

    [MethodImpl(256 | 512)]
    public static long3 operator +(long3 a, long b) => a + new long3(b);

    [MethodImpl(256 | 512)]
    public static long3 operator +(long a, long3 b) => new long3(a) + b;

    [MethodImpl(256 | 512)]
    public static long3 operator -(long3 a, long3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector - b.vector);
        return new((long)(a.x - b.x), (long)(a.y - b.y), (long)(a.z - b.z));
    }

    [MethodImpl(256 | 512)]
    public static long3 operator -(long3 a, long b) => a - new long3(b);

    [MethodImpl(256 | 512)]
    public static long3 operator -(long a, long3 b) => new long3(a) - b;

    [MethodImpl(256 | 512)]
    public static long3 operator *(long3 a, long3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector * b.vector);
        return new((long)(a.x * b.x), (long)(a.y * b.y), (long)(a.z * b.z));
    }

    [MethodImpl(256 | 512)]
    public static long3 operator *(long a, long3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a * b.vector);
        return new((long)(a * b.x), (long)(a * b.y), (long)(a * b.z));
    }

    [MethodImpl(256 | 512)]
    public static long3 operator *(long3 a, long b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector * b);
        return new((long)(a.x * b), (long)(a.y * b), (long)(a.z * b));
    }

    [MethodImpl(256 | 512)]
    public static long3 operator /(long3 a, long3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new((a.vector / b.vector.WithElement(3, 1L)));
        return new((long)(a.x / b.x), (long)(a.y / b.y), (long)(a.z / b.z));
    }

    [MethodImpl(256 | 512)]
    public static long3 operator /(long3 a, long b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new((a.vector / b));
        return new((long)(a.x / b), (long)(a.y / b), (long)(a.z / b));
    }

    [MethodImpl(256 | 512)]
    public static long3 operator /(long a, long3 b) => new long3(a) / b;

    [MethodImpl(256 | 512)]
    public static long3 operator %(long3 a, long3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return a - (a / b) * b;
        return new((long)(a.x % b.x), (long)(a.y % b.y), (long)(a.z % b.z));
    }

    [MethodImpl(256 | 512)]
    public static long3 operator %(long3 a, long b)
    {
        if (Vector256.IsHardwareAccelerated)
            return a - (a / b) * b;
        return new((long)(a.x % b), (long)(a.y % b), (long)(a.z % b));
    }

    [MethodImpl(256 | 512)]
    public static long3 operator %(long a, long3 b) => new long3(a) % b;

    [MethodImpl(256 | 512)]
    public static long3 operator --(long3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static long3 operator ++(long3 a) => a + One;
}

[Ex]
public static partial class math
{
    [MethodImpl(256 | 512)]
    public static long3 abs([This] long3 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(Vector256.Abs(a.vector));
        return new(a.x.abs(), a.y.abs(), a.z.abs());
    }

    [MethodImpl(256 | 512)]
    public static long3 sign([This] long3 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.SignInt(a.vector) & Vector256.Create(-1, -1, -1, 0).AsInt64());
        return new(a.x.sign(), a.y.sign(), a.z.sign());
    }

    [MethodImpl(256 | 512)]
    public static long3 min([This] long3 a, long3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(Vector256.Min(a.vector, b.vector));
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z));
    }

    [MethodImpl(256 | 512)]
    public static long3 max([This] long3 a, long3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(Vector256.Max(a.vector, b.vector));
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z));
    }

    [MethodImpl(256 | 512)]
    public static long3 clamp([This] long3 v, long3 min, long3 max)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(Vector256.Max(min.vector, Vector256.Min(max.vector, v.vector)));
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z));
    }

    [MethodImpl(256 | 512)]
    public static long3 clamp([This] long3 v, long min, long max) => v.clamp(new long3(min), new long3(max));

    [MethodImpl(256 | 512)]
    public static long3 lerp(long3 start, long3 end, [This] long3 t)
    {
        if (Vector256.IsHardwareAccelerated)
            return fma(t, end - start, start);
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static long3 lerp(long3 start, long3 end, [This] long t)
    {
        if (Vector256.IsHardwareAccelerated)
            return fma(new(t), end - start, start);
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static long3 lerp(long start, long end, [This] long3 t)
    {
        if (Vector256.IsHardwareAccelerated)
            return fma(t, (end - start), new(start));
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static long3 unlerp([This] long3 a, long3 start, long3 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static long3 unlerp([This] long a, long3 start, long3 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static long3 unlerp([This] long3 a, long start, long end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static long3 remap([This] long3 a, long3 srcStart, long3 srcEnd, long3 dstStart, long3 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static long3 remap([This] long3 a, long srcStart, long srcEnd, long dstStart, long dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static long dot([This] long3 a, long3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return Vector256.Dot(a.vector, b.vector);
        return (long)(a.x * b.x + a.y * b.y + a.z * b.z);
    }

    [MethodImpl(256 | 512)]
    public static long3 cross([This] long3 a, long3 b)
    {
        // (a * b.yzx - a.yzx * b).yzx;
        return fnma(a.yzx, b, a * b.yzx).yzx;
    }

    [MethodImpl(256 | 512)]
    public static long lengthsq([This] long3 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return Vector256.Dot(a.vector, a.vector);
        return (long)(a.x * a.x + a.y * a.y + a.z * a.z);
    }

    [MethodImpl(256 | 512)]
    public static long distancesq([This] long3 a, long3 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static long3 square([This] long3 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static long3 fma([This] long3 a, long3 b, long3 c)
    {
        if (Vector256.IsHardwareAccelerated)
            return (a * b) + c;
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y), a.z.fma(b.z, c.z));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static long3 fms([This] long3 a, long3 b, long3 c)
    {
        if (Vector256.IsHardwareAccelerated)
            return (a * b) - c;
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y), a.z.fms(b.z, c.z));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static long3 fnma([This] long3 a, long3 b, long3 c)
    {
        if (Vector256.IsHardwareAccelerated)
            return c - (a * b);
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y), a.z.fnma(b.z, c.z));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static long3 fsm([This] long3 c, long3 a, long3 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static long3 fam([This] long3 c, long3 a, long3 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static long3 mad([This] long3 a, long3 b, long3 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static long csum([This] long3 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return Vector256.Sum(a.vector);
        return (a.x + a.y + a.z);
    }

    [MethodImpl(256 | 512)]
    public static long cmin([This] long3 a)
    {
        if (Vector256.IsHardwareAccelerated || Vector128.IsHardwareAccelerated)
            return simd.CMin3(a.vector);
        return a.x.min(a.y).min(a.z);
    }

    [MethodImpl(256 | 512)]
    public static long cmax([This] long3 a)
    {
        if (Vector256.IsHardwareAccelerated || Vector128.IsHardwareAccelerated)
            return simd.CMax3(a.vector);
        return a.x.max(a.y).max(a.z);
    }

    [MethodImpl(256 | 512)]
    public static long cminsafe([This] long3 a)
    {
        if (Vector256.IsHardwareAccelerated || Vector128.IsHardwareAccelerated)
            return simd.CMin3(a.vector);
        return a.x.min(a.y).min(a.z);
    }

    [MethodImpl(256 | 512)]
    public static long cmaxsafe([This] long3 a)
    {
        if (Vector256.IsHardwareAccelerated || Vector128.IsHardwareAccelerated)
            return simd.CMax3(a.vector);
        return a.x.max(a.y).max(a.z);
    }
}

#endregion // long3

#region long4

public partial struct long4
{
    [MethodImpl(256 | 512)]
    public static long4 operator +(long4 a) => a;
    [MethodImpl(256 | 512)]
    public static long4 operator -(long4 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(-a.vector);
        return new((-a.x), (-a.y), (-a.z), (-a.w));
    }

    [MethodImpl(256 | 512)]
    public static long4 operator +(long4 a, long4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector + b.vector);
        return new((long)(a.x + b.x), (long)(a.y + b.y), (long)(a.z + b.z), (long)(a.w + b.w));
    }

    [MethodImpl(256 | 512)]
    public static long4 operator +(long4 a, long b) => a + new long4(b);

    [MethodImpl(256 | 512)]
    public static long4 operator +(long a, long4 b) => new long4(a) + b;

    [MethodImpl(256 | 512)]
    public static long4 operator -(long4 a, long4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector - b.vector);
        return new((long)(a.x - b.x), (long)(a.y - b.y), (long)(a.z - b.z), (long)(a.w - b.w));
    }

    [MethodImpl(256 | 512)]
    public static long4 operator -(long4 a, long b) => a - new long4(b);

    [MethodImpl(256 | 512)]
    public static long4 operator -(long a, long4 b) => new long4(a) - b;

    [MethodImpl(256 | 512)]
    public static long4 operator *(long4 a, long4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector * b.vector);
        return new((long)(a.x * b.x), (long)(a.y * b.y), (long)(a.z * b.z), (long)(a.w * b.w));
    }

    [MethodImpl(256 | 512)]
    public static long4 operator *(long a, long4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a * b.vector);
        return new((long)(a * b.x), (long)(a * b.y), (long)(a * b.z), (long)(a * b.w));
    }

    [MethodImpl(256 | 512)]
    public static long4 operator *(long4 a, long b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector * b);
        return new((long)(a.x * b), (long)(a.y * b), (long)(a.z * b), (long)(a.w * b));
    }

    [MethodImpl(256 | 512)]
    public static long4 operator /(long4 a, long4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new((a.vector / b.vector));
        return new((long)(a.x / b.x), (long)(a.y / b.y), (long)(a.z / b.z), (long)(a.w / b.w));
    }

    [MethodImpl(256 | 512)]
    public static long4 operator /(long4 a, long b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new((a.vector / b));
        return new((long)(a.x / b), (long)(a.y / b), (long)(a.z / b), (long)(a.w / b));
    }

    [MethodImpl(256 | 512)]
    public static long4 operator /(long a, long4 b) => new long4(a) / b;

    [MethodImpl(256 | 512)]
    public static long4 operator %(long4 a, long4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return a - (a / b) * b;
        return new((long)(a.x % b.x), (long)(a.y % b.y), (long)(a.z % b.z), (long)(a.w % b.w));
    }

    [MethodImpl(256 | 512)]
    public static long4 operator %(long4 a, long b)
    {
        if (Vector256.IsHardwareAccelerated)
            return a - (a / b) * b;
        return new((long)(a.x % b), (long)(a.y % b), (long)(a.z % b), (long)(a.w % b));
    }

    [MethodImpl(256 | 512)]
    public static long4 operator %(long a, long4 b) => new long4(a) % b;

    [MethodImpl(256 | 512)]
    public static long4 operator --(long4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static long4 operator ++(long4 a) => a + One;
}

[Ex]
public static partial class math
{
    [MethodImpl(256 | 512)]
    public static long4 abs([This] long4 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(Vector256.Abs(a.vector));
        return new(a.x.abs(), a.y.abs(), a.z.abs(), a.w.abs());
    }

    [MethodImpl(256 | 512)]
    public static long4 sign([This] long4 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.SignInt(a.vector));
        return new(a.x.sign(), a.y.sign(), a.z.sign(), a.w.sign());
    }

    [MethodImpl(256 | 512)]
    public static long4 min([This] long4 a, long4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(Vector256.Min(a.vector, b.vector));
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z), a.w.min(b.w));
    }

    [MethodImpl(256 | 512)]
    public static long4 max([This] long4 a, long4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(Vector256.Max(a.vector, b.vector));
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z), a.w.max(b.w));
    }

    [MethodImpl(256 | 512)]
    public static long4 clamp([This] long4 v, long4 min, long4 max)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(Vector256.Max(min.vector, Vector256.Min(max.vector, v.vector)));
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z), v.w.clamp(min.w, max.w));
    }

    [MethodImpl(256 | 512)]
    public static long4 clamp([This] long4 v, long min, long max) => v.clamp(new long4(min), new long4(max));

    [MethodImpl(256 | 512)]
    public static long4 lerp(long4 start, long4 end, [This] long4 t)
    {
        if (Vector256.IsHardwareAccelerated)
            return fma(t, end - start, start);
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static long4 lerp(long4 start, long4 end, [This] long t)
    {
        if (Vector256.IsHardwareAccelerated)
            return fma(new(t), end - start, start);
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static long4 lerp(long start, long end, [This] long4 t)
    {
        if (Vector256.IsHardwareAccelerated)
            return fma(t, (end - start), new(start));
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static long4 unlerp([This] long4 a, long4 start, long4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static long4 unlerp([This] long a, long4 start, long4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static long4 unlerp([This] long4 a, long start, long end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static long4 remap([This] long4 a, long4 srcStart, long4 srcEnd, long4 dstStart, long4 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static long4 remap([This] long4 a, long srcStart, long srcEnd, long dstStart, long dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static long dot([This] long4 a, long4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return Vector256.Dot(a.vector, b.vector);
        return (long)(a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w);
    }

    [MethodImpl(256 | 512)]
    public static long lengthsq([This] long4 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return Vector256.Dot(a.vector, a.vector);
        return (long)(a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w);
    }

    [MethodImpl(256 | 512)]
    public static long distancesq([This] long4 a, long4 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static long4 square([This] long4 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static long4 fma([This] long4 a, long4 b, long4 c)
    {
        if (Vector256.IsHardwareAccelerated)
            return (a * b) + c;
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y), a.z.fma(b.z, c.z), a.w.fma(b.w, c.w));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static long4 fms([This] long4 a, long4 b, long4 c)
    {
        if (Vector256.IsHardwareAccelerated)
            return (a * b) - c;
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y), a.z.fms(b.z, c.z), a.w.fms(b.w, c.w));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static long4 fnma([This] long4 a, long4 b, long4 c)
    {
        if (Vector256.IsHardwareAccelerated)
            return c - (a * b);
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y), a.z.fnma(b.z, c.z), a.w.fnma(b.w, c.w));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static long4 fsm([This] long4 c, long4 a, long4 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static long4 fam([This] long4 c, long4 a, long4 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static long4 mad([This] long4 a, long4 b, long4 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static long csum([This] long4 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return Vector256.Sum(a.vector);
        return (a.x + a.y + a.z + a.w);
    }

    [MethodImpl(256 | 512)]
    public static long cmin([This] long4 a)
    {
        if (Vector256.IsHardwareAccelerated || Vector128.IsHardwareAccelerated)
            return simd.CMin(a.vector);
        return a.x.min(a.y).min(a.z).min(a.w);
    }

    [MethodImpl(256 | 512)]
    public static long cmax([This] long4 a)
    {
        if (Vector256.IsHardwareAccelerated || Vector128.IsHardwareAccelerated)
            return simd.CMax(a.vector);
        return a.x.max(a.y).max(a.z).max(a.w);
    }

    [MethodImpl(256 | 512)]
    public static long cminsafe([This] long4 a)
    {
        if (Vector256.IsHardwareAccelerated || Vector128.IsHardwareAccelerated)
            return simd.CMin(a.vector);
        return a.x.min(a.y).min(a.z).min(a.w);
    }

    [MethodImpl(256 | 512)]
    public static long cmaxsafe([This] long4 a)
    {
        if (Vector256.IsHardwareAccelerated || Vector128.IsHardwareAccelerated)
            return simd.CMax(a.vector);
        return a.x.max(a.y).max(a.z).max(a.w);
    }
}

#endregion // long4

#region ulong2

public partial struct ulong2
{
    [MethodImpl(256 | 512)]
    public static ulong2 operator +(ulong2 a) => a;

    [MethodImpl(256 | 512)]
    public static ulong2 operator +(ulong2 a, ulong2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector + b.vector);
        return new((ulong)(a.x + b.x), (ulong)(a.y + b.y));
    }

    [MethodImpl(256 | 512)]
    public static ulong2 operator +(ulong2 a, ulong b) => a + new ulong2(b);

    [MethodImpl(256 | 512)]
    public static ulong2 operator +(ulong a, ulong2 b) => new ulong2(a) + b;

    [MethodImpl(256 | 512)]
    public static ulong2 operator -(ulong2 a, ulong2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector - b.vector);
        return new((ulong)(a.x - b.x), (ulong)(a.y - b.y));
    }

    [MethodImpl(256 | 512)]
    public static ulong2 operator -(ulong2 a, ulong b) => a - new ulong2(b);

    [MethodImpl(256 | 512)]
    public static ulong2 operator -(ulong a, ulong2 b) => new ulong2(a) - b;

    [MethodImpl(256 | 512)]
    public static ulong2 operator *(ulong2 a, ulong2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector * b.vector);
        return new((ulong)(a.x * b.x), (ulong)(a.y * b.y));
    }

    [MethodImpl(256 | 512)]
    public static ulong2 operator *(ulong a, ulong2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a * b.vector);
        return new((ulong)(a * b.x), (ulong)(a * b.y));
    }

    [MethodImpl(256 | 512)]
    public static ulong2 operator *(ulong2 a, ulong b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(a.vector * b);
        return new((ulong)(a.x * b), (ulong)(a.y * b));
    }

    [MethodImpl(256 | 512)]
    public static ulong2 operator /(ulong2 a, ulong2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new((a.vector / b.vector));
        return new((ulong)(a.x / b.x), (ulong)(a.y / b.y));
    }

    [MethodImpl(256 | 512)]
    public static ulong2 operator /(ulong2 a, ulong b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new((a.vector / b));
        return new((ulong)(a.x / b), (ulong)(a.y / b));
    }

    [MethodImpl(256 | 512)]
    public static ulong2 operator /(ulong a, ulong2 b) => new ulong2(a) / b;

    [MethodImpl(256 | 512)]
    public static ulong2 operator %(ulong2 a, ulong2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return a - (a / b) * b;
        return new((ulong)(a.x % b.x), (ulong)(a.y % b.y));
    }

    [MethodImpl(256 | 512)]
    public static ulong2 operator %(ulong2 a, ulong b)
    {
        if (Vector128.IsHardwareAccelerated)
            return a - (a / b) * b;
        return new((ulong)(a.x % b), (ulong)(a.y % b));
    }

    [MethodImpl(256 | 512)]
    public static ulong2 operator %(ulong a, ulong2 b) => new ulong2(a) % b;

    [MethodImpl(256 | 512)]
    public static ulong2 operator --(ulong2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static ulong2 operator ++(ulong2 a) => a + One;
}

[Ex]
public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ulong2 abs([This] ulong2 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.Abs(a.vector));
        return new(a.x.abs(), a.y.abs());
    }

    [MethodImpl(256 | 512)]
    public static ulong2 sign([This] ulong2 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.SignUInt(a.vector));
        return new(a.x.sign(), a.y.sign());
    }

    [MethodImpl(256 | 512)]
    public static ulong2 min([This] ulong2 a, ulong2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.Min(a.vector, b.vector));
        return new(a.x.min(b.x), a.y.min(b.y));
    }

    [MethodImpl(256 | 512)]
    public static ulong2 max([This] ulong2 a, ulong2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.Max(a.vector, b.vector));
        return new(a.x.max(b.x), a.y.max(b.y));
    }

    [MethodImpl(256 | 512)]
    public static ulong2 clamp([This] ulong2 v, ulong2 min, ulong2 max)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.Max(min.vector, Vector128.Min(max.vector, v.vector)));
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y));
    }

    [MethodImpl(256 | 512)]
    public static ulong2 clamp([This] ulong2 v, ulong min, ulong max) => v.clamp(new ulong2(min), new ulong2(max));

    [MethodImpl(256 | 512)]
    public static ulong2 lerp(ulong2 start, ulong2 end, [This] ulong2 t)
    {
        if (Vector128.IsHardwareAccelerated)
            return fma(t, end - start, start);
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static ulong2 lerp(ulong2 start, ulong2 end, [This] ulong t)
    {
        if (Vector128.IsHardwareAccelerated)
            return fma(new(t), end - start, start);
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static ulong2 lerp(ulong start, ulong end, [This] ulong2 t)
    {
        if (Vector128.IsHardwareAccelerated)
            return fma(t, (end - start), new(start));
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static ulong2 unlerp([This] ulong2 a, ulong2 start, ulong2 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ulong2 unlerp([This] ulong a, ulong2 start, ulong2 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ulong2 unlerp([This] ulong2 a, ulong start, ulong end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ulong2 remap([This] ulong2 a, ulong2 srcStart, ulong2 srcEnd, ulong2 dstStart, ulong2 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static ulong2 remap([This] ulong2 a, ulong srcStart, ulong srcEnd, ulong dstStart, ulong dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static ulong dot([This] ulong2 a, ulong2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return Vector128.Dot(a.vector, b.vector);
        return (ulong)(a.x * b.x + a.y * b.y);
    }

    [MethodImpl(256 | 512)]
    public static ulong lengthsq([This] ulong2 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return Vector128.Dot(a.vector, a.vector);
        return (ulong)(a.x * a.x + a.y * a.y);
    }

    [MethodImpl(256 | 512)]
    public static ulong distancesq([This] ulong2 a, ulong2 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static ulong2 square([This] ulong2 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ulong2 fma([This] ulong2 a, ulong2 b, ulong2 c)
    {
        if (Vector128.IsHardwareAccelerated)
            return (a * b) + c;
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static ulong2 fms([This] ulong2 a, ulong2 b, ulong2 c)
    {
        if (Vector128.IsHardwareAccelerated)
            return (a * b) - c;
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static ulong2 fnma([This] ulong2 a, ulong2 b, ulong2 c)
    {
        if (Vector128.IsHardwareAccelerated)
            return c - (a * b);
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static ulong2 fsm([This] ulong2 c, ulong2 a, ulong2 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ulong2 fam([This] ulong2 c, ulong2 a, ulong2 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ulong2 mad([This] ulong2 a, ulong2 b, ulong2 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static ulong csum([This] ulong2 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return Vector128.Sum(a.vector);
        return (a.x + a.y);
    }

    [MethodImpl(256 | 512)]
    public static ulong cmin([This] ulong2 a)
    {
        if (Vector256.IsHardwareAccelerated || Vector128.IsHardwareAccelerated)
            return simd.CMin(a.vector);
        return a.x.min(a.y);
    }

    [MethodImpl(256 | 512)]
    public static ulong cmax([This] ulong2 a)
    {
        if (Vector256.IsHardwareAccelerated || Vector128.IsHardwareAccelerated)
            return simd.CMax(a.vector);
        return a.x.max(a.y);
    }

    [MethodImpl(256 | 512)]
    public static ulong cminsafe([This] ulong2 a)
    {
        if (Vector256.IsHardwareAccelerated || Vector128.IsHardwareAccelerated)
            return simd.CMin(a.vector);
        return a.x.min(a.y);
    }

    [MethodImpl(256 | 512)]
    public static ulong cmaxsafe([This] ulong2 a)
    {
        if (Vector256.IsHardwareAccelerated || Vector128.IsHardwareAccelerated)
            return simd.CMax(a.vector);
        return a.x.max(a.y);
    }
}

#endregion // ulong2

#region ulong3

public partial struct ulong3
{
    [MethodImpl(256 | 512)]
    public static ulong3 operator +(ulong3 a) => a;

    [MethodImpl(256 | 512)]
    public static ulong3 operator +(ulong3 a, ulong3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector + b.vector);
        return new((ulong)(a.x + b.x), (ulong)(a.y + b.y), (ulong)(a.z + b.z));
    }

    [MethodImpl(256 | 512)]
    public static ulong3 operator +(ulong3 a, ulong b) => a + new ulong3(b);

    [MethodImpl(256 | 512)]
    public static ulong3 operator +(ulong a, ulong3 b) => new ulong3(a) + b;

    [MethodImpl(256 | 512)]
    public static ulong3 operator -(ulong3 a, ulong3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector - b.vector);
        return new((ulong)(a.x - b.x), (ulong)(a.y - b.y), (ulong)(a.z - b.z));
    }

    [MethodImpl(256 | 512)]
    public static ulong3 operator -(ulong3 a, ulong b) => a - new ulong3(b);

    [MethodImpl(256 | 512)]
    public static ulong3 operator -(ulong a, ulong3 b) => new ulong3(a) - b;

    [MethodImpl(256 | 512)]
    public static ulong3 operator *(ulong3 a, ulong3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector * b.vector);
        return new((ulong)(a.x * b.x), (ulong)(a.y * b.y), (ulong)(a.z * b.z));
    }

    [MethodImpl(256 | 512)]
    public static ulong3 operator *(ulong a, ulong3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a * b.vector);
        return new((ulong)(a * b.x), (ulong)(a * b.y), (ulong)(a * b.z));
    }

    [MethodImpl(256 | 512)]
    public static ulong3 operator *(ulong3 a, ulong b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector * b);
        return new((ulong)(a.x * b), (ulong)(a.y * b), (ulong)(a.z * b));
    }

    [MethodImpl(256 | 512)]
    public static ulong3 operator /(ulong3 a, ulong3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new((a.vector / b.vector.WithElement(3, 1UL)));
        return new((ulong)(a.x / b.x), (ulong)(a.y / b.y), (ulong)(a.z / b.z));
    }

    [MethodImpl(256 | 512)]
    public static ulong3 operator /(ulong3 a, ulong b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new((a.vector / b));
        return new((ulong)(a.x / b), (ulong)(a.y / b), (ulong)(a.z / b));
    }

    [MethodImpl(256 | 512)]
    public static ulong3 operator /(ulong a, ulong3 b) => new ulong3(a) / b;

    [MethodImpl(256 | 512)]
    public static ulong3 operator %(ulong3 a, ulong3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return a - (a / b) * b;
        return new((ulong)(a.x % b.x), (ulong)(a.y % b.y), (ulong)(a.z % b.z));
    }

    [MethodImpl(256 | 512)]
    public static ulong3 operator %(ulong3 a, ulong b)
    {
        if (Vector256.IsHardwareAccelerated)
            return a - (a / b) * b;
        return new((ulong)(a.x % b), (ulong)(a.y % b), (ulong)(a.z % b));
    }

    [MethodImpl(256 | 512)]
    public static ulong3 operator %(ulong a, ulong3 b) => new ulong3(a) % b;

    [MethodImpl(256 | 512)]
    public static ulong3 operator --(ulong3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static ulong3 operator ++(ulong3 a) => a + One;
}

[Ex]
public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ulong3 abs([This] ulong3 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(Vector256.Abs(a.vector));
        return new(a.x.abs(), a.y.abs(), a.z.abs());
    }

    [MethodImpl(256 | 512)]
    public static ulong3 sign([This] ulong3 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.SignUInt(a.vector) & Vector256.Create(-1, -1, -1, 0).AsUInt64());
        return new(a.x.sign(), a.y.sign(), a.z.sign());
    }

    [MethodImpl(256 | 512)]
    public static ulong3 min([This] ulong3 a, ulong3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(Vector256.Min(a.vector, b.vector));
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z));
    }

    [MethodImpl(256 | 512)]
    public static ulong3 max([This] ulong3 a, ulong3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(Vector256.Max(a.vector, b.vector));
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z));
    }

    [MethodImpl(256 | 512)]
    public static ulong3 clamp([This] ulong3 v, ulong3 min, ulong3 max)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(Vector256.Max(min.vector, Vector256.Min(max.vector, v.vector)));
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z));
    }

    [MethodImpl(256 | 512)]
    public static ulong3 clamp([This] ulong3 v, ulong min, ulong max) => v.clamp(new ulong3(min), new ulong3(max));

    [MethodImpl(256 | 512)]
    public static ulong3 lerp(ulong3 start, ulong3 end, [This] ulong3 t)
    {
        if (Vector256.IsHardwareAccelerated)
            return fma(t, end - start, start);
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static ulong3 lerp(ulong3 start, ulong3 end, [This] ulong t)
    {
        if (Vector256.IsHardwareAccelerated)
            return fma(new(t), end - start, start);
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static ulong3 lerp(ulong start, ulong end, [This] ulong3 t)
    {
        if (Vector256.IsHardwareAccelerated)
            return fma(t, (end - start), new(start));
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static ulong3 unlerp([This] ulong3 a, ulong3 start, ulong3 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ulong3 unlerp([This] ulong a, ulong3 start, ulong3 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ulong3 unlerp([This] ulong3 a, ulong start, ulong end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ulong3 remap([This] ulong3 a, ulong3 srcStart, ulong3 srcEnd, ulong3 dstStart, ulong3 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static ulong3 remap([This] ulong3 a, ulong srcStart, ulong srcEnd, ulong dstStart, ulong dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static ulong dot([This] ulong3 a, ulong3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return Vector256.Dot(a.vector, b.vector);
        return (ulong)(a.x * b.x + a.y * b.y + a.z * b.z);
    }

    [MethodImpl(256 | 512)]
    public static ulong3 cross([This] ulong3 a, ulong3 b)
    {
        // (a * b.yzx - a.yzx * b).yzx;
        return fnma(a.yzx, b, a * b.yzx).yzx;
    }

    [MethodImpl(256 | 512)]
    public static ulong lengthsq([This] ulong3 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return Vector256.Dot(a.vector, a.vector);
        return (ulong)(a.x * a.x + a.y * a.y + a.z * a.z);
    }

    [MethodImpl(256 | 512)]
    public static ulong distancesq([This] ulong3 a, ulong3 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static ulong3 square([This] ulong3 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ulong3 fma([This] ulong3 a, ulong3 b, ulong3 c)
    {
        if (Vector256.IsHardwareAccelerated)
            return (a * b) + c;
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y), a.z.fma(b.z, c.z));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static ulong3 fms([This] ulong3 a, ulong3 b, ulong3 c)
    {
        if (Vector256.IsHardwareAccelerated)
            return (a * b) - c;
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y), a.z.fms(b.z, c.z));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static ulong3 fnma([This] ulong3 a, ulong3 b, ulong3 c)
    {
        if (Vector256.IsHardwareAccelerated)
            return c - (a * b);
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y), a.z.fnma(b.z, c.z));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static ulong3 fsm([This] ulong3 c, ulong3 a, ulong3 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ulong3 fam([This] ulong3 c, ulong3 a, ulong3 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ulong3 mad([This] ulong3 a, ulong3 b, ulong3 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static ulong csum([This] ulong3 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return Vector256.Sum(a.vector);
        return (a.x + a.y + a.z);
    }

    [MethodImpl(256 | 512)]
    public static ulong cmin([This] ulong3 a)
    {
        if (Vector256.IsHardwareAccelerated || Vector128.IsHardwareAccelerated)
            return simd.CMin3(a.vector);
        return a.x.min(a.y).min(a.z);
    }

    [MethodImpl(256 | 512)]
    public static ulong cmax([This] ulong3 a)
    {
        if (Vector256.IsHardwareAccelerated || Vector128.IsHardwareAccelerated)
            return simd.CMax3(a.vector);
        return a.x.max(a.y).max(a.z);
    }

    [MethodImpl(256 | 512)]
    public static ulong cminsafe([This] ulong3 a)
    {
        if (Vector256.IsHardwareAccelerated || Vector128.IsHardwareAccelerated)
            return simd.CMin3(a.vector);
        return a.x.min(a.y).min(a.z);
    }

    [MethodImpl(256 | 512)]
    public static ulong cmaxsafe([This] ulong3 a)
    {
        if (Vector256.IsHardwareAccelerated || Vector128.IsHardwareAccelerated)
            return simd.CMax3(a.vector);
        return a.x.max(a.y).max(a.z);
    }
}

#endregion // ulong3

#region ulong4

public partial struct ulong4
{
    [MethodImpl(256 | 512)]
    public static ulong4 operator +(ulong4 a) => a;

    [MethodImpl(256 | 512)]
    public static ulong4 operator +(ulong4 a, ulong4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector + b.vector);
        return new((ulong)(a.x + b.x), (ulong)(a.y + b.y), (ulong)(a.z + b.z), (ulong)(a.w + b.w));
    }

    [MethodImpl(256 | 512)]
    public static ulong4 operator +(ulong4 a, ulong b) => a + new ulong4(b);

    [MethodImpl(256 | 512)]
    public static ulong4 operator +(ulong a, ulong4 b) => new ulong4(a) + b;

    [MethodImpl(256 | 512)]
    public static ulong4 operator -(ulong4 a, ulong4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector - b.vector);
        return new((ulong)(a.x - b.x), (ulong)(a.y - b.y), (ulong)(a.z - b.z), (ulong)(a.w - b.w));
    }

    [MethodImpl(256 | 512)]
    public static ulong4 operator -(ulong4 a, ulong b) => a - new ulong4(b);

    [MethodImpl(256 | 512)]
    public static ulong4 operator -(ulong a, ulong4 b) => new ulong4(a) - b;

    [MethodImpl(256 | 512)]
    public static ulong4 operator *(ulong4 a, ulong4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector * b.vector);
        return new((ulong)(a.x * b.x), (ulong)(a.y * b.y), (ulong)(a.z * b.z), (ulong)(a.w * b.w));
    }

    [MethodImpl(256 | 512)]
    public static ulong4 operator *(ulong a, ulong4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a * b.vector);
        return new((ulong)(a * b.x), (ulong)(a * b.y), (ulong)(a * b.z), (ulong)(a * b.w));
    }

    [MethodImpl(256 | 512)]
    public static ulong4 operator *(ulong4 a, ulong b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(a.vector * b);
        return new((ulong)(a.x * b), (ulong)(a.y * b), (ulong)(a.z * b), (ulong)(a.w * b));
    }

    [MethodImpl(256 | 512)]
    public static ulong4 operator /(ulong4 a, ulong4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new((a.vector / b.vector));
        return new((ulong)(a.x / b.x), (ulong)(a.y / b.y), (ulong)(a.z / b.z), (ulong)(a.w / b.w));
    }

    [MethodImpl(256 | 512)]
    public static ulong4 operator /(ulong4 a, ulong b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new((a.vector / b));
        return new((ulong)(a.x / b), (ulong)(a.y / b), (ulong)(a.z / b), (ulong)(a.w / b));
    }

    [MethodImpl(256 | 512)]
    public static ulong4 operator /(ulong a, ulong4 b) => new ulong4(a) / b;

    [MethodImpl(256 | 512)]
    public static ulong4 operator %(ulong4 a, ulong4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return a - (a / b) * b;
        return new((ulong)(a.x % b.x), (ulong)(a.y % b.y), (ulong)(a.z % b.z), (ulong)(a.w % b.w));
    }

    [MethodImpl(256 | 512)]
    public static ulong4 operator %(ulong4 a, ulong b)
    {
        if (Vector256.IsHardwareAccelerated)
            return a - (a / b) * b;
        return new((ulong)(a.x % b), (ulong)(a.y % b), (ulong)(a.z % b), (ulong)(a.w % b));
    }

    [MethodImpl(256 | 512)]
    public static ulong4 operator %(ulong a, ulong4 b) => new ulong4(a) % b;

    [MethodImpl(256 | 512)]
    public static ulong4 operator --(ulong4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static ulong4 operator ++(ulong4 a) => a + One;
}

[Ex]
public static partial class math
{
    [MethodImpl(256 | 512)]
    public static ulong4 abs([This] ulong4 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(Vector256.Abs(a.vector));
        return new(a.x.abs(), a.y.abs(), a.z.abs(), a.w.abs());
    }

    [MethodImpl(256 | 512)]
    public static ulong4 sign([This] ulong4 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.SignUInt(a.vector));
        return new(a.x.sign(), a.y.sign(), a.z.sign(), a.w.sign());
    }

    [MethodImpl(256 | 512)]
    public static ulong4 min([This] ulong4 a, ulong4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(Vector256.Min(a.vector, b.vector));
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z), a.w.min(b.w));
    }

    [MethodImpl(256 | 512)]
    public static ulong4 max([This] ulong4 a, ulong4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(Vector256.Max(a.vector, b.vector));
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z), a.w.max(b.w));
    }

    [MethodImpl(256 | 512)]
    public static ulong4 clamp([This] ulong4 v, ulong4 min, ulong4 max)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(Vector256.Max(min.vector, Vector256.Min(max.vector, v.vector)));
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z), v.w.clamp(min.w, max.w));
    }

    [MethodImpl(256 | 512)]
    public static ulong4 clamp([This] ulong4 v, ulong min, ulong max) => v.clamp(new ulong4(min), new ulong4(max));

    [MethodImpl(256 | 512)]
    public static ulong4 lerp(ulong4 start, ulong4 end, [This] ulong4 t)
    {
        if (Vector256.IsHardwareAccelerated)
            return fma(t, end - start, start);
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static ulong4 lerp(ulong4 start, ulong4 end, [This] ulong t)
    {
        if (Vector256.IsHardwareAccelerated)
            return fma(new(t), end - start, start);
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static ulong4 lerp(ulong start, ulong end, [This] ulong4 t)
    {
        if (Vector256.IsHardwareAccelerated)
            return fma(t, (end - start), new(start));
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static ulong4 unlerp([This] ulong4 a, ulong4 start, ulong4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ulong4 unlerp([This] ulong a, ulong4 start, ulong4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ulong4 unlerp([This] ulong4 a, ulong start, ulong end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static ulong4 remap([This] ulong4 a, ulong4 srcStart, ulong4 srcEnd, ulong4 dstStart, ulong4 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static ulong4 remap([This] ulong4 a, ulong srcStart, ulong srcEnd, ulong dstStart, ulong dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static ulong dot([This] ulong4 a, ulong4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return Vector256.Dot(a.vector, b.vector);
        return (ulong)(a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w);
    }

    [MethodImpl(256 | 512)]
    public static ulong lengthsq([This] ulong4 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return Vector256.Dot(a.vector, a.vector);
        return (ulong)(a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w);
    }

    [MethodImpl(256 | 512)]
    public static ulong distancesq([This] ulong4 a, ulong4 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static ulong4 square([This] ulong4 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ulong4 fma([This] ulong4 a, ulong4 b, ulong4 c)
    {
        if (Vector256.IsHardwareAccelerated)
            return (a * b) + c;
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y), a.z.fma(b.z, c.z), a.w.fma(b.w, c.w));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static ulong4 fms([This] ulong4 a, ulong4 b, ulong4 c)
    {
        if (Vector256.IsHardwareAccelerated)
            return (a * b) - c;
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y), a.z.fms(b.z, c.z), a.w.fms(b.w, c.w));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static ulong4 fnma([This] ulong4 a, ulong4 b, ulong4 c)
    {
        if (Vector256.IsHardwareAccelerated)
            return c - (a * b);
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y), a.z.fnma(b.z, c.z), a.w.fnma(b.w, c.w));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static ulong4 fsm([This] ulong4 c, ulong4 a, ulong4 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ulong4 fam([This] ulong4 c, ulong4 a, ulong4 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static ulong4 mad([This] ulong4 a, ulong4 b, ulong4 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static ulong csum([This] ulong4 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return Vector256.Sum(a.vector);
        return (a.x + a.y + a.z + a.w);
    }

    [MethodImpl(256 | 512)]
    public static ulong cmin([This] ulong4 a)
    {
        if (Vector256.IsHardwareAccelerated || Vector128.IsHardwareAccelerated)
            return simd.CMin(a.vector);
        return a.x.min(a.y).min(a.z).min(a.w);
    }

    [MethodImpl(256 | 512)]
    public static ulong cmax([This] ulong4 a)
    {
        if (Vector256.IsHardwareAccelerated || Vector128.IsHardwareAccelerated)
            return simd.CMax(a.vector);
        return a.x.max(a.y).max(a.z).max(a.w);
    }

    [MethodImpl(256 | 512)]
    public static ulong cminsafe([This] ulong4 a)
    {
        if (Vector256.IsHardwareAccelerated || Vector128.IsHardwareAccelerated)
            return simd.CMin(a.vector);
        return a.x.min(a.y).min(a.z).min(a.w);
    }

    [MethodImpl(256 | 512)]
    public static ulong cmaxsafe([This] ulong4 a)
    {
        if (Vector256.IsHardwareAccelerated || Vector128.IsHardwareAccelerated)
            return simd.CMax(a.vector);
        return a.x.max(a.y).max(a.z).max(a.w);
    }
}

#endregion // ulong4

#region decimal2

public partial struct decimal2
{
    [MethodImpl(256 | 512)]
    public static decimal2 operator +(decimal2 a) => a;
    [MethodImpl(256 | 512)]
    public static decimal2 operator -(decimal2 a)
    {
        return new((-a.x), (-a.y));
    }

    [MethodImpl(256 | 512)]
    public static decimal2 operator +(decimal2 a, decimal2 b)
    {
        return new((decimal)(a.x + b.x), (decimal)(a.y + b.y));
    }

    [MethodImpl(256 | 512)]
    public static decimal2 operator +(decimal2 a, decimal b) => a + new decimal2(b);

    [MethodImpl(256 | 512)]
    public static decimal2 operator +(decimal a, decimal2 b) => new decimal2(a) + b;

    [MethodImpl(256 | 512)]
    public static decimal2 operator -(decimal2 a, decimal2 b)
    {
        return new((decimal)(a.x - b.x), (decimal)(a.y - b.y));
    }

    [MethodImpl(256 | 512)]
    public static decimal2 operator -(decimal2 a, decimal b) => a - new decimal2(b);

    [MethodImpl(256 | 512)]
    public static decimal2 operator -(decimal a, decimal2 b) => new decimal2(a) - b;

    [MethodImpl(256 | 512)]
    public static decimal2 operator *(decimal2 a, decimal2 b)
    {
        return new((decimal)(a.x * b.x), (decimal)(a.y * b.y));
    }

    [MethodImpl(256 | 512)]
    public static decimal2 operator *(decimal a, decimal2 b)
    {
        return new((decimal)(a * b.x), (decimal)(a * b.y));
    }

    [MethodImpl(256 | 512)]
    public static decimal2 operator *(decimal2 a, decimal b)
    {
        return new((decimal)(a.x * b), (decimal)(a.y * b));
    }

    [MethodImpl(256 | 512)]
    public static decimal2 operator /(decimal2 a, decimal2 b)
    {
        return new((decimal)(a.x / b.x), (decimal)(a.y / b.y));
    }

    [MethodImpl(256 | 512)]
    public static decimal2 operator /(decimal2 a, decimal b)
    {
        return new((decimal)(a.x / b), (decimal)(a.y / b));
    }

    [MethodImpl(256 | 512)]
    public static decimal2 operator /(decimal a, decimal2 b) => new decimal2(a) / b;

    [MethodImpl(256 | 512)]
    public static decimal2 operator %(decimal2 a, decimal2 b)
    {
        return new((decimal)(a.x % b.x), (decimal)(a.y % b.y));
    }

    [MethodImpl(256 | 512)]
    public static decimal2 operator %(decimal2 a, decimal b)
    {
        return new((decimal)(a.x % b), (decimal)(a.y % b));
    }

    [MethodImpl(256 | 512)]
    public static decimal2 operator %(decimal a, decimal2 b) => new decimal2(a) % b;

    [MethodImpl(256 | 512)]
    public static decimal2 operator --(decimal2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static decimal2 operator ++(decimal2 a) => a + One;
}

[Ex]
public static partial class math
{
    [MethodImpl(256 | 512)]
    public static decimal2 abs([This] decimal2 a)
    {
        return new(a.x.abs(), a.y.abs());
    }

    [MethodImpl(256 | 512)]
    public static decimal2 sign([This] decimal2 a)
    {
        return new(a.x.sign(), a.y.sign());
    }

    [MethodImpl(256 | 512)]
    public static decimal2 min([This] decimal2 a, decimal2 b)
    {
        return new(a.x.min(b.x), a.y.min(b.y));
    }

    [MethodImpl(256 | 512)]
    public static decimal2 max([This] decimal2 a, decimal2 b)
    {
        return new(a.x.max(b.x), a.y.max(b.y));
    }

    [MethodImpl(256 | 512)]
    public static decimal2 clamp([This] decimal2 v, decimal2 min, decimal2 max)
    {
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y));
    }

    [MethodImpl(256 | 512)]
    public static decimal2 clamp([This] decimal2 v, decimal min, decimal max) => v.clamp(new decimal2(min), new decimal2(max));

    [MethodImpl(256 | 512)]
    public static decimal2 lerp(decimal2 start, decimal2 end, [This] decimal2 t)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static decimal2 lerp(decimal2 start, decimal2 end, [This] decimal t)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static decimal2 lerp(decimal start, decimal end, [This] decimal2 t)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static decimal2 unlerp([This] decimal2 a, decimal2 start, decimal2 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static decimal2 unlerp([This] decimal a, decimal2 start, decimal2 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static decimal2 unlerp([This] decimal2 a, decimal start, decimal end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static decimal2 remap([This] decimal2 a, decimal2 srcStart, decimal2 srcEnd, decimal2 dstStart, decimal2 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static decimal2 remap([This] decimal2 a, decimal srcStart, decimal srcEnd, decimal dstStart, decimal dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static decimal dot([This] decimal2 a, decimal2 b)
    {
        return (decimal)(a.x * b.x + a.y * b.y);
    }

    [MethodImpl(256 | 512)]
    public static decimal lengthsq([This] decimal2 a)
    {
        return (decimal)(a.x * a.x + a.y * a.y);
    }

    [MethodImpl(256 | 512)]
    public static decimal distancesq([This] decimal2 a, decimal2 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static decimal2 square([This] decimal2 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static decimal2 fma([This] decimal2 a, decimal2 b, decimal2 c)
    {
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static decimal2 fms([This] decimal2 a, decimal2 b, decimal2 c)
    {
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static decimal2 fnma([This] decimal2 a, decimal2 b, decimal2 c)
    {
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static decimal2 fsm([This] decimal2 c, decimal2 a, decimal2 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static decimal2 fam([This] decimal2 c, decimal2 a, decimal2 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static decimal2 mad([This] decimal2 a, decimal2 b, decimal2 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static decimal csum([This] decimal2 a)
    {
        return (a.x + a.y);
    }

    [MethodImpl(256 | 512)]
    public static decimal cmin([This] decimal2 a)
    {
        return a.x.min(a.y);
    }

    [MethodImpl(256 | 512)]
    public static decimal cmax([This] decimal2 a)
    {
        return a.x.max(a.y);
    }

    [MethodImpl(256 | 512)]
    public static decimal cminsafe([This] decimal2 a)
    {
        return a.x.min(a.y);
    }

    [MethodImpl(256 | 512)]
    public static decimal cmaxsafe([This] decimal2 a)
    {
        return a.x.max(a.y);
    }
}

#endregion // decimal2

#region decimal3

public partial struct decimal3
{
    [MethodImpl(256 | 512)]
    public static decimal3 operator +(decimal3 a) => a;
    [MethodImpl(256 | 512)]
    public static decimal3 operator -(decimal3 a)
    {
        return new((-a.x), (-a.y), (-a.z));
    }

    [MethodImpl(256 | 512)]
    public static decimal3 operator +(decimal3 a, decimal3 b)
    {
        return new((decimal)(a.x + b.x), (decimal)(a.y + b.y), (decimal)(a.z + b.z));
    }

    [MethodImpl(256 | 512)]
    public static decimal3 operator +(decimal3 a, decimal b) => a + new decimal3(b);

    [MethodImpl(256 | 512)]
    public static decimal3 operator +(decimal a, decimal3 b) => new decimal3(a) + b;

    [MethodImpl(256 | 512)]
    public static decimal3 operator -(decimal3 a, decimal3 b)
    {
        return new((decimal)(a.x - b.x), (decimal)(a.y - b.y), (decimal)(a.z - b.z));
    }

    [MethodImpl(256 | 512)]
    public static decimal3 operator -(decimal3 a, decimal b) => a - new decimal3(b);

    [MethodImpl(256 | 512)]
    public static decimal3 operator -(decimal a, decimal3 b) => new decimal3(a) - b;

    [MethodImpl(256 | 512)]
    public static decimal3 operator *(decimal3 a, decimal3 b)
    {
        return new((decimal)(a.x * b.x), (decimal)(a.y * b.y), (decimal)(a.z * b.z));
    }

    [MethodImpl(256 | 512)]
    public static decimal3 operator *(decimal a, decimal3 b)
    {
        return new((decimal)(a * b.x), (decimal)(a * b.y), (decimal)(a * b.z));
    }

    [MethodImpl(256 | 512)]
    public static decimal3 operator *(decimal3 a, decimal b)
    {
        return new((decimal)(a.x * b), (decimal)(a.y * b), (decimal)(a.z * b));
    }

    [MethodImpl(256 | 512)]
    public static decimal3 operator /(decimal3 a, decimal3 b)
    {
        return new((decimal)(a.x / b.x), (decimal)(a.y / b.y), (decimal)(a.z / b.z));
    }

    [MethodImpl(256 | 512)]
    public static decimal3 operator /(decimal3 a, decimal b)
    {
        return new((decimal)(a.x / b), (decimal)(a.y / b), (decimal)(a.z / b));
    }

    [MethodImpl(256 | 512)]
    public static decimal3 operator /(decimal a, decimal3 b) => new decimal3(a) / b;

    [MethodImpl(256 | 512)]
    public static decimal3 operator %(decimal3 a, decimal3 b)
    {
        return new((decimal)(a.x % b.x), (decimal)(a.y % b.y), (decimal)(a.z % b.z));
    }

    [MethodImpl(256 | 512)]
    public static decimal3 operator %(decimal3 a, decimal b)
    {
        return new((decimal)(a.x % b), (decimal)(a.y % b), (decimal)(a.z % b));
    }

    [MethodImpl(256 | 512)]
    public static decimal3 operator %(decimal a, decimal3 b) => new decimal3(a) % b;

    [MethodImpl(256 | 512)]
    public static decimal3 operator --(decimal3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static decimal3 operator ++(decimal3 a) => a + One;
}

[Ex]
public static partial class math
{
    [MethodImpl(256 | 512)]
    public static decimal3 abs([This] decimal3 a)
    {
        return new(a.x.abs(), a.y.abs(), a.z.abs());
    }

    [MethodImpl(256 | 512)]
    public static decimal3 sign([This] decimal3 a)
    {
        return new(a.x.sign(), a.y.sign(), a.z.sign());
    }

    [MethodImpl(256 | 512)]
    public static decimal3 min([This] decimal3 a, decimal3 b)
    {
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z));
    }

    [MethodImpl(256 | 512)]
    public static decimal3 max([This] decimal3 a, decimal3 b)
    {
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z));
    }

    [MethodImpl(256 | 512)]
    public static decimal3 clamp([This] decimal3 v, decimal3 min, decimal3 max)
    {
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z));
    }

    [MethodImpl(256 | 512)]
    public static decimal3 clamp([This] decimal3 v, decimal min, decimal max) => v.clamp(new decimal3(min), new decimal3(max));

    [MethodImpl(256 | 512)]
    public static decimal3 lerp(decimal3 start, decimal3 end, [This] decimal3 t)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static decimal3 lerp(decimal3 start, decimal3 end, [This] decimal t)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static decimal3 lerp(decimal start, decimal end, [This] decimal3 t)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static decimal3 unlerp([This] decimal3 a, decimal3 start, decimal3 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static decimal3 unlerp([This] decimal a, decimal3 start, decimal3 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static decimal3 unlerp([This] decimal3 a, decimal start, decimal end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static decimal3 remap([This] decimal3 a, decimal3 srcStart, decimal3 srcEnd, decimal3 dstStart, decimal3 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static decimal3 remap([This] decimal3 a, decimal srcStart, decimal srcEnd, decimal dstStart, decimal dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static decimal dot([This] decimal3 a, decimal3 b)
    {
        return (decimal)(a.x * b.x + a.y * b.y + a.z * b.z);
    }

    [MethodImpl(256 | 512)]
    public static decimal3 cross([This] decimal3 a, decimal3 b)
    {
        // (a * b.yzx - a.yzx * b).yzx;
        return fnma(a.yzx, b, a * b.yzx).yzx;
    }

    [MethodImpl(256 | 512)]
    public static decimal lengthsq([This] decimal3 a)
    {
        return (decimal)(a.x * a.x + a.y * a.y + a.z * a.z);
    }

    [MethodImpl(256 | 512)]
    public static decimal distancesq([This] decimal3 a, decimal3 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static decimal3 square([This] decimal3 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static decimal3 fma([This] decimal3 a, decimal3 b, decimal3 c)
    {
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y), a.z.fma(b.z, c.z));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static decimal3 fms([This] decimal3 a, decimal3 b, decimal3 c)
    {
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y), a.z.fms(b.z, c.z));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static decimal3 fnma([This] decimal3 a, decimal3 b, decimal3 c)
    {
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y), a.z.fnma(b.z, c.z));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static decimal3 fsm([This] decimal3 c, decimal3 a, decimal3 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static decimal3 fam([This] decimal3 c, decimal3 a, decimal3 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static decimal3 mad([This] decimal3 a, decimal3 b, decimal3 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static decimal csum([This] decimal3 a)
    {
        return (a.x + a.y + a.z);
    }

    [MethodImpl(256 | 512)]
    public static decimal cmin([This] decimal3 a)
    {
        return a.x.min(a.y).min(a.z);
    }

    [MethodImpl(256 | 512)]
    public static decimal cmax([This] decimal3 a)
    {
        return a.x.max(a.y).max(a.z);
    }

    [MethodImpl(256 | 512)]
    public static decimal cminsafe([This] decimal3 a)
    {
        return a.x.min(a.y).min(a.z);
    }

    [MethodImpl(256 | 512)]
    public static decimal cmaxsafe([This] decimal3 a)
    {
        return a.x.max(a.y).max(a.z);
    }
}

#endregion // decimal3

#region decimal4

public partial struct decimal4
{
    [MethodImpl(256 | 512)]
    public static decimal4 operator +(decimal4 a) => a;
    [MethodImpl(256 | 512)]
    public static decimal4 operator -(decimal4 a)
    {
        return new((-a.x), (-a.y), (-a.z), (-a.w));
    }

    [MethodImpl(256 | 512)]
    public static decimal4 operator +(decimal4 a, decimal4 b)
    {
        return new((decimal)(a.x + b.x), (decimal)(a.y + b.y), (decimal)(a.z + b.z), (decimal)(a.w + b.w));
    }

    [MethodImpl(256 | 512)]
    public static decimal4 operator +(decimal4 a, decimal b) => a + new decimal4(b);

    [MethodImpl(256 | 512)]
    public static decimal4 operator +(decimal a, decimal4 b) => new decimal4(a) + b;

    [MethodImpl(256 | 512)]
    public static decimal4 operator -(decimal4 a, decimal4 b)
    {
        return new((decimal)(a.x - b.x), (decimal)(a.y - b.y), (decimal)(a.z - b.z), (decimal)(a.w - b.w));
    }

    [MethodImpl(256 | 512)]
    public static decimal4 operator -(decimal4 a, decimal b) => a - new decimal4(b);

    [MethodImpl(256 | 512)]
    public static decimal4 operator -(decimal a, decimal4 b) => new decimal4(a) - b;

    [MethodImpl(256 | 512)]
    public static decimal4 operator *(decimal4 a, decimal4 b)
    {
        return new((decimal)(a.x * b.x), (decimal)(a.y * b.y), (decimal)(a.z * b.z), (decimal)(a.w * b.w));
    }

    [MethodImpl(256 | 512)]
    public static decimal4 operator *(decimal a, decimal4 b)
    {
        return new((decimal)(a * b.x), (decimal)(a * b.y), (decimal)(a * b.z), (decimal)(a * b.w));
    }

    [MethodImpl(256 | 512)]
    public static decimal4 operator *(decimal4 a, decimal b)
    {
        return new((decimal)(a.x * b), (decimal)(a.y * b), (decimal)(a.z * b), (decimal)(a.w * b));
    }

    [MethodImpl(256 | 512)]
    public static decimal4 operator /(decimal4 a, decimal4 b)
    {
        return new((decimal)(a.x / b.x), (decimal)(a.y / b.y), (decimal)(a.z / b.z), (decimal)(a.w / b.w));
    }

    [MethodImpl(256 | 512)]
    public static decimal4 operator /(decimal4 a, decimal b)
    {
        return new((decimal)(a.x / b), (decimal)(a.y / b), (decimal)(a.z / b), (decimal)(a.w / b));
    }

    [MethodImpl(256 | 512)]
    public static decimal4 operator /(decimal a, decimal4 b) => new decimal4(a) / b;

    [MethodImpl(256 | 512)]
    public static decimal4 operator %(decimal4 a, decimal4 b)
    {
        return new((decimal)(a.x % b.x), (decimal)(a.y % b.y), (decimal)(a.z % b.z), (decimal)(a.w % b.w));
    }

    [MethodImpl(256 | 512)]
    public static decimal4 operator %(decimal4 a, decimal b)
    {
        return new((decimal)(a.x % b), (decimal)(a.y % b), (decimal)(a.z % b), (decimal)(a.w % b));
    }

    [MethodImpl(256 | 512)]
    public static decimal4 operator %(decimal a, decimal4 b) => new decimal4(a) % b;

    [MethodImpl(256 | 512)]
    public static decimal4 operator --(decimal4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static decimal4 operator ++(decimal4 a) => a + One;
}

[Ex]
public static partial class math
{
    [MethodImpl(256 | 512)]
    public static decimal4 abs([This] decimal4 a)
    {
        return new(a.x.abs(), a.y.abs(), a.z.abs(), a.w.abs());
    }

    [MethodImpl(256 | 512)]
    public static decimal4 sign([This] decimal4 a)
    {
        return new(a.x.sign(), a.y.sign(), a.z.sign(), a.w.sign());
    }

    [MethodImpl(256 | 512)]
    public static decimal4 min([This] decimal4 a, decimal4 b)
    {
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z), a.w.min(b.w));
    }

    [MethodImpl(256 | 512)]
    public static decimal4 max([This] decimal4 a, decimal4 b)
    {
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z), a.w.max(b.w));
    }

    [MethodImpl(256 | 512)]
    public static decimal4 clamp([This] decimal4 v, decimal4 min, decimal4 max)
    {
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z), v.w.clamp(min.w, max.w));
    }

    [MethodImpl(256 | 512)]
    public static decimal4 clamp([This] decimal4 v, decimal min, decimal max) => v.clamp(new decimal4(min), new decimal4(max));

    [MethodImpl(256 | 512)]
    public static decimal4 lerp(decimal4 start, decimal4 end, [This] decimal4 t)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static decimal4 lerp(decimal4 start, decimal4 end, [This] decimal t)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static decimal4 lerp(decimal start, decimal end, [This] decimal4 t)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static decimal4 unlerp([This] decimal4 a, decimal4 start, decimal4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static decimal4 unlerp([This] decimal a, decimal4 start, decimal4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static decimal4 unlerp([This] decimal4 a, decimal start, decimal end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static decimal4 remap([This] decimal4 a, decimal4 srcStart, decimal4 srcEnd, decimal4 dstStart, decimal4 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static decimal4 remap([This] decimal4 a, decimal srcStart, decimal srcEnd, decimal dstStart, decimal dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static decimal dot([This] decimal4 a, decimal4 b)
    {
        return (decimal)(a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w);
    }

    [MethodImpl(256 | 512)]
    public static decimal lengthsq([This] decimal4 a)
    {
        return (decimal)(a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w);
    }

    [MethodImpl(256 | 512)]
    public static decimal distancesq([This] decimal4 a, decimal4 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static decimal4 square([This] decimal4 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static decimal4 fma([This] decimal4 a, decimal4 b, decimal4 c)
    {
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y), a.z.fma(b.z, c.z), a.w.fma(b.w, c.w));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static decimal4 fms([This] decimal4 a, decimal4 b, decimal4 c)
    {
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y), a.z.fms(b.z, c.z), a.w.fms(b.w, c.w));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static decimal4 fnma([This] decimal4 a, decimal4 b, decimal4 c)
    {
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y), a.z.fnma(b.z, c.z), a.w.fnma(b.w, c.w));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static decimal4 fsm([This] decimal4 c, decimal4 a, decimal4 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static decimal4 fam([This] decimal4 c, decimal4 a, decimal4 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static decimal4 mad([This] decimal4 a, decimal4 b, decimal4 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static decimal csum([This] decimal4 a)
    {
        return (a.x + a.y + a.z + a.w);
    }

    [MethodImpl(256 | 512)]
    public static decimal cmin([This] decimal4 a)
    {
        return a.x.min(a.y).min(a.z).min(a.w);
    }

    [MethodImpl(256 | 512)]
    public static decimal cmax([This] decimal4 a)
    {
        return a.x.max(a.y).max(a.z).max(a.w);
    }

    [MethodImpl(256 | 512)]
    public static decimal cminsafe([This] decimal4 a)
    {
        return a.x.min(a.y).min(a.z).min(a.w);
    }

    [MethodImpl(256 | 512)]
    public static decimal cmaxsafe([This] decimal4 a)
    {
        return a.x.max(a.y).max(a.z).max(a.w);
    }
}

#endregion // decimal4

#region half2

public partial struct half2
{
    [MethodImpl(256 | 512)]
    public static half2 operator +(half2 a) => a;
    [MethodImpl(256 | 512)]
    public static half2 operator -(half2 a)
    {
        return new((half)(-a.x), (half)(-a.y));
    }

    [MethodImpl(256 | 512)]
    public static half2 operator +(half2 a, half2 b)
    {
        return new((half)(a.x + b.x), (half)(a.y + b.y));
    }

    [MethodImpl(256 | 512)]
    public static half2 operator +(half2 a, half b) => a + new half2(b);

    [MethodImpl(256 | 512)]
    public static half2 operator +(half a, half2 b) => new half2(a) + b;

    [MethodImpl(256 | 512)]
    public static half2 operator -(half2 a, half2 b)
    {
        return new((half)(a.x - b.x), (half)(a.y - b.y));
    }

    [MethodImpl(256 | 512)]
    public static half2 operator -(half2 a, half b) => a - new half2(b);

    [MethodImpl(256 | 512)]
    public static half2 operator -(half a, half2 b) => new half2(a) - b;

    [MethodImpl(256 | 512)]
    public static half2 operator *(half2 a, half2 b)
    {
        return new((half)(a.x * b.x), (half)(a.y * b.y));
    }

    [MethodImpl(256 | 512)]
    public static half2 operator *(half a, half2 b)
    {
        return new((half)(a * b.x), (half)(a * b.y));
    }

    [MethodImpl(256 | 512)]
    public static half2 operator *(half2 a, half b)
    {
        return new((half)(a.x * b), (half)(a.y * b));
    }

    [MethodImpl(256 | 512)]
    public static half2 operator /(half2 a, half2 b)
    {
        return new((half)(a.x / b.x), (half)(a.y / b.y));
    }

    [MethodImpl(256 | 512)]
    public static half2 operator /(half2 a, half b)
    {
        return new((half)(a.x / b), (half)(a.y / b));
    }

    [MethodImpl(256 | 512)]
    public static half2 operator /(half a, half2 b) => new half2(a) / b;

    [MethodImpl(256 | 512)]
    public static half2 operator %(half2 a, half2 b)
    {
        return new((half)(a.x % b.x), (half)(a.y % b.y));
    }

    [MethodImpl(256 | 512)]
    public static half2 operator %(half2 a, half b)
    {
        return new((half)(a.x % b), (half)(a.y % b));
    }

    [MethodImpl(256 | 512)]
    public static half2 operator %(half a, half2 b) => new half2(a) % b;

    [MethodImpl(256 | 512)]
    public static half2 operator --(half2 a) => a - One;

    [MethodImpl(256 | 512)]
    public static half2 operator ++(half2 a) => a + One;
}

[Ex]
public static partial class math
{
    [MethodImpl(256 | 512)]
    public static half2 abs([This] half2 a)
    {
        return new(a.x.abs(), a.y.abs());
    }

    [MethodImpl(256 | 512)]
    public static half2 sign([This] half2 a)
    {
        return new(a.x.sign(), a.y.sign());
    }

    [MethodImpl(256 | 512)]
    public static half2 min([This] half2 a, half2 b)
    {
        return new(a.x.min(b.x), a.y.min(b.y));
    }

    [MethodImpl(256 | 512)]
    public static half2 max([This] half2 a, half2 b)
    {
        return new(a.x.max(b.x), a.y.max(b.y));
    }

    [MethodImpl(256 | 512)]
    public static half2 clamp([This] half2 v, half2 min, half2 max)
    {
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y));
    }

    [MethodImpl(256 | 512)]
    public static half2 clamp([This] half2 v, half min, half max) => v.clamp(new half2(min), new half2(max));

    [MethodImpl(256 | 512)]
    public static half2 lerp(half2 start, half2 end, [This] half2 t)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static half2 lerp(half2 start, half2 end, [This] half t)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static half2 lerp(half start, half end, [This] half2 t)
    {
        return start + t * (half)(end - start);
    }

    [MethodImpl(256 | 512)]
    public static half2 unlerp([This] half2 a, half2 start, half2 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static half2 unlerp([This] half a, half2 start, half2 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static half2 unlerp([This] half2 a, half start, half end) => (a - start) / (half)(end - start);

    [MethodImpl(256 | 512)]
    public static half2 remap([This] half2 a, half2 srcStart, half2 srcEnd, half2 dstStart, half2 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static half2 remap([This] half2 a, half srcStart, half srcEnd, half dstStart, half dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static half dot([This] half2 a, half2 b)
    {
        return (half)(a.x * b.x + a.y * b.y);
    }

    [MethodImpl(256 | 512)]
    public static half lengthsq([This] half2 a)
    {
        return (half)(a.x * a.x + a.y * a.y);
    }

    [MethodImpl(256 | 512)]
    public static half distancesq([This] half2 a, half2 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static half2 square([This] half2 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static half2 fma([This] half2 a, half2 b, half2 c)
    {
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static half2 fms([This] half2 a, half2 b, half2 c)
    {
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static half2 fnma([This] half2 a, half2 b, half2 c)
    {
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static half2 fsm([This] half2 c, half2 a, half2 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static half2 fam([This] half2 c, half2 a, half2 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static half2 mad([This] half2 a, half2 b, half2 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static half csum([This] half2 a)
    {
        return (half)(a.x + a.y);
    }

    [MethodImpl(256 | 512)]
    public static half cmin([This] half2 a)
    {
        return a.x.min(a.y);
    }

    [MethodImpl(256 | 512)]
    public static half cmax([This] half2 a)
    {
        return a.x.max(a.y);
    }

    [MethodImpl(256 | 512)]
    public static half cminsafe([This] half2 a)
    {
        return a.x.min(a.y);
    }

    [MethodImpl(256 | 512)]
    public static half cmaxsafe([This] half2 a)
    {
        return a.x.max(a.y);
    }
}

#endregion // half2

#region half3

public partial struct half3
{
    [MethodImpl(256 | 512)]
    public static half3 operator +(half3 a) => a;
    [MethodImpl(256 | 512)]
    public static half3 operator -(half3 a)
    {
        return new((half)(-a.x), (half)(-a.y), (half)(-a.z));
    }

    [MethodImpl(256 | 512)]
    public static half3 operator +(half3 a, half3 b)
    {
        return new((half)(a.x + b.x), (half)(a.y + b.y), (half)(a.z + b.z));
    }

    [MethodImpl(256 | 512)]
    public static half3 operator +(half3 a, half b) => a + new half3(b);

    [MethodImpl(256 | 512)]
    public static half3 operator +(half a, half3 b) => new half3(a) + b;

    [MethodImpl(256 | 512)]
    public static half3 operator -(half3 a, half3 b)
    {
        return new((half)(a.x - b.x), (half)(a.y - b.y), (half)(a.z - b.z));
    }

    [MethodImpl(256 | 512)]
    public static half3 operator -(half3 a, half b) => a - new half3(b);

    [MethodImpl(256 | 512)]
    public static half3 operator -(half a, half3 b) => new half3(a) - b;

    [MethodImpl(256 | 512)]
    public static half3 operator *(half3 a, half3 b)
    {
        return new((half)(a.x * b.x), (half)(a.y * b.y), (half)(a.z * b.z));
    }

    [MethodImpl(256 | 512)]
    public static half3 operator *(half a, half3 b)
    {
        return new((half)(a * b.x), (half)(a * b.y), (half)(a * b.z));
    }

    [MethodImpl(256 | 512)]
    public static half3 operator *(half3 a, half b)
    {
        return new((half)(a.x * b), (half)(a.y * b), (half)(a.z * b));
    }

    [MethodImpl(256 | 512)]
    public static half3 operator /(half3 a, half3 b)
    {
        return new((half)(a.x / b.x), (half)(a.y / b.y), (half)(a.z / b.z));
    }

    [MethodImpl(256 | 512)]
    public static half3 operator /(half3 a, half b)
    {
        return new((half)(a.x / b), (half)(a.y / b), (half)(a.z / b));
    }

    [MethodImpl(256 | 512)]
    public static half3 operator /(half a, half3 b) => new half3(a) / b;

    [MethodImpl(256 | 512)]
    public static half3 operator %(half3 a, half3 b)
    {
        return new((half)(a.x % b.x), (half)(a.y % b.y), (half)(a.z % b.z));
    }

    [MethodImpl(256 | 512)]
    public static half3 operator %(half3 a, half b)
    {
        return new((half)(a.x % b), (half)(a.y % b), (half)(a.z % b));
    }

    [MethodImpl(256 | 512)]
    public static half3 operator %(half a, half3 b) => new half3(a) % b;

    [MethodImpl(256 | 512)]
    public static half3 operator --(half3 a) => a - One;

    [MethodImpl(256 | 512)]
    public static half3 operator ++(half3 a) => a + One;
}

[Ex]
public static partial class math
{
    [MethodImpl(256 | 512)]
    public static half3 abs([This] half3 a)
    {
        return new(a.x.abs(), a.y.abs(), a.z.abs());
    }

    [MethodImpl(256 | 512)]
    public static half3 sign([This] half3 a)
    {
        return new(a.x.sign(), a.y.sign(), a.z.sign());
    }

    [MethodImpl(256 | 512)]
    public static half3 min([This] half3 a, half3 b)
    {
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z));
    }

    [MethodImpl(256 | 512)]
    public static half3 max([This] half3 a, half3 b)
    {
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z));
    }

    [MethodImpl(256 | 512)]
    public static half3 clamp([This] half3 v, half3 min, half3 max)
    {
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z));
    }

    [MethodImpl(256 | 512)]
    public static half3 clamp([This] half3 v, half min, half max) => v.clamp(new half3(min), new half3(max));

    [MethodImpl(256 | 512)]
    public static half3 lerp(half3 start, half3 end, [This] half3 t)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static half3 lerp(half3 start, half3 end, [This] half t)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static half3 lerp(half start, half end, [This] half3 t)
    {
        return start + t * (half)(end - start);
    }

    [MethodImpl(256 | 512)]
    public static half3 unlerp([This] half3 a, half3 start, half3 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static half3 unlerp([This] half a, half3 start, half3 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static half3 unlerp([This] half3 a, half start, half end) => (a - start) / (half)(end - start);

    [MethodImpl(256 | 512)]
    public static half3 remap([This] half3 a, half3 srcStart, half3 srcEnd, half3 dstStart, half3 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static half3 remap([This] half3 a, half srcStart, half srcEnd, half dstStart, half dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static half dot([This] half3 a, half3 b)
    {
        return (half)(a.x * b.x + a.y * b.y + a.z * b.z);
    }

    [MethodImpl(256 | 512)]
    public static half3 cross([This] half3 a, half3 b)
    {
        // (a * b.yzx - a.yzx * b).yzx;
        return fnma(a.yzx, b, a * b.yzx).yzx;
    }

    [MethodImpl(256 | 512)]
    public static half lengthsq([This] half3 a)
    {
        return (half)(a.x * a.x + a.y * a.y + a.z * a.z);
    }

    [MethodImpl(256 | 512)]
    public static half distancesq([This] half3 a, half3 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static half3 square([This] half3 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static half3 fma([This] half3 a, half3 b, half3 c)
    {
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y), a.z.fma(b.z, c.z));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static half3 fms([This] half3 a, half3 b, half3 c)
    {
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y), a.z.fms(b.z, c.z));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static half3 fnma([This] half3 a, half3 b, half3 c)
    {
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y), a.z.fnma(b.z, c.z));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static half3 fsm([This] half3 c, half3 a, half3 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static half3 fam([This] half3 c, half3 a, half3 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static half3 mad([This] half3 a, half3 b, half3 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static half csum([This] half3 a)
    {
        return (half)(a.x + a.y + a.z);
    }

    [MethodImpl(256 | 512)]
    public static half cmin([This] half3 a)
    {
        return a.x.min(a.y).min(a.z);
    }

    [MethodImpl(256 | 512)]
    public static half cmax([This] half3 a)
    {
        return a.x.max(a.y).max(a.z);
    }

    [MethodImpl(256 | 512)]
    public static half cminsafe([This] half3 a)
    {
        return a.x.min(a.y).min(a.z);
    }

    [MethodImpl(256 | 512)]
    public static half cmaxsafe([This] half3 a)
    {
        return a.x.max(a.y).max(a.z);
    }
}

#endregion // half3

#region half4

public partial struct half4
{
    [MethodImpl(256 | 512)]
    public static half4 operator +(half4 a) => a;
    [MethodImpl(256 | 512)]
    public static half4 operator -(half4 a)
    {
        return new((half)(-a.x), (half)(-a.y), (half)(-a.z), (half)(-a.w));
    }

    [MethodImpl(256 | 512)]
    public static half4 operator +(half4 a, half4 b)
    {
        return new((half)(a.x + b.x), (half)(a.y + b.y), (half)(a.z + b.z), (half)(a.w + b.w));
    }

    [MethodImpl(256 | 512)]
    public static half4 operator +(half4 a, half b) => a + new half4(b);

    [MethodImpl(256 | 512)]
    public static half4 operator +(half a, half4 b) => new half4(a) + b;

    [MethodImpl(256 | 512)]
    public static half4 operator -(half4 a, half4 b)
    {
        return new((half)(a.x - b.x), (half)(a.y - b.y), (half)(a.z - b.z), (half)(a.w - b.w));
    }

    [MethodImpl(256 | 512)]
    public static half4 operator -(half4 a, half b) => a - new half4(b);

    [MethodImpl(256 | 512)]
    public static half4 operator -(half a, half4 b) => new half4(a) - b;

    [MethodImpl(256 | 512)]
    public static half4 operator *(half4 a, half4 b)
    {
        return new((half)(a.x * b.x), (half)(a.y * b.y), (half)(a.z * b.z), (half)(a.w * b.w));
    }

    [MethodImpl(256 | 512)]
    public static half4 operator *(half a, half4 b)
    {
        return new((half)(a * b.x), (half)(a * b.y), (half)(a * b.z), (half)(a * b.w));
    }

    [MethodImpl(256 | 512)]
    public static half4 operator *(half4 a, half b)
    {
        return new((half)(a.x * b), (half)(a.y * b), (half)(a.z * b), (half)(a.w * b));
    }

    [MethodImpl(256 | 512)]
    public static half4 operator /(half4 a, half4 b)
    {
        return new((half)(a.x / b.x), (half)(a.y / b.y), (half)(a.z / b.z), (half)(a.w / b.w));
    }

    [MethodImpl(256 | 512)]
    public static half4 operator /(half4 a, half b)
    {
        return new((half)(a.x / b), (half)(a.y / b), (half)(a.z / b), (half)(a.w / b));
    }

    [MethodImpl(256 | 512)]
    public static half4 operator /(half a, half4 b) => new half4(a) / b;

    [MethodImpl(256 | 512)]
    public static half4 operator %(half4 a, half4 b)
    {
        return new((half)(a.x % b.x), (half)(a.y % b.y), (half)(a.z % b.z), (half)(a.w % b.w));
    }

    [MethodImpl(256 | 512)]
    public static half4 operator %(half4 a, half b)
    {
        return new((half)(a.x % b), (half)(a.y % b), (half)(a.z % b), (half)(a.w % b));
    }

    [MethodImpl(256 | 512)]
    public static half4 operator %(half a, half4 b) => new half4(a) % b;

    [MethodImpl(256 | 512)]
    public static half4 operator --(half4 a) => a - One;

    [MethodImpl(256 | 512)]
    public static half4 operator ++(half4 a) => a + One;
}

[Ex]
public static partial class math
{
    [MethodImpl(256 | 512)]
    public static half4 abs([This] half4 a)
    {
        return new(a.x.abs(), a.y.abs(), a.z.abs(), a.w.abs());
    }

    [MethodImpl(256 | 512)]
    public static half4 sign([This] half4 a)
    {
        return new(a.x.sign(), a.y.sign(), a.z.sign(), a.w.sign());
    }

    [MethodImpl(256 | 512)]
    public static half4 min([This] half4 a, half4 b)
    {
        return new(a.x.min(b.x), a.y.min(b.y), a.z.min(b.z), a.w.min(b.w));
    }

    [MethodImpl(256 | 512)]
    public static half4 max([This] half4 a, half4 b)
    {
        return new(a.x.max(b.x), a.y.max(b.y), a.z.max(b.z), a.w.max(b.w));
    }

    [MethodImpl(256 | 512)]
    public static half4 clamp([This] half4 v, half4 min, half4 max)
    {
        return new(v.x.clamp(min.x, max.x), v.y.clamp(min.y, max.y), v.z.clamp(min.z, max.z), v.w.clamp(min.w, max.w));
    }

    [MethodImpl(256 | 512)]
    public static half4 clamp([This] half4 v, half min, half max) => v.clamp(new half4(min), new half4(max));

    [MethodImpl(256 | 512)]
    public static half4 lerp(half4 start, half4 end, [This] half4 t)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static half4 lerp(half4 start, half4 end, [This] half t)
    {
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static half4 lerp(half start, half end, [This] half4 t)
    {
        return start + t * (half)(end - start);
    }

    [MethodImpl(256 | 512)]
    public static half4 unlerp([This] half4 a, half4 start, half4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static half4 unlerp([This] half a, half4 start, half4 end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static half4 unlerp([This] half4 a, half start, half end) => (a - start) / (half)(end - start);

    [MethodImpl(256 | 512)]
    public static half4 remap([This] half4 a, half4 srcStart, half4 srcEnd, half4 dstStart, half4 dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static half4 remap([This] half4 a, half srcStart, half srcEnd, half dstStart, half dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static half dot([This] half4 a, half4 b)
    {
        return (half)(a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w);
    }

    [MethodImpl(256 | 512)]
    public static half lengthsq([This] half4 a)
    {
        return (half)(a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w);
    }

    [MethodImpl(256 | 512)]
    public static half distancesq([This] half4 a, half4 b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static half4 square([This] half4 a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static half4 fma([This] half4 a, half4 b, half4 c)
    {
        return new(a.x.fma(b.x, c.x), a.y.fma(b.y, c.y), a.z.fma(b.z, c.z), a.w.fma(b.w, c.w));
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static half4 fms([This] half4 a, half4 b, half4 c)
    {
        return new(a.x.fms(b.x, c.x), a.y.fms(b.y, c.y), a.z.fms(b.z, c.z), a.w.fms(b.w, c.w));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static half4 fnma([This] half4 a, half4 b, half4 c)
    {
        return new(a.x.fnma(b.x, c.x), a.y.fnma(b.y, c.y), a.z.fnma(b.z, c.z), a.w.fnma(b.w, c.w));
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static half4 fsm([This] half4 c, half4 a, half4 b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static half4 fam([This] half4 c, half4 a, half4 b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static half4 mad([This] half4 a, half4 b, half4 c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static half csum([This] half4 a)
    {
        return (half)(a.x + a.y + a.z + a.w);
    }

    [MethodImpl(256 | 512)]
    public static half cmin([This] half4 a)
    {
        return a.x.min(a.y).min(a.z).min(a.w);
    }

    [MethodImpl(256 | 512)]
    public static half cmax([This] half4 a)
    {
        return a.x.max(a.y).max(a.z).max(a.w);
    }

    [MethodImpl(256 | 512)]
    public static half cminsafe([This] half4 a)
    {
        return a.x.min(a.y).min(a.z).min(a.w);
    }

    [MethodImpl(256 | 512)]
    public static half cmaxsafe([This] half4 a)
    {
        return a.x.max(a.y).max(a.z).max(a.w);
    }
}

#endregion // half4
