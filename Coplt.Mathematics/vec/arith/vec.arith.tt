<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="../../types.ttinclude" #><#@ import namespace="System.Linq" #>// generated by template, do not modify manually

namespace Coplt.Mathematics;
<#
    foreach (var typ in Typ.Typs)
    {
        if (!typ.arith) continue;

        for (var i = 2; i <= 4; i++)
        {
            var typeName = $"{typ.name}{i}";

            var byteSize = typ.size * (i is 3 ? 4 : i);
            var bitSize = 8 * byteSize;
#>

#region <#= typeName #>

public partial struct <#= typeName #>
{
    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator +(<#= typeName #> a) => a;
<#
            if (typ.sig)
            {
#>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator -(<#= typeName #> a)
    {
<#
                if (typ.simd)
                {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
            return new(-a.vector<#
                    if (i == 3)
                    {
#> & Vector<#= bitSize #>.Create(-1, -1, -1, 0).As<#= typ.Type #>()<#
                    }
#>);
<#
                }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"{typ.arithCast}(-a.{Typ.xyzw[n]})")) #>);
    }
<#
            }
#>

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator +(<#= typeName #> a, <#= typeName #> b)
    {
<#
            if (typ.simd)
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
            return new(a.vector + b.vector);
<#
            }
#>
        return new(<#=
                string.Join(", ", Enumerable.Range(0, i).Select(n => $"({typ.compType})(a.{Typ.xyzw[n]} + b.{Typ.xyzw[n]})")) #>);
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator +(<#= typeName #> a, <#= typ.compType #> b) => a + new <#= typeName #>(b);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator +(<#= typ.compType #> a, <#= typeName #> b) => new <#= typeName #>(a) + b;

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator -(<#= typeName #> a, <#= typeName #> b)
    {
<#
            if (typ.simd)
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
            return new(a.vector - b.vector);
<#
            }
#>
        return new(<#=
                string.Join(", ", Enumerable.Range(0, i).Select(n => $"({typ.compType})(a.{Typ.xyzw[n]} - b.{Typ.xyzw[n]})")) #>);
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator -(<#= typeName #> a, <#= typ.compType #> b) => a - new <#= typeName #>(b);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator -(<#= typ.compType #> a, <#= typeName #> b) => new <#= typeName #>(a) - b;

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator *(<#= typeName #> a, <#= typeName #> b)
    {
<#
            if (typ.simd)
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
            return new(a.vector * b.vector);
<#
            }
#>
        return new(<#=
                string.Join(", ", Enumerable.Range(0, i).Select(n => $"({typ.compType})(a.{Typ.xyzw[n]} * b.{Typ.xyzw[n]})")) #>);
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator *(<#= typ.compType #> a, <#= typeName #> b)
    {
<#
            if (typ.simd)
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
            return new(a * b.vector);
<#
            }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"({typ.compType})(a * b.{Typ.xyzw[n]})")) #>);
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator *(<#= typeName #> a, <#= typ.compType #> b)
    {
<#
            if (typ.simd)
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
            return new(a.vector * b);
<#
            }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"({typ.compType})(a.{Typ.xyzw[n]} * b)")) #>);
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator /(<#= typeName #> a, <#= typeName #> b)
    {
<#
            if (typ.simd)
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
            return new((a.vector / b.vector)<#
                if (i == 3 && typ.f)
                {
#> & Vector<#= bitSize #>.Create(-1, -1, -1, 0).As<#= typ.Type #>()<#
                }
#>);
<#
            }
#>
        return new(<#=
                string.Join(", ", Enumerable.Range(0, i).Select(n => $"({typ.compType})(a.{Typ.xyzw[n]} / b.{Typ.xyzw[n]})")) #>);
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator /(<#= typeName #> a, <#= typ.compType #> b)
    {
<#
            if (typ.simd)
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
            return new((a.vector / b)<#
                if (i == 3 && typ.f)
                {
#> & Vector<#= bitSize #>.Create(-1, -1, -1, 0).As<#= typ.Type #>()<#
                }
#>);
<#
            }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"({typ.compType})(a.{Typ.xyzw[n]} / b)")) #>);
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator /(<#= typ.compType #> a, <#= typeName #> b) => new <#= typeName #>(a) / b;

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator %(<#= typeName #> a, <#= typeName #> b)
    {
<#
            if (typ.simd && typ.f)
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
            return new(simd.Rem(a.vector, b.vector)<#
                if (i == 3 && typ.f)
                {
#> & Vector<#= bitSize #>.Create(-1, -1, -1, 0).As<#= typ.Type #>()<#
                }
#>);
<#
            }
#>
        return new(<#=
                string.Join(", ", Enumerable.Range(0, i).Select(n => $"({typ.compType})(a.{Typ.xyzw[n]} % b.{Typ.xyzw[n]})")) #>);
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator %(<#= typeName #> a, <#= typ.compType #> b)
    {
<#
            if (typ.simd && typ.f)
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
            return new(simd.Rem(a.vector, b)<#
                if (i == 3 && typ.f)
                {
#> & Vector<#= bitSize #>.Create(-1, -1, -1, 0).As<#= typ.Type #>()<#
                }
#>);
<#
            }
#>
        return new(<#=
                string.Join(", ", Enumerable.Range(0, i).Select(n => $"({typ.compType})(a.{Typ.xyzw[n]} % b)")) #>);
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator %(<#= typ.compType #> a, <#= typeName #> b) => new <#= typeName #>(a) % b;

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator --(<#= typeName #> a) => a - One;

    [MethodImpl(256 | 512)]
    public static <#= typeName #> operator ++(<#= typeName #> a) => a + One;
}

[Ex]
public static partial class math
{
    [MethodImpl(256 | 512)]
    public static <#= typeName #> abs([This] <#= typeName #> a)
    {
<#
            if (typ.simd)
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
            return new(Vector<#= bitSize #>.Abs(a.vector));
<#
            }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.abs()")) #>);
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> sign([This] <#= typeName #> a)
    {
<#
            if (typ.simd && (typ.f || typ.i))
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
            return new(<#
                if (typ.f)
                {
#>simd.SignFloat(a.vector)<#
                }
                else if (typ.sig)
                {
#>simd.SignInt(a.vector)<#
                }
                else
                {
#>simd.SignUInt(a.vector)<#
                }
#><#
                if (i == 3)
                {
#> & Vector<#= bitSize #>.Create(-1, -1, -1, 0).As<#= typ.Type #>()<#
                }
#>);
<#
            }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.sign()")) #>);
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> min([This] <#= typeName #> a, <#= typeName #> b)
    {
<#
            if (typ.simd)
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
            return new(Vector<#= bitSize #>.Min(a.vector, b.vector));
<#
            }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.min(b.{Typ.xyzw[n]})")) #>);
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> max([This] <#= typeName #> a, <#= typeName #> b)
    {
<#
            if (typ.simd)
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
            return new(Vector<#= bitSize #>.Max(a.vector, b.vector));
<#
            }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.max(b.{Typ.xyzw[n]})")) #>);
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> clamp([This] <#= typeName #> v, <#= typeName #> min, <#= typeName #> max)
    {
<#
            if (typ.simd)
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
            return new(Vector<#= bitSize #>.Max(min.vector, Vector<#= bitSize #>.Min(max.vector, v.vector)));
<#
            }
#>
        return new(<#=
                string.Join(", ", Enumerable.Range(0, i).Select(n => $"v.{Typ.xyzw[n]}.clamp(min.{Typ.xyzw[n]}, max.{Typ.xyzw[n]})")) #>);
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> clamp([This] <#= typeName #> v, <#= typ.simdComp #> min, <#= typ.simdComp #> max) => v.clamp(new <#= typeName #>(min), new <#= typeName #>(max));

    [MethodImpl(256 | 512)]
    public static <#= typeName #> lerp(<#= typeName #> start, <#= typeName #> end, [This] <#= typeName #> t)
    {
<#
            if (typ.simd)
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
            return fma(t, end - start, start);
<#
            }
#>
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> lerp(<#= typeName #> start, <#= typeName #> end, [This] <#= typ.simdComp #> t)
    {
<#
            if (typ.simd)
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
            return fma(new(t), end - start, start);
<#
            }
#>
        return start + t * (end - start);
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> lerp(<#= typ.simdComp #> start, <#= typ.simdComp #> end, [This] <#= typeName #> t)
    {
<#
            if (typ.simd)
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
            return fma(t, <#= typ.arithCast #>(end - start), new(start));
<#
            }
#>
        return start + t * <#= typ.arithCast #>(end - start);
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> unlerp([This] <#= typeName #> a, <#= typeName #> start, <#= typeName #> end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> unlerp([This] <#= typ.simdComp #> a, <#= typeName #> start, <#= typeName #> end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> unlerp([This] <#= typeName #> a, <#= typ.simdComp #> start, <#= typ.simdComp #> end) => (a - start) / <#= typ.arithCast #>(end - start);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> remap([This] <#= typeName #> a, <#= typeName #> srcStart, <#= typeName #> srcEnd, <#= typeName #> dstStart, <#= typeName #> dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> remap([This] <#= typeName #> a, <#= typ.simdComp #> srcStart, <#= typ.simdComp #> srcEnd, <#= typ.simdComp #> dstStart, <#= typ.simdComp #> dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static <#= typ.simdComp #> dot([This] <#= typeName #> a, <#= typeName #> b)
    {
<#
            if (typ.simd)
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
            return Vector<#= bitSize #>.Dot(a.vector, b.vector);
<#
            }
#>
        return (<#= typ.simdComp #>)(<#= string.Join(" + ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]} * b.{Typ.xyzw[n]}")) #>);
    }
<#
            if (i == 3)
            {
#>

    [MethodImpl(256 | 512)]
    public static <#= typeName #> cross([This] <#= typeName #> a, <#= typeName #> b) => (a * b.yzx - a.yzx * b).yzx;
<#
            }
#>

    [MethodImpl(256 | 512)]
    public static <#= typ.simdComp #> lengthsq([This] <#= typeName #> a)
    {
<#
            if (typ.simd)
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
            return Vector<#= bitSize #>.Dot(a.vector, a.vector);
<#
            }
#>
        return (<#= typ.simdComp #>)(<#= string.Join(" + ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]} * a.{Typ.xyzw[n]}")) #>);
    }

    [MethodImpl(256 | 512)]
    public static <#= typ.simdComp #> distancesq([This] <#= typeName #> a, <#= typeName #> b) => lengthsq(b - a);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> square([This] <#= typeName #> a) => a * a;

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> fma([This] <#= typeName #> a, <#= typeName #> b, <#= typeName #> c)
    {
<#
            if (typ.simd && typ.f && typ.bin)
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
            return new(simd.Fma(a.vector, b.vector, c.vector));
<#
            }
#>
        return new(<#=
                string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.fma(b.{Typ.xyzw[n]}, c.{Typ.xyzw[n]})")) #>);
    }

    /// <summary>
    /// Fusion Subtraction and Multiplication
    /// <code>(a * b) - c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Subtrahend c</param>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> fms([This] <#= typeName #> a, <#= typeName #> b, <#= typeName #> c)
    {
<#
            if (typ.simd && typ.f && typ.bin)
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
            return new(simd.Fms(a.vector, b.vector, c.vector));
<#
            }
#>
        return new(<#=
                string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.fms(b.{Typ.xyzw[n]}, c.{Typ.xyzw[n]})")) #>);
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code> or <code>-(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> fnma([This] <#= typeName #> a, <#= typeName #> b, <#= typeName #> c)
    {
<#
            if (typ.simd && typ.f && typ.bin)
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
            return new(simd.Fnma(a.vector, b.vector, c.vector));
<#
            }
#>
        return new(<#=
                string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.fnma(b.{Typ.xyzw[n]}, c.{Typ.xyzw[n]})")) #>);
    }

    /// <summary>
    /// Fusion Multiplication and Subtraction
    /// <code>c - (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Minuend c</param>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> fsm([This] <#= typeName #> c, <#= typeName #> a, <#= typeName #> b) => fnma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>c + (a * b)</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> fam([This] <#= typeName #> c, <#= typeName #> a, <#= typeName #> b) => fma(a, b, c);

    /// <summary>
    /// Fusion Addition and Multiplication
    /// <code>(a * b) + c</code>
    /// </summary>
    /// <param name="a">Multiplier a</param>
    /// <param name="b">Multiplier b</param>
    /// <param name="c">Addend c</param>
    [MethodImpl(256 | 512)]
    public static <#= typeName #> mad([This] <#= typeName #> a, <#= typeName #> b, <#= typeName #> c) => fma(a, b, c);

    [MethodImpl(256 | 512)]
    public static <#= typ.compType #> csum([This] <#= typeName #> a)
    {
<#
            if (typ.simd)
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
            return Vector<#= bitSize #>.Sum(a.vector);
<#
            }
#>
        return <#= typ.arithCast #>(<#= string.Join(" + ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}")) #>);
    }

    [MethodImpl(256 | 512)]
    public static <#= typ.compType #> cmin([This] <#= typeName #> a)
    {
        return a.x<#= string.Join("", Enumerable.Range(1, i - 1).Select(n => $".min(a.{Typ.xyzw[n]})")) #>;
    }

    [MethodImpl(256 | 512)]
    public static <#= typ.compType #> cmax([This] <#= typeName #> a)
    {
        return a.x<#= string.Join("", Enumerable.Range(1, i - 1).Select(n => $".max(a.{Typ.xyzw[n]})")) #>;
    }
}

#endregion // <#= typeName #>
<#
        }
    }
#>
