// generated by template, do not modify manually

namespace Coplt.Mathematics;

#region float2

[Ex]
public static partial class math
{
    #pragma warning disable CS1718
    // ReSharper disable once EqualExpressionComparison
    [MethodImpl(256 | 512)]
    public static b32v2 isNaN([This] float2 a) => a != a;
    #pragma warning restore CS1718

    [MethodImpl(256 | 512)]
    public static b32v2 isFinite([This] float2 a) => abs(a) < float.PositiveInfinity;

    [MethodImpl(256 | 512)]
    public static b32v2 isInf([This] float2 a)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(simd.IsInfinity(a.vector).AsUInt32());
        return new(a.x.isInf(), a.y.isInf());
    }

    [MethodImpl(256 | 512)]
    public static b32v2 isPosInf([This] float2 a)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(Vector64.Equals(a.vector, Vector64.Create(float.PositiveInfinity)).AsUInt32());
        return new(a.x.isPosInf(), a.y.isPosInf());
    }

    [MethodImpl(256 | 512)]
    public static b32v2 isNegInf([This] float2 a)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(Vector64.Equals(a.vector, Vector64.Create(float.NegativeInfinity)).AsUInt32());
        return new(a.x.isNegInf(), a.y.isNegInf());
    }

    [MethodImpl(256 | 512)]
    public static float2 log([This] float2 a)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(simd.Log(a.vector));
        return new(a.x.log(), a.y.log());
    }

    [MethodImpl(256 | 512)]
    public static float2 log2([This] float2 a)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(simd.Log2(a.vector));
        return new(a.x.log2(), a.y.log2());
    }

    [MethodImpl(256 | 512)]
    public static float2 log([This] float2 a, float2 b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(simd.Log(a.vector) / simd.Log(b.vector));
        return new(a.x.log(b.x), a.y.log(b.y));
    }

    [MethodImpl(256 | 512)]
    public static float2 log10([This] float2 a)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(simd.Log10(a.vector));
        return new(a.x.log10(), a.y.log10());
    }

    [MethodImpl(256 | 512)]
    public static float2 exp([This] float2 a)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(simd.Exp(a.vector));
        return new(a.x.exp(), a.y.exp());
    }

    [MethodImpl(256 | 512)]
    public static float2 exp2([This] float2 a)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(simd.Exp2(a.vector));
        return new(a.x.exp2(), a.y.exp2());
    }

    [MethodImpl(256 | 512)]
    public static float2 exp10([This] float2 a)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(simd.Exp10(a.vector));
        return new(a.x.exp10(), a.y.exp10());
    }

    [MethodImpl(256 | 512)]
    public static float2 pow([This] float2 a, float2 b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(simd.Pow(a.vector, b.vector));
        return new(a.x.pow(b.x), a.y.pow(b.y));
    }

    [MethodImpl(256 | 512)]
    public static float2 pow([This] float2 a, float b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(simd.Pow(a.vector, b));
        return new(a.x.pow(b), a.y.pow(b));
    }

    [MethodImpl(256 | 512)]
    public static float2 sqrt([This] float2 a)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(Vector64.Sqrt(a.vector));
        return new(a.x.sqrt(), a.y.sqrt());
    }

    [MethodImpl(256 | 512)]
    public static float2 rsqrt([This] float2 a) => float2.One / sqrt(a);

    [MethodImpl(256 | 512)]
    public static float length([This] float2 a) => dot(a, a).sqrt();

    [MethodImpl(256 | 512)]
    public static float distance([This] float2 a, float2 b) => length(b - a);

    [MethodImpl(256 | 512)]
    public static float2 normalize([This] float2 a) => a * dot(a, a).rsqrt();

    [MethodImpl(256 | 512)]
    public static float2 normalizeSafe([This] float2 a, float2 defaultValue = default)
    {
        var len = dot(a, a);
        return select(len > 1.175494351e-38f, a * rsqrt(len), defaultValue);
    }

    [MethodImpl(256 | 512)]
    public static float2 step(float2 threshold, [This] float2 a) =>
        select(a >= threshold, float2.One, default);

    [MethodImpl(256 | 512)]
    public static float2 refract(float2 i, float2 n, [This] float indexOfRefraction)
    {
        var ni = dot(n, i);
        var k = (float)(1.0f - indexOfRefraction * indexOfRefraction * (1.0f - ni * ni));
        return select(k >= 0.0f, indexOfRefraction * i - (float)((float)(indexOfRefraction * ni) + sqrt(k)) * n, default);
    }

    [MethodImpl(256 | 512)]
    public static float2 projectSafe([This] float2 a, float2 onto, float2 defaultValue = default) 
    {
        var proj = project(a, onto);
        return select(all(isFinite(proj)), proj, defaultValue);
    }

    [MethodImpl(256 | 512)]
    public static float2 faceForward([This] float2 n, float2 i, float2 ng) =>
        select(dot(ng, i) >= 0.0f, -n, n);

    [MethodImpl(256 | 512)]
    public static float2 sin([This] float2 a)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(simd.Sin(a.vector));
        return new(a.x.sin(), a.y.sin());
    }

    [MethodImpl(256 | 512)]
    public static float2 cos([This] float2 a)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(simd.Cos(a.vector));
        return new(a.x.cos(), a.y.cos());
    }

    [MethodImpl(256 | 512)]
    public static (float2 sin, float2 cos) sincos([This] float2 a)
    {
        if (Vector64.IsHardwareAccelerated)
        {
            var (sin, cos) = simd.SinCos(a.vector);
            return (new(sin), new(cos));
        }
        a.x.sincos(out var sin0, out var cos0);
        a.y.sincos(out var sin1, out var cos1);
        return (
            new(sin0, sin1),
            new(cos0, cos1)
        );
    }

    [MethodImpl(256 | 512)]
    public static void sincos([This] float2 a, out float2 sin, out float2 cos)
    {
        if (Vector64.IsHardwareAccelerated)
        {
            (sin.vector, cos.vector) = simd.SinCos(a.vector);
            return;
        }
        a.x.sincos(out var sin0, out var cos0);
        a.y.sincos(out var sin1, out var cos1);
        sin = new(sin0, sin1);
        cos = new(cos0, cos1);
    }

    [MethodImpl(256 | 512)]
    public static float2 tan([This] float2 a)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(simd.Tan(a.vector));
        return new(a.x.tan(), a.y.tan());
    }

    [MethodImpl(256 | 512)]
    public static float2 asin([This] float2 a)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(simd.Asin(a.vector));
        return new(a.x.asin(), a.y.asin());
    }

    [MethodImpl(256 | 512)]
    public static float2 acos([This] float2 a)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(simd.Acos(a.vector));
        return new(a.x.acos(), a.y.acos());
    }

    [MethodImpl(256 | 512)]
    public static float2 atan([This] float2 a)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(simd.Atan(a.vector));
        return new(a.x.atan(), a.y.atan());
    }

    [MethodImpl(256 | 512)]
    public static float2 atan2([This] float2 a, float2 b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(simd.Atan2(a.vector, b.vector));
        return new(a.x.atan2(b.x), a.y.atan2(b.y));
    }

    [MethodImpl(256 | 512)]
    public static float2 sinh([This] float2 a)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(simd.Sinh(a.vector));
        return new(a.x.sinh(), a.y.sinh());
    }

    [MethodImpl(256 | 512)]
    public static float2 cosh([This] float2 a)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(simd.Cosh(a.vector));
        return new(a.x.cosh(), a.y.cosh());
    }

    [MethodImpl(256 | 512)]
    public static float2 tanh([This] float2 a)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(simd.Tanh(a.vector));
        return new(a.x.tanh(), a.y.tanh());
    }

    [MethodImpl(256 | 512)]
    public static float2 asinh([This] float2 a)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(simd.Asinh(a.vector));
        return new(a.x.asinh(), a.y.asinh());
    }

    [MethodImpl(256 | 512)]
    public static float2 acosh([This] float2 a)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(simd.Acosh(a.vector));
        return new(a.x.acosh(), a.y.acosh());
    }

    [MethodImpl(256 | 512)]
    public static float2 atanh([This] float2 a)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(simd.Atanh(a.vector));
        return new(a.x.atanh(), a.y.atanh());
    }

    [MethodImpl(256 | 512)]
    public static float2 chgsign([This] float2 a, float2 b)
    {
        var sig = new uint2(0x8000_0000).asf();
        return (b & sig) ^ a;
    }
}

#endregion // float2

#region float3

[Ex]
public static partial class math
{
    #pragma warning disable CS1718
    // ReSharper disable once EqualExpressionComparison
    [MethodImpl(256 | 512)]
    public static b32v3 isNaN([This] float3 a) => a != a;
    #pragma warning restore CS1718

    [MethodImpl(256 | 512)]
    public static b32v3 isFinite([This] float3 a) => abs(a) < float.PositiveInfinity;

    [MethodImpl(256 | 512)]
    public static b32v3 isInf([This] float3 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.IsInfinity(a.vector).AsUInt32());
        return new(a.x.isInf(), a.y.isInf(), a.z.isInf());
    }

    [MethodImpl(256 | 512)]
    public static b32v3 isPosInf([This] float3 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.Equals(a.vector, Vector128.Create(float.PositiveInfinity)).AsUInt32());
        return new(a.x.isPosInf(), a.y.isPosInf(), a.z.isPosInf());
    }

    [MethodImpl(256 | 512)]
    public static b32v3 isNegInf([This] float3 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.Equals(a.vector, Vector128.Create(float.NegativeInfinity)).AsUInt32());
        return new(a.x.isNegInf(), a.y.isNegInf(), a.z.isNegInf());
    }

    [MethodImpl(256 | 512)]
    public static float3 log([This] float3 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Log(a.vector));
        return new(a.x.log(), a.y.log(), a.z.log());
    }

    [MethodImpl(256 | 512)]
    public static float3 log2([This] float3 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Log2(a.vector));
        return new(a.x.log2(), a.y.log2(), a.z.log2());
    }

    [MethodImpl(256 | 512)]
    public static float3 log([This] float3 a, float3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Log(a.vector) / simd.Log(b.vector));
        return new(a.x.log(b.x), a.y.log(b.y), a.z.log(b.z));
    }

    [MethodImpl(256 | 512)]
    public static float3 log10([This] float3 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Log10(a.vector));
        return new(a.x.log10(), a.y.log10(), a.z.log10());
    }

    [MethodImpl(256 | 512)]
    public static float3 exp([This] float3 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Exp(a.vector));
        return new(a.x.exp(), a.y.exp(), a.z.exp());
    }

    [MethodImpl(256 | 512)]
    public static float3 exp2([This] float3 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Exp2(a.vector));
        return new(a.x.exp2(), a.y.exp2(), a.z.exp2());
    }

    [MethodImpl(256 | 512)]
    public static float3 exp10([This] float3 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Exp10(a.vector));
        return new(a.x.exp10(), a.y.exp10(), a.z.exp10());
    }

    [MethodImpl(256 | 512)]
    public static float3 pow([This] float3 a, float3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Pow(a.vector, b.vector));
        return new(a.x.pow(b.x), a.y.pow(b.y), a.z.pow(b.z));
    }

    [MethodImpl(256 | 512)]
    public static float3 pow([This] float3 a, float b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Pow(a.vector, b));
        return new(a.x.pow(b), a.y.pow(b), a.z.pow(b));
    }

    [MethodImpl(256 | 512)]
    public static float3 sqrt([This] float3 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.Sqrt(a.vector));
        return new(a.x.sqrt(), a.y.sqrt(), a.z.sqrt());
    }

    [MethodImpl(256 | 512)]
    public static float3 rsqrt([This] float3 a) => float3.One / sqrt(a);

    [MethodImpl(256 | 512)]
    public static float length([This] float3 a) => dot(a, a).sqrt();

    [MethodImpl(256 | 512)]
    public static float distance([This] float3 a, float3 b) => length(b - a);

    [MethodImpl(256 | 512)]
    public static float3 normalize([This] float3 a) => a * dot(a, a).rsqrt();

    [MethodImpl(256 | 512)]
    public static float3 normalizeSafe([This] float3 a, float3 defaultValue = default)
    {
        var len = dot(a, a);
        return select(len > 1.175494351e-38f, a * rsqrt(len), defaultValue);
    }

    [MethodImpl(256 | 512)]
    public static float3 step(float3 threshold, [This] float3 a) =>
        select(a >= threshold, float3.One, default);

    [MethodImpl(256 | 512)]
    public static float3 refract(float3 i, float3 n, [This] float indexOfRefraction)
    {
        var ni = dot(n, i);
        var k = (float)(1.0f - indexOfRefraction * indexOfRefraction * (1.0f - ni * ni));
        return select(k >= 0.0f, indexOfRefraction * i - (float)((float)(indexOfRefraction * ni) + sqrt(k)) * n, default);
    }

    [MethodImpl(256 | 512)]
    public static float3 projectSafe([This] float3 a, float3 onto, float3 defaultValue = default) 
    {
        var proj = project(a, onto);
        return select(all(isFinite(proj)), proj, defaultValue);
    }

    [MethodImpl(256 | 512)]
    public static float3 faceForward([This] float3 n, float3 i, float3 ng) =>
        select(dot(ng, i) >= 0.0f, -n, n);

    [MethodImpl(256 | 512)]
    public static float3 sin([This] float3 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Sin(a.vector));
        return new(a.x.sin(), a.y.sin(), a.z.sin());
    }

    [MethodImpl(256 | 512)]
    public static float3 cos([This] float3 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Cos(a.vector));
        return new(a.x.cos(), a.y.cos(), a.z.cos());
    }

    [MethodImpl(256 | 512)]
    public static (float3 sin, float3 cos) sincos([This] float3 a)
    {
        if (Vector128.IsHardwareAccelerated)
        {
            var (sin, cos) = simd.SinCos(a.vector);
            return (new(sin), new(cos));
        }
        a.x.sincos(out var sin0, out var cos0);
        a.y.sincos(out var sin1, out var cos1);
        a.z.sincos(out var sin2, out var cos2);
        return (
            new(sin0, sin1, sin2),
            new(cos0, cos1, cos2)
        );
    }

    [MethodImpl(256 | 512)]
    public static void sincos([This] float3 a, out float3 sin, out float3 cos)
    {
        if (Vector128.IsHardwareAccelerated)
        {
            (sin.vector, cos.vector) = simd.SinCos(a.vector);
            return;
        }
        a.x.sincos(out var sin0, out var cos0);
        a.y.sincos(out var sin1, out var cos1);
        a.z.sincos(out var sin2, out var cos2);
        sin = new(sin0, sin1, sin2);
        cos = new(cos0, cos1, cos2);
    }

    [MethodImpl(256 | 512)]
    public static float3 tan([This] float3 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Tan(a.vector));
        return new(a.x.tan(), a.y.tan(), a.z.tan());
    }

    [MethodImpl(256 | 512)]
    public static float3 asin([This] float3 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Asin(a.vector));
        return new(a.x.asin(), a.y.asin(), a.z.asin());
    }

    [MethodImpl(256 | 512)]
    public static float3 acos([This] float3 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Acos(a.vector));
        return new(a.x.acos(), a.y.acos(), a.z.acos());
    }

    [MethodImpl(256 | 512)]
    public static float3 atan([This] float3 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Atan(a.vector));
        return new(a.x.atan(), a.y.atan(), a.z.atan());
    }

    [MethodImpl(256 | 512)]
    public static float3 atan2([This] float3 a, float3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Atan2(a.vector, b.vector));
        return new(a.x.atan2(b.x), a.y.atan2(b.y), a.z.atan2(b.z));
    }

    [MethodImpl(256 | 512)]
    public static float3 sinh([This] float3 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Sinh(a.vector));
        return new(a.x.sinh(), a.y.sinh(), a.z.sinh());
    }

    [MethodImpl(256 | 512)]
    public static float3 cosh([This] float3 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Cosh(a.vector));
        return new(a.x.cosh(), a.y.cosh(), a.z.cosh());
    }

    [MethodImpl(256 | 512)]
    public static float3 tanh([This] float3 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Tanh(a.vector));
        return new(a.x.tanh(), a.y.tanh(), a.z.tanh());
    }

    [MethodImpl(256 | 512)]
    public static float3 asinh([This] float3 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Asinh(a.vector));
        return new(a.x.asinh(), a.y.asinh(), a.z.asinh());
    }

    [MethodImpl(256 | 512)]
    public static float3 acosh([This] float3 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Acosh(a.vector));
        return new(a.x.acosh(), a.y.acosh(), a.z.acosh());
    }

    [MethodImpl(256 | 512)]
    public static float3 atanh([This] float3 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Atanh(a.vector));
        return new(a.x.atanh(), a.y.atanh(), a.z.atanh());
    }

    [MethodImpl(256 | 512)]
    public static float3 chgsign([This] float3 a, float3 b)
    {
        var sig = new uint3(0x8000_0000).asf();
        return (b & sig) ^ a;
    }
}

#endregion // float3

#region float4

[Ex]
public static partial class math
{
    #pragma warning disable CS1718
    // ReSharper disable once EqualExpressionComparison
    [MethodImpl(256 | 512)]
    public static b32v4 isNaN([This] float4 a) => a != a;
    #pragma warning restore CS1718

    [MethodImpl(256 | 512)]
    public static b32v4 isFinite([This] float4 a) => abs(a) < float.PositiveInfinity;

    [MethodImpl(256 | 512)]
    public static b32v4 isInf([This] float4 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.IsInfinity(a.vector).AsUInt32());
        return new(a.x.isInf(), a.y.isInf(), a.z.isInf(), a.w.isInf());
    }

    [MethodImpl(256 | 512)]
    public static b32v4 isPosInf([This] float4 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.Equals(a.vector, Vector128.Create(float.PositiveInfinity)).AsUInt32());
        return new(a.x.isPosInf(), a.y.isPosInf(), a.z.isPosInf(), a.w.isPosInf());
    }

    [MethodImpl(256 | 512)]
    public static b32v4 isNegInf([This] float4 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.Equals(a.vector, Vector128.Create(float.NegativeInfinity)).AsUInt32());
        return new(a.x.isNegInf(), a.y.isNegInf(), a.z.isNegInf(), a.w.isNegInf());
    }

    [MethodImpl(256 | 512)]
    public static float4 log([This] float4 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Log(a.vector));
        return new(a.x.log(), a.y.log(), a.z.log(), a.w.log());
    }

    [MethodImpl(256 | 512)]
    public static float4 log2([This] float4 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Log2(a.vector));
        return new(a.x.log2(), a.y.log2(), a.z.log2(), a.w.log2());
    }

    [MethodImpl(256 | 512)]
    public static float4 log([This] float4 a, float4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Log(a.vector) / simd.Log(b.vector));
        return new(a.x.log(b.x), a.y.log(b.y), a.z.log(b.z), a.w.log(b.w));
    }

    [MethodImpl(256 | 512)]
    public static float4 log10([This] float4 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Log10(a.vector));
        return new(a.x.log10(), a.y.log10(), a.z.log10(), a.w.log10());
    }

    [MethodImpl(256 | 512)]
    public static float4 exp([This] float4 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Exp(a.vector));
        return new(a.x.exp(), a.y.exp(), a.z.exp(), a.w.exp());
    }

    [MethodImpl(256 | 512)]
    public static float4 exp2([This] float4 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Exp2(a.vector));
        return new(a.x.exp2(), a.y.exp2(), a.z.exp2(), a.w.exp2());
    }

    [MethodImpl(256 | 512)]
    public static float4 exp10([This] float4 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Exp10(a.vector));
        return new(a.x.exp10(), a.y.exp10(), a.z.exp10(), a.w.exp10());
    }

    [MethodImpl(256 | 512)]
    public static float4 pow([This] float4 a, float4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Pow(a.vector, b.vector));
        return new(a.x.pow(b.x), a.y.pow(b.y), a.z.pow(b.z), a.w.pow(b.w));
    }

    [MethodImpl(256 | 512)]
    public static float4 pow([This] float4 a, float b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Pow(a.vector, b));
        return new(a.x.pow(b), a.y.pow(b), a.z.pow(b), a.w.pow(b));
    }

    [MethodImpl(256 | 512)]
    public static float4 sqrt([This] float4 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.Sqrt(a.vector));
        return new(a.x.sqrt(), a.y.sqrt(), a.z.sqrt(), a.w.sqrt());
    }

    [MethodImpl(256 | 512)]
    public static float4 rsqrt([This] float4 a) => float4.One / sqrt(a);

    [MethodImpl(256 | 512)]
    public static float length([This] float4 a) => dot(a, a).sqrt();

    [MethodImpl(256 | 512)]
    public static float distance([This] float4 a, float4 b) => length(b - a);

    [MethodImpl(256 | 512)]
    public static float4 normalize([This] float4 a) => a * dot(a, a).rsqrt();

    [MethodImpl(256 | 512)]
    public static float4 normalizeSafe([This] float4 a, float4 defaultValue = default)
    {
        var len = dot(a, a);
        return select(len > 1.175494351e-38f, a * rsqrt(len), defaultValue);
    }

    [MethodImpl(256 | 512)]
    public static float4 step(float4 threshold, [This] float4 a) =>
        select(a >= threshold, float4.One, default);

    [MethodImpl(256 | 512)]
    public static float4 refract(float4 i, float4 n, [This] float indexOfRefraction)
    {
        var ni = dot(n, i);
        var k = (float)(1.0f - indexOfRefraction * indexOfRefraction * (1.0f - ni * ni));
        return select(k >= 0.0f, indexOfRefraction * i - (float)((float)(indexOfRefraction * ni) + sqrt(k)) * n, default);
    }

    [MethodImpl(256 | 512)]
    public static float4 projectSafe([This] float4 a, float4 onto, float4 defaultValue = default) 
    {
        var proj = project(a, onto);
        return select(all(isFinite(proj)), proj, defaultValue);
    }

    [MethodImpl(256 | 512)]
    public static float4 faceForward([This] float4 n, float4 i, float4 ng) =>
        select(dot(ng, i) >= 0.0f, -n, n);

    [MethodImpl(256 | 512)]
    public static float4 sin([This] float4 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Sin(a.vector));
        return new(a.x.sin(), a.y.sin(), a.z.sin(), a.w.sin());
    }

    [MethodImpl(256 | 512)]
    public static float4 cos([This] float4 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Cos(a.vector));
        return new(a.x.cos(), a.y.cos(), a.z.cos(), a.w.cos());
    }

    [MethodImpl(256 | 512)]
    public static (float4 sin, float4 cos) sincos([This] float4 a)
    {
        if (Vector128.IsHardwareAccelerated)
        {
            var (sin, cos) = simd.SinCos(a.vector);
            return (new(sin), new(cos));
        }
        a.x.sincos(out var sin0, out var cos0);
        a.y.sincos(out var sin1, out var cos1);
        a.z.sincos(out var sin2, out var cos2);
        a.w.sincos(out var sin3, out var cos3);
        return (
            new(sin0, sin1, sin2, sin3),
            new(cos0, cos1, cos2, cos3)
        );
    }

    [MethodImpl(256 | 512)]
    public static void sincos([This] float4 a, out float4 sin, out float4 cos)
    {
        if (Vector128.IsHardwareAccelerated)
        {
            (sin.vector, cos.vector) = simd.SinCos(a.vector);
            return;
        }
        a.x.sincos(out var sin0, out var cos0);
        a.y.sincos(out var sin1, out var cos1);
        a.z.sincos(out var sin2, out var cos2);
        a.w.sincos(out var sin3, out var cos3);
        sin = new(sin0, sin1, sin2, sin3);
        cos = new(cos0, cos1, cos2, cos3);
    }

    [MethodImpl(256 | 512)]
    public static float4 tan([This] float4 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Tan(a.vector));
        return new(a.x.tan(), a.y.tan(), a.z.tan(), a.w.tan());
    }

    [MethodImpl(256 | 512)]
    public static float4 asin([This] float4 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Asin(a.vector));
        return new(a.x.asin(), a.y.asin(), a.z.asin(), a.w.asin());
    }

    [MethodImpl(256 | 512)]
    public static float4 acos([This] float4 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Acos(a.vector));
        return new(a.x.acos(), a.y.acos(), a.z.acos(), a.w.acos());
    }

    [MethodImpl(256 | 512)]
    public static float4 atan([This] float4 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Atan(a.vector));
        return new(a.x.atan(), a.y.atan(), a.z.atan(), a.w.atan());
    }

    [MethodImpl(256 | 512)]
    public static float4 atan2([This] float4 a, float4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Atan2(a.vector, b.vector));
        return new(a.x.atan2(b.x), a.y.atan2(b.y), a.z.atan2(b.z), a.w.atan2(b.w));
    }

    [MethodImpl(256 | 512)]
    public static float4 sinh([This] float4 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Sinh(a.vector));
        return new(a.x.sinh(), a.y.sinh(), a.z.sinh(), a.w.sinh());
    }

    [MethodImpl(256 | 512)]
    public static float4 cosh([This] float4 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Cosh(a.vector));
        return new(a.x.cosh(), a.y.cosh(), a.z.cosh(), a.w.cosh());
    }

    [MethodImpl(256 | 512)]
    public static float4 tanh([This] float4 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Tanh(a.vector));
        return new(a.x.tanh(), a.y.tanh(), a.z.tanh(), a.w.tanh());
    }

    [MethodImpl(256 | 512)]
    public static float4 asinh([This] float4 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Asinh(a.vector));
        return new(a.x.asinh(), a.y.asinh(), a.z.asinh(), a.w.asinh());
    }

    [MethodImpl(256 | 512)]
    public static float4 acosh([This] float4 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Acosh(a.vector));
        return new(a.x.acosh(), a.y.acosh(), a.z.acosh(), a.w.acosh());
    }

    [MethodImpl(256 | 512)]
    public static float4 atanh([This] float4 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Atanh(a.vector));
        return new(a.x.atanh(), a.y.atanh(), a.z.atanh(), a.w.atanh());
    }

    [MethodImpl(256 | 512)]
    public static float4 chgsign([This] float4 a, float4 b)
    {
        var sig = new uint4(0x8000_0000).asf();
        return (b & sig) ^ a;
    }
}

#endregion // float4

#region double2

[Ex]
public static partial class math
{
    #pragma warning disable CS1718
    // ReSharper disable once EqualExpressionComparison
    [MethodImpl(256 | 512)]
    public static b64v2 isNaN([This] double2 a) => a != a;
    #pragma warning restore CS1718

    [MethodImpl(256 | 512)]
    public static b64v2 isFinite([This] double2 a) => abs(a) < double.PositiveInfinity;

    [MethodImpl(256 | 512)]
    public static b64v2 isInf([This] double2 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.IsInfinity(a.vector).AsUInt64());
        return new(a.x.isInf(), a.y.isInf());
    }

    [MethodImpl(256 | 512)]
    public static b64v2 isPosInf([This] double2 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.Equals(a.vector, Vector128.Create(double.PositiveInfinity)).AsUInt64());
        return new(a.x.isPosInf(), a.y.isPosInf());
    }

    [MethodImpl(256 | 512)]
    public static b64v2 isNegInf([This] double2 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.Equals(a.vector, Vector128.Create(double.NegativeInfinity)).AsUInt64());
        return new(a.x.isNegInf(), a.y.isNegInf());
    }

    [MethodImpl(256 | 512)]
    public static double2 log([This] double2 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Log(a.vector));
        return new(a.x.log(), a.y.log());
    }

    [MethodImpl(256 | 512)]
    public static double2 log2([This] double2 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Log2(a.vector));
        return new(a.x.log2(), a.y.log2());
    }

    [MethodImpl(256 | 512)]
    public static double2 log([This] double2 a, double2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Log(a.vector) / simd.Log(b.vector));
        return new(a.x.log(b.x), a.y.log(b.y));
    }

    [MethodImpl(256 | 512)]
    public static double2 log10([This] double2 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Log10(a.vector));
        return new(a.x.log10(), a.y.log10());
    }

    [MethodImpl(256 | 512)]
    public static double2 exp([This] double2 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Exp(a.vector));
        return new(a.x.exp(), a.y.exp());
    }

    [MethodImpl(256 | 512)]
    public static double2 exp2([This] double2 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Exp2(a.vector));
        return new(a.x.exp2(), a.y.exp2());
    }

    [MethodImpl(256 | 512)]
    public static double2 exp10([This] double2 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Exp10(a.vector));
        return new(a.x.exp10(), a.y.exp10());
    }

    [MethodImpl(256 | 512)]
    public static double2 pow([This] double2 a, double2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Pow(a.vector, b.vector));
        return new(a.x.pow(b.x), a.y.pow(b.y));
    }

    [MethodImpl(256 | 512)]
    public static double2 pow([This] double2 a, double b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Pow(a.vector, b));
        return new(a.x.pow(b), a.y.pow(b));
    }

    [MethodImpl(256 | 512)]
    public static double2 sqrt([This] double2 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.Sqrt(a.vector));
        return new(a.x.sqrt(), a.y.sqrt());
    }

    [MethodImpl(256 | 512)]
    public static double2 rsqrt([This] double2 a) => double2.One / sqrt(a);

    [MethodImpl(256 | 512)]
    public static double length([This] double2 a) => dot(a, a).sqrt();

    [MethodImpl(256 | 512)]
    public static double distance([This] double2 a, double2 b) => length(b - a);

    [MethodImpl(256 | 512)]
    public static double2 normalize([This] double2 a) => a * dot(a, a).rsqrt();

    [MethodImpl(256 | 512)]
    public static double2 normalizeSafe([This] double2 a, double2 defaultValue = default)
    {
        var len = dot(a, a);
        return select(len > 1.175494351e-38, a * rsqrt(len), defaultValue);
    }

    [MethodImpl(256 | 512)]
    public static double2 step(double2 threshold, [This] double2 a) =>
        select(a >= threshold, double2.One, default);

    [MethodImpl(256 | 512)]
    public static double2 refract(double2 i, double2 n, [This] double indexOfRefraction)
    {
        var ni = dot(n, i);
        var k = (double)(1.0 - indexOfRefraction * indexOfRefraction * (1.0 - ni * ni));
        return select(k >= 0.0, indexOfRefraction * i - (double)((double)(indexOfRefraction * ni) + sqrt(k)) * n, default);
    }

    [MethodImpl(256 | 512)]
    public static double2 projectSafe([This] double2 a, double2 onto, double2 defaultValue = default) 
    {
        var proj = project(a, onto);
        return select(all(isFinite(proj)), proj, defaultValue);
    }

    [MethodImpl(256 | 512)]
    public static double2 faceForward([This] double2 n, double2 i, double2 ng) =>
        select(dot(ng, i) >= 0.0, -n, n);

    [MethodImpl(256 | 512)]
    public static double2 sin([This] double2 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Sin(a.vector));
        return new(a.x.sin(), a.y.sin());
    }

    [MethodImpl(256 | 512)]
    public static double2 cos([This] double2 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Cos(a.vector));
        return new(a.x.cos(), a.y.cos());
    }

    [MethodImpl(256 | 512)]
    public static (double2 sin, double2 cos) sincos([This] double2 a)
    {
        if (Vector128.IsHardwareAccelerated)
        {
            var (sin, cos) = simd.SinCos(a.vector);
            return (new(sin), new(cos));
        }
        a.x.sincos(out var sin0, out var cos0);
        a.y.sincos(out var sin1, out var cos1);
        return (
            new(sin0, sin1),
            new(cos0, cos1)
        );
    }

    [MethodImpl(256 | 512)]
    public static void sincos([This] double2 a, out double2 sin, out double2 cos)
    {
        if (Vector128.IsHardwareAccelerated)
        {
            (sin.vector, cos.vector) = simd.SinCos(a.vector);
            return;
        }
        a.x.sincos(out var sin0, out var cos0);
        a.y.sincos(out var sin1, out var cos1);
        sin = new(sin0, sin1);
        cos = new(cos0, cos1);
    }

    [MethodImpl(256 | 512)]
    public static double2 tan([This] double2 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Tan(a.vector));
        return new(a.x.tan(), a.y.tan());
    }

    [MethodImpl(256 | 512)]
    public static double2 asin([This] double2 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Asin(a.vector));
        return new(a.x.asin(), a.y.asin());
    }

    [MethodImpl(256 | 512)]
    public static double2 acos([This] double2 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Acos(a.vector));
        return new(a.x.acos(), a.y.acos());
    }

    [MethodImpl(256 | 512)]
    public static double2 atan([This] double2 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Atan(a.vector));
        return new(a.x.atan(), a.y.atan());
    }

    [MethodImpl(256 | 512)]
    public static double2 atan2([This] double2 a, double2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Atan2(a.vector, b.vector));
        return new(a.x.atan2(b.x), a.y.atan2(b.y));
    }

    [MethodImpl(256 | 512)]
    public static double2 sinh([This] double2 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Sinh(a.vector));
        return new(a.x.sinh(), a.y.sinh());
    }

    [MethodImpl(256 | 512)]
    public static double2 cosh([This] double2 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Cosh(a.vector));
        return new(a.x.cosh(), a.y.cosh());
    }

    [MethodImpl(256 | 512)]
    public static double2 tanh([This] double2 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Tanh(a.vector));
        return new(a.x.tanh(), a.y.tanh());
    }

    [MethodImpl(256 | 512)]
    public static double2 asinh([This] double2 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Asinh(a.vector));
        return new(a.x.asinh(), a.y.asinh());
    }

    [MethodImpl(256 | 512)]
    public static double2 acosh([This] double2 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Acosh(a.vector));
        return new(a.x.acosh(), a.y.acosh());
    }

    [MethodImpl(256 | 512)]
    public static double2 atanh([This] double2 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Atanh(a.vector));
        return new(a.x.atanh(), a.y.atanh());
    }

    [MethodImpl(256 | 512)]
    public static double2 chgsign([This] double2 a, double2 b)
    {
        var sig = new ulong2(0x8000_0000_0000_0000).asf();
        return (b & sig) ^ a;
    }
}

#endregion // double2

#region double3

[Ex]
public static partial class math
{
    #pragma warning disable CS1718
    // ReSharper disable once EqualExpressionComparison
    [MethodImpl(256 | 512)]
    public static b64v3 isNaN([This] double3 a) => a != a;
    #pragma warning restore CS1718

    [MethodImpl(256 | 512)]
    public static b64v3 isFinite([This] double3 a) => abs(a) < double.PositiveInfinity;

    [MethodImpl(256 | 512)]
    public static b64v3 isInf([This] double3 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.IsInfinity(a.vector).AsUInt64());
        return new(a.x.isInf(), a.y.isInf(), a.z.isInf());
    }

    [MethodImpl(256 | 512)]
    public static b64v3 isPosInf([This] double3 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(Vector256.Equals(a.vector, Vector256.Create(double.PositiveInfinity)).AsUInt64());
        return new(a.x.isPosInf(), a.y.isPosInf(), a.z.isPosInf());
    }

    [MethodImpl(256 | 512)]
    public static b64v3 isNegInf([This] double3 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(Vector256.Equals(a.vector, Vector256.Create(double.NegativeInfinity)).AsUInt64());
        return new(a.x.isNegInf(), a.y.isNegInf(), a.z.isNegInf());
    }

    [MethodImpl(256 | 512)]
    public static double3 log([This] double3 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Log(a.vector));
        return new(a.x.log(), a.y.log(), a.z.log());
    }

    [MethodImpl(256 | 512)]
    public static double3 log2([This] double3 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Log2(a.vector));
        return new(a.x.log2(), a.y.log2(), a.z.log2());
    }

    [MethodImpl(256 | 512)]
    public static double3 log([This] double3 a, double3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Log(a.vector) / simd.Log(b.vector));
        return new(a.x.log(b.x), a.y.log(b.y), a.z.log(b.z));
    }

    [MethodImpl(256 | 512)]
    public static double3 log10([This] double3 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Log10(a.vector));
        return new(a.x.log10(), a.y.log10(), a.z.log10());
    }

    [MethodImpl(256 | 512)]
    public static double3 exp([This] double3 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Exp(a.vector));
        return new(a.x.exp(), a.y.exp(), a.z.exp());
    }

    [MethodImpl(256 | 512)]
    public static double3 exp2([This] double3 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Exp2(a.vector));
        return new(a.x.exp2(), a.y.exp2(), a.z.exp2());
    }

    [MethodImpl(256 | 512)]
    public static double3 exp10([This] double3 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Exp10(a.vector));
        return new(a.x.exp10(), a.y.exp10(), a.z.exp10());
    }

    [MethodImpl(256 | 512)]
    public static double3 pow([This] double3 a, double3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Pow(a.vector, b.vector));
        return new(a.x.pow(b.x), a.y.pow(b.y), a.z.pow(b.z));
    }

    [MethodImpl(256 | 512)]
    public static double3 pow([This] double3 a, double b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Pow(a.vector, b));
        return new(a.x.pow(b), a.y.pow(b), a.z.pow(b));
    }

    [MethodImpl(256 | 512)]
    public static double3 sqrt([This] double3 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(Vector256.Sqrt(a.vector));
        return new(a.x.sqrt(), a.y.sqrt(), a.z.sqrt());
    }

    [MethodImpl(256 | 512)]
    public static double3 rsqrt([This] double3 a) => double3.One / sqrt(a);

    [MethodImpl(256 | 512)]
    public static double length([This] double3 a) => dot(a, a).sqrt();

    [MethodImpl(256 | 512)]
    public static double distance([This] double3 a, double3 b) => length(b - a);

    [MethodImpl(256 | 512)]
    public static double3 normalize([This] double3 a) => a * dot(a, a).rsqrt();

    [MethodImpl(256 | 512)]
    public static double3 normalizeSafe([This] double3 a, double3 defaultValue = default)
    {
        var len = dot(a, a);
        return select(len > 1.175494351e-38, a * rsqrt(len), defaultValue);
    }

    [MethodImpl(256 | 512)]
    public static double3 step(double3 threshold, [This] double3 a) =>
        select(a >= threshold, double3.One, default);

    [MethodImpl(256 | 512)]
    public static double3 refract(double3 i, double3 n, [This] double indexOfRefraction)
    {
        var ni = dot(n, i);
        var k = (double)(1.0 - indexOfRefraction * indexOfRefraction * (1.0 - ni * ni));
        return select(k >= 0.0, indexOfRefraction * i - (double)((double)(indexOfRefraction * ni) + sqrt(k)) * n, default);
    }

    [MethodImpl(256 | 512)]
    public static double3 projectSafe([This] double3 a, double3 onto, double3 defaultValue = default) 
    {
        var proj = project(a, onto);
        return select(all(isFinite(proj)), proj, defaultValue);
    }

    [MethodImpl(256 | 512)]
    public static double3 faceForward([This] double3 n, double3 i, double3 ng) =>
        select(dot(ng, i) >= 0.0, -n, n);

    [MethodImpl(256 | 512)]
    public static double3 sin([This] double3 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Sin(a.vector));
        return new(a.x.sin(), a.y.sin(), a.z.sin());
    }

    [MethodImpl(256 | 512)]
    public static double3 cos([This] double3 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Cos(a.vector));
        return new(a.x.cos(), a.y.cos(), a.z.cos());
    }

    [MethodImpl(256 | 512)]
    public static (double3 sin, double3 cos) sincos([This] double3 a)
    {
        if (Vector256.IsHardwareAccelerated)
        {
            var (sin, cos) = simd.SinCos(a.vector);
            return (new(sin), new(cos));
        }
        a.x.sincos(out var sin0, out var cos0);
        a.y.sincos(out var sin1, out var cos1);
        a.z.sincos(out var sin2, out var cos2);
        return (
            new(sin0, sin1, sin2),
            new(cos0, cos1, cos2)
        );
    }

    [MethodImpl(256 | 512)]
    public static void sincos([This] double3 a, out double3 sin, out double3 cos)
    {
        if (Vector256.IsHardwareAccelerated)
        {
            (sin.vector, cos.vector) = simd.SinCos(a.vector);
            return;
        }
        a.x.sincos(out var sin0, out var cos0);
        a.y.sincos(out var sin1, out var cos1);
        a.z.sincos(out var sin2, out var cos2);
        sin = new(sin0, sin1, sin2);
        cos = new(cos0, cos1, cos2);
    }

    [MethodImpl(256 | 512)]
    public static double3 tan([This] double3 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Tan(a.vector));
        return new(a.x.tan(), a.y.tan(), a.z.tan());
    }

    [MethodImpl(256 | 512)]
    public static double3 asin([This] double3 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Asin(a.vector));
        return new(a.x.asin(), a.y.asin(), a.z.asin());
    }

    [MethodImpl(256 | 512)]
    public static double3 acos([This] double3 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Acos(a.vector));
        return new(a.x.acos(), a.y.acos(), a.z.acos());
    }

    [MethodImpl(256 | 512)]
    public static double3 atan([This] double3 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Atan(a.vector));
        return new(a.x.atan(), a.y.atan(), a.z.atan());
    }

    [MethodImpl(256 | 512)]
    public static double3 atan2([This] double3 a, double3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Atan2(a.vector, b.vector));
        return new(a.x.atan2(b.x), a.y.atan2(b.y), a.z.atan2(b.z));
    }

    [MethodImpl(256 | 512)]
    public static double3 sinh([This] double3 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Sinh(a.vector));
        return new(a.x.sinh(), a.y.sinh(), a.z.sinh());
    }

    [MethodImpl(256 | 512)]
    public static double3 cosh([This] double3 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Cosh(a.vector));
        return new(a.x.cosh(), a.y.cosh(), a.z.cosh());
    }

    [MethodImpl(256 | 512)]
    public static double3 tanh([This] double3 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Tanh(a.vector));
        return new(a.x.tanh(), a.y.tanh(), a.z.tanh());
    }

    [MethodImpl(256 | 512)]
    public static double3 asinh([This] double3 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Asinh(a.vector));
        return new(a.x.asinh(), a.y.asinh(), a.z.asinh());
    }

    [MethodImpl(256 | 512)]
    public static double3 acosh([This] double3 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Acosh(a.vector));
        return new(a.x.acosh(), a.y.acosh(), a.z.acosh());
    }

    [MethodImpl(256 | 512)]
    public static double3 atanh([This] double3 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Atanh(a.vector));
        return new(a.x.atanh(), a.y.atanh(), a.z.atanh());
    }

    [MethodImpl(256 | 512)]
    public static double3 chgsign([This] double3 a, double3 b)
    {
        var sig = new ulong3(0x8000_0000_0000_0000).asf();
        return (b & sig) ^ a;
    }
}

#endregion // double3

#region double4

[Ex]
public static partial class math
{
    #pragma warning disable CS1718
    // ReSharper disable once EqualExpressionComparison
    [MethodImpl(256 | 512)]
    public static b64v4 isNaN([This] double4 a) => a != a;
    #pragma warning restore CS1718

    [MethodImpl(256 | 512)]
    public static b64v4 isFinite([This] double4 a) => abs(a) < double.PositiveInfinity;

    [MethodImpl(256 | 512)]
    public static b64v4 isInf([This] double4 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.IsInfinity(a.vector).AsUInt64());
        return new(a.x.isInf(), a.y.isInf(), a.z.isInf(), a.w.isInf());
    }

    [MethodImpl(256 | 512)]
    public static b64v4 isPosInf([This] double4 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(Vector256.Equals(a.vector, Vector256.Create(double.PositiveInfinity)).AsUInt64());
        return new(a.x.isPosInf(), a.y.isPosInf(), a.z.isPosInf(), a.w.isPosInf());
    }

    [MethodImpl(256 | 512)]
    public static b64v4 isNegInf([This] double4 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(Vector256.Equals(a.vector, Vector256.Create(double.NegativeInfinity)).AsUInt64());
        return new(a.x.isNegInf(), a.y.isNegInf(), a.z.isNegInf(), a.w.isNegInf());
    }

    [MethodImpl(256 | 512)]
    public static double4 log([This] double4 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Log(a.vector));
        return new(a.x.log(), a.y.log(), a.z.log(), a.w.log());
    }

    [MethodImpl(256 | 512)]
    public static double4 log2([This] double4 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Log2(a.vector));
        return new(a.x.log2(), a.y.log2(), a.z.log2(), a.w.log2());
    }

    [MethodImpl(256 | 512)]
    public static double4 log([This] double4 a, double4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Log(a.vector) / simd.Log(b.vector));
        return new(a.x.log(b.x), a.y.log(b.y), a.z.log(b.z), a.w.log(b.w));
    }

    [MethodImpl(256 | 512)]
    public static double4 log10([This] double4 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Log10(a.vector));
        return new(a.x.log10(), a.y.log10(), a.z.log10(), a.w.log10());
    }

    [MethodImpl(256 | 512)]
    public static double4 exp([This] double4 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Exp(a.vector));
        return new(a.x.exp(), a.y.exp(), a.z.exp(), a.w.exp());
    }

    [MethodImpl(256 | 512)]
    public static double4 exp2([This] double4 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Exp2(a.vector));
        return new(a.x.exp2(), a.y.exp2(), a.z.exp2(), a.w.exp2());
    }

    [MethodImpl(256 | 512)]
    public static double4 exp10([This] double4 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Exp10(a.vector));
        return new(a.x.exp10(), a.y.exp10(), a.z.exp10(), a.w.exp10());
    }

    [MethodImpl(256 | 512)]
    public static double4 pow([This] double4 a, double4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Pow(a.vector, b.vector));
        return new(a.x.pow(b.x), a.y.pow(b.y), a.z.pow(b.z), a.w.pow(b.w));
    }

    [MethodImpl(256 | 512)]
    public static double4 pow([This] double4 a, double b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Pow(a.vector, b));
        return new(a.x.pow(b), a.y.pow(b), a.z.pow(b), a.w.pow(b));
    }

    [MethodImpl(256 | 512)]
    public static double4 sqrt([This] double4 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(Vector256.Sqrt(a.vector));
        return new(a.x.sqrt(), a.y.sqrt(), a.z.sqrt(), a.w.sqrt());
    }

    [MethodImpl(256 | 512)]
    public static double4 rsqrt([This] double4 a) => double4.One / sqrt(a);

    [MethodImpl(256 | 512)]
    public static double length([This] double4 a) => dot(a, a).sqrt();

    [MethodImpl(256 | 512)]
    public static double distance([This] double4 a, double4 b) => length(b - a);

    [MethodImpl(256 | 512)]
    public static double4 normalize([This] double4 a) => a * dot(a, a).rsqrt();

    [MethodImpl(256 | 512)]
    public static double4 normalizeSafe([This] double4 a, double4 defaultValue = default)
    {
        var len = dot(a, a);
        return select(len > 1.175494351e-38, a * rsqrt(len), defaultValue);
    }

    [MethodImpl(256 | 512)]
    public static double4 step(double4 threshold, [This] double4 a) =>
        select(a >= threshold, double4.One, default);

    [MethodImpl(256 | 512)]
    public static double4 refract(double4 i, double4 n, [This] double indexOfRefraction)
    {
        var ni = dot(n, i);
        var k = (double)(1.0 - indexOfRefraction * indexOfRefraction * (1.0 - ni * ni));
        return select(k >= 0.0, indexOfRefraction * i - (double)((double)(indexOfRefraction * ni) + sqrt(k)) * n, default);
    }

    [MethodImpl(256 | 512)]
    public static double4 projectSafe([This] double4 a, double4 onto, double4 defaultValue = default) 
    {
        var proj = project(a, onto);
        return select(all(isFinite(proj)), proj, defaultValue);
    }

    [MethodImpl(256 | 512)]
    public static double4 faceForward([This] double4 n, double4 i, double4 ng) =>
        select(dot(ng, i) >= 0.0, -n, n);

    [MethodImpl(256 | 512)]
    public static double4 sin([This] double4 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Sin(a.vector));
        return new(a.x.sin(), a.y.sin(), a.z.sin(), a.w.sin());
    }

    [MethodImpl(256 | 512)]
    public static double4 cos([This] double4 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Cos(a.vector));
        return new(a.x.cos(), a.y.cos(), a.z.cos(), a.w.cos());
    }

    [MethodImpl(256 | 512)]
    public static (double4 sin, double4 cos) sincos([This] double4 a)
    {
        if (Vector256.IsHardwareAccelerated)
        {
            var (sin, cos) = simd.SinCos(a.vector);
            return (new(sin), new(cos));
        }
        a.x.sincos(out var sin0, out var cos0);
        a.y.sincos(out var sin1, out var cos1);
        a.z.sincos(out var sin2, out var cos2);
        a.w.sincos(out var sin3, out var cos3);
        return (
            new(sin0, sin1, sin2, sin3),
            new(cos0, cos1, cos2, cos3)
        );
    }

    [MethodImpl(256 | 512)]
    public static void sincos([This] double4 a, out double4 sin, out double4 cos)
    {
        if (Vector256.IsHardwareAccelerated)
        {
            (sin.vector, cos.vector) = simd.SinCos(a.vector);
            return;
        }
        a.x.sincos(out var sin0, out var cos0);
        a.y.sincos(out var sin1, out var cos1);
        a.z.sincos(out var sin2, out var cos2);
        a.w.sincos(out var sin3, out var cos3);
        sin = new(sin0, sin1, sin2, sin3);
        cos = new(cos0, cos1, cos2, cos3);
    }

    [MethodImpl(256 | 512)]
    public static double4 tan([This] double4 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Tan(a.vector));
        return new(a.x.tan(), a.y.tan(), a.z.tan(), a.w.tan());
    }

    [MethodImpl(256 | 512)]
    public static double4 asin([This] double4 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Asin(a.vector));
        return new(a.x.asin(), a.y.asin(), a.z.asin(), a.w.asin());
    }

    [MethodImpl(256 | 512)]
    public static double4 acos([This] double4 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Acos(a.vector));
        return new(a.x.acos(), a.y.acos(), a.z.acos(), a.w.acos());
    }

    [MethodImpl(256 | 512)]
    public static double4 atan([This] double4 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Atan(a.vector));
        return new(a.x.atan(), a.y.atan(), a.z.atan(), a.w.atan());
    }

    [MethodImpl(256 | 512)]
    public static double4 atan2([This] double4 a, double4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Atan2(a.vector, b.vector));
        return new(a.x.atan2(b.x), a.y.atan2(b.y), a.z.atan2(b.z), a.w.atan2(b.w));
    }

    [MethodImpl(256 | 512)]
    public static double4 sinh([This] double4 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Sinh(a.vector));
        return new(a.x.sinh(), a.y.sinh(), a.z.sinh(), a.w.sinh());
    }

    [MethodImpl(256 | 512)]
    public static double4 cosh([This] double4 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Cosh(a.vector));
        return new(a.x.cosh(), a.y.cosh(), a.z.cosh(), a.w.cosh());
    }

    [MethodImpl(256 | 512)]
    public static double4 tanh([This] double4 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Tanh(a.vector));
        return new(a.x.tanh(), a.y.tanh(), a.z.tanh(), a.w.tanh());
    }

    [MethodImpl(256 | 512)]
    public static double4 asinh([This] double4 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Asinh(a.vector));
        return new(a.x.asinh(), a.y.asinh(), a.z.asinh(), a.w.asinh());
    }

    [MethodImpl(256 | 512)]
    public static double4 acosh([This] double4 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Acosh(a.vector));
        return new(a.x.acosh(), a.y.acosh(), a.z.acosh(), a.w.acosh());
    }

    [MethodImpl(256 | 512)]
    public static double4 atanh([This] double4 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Atanh(a.vector));
        return new(a.x.atanh(), a.y.atanh(), a.z.atanh(), a.w.atanh());
    }

    [MethodImpl(256 | 512)]
    public static double4 chgsign([This] double4 a, double4 b)
    {
        var sig = new ulong4(0x8000_0000_0000_0000).asf();
        return (b & sig) ^ a;
    }
}

#endregion // double4

#region half2

[Ex]
public static partial class math
{
    #pragma warning disable CS1718
    // ReSharper disable once EqualExpressionComparison
    [MethodImpl(256 | 512)]
    public static b16v2 isNaN([This] half2 a) => a != a;
    #pragma warning restore CS1718

    [MethodImpl(256 | 512)]
    public static b16v2 isFinite([This] half2 a) => abs(a) < half.PositiveInfinity;

    [MethodImpl(256 | 512)]
    public static b16v2 isInf([This] half2 a)
    {
        return new(a.x.isInf(), a.y.isInf());
    }

    [MethodImpl(256 | 512)]
    public static b16v2 isPosInf([This] half2 a)
    {
        return new(a.x.isPosInf(), a.y.isPosInf());
    }

    [MethodImpl(256 | 512)]
    public static b16v2 isNegInf([This] half2 a)
    {
        return new(a.x.isNegInf(), a.y.isNegInf());
    }

    [MethodImpl(256 | 512)]
    public static half2 log([This] half2 a)
    {
        return new(a.x.log(), a.y.log());
    }

    [MethodImpl(256 | 512)]
    public static half2 log2([This] half2 a)
    {
        return new(a.x.log2(), a.y.log2());
    }

    [MethodImpl(256 | 512)]
    public static half2 log([This] half2 a, half2 b)
    {
        return new(a.x.log(b.x), a.y.log(b.y));
    }

    [MethodImpl(256 | 512)]
    public static half2 log10([This] half2 a)
    {
        return new(a.x.log10(), a.y.log10());
    }

    [MethodImpl(256 | 512)]
    public static half2 exp([This] half2 a)
    {
        return new(a.x.exp(), a.y.exp());
    }

    [MethodImpl(256 | 512)]
    public static half2 exp2([This] half2 a)
    {
        return new(a.x.exp2(), a.y.exp2());
    }

    [MethodImpl(256 | 512)]
    public static half2 exp10([This] half2 a)
    {
        return new(a.x.exp10(), a.y.exp10());
    }

    [MethodImpl(256 | 512)]
    public static half2 pow([This] half2 a, half2 b)
    {
        return new(a.x.pow(b.x), a.y.pow(b.y));
    }

    [MethodImpl(256 | 512)]
    public static half2 pow([This] half2 a, half b)
    {
        return new(a.x.pow(b), a.y.pow(b));
    }

    [MethodImpl(256 | 512)]
    public static half2 sqrt([This] half2 a)
    {
        return new(a.x.sqrt(), a.y.sqrt());
    }

    [MethodImpl(256 | 512)]
    public static half2 rsqrt([This] half2 a) => half2.One / sqrt(a);

    [MethodImpl(256 | 512)]
    public static half length([This] half2 a) => dot(a, a).sqrt();

    [MethodImpl(256 | 512)]
    public static half distance([This] half2 a, half2 b) => length(b - a);

    [MethodImpl(256 | 512)]
    public static half2 normalize([This] half2 a) => a * dot(a, a).rsqrt();

    [MethodImpl(256 | 512)]
    public static half2 normalizeSafe([This] half2 a, half2 defaultValue = default)
    {
        var len = dot(a, a);
        return select(len > 1.175494351e-38f.half(), a * rsqrt(len), defaultValue);
    }

    [MethodImpl(256 | 512)]
    public static half2 step(half2 threshold, [This] half2 a) =>
        select(a >= threshold, half2.One, default);

    [MethodImpl(256 | 512)]
    public static half2 refract(half2 i, half2 n, [This] half indexOfRefraction)
    {
        var ni = dot(n, i);
        var k = (half)(1.0f.half() - indexOfRefraction * indexOfRefraction * (1.0f.half() - ni * ni));
        return select(k >= 0.0f.half(), indexOfRefraction * i - (half)((half)(indexOfRefraction * ni) + sqrt(k)) * n, default);
    }

    [MethodImpl(256 | 512)]
    public static half2 projectSafe([This] half2 a, half2 onto, half2 defaultValue = default) 
    {
        var proj = project(a, onto);
        return select(all(isFinite(proj)), proj, defaultValue);
    }

    [MethodImpl(256 | 512)]
    public static half2 faceForward([This] half2 n, half2 i, half2 ng) =>
        select(dot(ng, i) >= 0.0f.half(), -n, n);

    [MethodImpl(256 | 512)]
    public static half2 sin([This] half2 a)
    {
        return new(a.x.sin(), a.y.sin());
    }

    [MethodImpl(256 | 512)]
    public static half2 cos([This] half2 a)
    {
        return new(a.x.cos(), a.y.cos());
    }

    [MethodImpl(256 | 512)]
    public static (half2 sin, half2 cos) sincos([This] half2 a)
    {
        a.x.sincos(out var sin0, out var cos0);
        a.y.sincos(out var sin1, out var cos1);
        return (
            new(sin0, sin1),
            new(cos0, cos1)
        );
    }

    [MethodImpl(256 | 512)]
    public static void sincos([This] half2 a, out half2 sin, out half2 cos)
    {
        a.x.sincos(out var sin0, out var cos0);
        a.y.sincos(out var sin1, out var cos1);
        sin = new(sin0, sin1);
        cos = new(cos0, cos1);
    }

    [MethodImpl(256 | 512)]
    public static half2 tan([This] half2 a)
    {
        return new(a.x.tan(), a.y.tan());
    }

    [MethodImpl(256 | 512)]
    public static half2 asin([This] half2 a)
    {
        return new(a.x.asin(), a.y.asin());
    }

    [MethodImpl(256 | 512)]
    public static half2 acos([This] half2 a)
    {
        return new(a.x.acos(), a.y.acos());
    }

    [MethodImpl(256 | 512)]
    public static half2 atan([This] half2 a)
    {
        return new(a.x.atan(), a.y.atan());
    }

    [MethodImpl(256 | 512)]
    public static half2 atan2([This] half2 a, half2 b)
    {
        return new(a.x.atan2(b.x), a.y.atan2(b.y));
    }

    [MethodImpl(256 | 512)]
    public static half2 sinh([This] half2 a)
    {
        return new(a.x.sinh(), a.y.sinh());
    }

    [MethodImpl(256 | 512)]
    public static half2 cosh([This] half2 a)
    {
        return new(a.x.cosh(), a.y.cosh());
    }

    [MethodImpl(256 | 512)]
    public static half2 tanh([This] half2 a)
    {
        return new(a.x.tanh(), a.y.tanh());
    }

    [MethodImpl(256 | 512)]
    public static half2 asinh([This] half2 a)
    {
        return new(a.x.asinh(), a.y.asinh());
    }

    [MethodImpl(256 | 512)]
    public static half2 acosh([This] half2 a)
    {
        return new(a.x.acosh(), a.y.acosh());
    }

    [MethodImpl(256 | 512)]
    public static half2 atanh([This] half2 a)
    {
        return new(a.x.atanh(), a.y.atanh());
    }

    [MethodImpl(256 | 512)]
    public static half2 chgsign([This] half2 a, half2 b)
    {
        var sig = new ushort2(0x8000).asf();
        return (b & sig) ^ a;
    }
}

#endregion // half2

#region half3

[Ex]
public static partial class math
{
    #pragma warning disable CS1718
    // ReSharper disable once EqualExpressionComparison
    [MethodImpl(256 | 512)]
    public static b16v3 isNaN([This] half3 a) => a != a;
    #pragma warning restore CS1718

    [MethodImpl(256 | 512)]
    public static b16v3 isFinite([This] half3 a) => abs(a) < half.PositiveInfinity;

    [MethodImpl(256 | 512)]
    public static b16v3 isInf([This] half3 a)
    {
        return new(a.x.isInf(), a.y.isInf(), a.z.isInf());
    }

    [MethodImpl(256 | 512)]
    public static b16v3 isPosInf([This] half3 a)
    {
        return new(a.x.isPosInf(), a.y.isPosInf(), a.z.isPosInf());
    }

    [MethodImpl(256 | 512)]
    public static b16v3 isNegInf([This] half3 a)
    {
        return new(a.x.isNegInf(), a.y.isNegInf(), a.z.isNegInf());
    }

    [MethodImpl(256 | 512)]
    public static half3 log([This] half3 a)
    {
        return new(a.x.log(), a.y.log(), a.z.log());
    }

    [MethodImpl(256 | 512)]
    public static half3 log2([This] half3 a)
    {
        return new(a.x.log2(), a.y.log2(), a.z.log2());
    }

    [MethodImpl(256 | 512)]
    public static half3 log([This] half3 a, half3 b)
    {
        return new(a.x.log(b.x), a.y.log(b.y), a.z.log(b.z));
    }

    [MethodImpl(256 | 512)]
    public static half3 log10([This] half3 a)
    {
        return new(a.x.log10(), a.y.log10(), a.z.log10());
    }

    [MethodImpl(256 | 512)]
    public static half3 exp([This] half3 a)
    {
        return new(a.x.exp(), a.y.exp(), a.z.exp());
    }

    [MethodImpl(256 | 512)]
    public static half3 exp2([This] half3 a)
    {
        return new(a.x.exp2(), a.y.exp2(), a.z.exp2());
    }

    [MethodImpl(256 | 512)]
    public static half3 exp10([This] half3 a)
    {
        return new(a.x.exp10(), a.y.exp10(), a.z.exp10());
    }

    [MethodImpl(256 | 512)]
    public static half3 pow([This] half3 a, half3 b)
    {
        return new(a.x.pow(b.x), a.y.pow(b.y), a.z.pow(b.z));
    }

    [MethodImpl(256 | 512)]
    public static half3 pow([This] half3 a, half b)
    {
        return new(a.x.pow(b), a.y.pow(b), a.z.pow(b));
    }

    [MethodImpl(256 | 512)]
    public static half3 sqrt([This] half3 a)
    {
        return new(a.x.sqrt(), a.y.sqrt(), a.z.sqrt());
    }

    [MethodImpl(256 | 512)]
    public static half3 rsqrt([This] half3 a) => half3.One / sqrt(a);

    [MethodImpl(256 | 512)]
    public static half length([This] half3 a) => dot(a, a).sqrt();

    [MethodImpl(256 | 512)]
    public static half distance([This] half3 a, half3 b) => length(b - a);

    [MethodImpl(256 | 512)]
    public static half3 normalize([This] half3 a) => a * dot(a, a).rsqrt();

    [MethodImpl(256 | 512)]
    public static half3 normalizeSafe([This] half3 a, half3 defaultValue = default)
    {
        var len = dot(a, a);
        return select(len > 1.175494351e-38f.half(), a * rsqrt(len), defaultValue);
    }

    [MethodImpl(256 | 512)]
    public static half3 step(half3 threshold, [This] half3 a) =>
        select(a >= threshold, half3.One, default);

    [MethodImpl(256 | 512)]
    public static half3 refract(half3 i, half3 n, [This] half indexOfRefraction)
    {
        var ni = dot(n, i);
        var k = (half)(1.0f.half() - indexOfRefraction * indexOfRefraction * (1.0f.half() - ni * ni));
        return select(k >= 0.0f.half(), indexOfRefraction * i - (half)((half)(indexOfRefraction * ni) + sqrt(k)) * n, default);
    }

    [MethodImpl(256 | 512)]
    public static half3 projectSafe([This] half3 a, half3 onto, half3 defaultValue = default) 
    {
        var proj = project(a, onto);
        return select(all(isFinite(proj)), proj, defaultValue);
    }

    [MethodImpl(256 | 512)]
    public static half3 faceForward([This] half3 n, half3 i, half3 ng) =>
        select(dot(ng, i) >= 0.0f.half(), -n, n);

    [MethodImpl(256 | 512)]
    public static half3 sin([This] half3 a)
    {
        return new(a.x.sin(), a.y.sin(), a.z.sin());
    }

    [MethodImpl(256 | 512)]
    public static half3 cos([This] half3 a)
    {
        return new(a.x.cos(), a.y.cos(), a.z.cos());
    }

    [MethodImpl(256 | 512)]
    public static (half3 sin, half3 cos) sincos([This] half3 a)
    {
        a.x.sincos(out var sin0, out var cos0);
        a.y.sincos(out var sin1, out var cos1);
        a.z.sincos(out var sin2, out var cos2);
        return (
            new(sin0, sin1, sin2),
            new(cos0, cos1, cos2)
        );
    }

    [MethodImpl(256 | 512)]
    public static void sincos([This] half3 a, out half3 sin, out half3 cos)
    {
        a.x.sincos(out var sin0, out var cos0);
        a.y.sincos(out var sin1, out var cos1);
        a.z.sincos(out var sin2, out var cos2);
        sin = new(sin0, sin1, sin2);
        cos = new(cos0, cos1, cos2);
    }

    [MethodImpl(256 | 512)]
    public static half3 tan([This] half3 a)
    {
        return new(a.x.tan(), a.y.tan(), a.z.tan());
    }

    [MethodImpl(256 | 512)]
    public static half3 asin([This] half3 a)
    {
        return new(a.x.asin(), a.y.asin(), a.z.asin());
    }

    [MethodImpl(256 | 512)]
    public static half3 acos([This] half3 a)
    {
        return new(a.x.acos(), a.y.acos(), a.z.acos());
    }

    [MethodImpl(256 | 512)]
    public static half3 atan([This] half3 a)
    {
        return new(a.x.atan(), a.y.atan(), a.z.atan());
    }

    [MethodImpl(256 | 512)]
    public static half3 atan2([This] half3 a, half3 b)
    {
        return new(a.x.atan2(b.x), a.y.atan2(b.y), a.z.atan2(b.z));
    }

    [MethodImpl(256 | 512)]
    public static half3 sinh([This] half3 a)
    {
        return new(a.x.sinh(), a.y.sinh(), a.z.sinh());
    }

    [MethodImpl(256 | 512)]
    public static half3 cosh([This] half3 a)
    {
        return new(a.x.cosh(), a.y.cosh(), a.z.cosh());
    }

    [MethodImpl(256 | 512)]
    public static half3 tanh([This] half3 a)
    {
        return new(a.x.tanh(), a.y.tanh(), a.z.tanh());
    }

    [MethodImpl(256 | 512)]
    public static half3 asinh([This] half3 a)
    {
        return new(a.x.asinh(), a.y.asinh(), a.z.asinh());
    }

    [MethodImpl(256 | 512)]
    public static half3 acosh([This] half3 a)
    {
        return new(a.x.acosh(), a.y.acosh(), a.z.acosh());
    }

    [MethodImpl(256 | 512)]
    public static half3 atanh([This] half3 a)
    {
        return new(a.x.atanh(), a.y.atanh(), a.z.atanh());
    }

    [MethodImpl(256 | 512)]
    public static half3 chgsign([This] half3 a, half3 b)
    {
        var sig = new ushort3(0x8000).asf();
        return (b & sig) ^ a;
    }
}

#endregion // half3

#region half4

[Ex]
public static partial class math
{
    #pragma warning disable CS1718
    // ReSharper disable once EqualExpressionComparison
    [MethodImpl(256 | 512)]
    public static b16v4 isNaN([This] half4 a) => a != a;
    #pragma warning restore CS1718

    [MethodImpl(256 | 512)]
    public static b16v4 isFinite([This] half4 a) => abs(a) < half.PositiveInfinity;

    [MethodImpl(256 | 512)]
    public static b16v4 isInf([This] half4 a)
    {
        return new(a.x.isInf(), a.y.isInf(), a.z.isInf(), a.w.isInf());
    }

    [MethodImpl(256 | 512)]
    public static b16v4 isPosInf([This] half4 a)
    {
        return new(a.x.isPosInf(), a.y.isPosInf(), a.z.isPosInf(), a.w.isPosInf());
    }

    [MethodImpl(256 | 512)]
    public static b16v4 isNegInf([This] half4 a)
    {
        return new(a.x.isNegInf(), a.y.isNegInf(), a.z.isNegInf(), a.w.isNegInf());
    }

    [MethodImpl(256 | 512)]
    public static half4 log([This] half4 a)
    {
        return new(a.x.log(), a.y.log(), a.z.log(), a.w.log());
    }

    [MethodImpl(256 | 512)]
    public static half4 log2([This] half4 a)
    {
        return new(a.x.log2(), a.y.log2(), a.z.log2(), a.w.log2());
    }

    [MethodImpl(256 | 512)]
    public static half4 log([This] half4 a, half4 b)
    {
        return new(a.x.log(b.x), a.y.log(b.y), a.z.log(b.z), a.w.log(b.w));
    }

    [MethodImpl(256 | 512)]
    public static half4 log10([This] half4 a)
    {
        return new(a.x.log10(), a.y.log10(), a.z.log10(), a.w.log10());
    }

    [MethodImpl(256 | 512)]
    public static half4 exp([This] half4 a)
    {
        return new(a.x.exp(), a.y.exp(), a.z.exp(), a.w.exp());
    }

    [MethodImpl(256 | 512)]
    public static half4 exp2([This] half4 a)
    {
        return new(a.x.exp2(), a.y.exp2(), a.z.exp2(), a.w.exp2());
    }

    [MethodImpl(256 | 512)]
    public static half4 exp10([This] half4 a)
    {
        return new(a.x.exp10(), a.y.exp10(), a.z.exp10(), a.w.exp10());
    }

    [MethodImpl(256 | 512)]
    public static half4 pow([This] half4 a, half4 b)
    {
        return new(a.x.pow(b.x), a.y.pow(b.y), a.z.pow(b.z), a.w.pow(b.w));
    }

    [MethodImpl(256 | 512)]
    public static half4 pow([This] half4 a, half b)
    {
        return new(a.x.pow(b), a.y.pow(b), a.z.pow(b), a.w.pow(b));
    }

    [MethodImpl(256 | 512)]
    public static half4 sqrt([This] half4 a)
    {
        return new(a.x.sqrt(), a.y.sqrt(), a.z.sqrt(), a.w.sqrt());
    }

    [MethodImpl(256 | 512)]
    public static half4 rsqrt([This] half4 a) => half4.One / sqrt(a);

    [MethodImpl(256 | 512)]
    public static half length([This] half4 a) => dot(a, a).sqrt();

    [MethodImpl(256 | 512)]
    public static half distance([This] half4 a, half4 b) => length(b - a);

    [MethodImpl(256 | 512)]
    public static half4 normalize([This] half4 a) => a * dot(a, a).rsqrt();

    [MethodImpl(256 | 512)]
    public static half4 normalizeSafe([This] half4 a, half4 defaultValue = default)
    {
        var len = dot(a, a);
        return select(len > 1.175494351e-38f.half(), a * rsqrt(len), defaultValue);
    }

    [MethodImpl(256 | 512)]
    public static half4 step(half4 threshold, [This] half4 a) =>
        select(a >= threshold, half4.One, default);

    [MethodImpl(256 | 512)]
    public static half4 refract(half4 i, half4 n, [This] half indexOfRefraction)
    {
        var ni = dot(n, i);
        var k = (half)(1.0f.half() - indexOfRefraction * indexOfRefraction * (1.0f.half() - ni * ni));
        return select(k >= 0.0f.half(), indexOfRefraction * i - (half)((half)(indexOfRefraction * ni) + sqrt(k)) * n, default);
    }

    [MethodImpl(256 | 512)]
    public static half4 projectSafe([This] half4 a, half4 onto, half4 defaultValue = default) 
    {
        var proj = project(a, onto);
        return select(all(isFinite(proj)), proj, defaultValue);
    }

    [MethodImpl(256 | 512)]
    public static half4 faceForward([This] half4 n, half4 i, half4 ng) =>
        select(dot(ng, i) >= 0.0f.half(), -n, n);

    [MethodImpl(256 | 512)]
    public static half4 sin([This] half4 a)
    {
        return new(a.x.sin(), a.y.sin(), a.z.sin(), a.w.sin());
    }

    [MethodImpl(256 | 512)]
    public static half4 cos([This] half4 a)
    {
        return new(a.x.cos(), a.y.cos(), a.z.cos(), a.w.cos());
    }

    [MethodImpl(256 | 512)]
    public static (half4 sin, half4 cos) sincos([This] half4 a)
    {
        a.x.sincos(out var sin0, out var cos0);
        a.y.sincos(out var sin1, out var cos1);
        a.z.sincos(out var sin2, out var cos2);
        a.w.sincos(out var sin3, out var cos3);
        return (
            new(sin0, sin1, sin2, sin3),
            new(cos0, cos1, cos2, cos3)
        );
    }

    [MethodImpl(256 | 512)]
    public static void sincos([This] half4 a, out half4 sin, out half4 cos)
    {
        a.x.sincos(out var sin0, out var cos0);
        a.y.sincos(out var sin1, out var cos1);
        a.z.sincos(out var sin2, out var cos2);
        a.w.sincos(out var sin3, out var cos3);
        sin = new(sin0, sin1, sin2, sin3);
        cos = new(cos0, cos1, cos2, cos3);
    }

    [MethodImpl(256 | 512)]
    public static half4 tan([This] half4 a)
    {
        return new(a.x.tan(), a.y.tan(), a.z.tan(), a.w.tan());
    }

    [MethodImpl(256 | 512)]
    public static half4 asin([This] half4 a)
    {
        return new(a.x.asin(), a.y.asin(), a.z.asin(), a.w.asin());
    }

    [MethodImpl(256 | 512)]
    public static half4 acos([This] half4 a)
    {
        return new(a.x.acos(), a.y.acos(), a.z.acos(), a.w.acos());
    }

    [MethodImpl(256 | 512)]
    public static half4 atan([This] half4 a)
    {
        return new(a.x.atan(), a.y.atan(), a.z.atan(), a.w.atan());
    }

    [MethodImpl(256 | 512)]
    public static half4 atan2([This] half4 a, half4 b)
    {
        return new(a.x.atan2(b.x), a.y.atan2(b.y), a.z.atan2(b.z), a.w.atan2(b.w));
    }

    [MethodImpl(256 | 512)]
    public static half4 sinh([This] half4 a)
    {
        return new(a.x.sinh(), a.y.sinh(), a.z.sinh(), a.w.sinh());
    }

    [MethodImpl(256 | 512)]
    public static half4 cosh([This] half4 a)
    {
        return new(a.x.cosh(), a.y.cosh(), a.z.cosh(), a.w.cosh());
    }

    [MethodImpl(256 | 512)]
    public static half4 tanh([This] half4 a)
    {
        return new(a.x.tanh(), a.y.tanh(), a.z.tanh(), a.w.tanh());
    }

    [MethodImpl(256 | 512)]
    public static half4 asinh([This] half4 a)
    {
        return new(a.x.asinh(), a.y.asinh(), a.z.asinh(), a.w.asinh());
    }

    [MethodImpl(256 | 512)]
    public static half4 acosh([This] half4 a)
    {
        return new(a.x.acosh(), a.y.acosh(), a.z.acosh(), a.w.acosh());
    }

    [MethodImpl(256 | 512)]
    public static half4 atanh([This] half4 a)
    {
        return new(a.x.atanh(), a.y.atanh(), a.z.atanh(), a.w.atanh());
    }

    [MethodImpl(256 | 512)]
    public static half4 chgsign([This] half4 a, half4 b)
    {
        var sig = new ushort4(0x8000).asf();
        return (b & sig) ^ a;
    }
}

#endregion // half4
