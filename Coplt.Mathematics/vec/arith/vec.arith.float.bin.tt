<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="../../types.ttinclude" #><#@ import namespace="System.Linq" #>// generated by template, do not modify manually

namespace Coplt.Mathematics;
<#
    foreach (var typ in Typ.Typs)
    {
        if (!typ.f) continue;
        if (!typ.arith) continue;
        if (!typ.bin) continue;

        for (var i = 2; i <= 4; i++)
        {
            var typeName = $"{typ.name}{i}";

            var byteSize = typ.size * (i is 3 ? 4 : i);
            var bitSize = 8 * byteSize;

            var bSize = typ.size * 8;
            var bTypeName = $"b{bSize}v{i}";
#>

#region <#= typeName #>

[Ex]
public static partial class math
{
    #pragma warning disable CS1718
    // ReSharper disable once EqualExpressionComparison
    [MethodImpl(256 | 512)]
    public static <#= bTypeName #> isNaN([This] <#= typeName #> a) => a != a;
    #pragma warning restore CS1718

    [MethodImpl(256 | 512)]
    public static <#= bTypeName #> isFinite([This] <#= typeName #> a) => abs(a) < <#= typ.simdComp #>.PositiveInfinity;

    [MethodImpl(256 | 512)]
    public static <#= bTypeName #> isInf([This] <#= typeName #> a)
    {
<#
            if (typ.simd)
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
            return new(simd.IsInfinity(a.vector).AsUInt<#= bSize #>());
<#
            }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.isInf()")) #>);
    }

    [MethodImpl(256 | 512)]
    public static <#= bTypeName #> isPosInf([This] <#= typeName #> a)
    {
<#
            if (typ.simd)
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
            return new(Vector<#= bitSize #>.Equals(a.vector, Vector<#= bitSize #>.Create(<#= typ.simdComp #>.PositiveInfinity)).AsUInt<#= bSize #>());
<#
            }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.isPosInf()")) #>);
    }

    [MethodImpl(256 | 512)]
    public static <#= bTypeName #> isNegInf([This] <#= typeName #> a)
    {
<#
            if (typ.simd)
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
            return new(Vector<#= bitSize #>.Equals(a.vector, Vector<#= bitSize #>.Create(<#= typ.simdComp #>.NegativeInfinity)).AsUInt<#= bSize #>());
<#
            }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.isNegInf()")) #>);
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> log([This] <#= typeName #> a)
    {
<#
            if (typ.simd)
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
            return new(simd.Log(a.vector));
<#
            }
#>
        return new(<#=
                string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.log()")) #>);
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> log2([This] <#= typeName #> a)
    {
<#
            if (typ.simd)
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
            return new(simd.Log2(a.vector));
<#
            }
#>
        return new(<#=
                string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.log2()")) #>);
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> log([This] <#= typeName #> a, <#= typeName #> b)
    {
<#
            if (typ.simd)
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
            return new(simd.Log(a.vector) / simd.Log(b.vector));
<#
            }
#>
        return new(<#=
                string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.log(b.{Typ.xyzw[n]})")) #>);
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> log10([This] <#= typeName #> a)
    {
<#
            if (typ.simd)
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
            return new(simd.Log10(a.vector));
<#
            }
#>
        return new(<#=
                string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.log10()")) #>);
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> exp([This] <#= typeName #> a)
    {
<#
            if (typ.simd)
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
            return new(simd.Exp(a.vector));
<#
            }
#>
        return new(<#=
                string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.exp()")) #>);
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> exp2([This] <#= typeName #> a)
    {
<#
            if (typ.simd)
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
            return new(simd.Exp2(a.vector));
<#
            }
#>
        return new(<#=
                string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.exp2()")) #>);
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> exp10([This] <#= typeName #> a)
    {
<#
            if (typ.simd)
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
            return new(simd.Exp10(a.vector));
<#
            }
#>
        return new(<#=
                string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.exp10()")) #>);
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> pow([This] <#= typeName #> a, <#= typeName #> b)
    {
<#
            if (typ.simd)
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
            return new(simd.Pow(a.vector, b.vector));
<#
            }
#>
        return new(<#=
                string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.pow(b.{Typ.xyzw[n]})")) #>);
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> pow([This] <#= typeName #> a, <#= typ.simdComp #> b)
    {
<#
            if (typ.simd)
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
            return new(simd.Pow(a.vector, b));
<#
            }
#>
        return new(<#=
                string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.pow(b)")) #>);
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> sqrt([This] <#= typeName #> a)
    {
<#
            if (typ.simd)
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
            return new(Vector<#= bitSize #>.Sqrt(a.vector));
<#
            }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.sqrt()")) #>);
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> rsqrt([This] <#= typeName #> a)
    {
<#
            if (typ.simd)
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
            return new(simd.RSqrt(a.vector));
<#
            }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.rsqrt()")) #>);
    }

    [MethodImpl(256 | 512)]
    public static <#= typ.compType #> length([This] <#= typeName #> a) => dot(a, a).sqrt();

    [MethodImpl(256 | 512)]
    public static <#= typ.compType #> distance([This] <#= typeName #> a, <#= typeName #> b) => length(b - a);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> normalize([This] <#= typeName #> a) => a * dot(a, a).rsqrt();

    [MethodImpl(256 | 512)]
    public static <#= typeName #> normalizeSafe([This] <#= typeName #> a, <#= typeName #> defaultValue = default)
    {
        var len = dot(a, a);
        return select(len > 1.175494351e-38<#= typ.suffix #>, a * rsqrt(len), defaultValue);
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> step(<#= typeName #> threshold, [This] <#= typeName #> a) =>
        select(a >= threshold, <#= typeName #>.One, default);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> refract(<#= typeName #> i, <#= typeName #> n, [This] <#= typ.simdComp #> indexOfRefraction)
    {
        var ni = dot(n, i);
        var k = (<#= typ.simdComp #>)(1.0<#= typ.suffix #> - indexOfRefraction * indexOfRefraction * (1.0<#= typ.suffix #> - ni * ni));
        return select(k >= 0.0<#= typ.suffix #>, indexOfRefraction * i - (<#= typ.simdComp #>)((<#= typ.simdComp #>)(indexOfRefraction * ni) + sqrt(k)) * n, default);
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> projectSafe([This] <#= typeName #> a, <#= typeName #> onto, <#= typeName #> defaultValue = default) 
    {
        var proj = project(a, onto);
        return select(all(isFinite(proj)), proj, defaultValue);
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> faceForward([This] <#= typeName #> n, <#= typeName #> i, <#= typeName #> ng) =>
        select(dot(ng, i) >= 0.0<#= typ.suffix #>, -n, n);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> sin([This] <#= typeName #> a)
    {
<#
            if (typ.simd)
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
            return new(simd.Sin(a.vector));
<#
            }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.sin()")) #>);
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> cos([This] <#= typeName #> a)
    {
<#
            if (typ.simd)
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
            return new(simd.Cos(a.vector));
<#
            }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.cos()")) #>);
    }

    [MethodImpl(256 | 512)]
    public static (<#= typeName #> sin, <#= typeName #> cos) sincos([This] <#= typeName #> a)
    {
<#
            if (typ.simd)
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
        {
            var (sin, cos) = simd.SinCos(a.vector);
            return (new(sin), new(cos));
        }
<#
            }
#>
        <#=
                string.Join(";\n        ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.sincos(out var sin{n}, out var cos{n})")) #>;
        return (
            new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"sin{n}")) #>),
            new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"cos{n}")) #>)
        );
    }

    [MethodImpl(256 | 512)]
    public static void sincos([This] <#= typeName #> a, out <#= typeName #> sin, out <#= typeName #> cos)
    {
<#
            if (typ.simd)
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
        {
            (sin.vector, cos.vector) = simd.SinCos(a.vector);
            return;
        }
<#
            }
#>
        <#=
                string.Join(";\n        ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.sincos(out var sin{n}, out var cos{n})")) #>;
        sin = new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"sin{n}")) #>);
        cos = new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"cos{n}")) #>);
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> tan([This] <#= typeName #> a)
    {
<#
            if (typ.simd)
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
            return new(simd.Tan(a.vector));
<#
            }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.tan()")) #>);
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> asin([This] <#= typeName #> a)
    {
<#
            if (typ.simd)
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
            return new(simd.Asin(a.vector));
<#
            }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.asin()")) #>);
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> acos([This] <#= typeName #> a)
    {
<#
            if (typ.simd)
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
            return new(simd.Acos(a.vector));
<#
            }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.acos()")) #>);
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> atan([This] <#= typeName #> a)
    {
<#
            if (typ.simd)
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
            return new(simd.Atan(a.vector));
<#
            }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.atan()")) #>);
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> atan2([This] <#= typeName #> a, <#= typeName #> b)
    {
<#
            if (typ.simd)
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
            return new(simd.Atan2(a.vector, b.vector));
<#
            }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.atan2(b.{Typ.xyzw[n]})")) #>);
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> sinh([This] <#= typeName #> a)
    {
<#
            if (typ.simd)
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
            return new(simd.Sinh(a.vector));
<#
            }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.sinh()")) #>);
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> cosh([This] <#= typeName #> a)
    {
<#
            if (typ.simd)
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
            return new(simd.Cosh(a.vector));
<#
            }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.cosh()")) #>);
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> tanh([This] <#= typeName #> a)
    {
<#
            if (typ.simd)
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
            return new(simd.Tanh(a.vector));
<#
            }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.tanh()")) #>);
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> asinh([This] <#= typeName #> a)
    {
<#
            if (typ.simd)
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
            return new(simd.Asinh(a.vector));
<#
            }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.asinh()")) #>);
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> acosh([This] <#= typeName #> a)
    {
<#
            if (typ.simd)
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
            return new(simd.Acosh(a.vector));
<#
            }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.acosh()")) #>);
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> atanh([This] <#= typeName #> a)
    {
<#
            if (typ.simd)
            {
#>
        if (Vector<#= bitSize #>.IsHardwareAccelerated)
            return new(simd.Atanh(a.vector));
<#
            }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.atanh()")) #>);
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> chgsign([This] <#= typeName #> a, <#= typeName #> b)
    {
        var sig = new <#= typ.maskType #><#= i #>(<#=
                    typ.name switch { "half" => "0x8000", "float" => "0x8000_0000", "double" => "0x8000_0000_0000_0000", _ => "" } #>).asf();
        return (b & sig) ^ a;
    }
}

#endregion // <#= typeName #>
<#
        }
    }
#>
