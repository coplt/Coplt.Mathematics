// generated by template, do not modify manually

namespace Coplt.Mathematics;

#region float2

public partial struct float2
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static float2 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277f); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static float2 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094f); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static float2 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009f);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static float2 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923f);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static float2 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846f);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static float2 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861f);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static float2 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144f);
    }
}

[Ex]
public static partial class math
{
    [MethodImpl(256 | 512)]
    public static float2 mod([This] float2 a, float2 b)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(simd.Mod(a.vector, b.vector));
        return new(a.x.mod(b.x), a.y.mod(b.y));
    }

    [MethodImpl(256 | 512)]
    public static float2 ceil([This] float2 a)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(Vector64.Ceiling(a.vector));
        return new(a.x.ceil(), a.y.ceil());
    }

    [MethodImpl(256 | 512)]
    public static float2 floor([This] float2 a)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(Vector64.Floor(a.vector));
        return new(a.x.floor(), a.y.floor());
    }

    [MethodImpl(256 | 512)]
    public static float2 round([This] float2 a)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(simd.Round(a.vector));
        return new(a.x.round(), a.y.round());
    }

    [MethodImpl(256 | 512)]
    public static float2 trunc([This] float2 a)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(simd.RoundToZero(a.vector));
        return new(a.x.trunc(), a.y.trunc());
    }

    [MethodImpl(256 | 512)]
    public static float2 frac([This] float2 a)
    {
        if (Vector64.IsHardwareAccelerated)
            return a - floor(a);
        return new(a.x.frac(), a.y.frac());
    }

    [MethodImpl(256 | 512)]
    public static float2 modf([This] float2 d, out float2 i)
    {
        if (Vector64.IsHardwareAccelerated)
        {
            i = trunc(d);
            return d - i;
        }
        float2 r = new(d.x.modf(out var i0), d.y.modf(out var i1));
        i = new(i0, i1);
        return r;
    }

    [MethodImpl(256 | 512)]
    public static float2 rcp([This] float2 a)
    {
        if (Vector64.IsHardwareAccelerated)
            return new(simd.Rcp(a.vector));
        return new(a.x.rcp(), a.y.rcp());
    }

    [MethodImpl(256 | 512)]
    public static float2 saturate([This] float2 a)
    {
        if (Vector64.IsHardwareAccelerated)
            return a.clamp(default, float2.One);
        return new(a.x.saturate(), a.y.saturate());
    }

    [MethodImpl(256 | 512)]
    public static float2 smoothstep(float2 min, float2 max, [This] float2 a)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * fnma(2.0f, t, 3.0f); // (3.0f - (2.0f * t))
    }

    [MethodImpl(256 | 512)]
    public static float2 reflect([This] float2 i, float2 n) => i - 2f * n * dot(i, n);

    [MethodImpl(256 | 512)]
    public static float2 project([This] float2 a, float2 onto) =>
        (float)(dot(a, onto) / dot(onto, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static float2 projectOnPlane([This] float2 a, float2 plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static float2 projectNormalized([This] float2 a, float2 onto) =>
        (float)(dot(a, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static float2 projectOnPlaneNormalized([This] float2 a, float2 plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static float2 radians([This] float2 a) => a * float2.DegToRad;

    [MethodImpl(256 | 512)]
    public static float2 degrees([This] float2 a) => a * float2.RadToDeg;

    [MethodImpl(256 | 512)]
    public static float2 wrap([This] float2 x, float2 min, float2 max)
    {
        if (Vector64.IsHardwareAccelerated)
        {
            var add = select(x >= float2.Zero, min, max);
            var off = x % (max - min);
            return add + off;
        }
        return new(x.x.wrap(min.x, max.x), x.y.wrap(min.y, max.y));
    }

    [MethodImpl(256 | 512)]
    public static float2 wrap([This] float2 x, float min, float max)
    {
        if (Vector64.IsHardwareAccelerated)
        {
            var add = select(x >= float2.Zero, min, max);
            var off = x % (max - min);
            return add + off;
        }
        return new(x.x.wrap(min, max), x.y.wrap(min, max));
    }
}

#endregion // float2

#region float3

public partial struct float3
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static float3 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277f); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static float3 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094f); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static float3 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009f);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static float3 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923f);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static float3 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846f);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static float3 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861f);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static float3 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144f);
    }
}

[Ex]
public static partial class math
{
    [MethodImpl(256 | 512)]
    public static float3 mod([This] float3 a, float3 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Mod(a.vector, b.vector) & Vector128.Create(-1, -1, -1, 0).AsSingle());
        return new(a.x.mod(b.x), a.y.mod(b.y), a.z.mod(b.z));
    }

    [MethodImpl(256 | 512)]
    public static float3 ceil([This] float3 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.Ceiling(a.vector));
        return new(a.x.ceil(), a.y.ceil(), a.z.ceil());
    }

    [MethodImpl(256 | 512)]
    public static float3 floor([This] float3 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.Floor(a.vector));
        return new(a.x.floor(), a.y.floor(), a.z.floor());
    }

    [MethodImpl(256 | 512)]
    public static float3 round([This] float3 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Round(a.vector));
        return new(a.x.round(), a.y.round(), a.z.round());
    }

    [MethodImpl(256 | 512)]
    public static float3 trunc([This] float3 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.RoundToZero(a.vector));
        return new(a.x.trunc(), a.y.trunc(), a.z.trunc());
    }

    [MethodImpl(256 | 512)]
    public static float3 frac([This] float3 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return a - floor(a);
        return new(a.x.frac(), a.y.frac(), a.z.frac());
    }

    [MethodImpl(256 | 512)]
    public static float3 modf([This] float3 d, out float3 i)
    {
        if (Vector128.IsHardwareAccelerated)
        {
            i = trunc(d);
            return d - i;
        }
        float3 r = new(d.x.modf(out var i0), d.y.modf(out var i1), d.z.modf(out var i2));
        i = new(i0, i1, i2);
        return r;
    }

    [MethodImpl(256 | 512)]
    public static float3 rcp([This] float3 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Rcp(a.vector));
        return new(a.x.rcp(), a.y.rcp(), a.z.rcp());
    }

    [MethodImpl(256 | 512)]
    public static float3 saturate([This] float3 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return a.clamp(default, float3.One);
        return new(a.x.saturate(), a.y.saturate(), a.z.saturate());
    }

    [MethodImpl(256 | 512)]
    public static float3 smoothstep(float3 min, float3 max, [This] float3 a)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * fnma(2.0f, t, 3.0f); // (3.0f - (2.0f * t))
    }

    [MethodImpl(256 | 512)]
    public static float3 reflect([This] float3 i, float3 n) => i - 2f * n * dot(i, n);

    [MethodImpl(256 | 512)]
    public static float3 project([This] float3 a, float3 onto) =>
        (float)(dot(a, onto) / dot(onto, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static float3 projectOnPlane([This] float3 a, float3 plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static float3 projectNormalized([This] float3 a, float3 onto) =>
        (float)(dot(a, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static float3 projectOnPlaneNormalized([This] float3 a, float3 plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static float3 radians([This] float3 a) => a * float3.DegToRad;

    [MethodImpl(256 | 512)]
    public static float3 degrees([This] float3 a) => a * float3.RadToDeg;

    [MethodImpl(256 | 512)]
    public static float3 wrap([This] float3 x, float3 min, float3 max)
    {
        if (Vector128.IsHardwareAccelerated)
        {
            var add = select(x >= float3.Zero, min, max);
            var off = x % (max - min);
            return add + off;
        }
        return new(x.x.wrap(min.x, max.x), x.y.wrap(min.y, max.y), x.z.wrap(min.z, max.z));
    }

    [MethodImpl(256 | 512)]
    public static float3 wrap([This] float3 x, float min, float max)
    {
        if (Vector128.IsHardwareAccelerated)
        {
            var add = select(x >= float3.Zero, min, max);
            var off = x % (max - min);
            return add + off;
        }
        return new(x.x.wrap(min, max), x.y.wrap(min, max), x.z.wrap(min, max));
    }
}

#endregion // float3

#region float4

public partial struct float4
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static float4 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277f); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static float4 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094f); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static float4 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009f);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static float4 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923f);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static float4 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846f);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static float4 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861f);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static float4 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144f);
    }
}

[Ex]
public static partial class math
{
    [MethodImpl(256 | 512)]
    public static float4 mod([This] float4 a, float4 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Mod(a.vector, b.vector));
        return new(a.x.mod(b.x), a.y.mod(b.y), a.z.mod(b.z), a.w.mod(b.w));
    }

    [MethodImpl(256 | 512)]
    public static float4 ceil([This] float4 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.Ceiling(a.vector));
        return new(a.x.ceil(), a.y.ceil(), a.z.ceil(), a.w.ceil());
    }

    [MethodImpl(256 | 512)]
    public static float4 floor([This] float4 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.Floor(a.vector));
        return new(a.x.floor(), a.y.floor(), a.z.floor(), a.w.floor());
    }

    [MethodImpl(256 | 512)]
    public static float4 round([This] float4 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Round(a.vector));
        return new(a.x.round(), a.y.round(), a.z.round(), a.w.round());
    }

    [MethodImpl(256 | 512)]
    public static float4 trunc([This] float4 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.RoundToZero(a.vector));
        return new(a.x.trunc(), a.y.trunc(), a.z.trunc(), a.w.trunc());
    }

    [MethodImpl(256 | 512)]
    public static float4 frac([This] float4 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return a - floor(a);
        return new(a.x.frac(), a.y.frac(), a.z.frac(), a.w.frac());
    }

    [MethodImpl(256 | 512)]
    public static float4 modf([This] float4 d, out float4 i)
    {
        if (Vector128.IsHardwareAccelerated)
        {
            i = trunc(d);
            return d - i;
        }
        float4 r = new(d.x.modf(out var i0), d.y.modf(out var i1), d.z.modf(out var i2), d.w.modf(out var i3));
        i = new(i0, i1, i2, i3);
        return r;
    }

    [MethodImpl(256 | 512)]
    public static float4 rcp([This] float4 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Rcp(a.vector));
        return new(a.x.rcp(), a.y.rcp(), a.z.rcp(), a.w.rcp());
    }

    [MethodImpl(256 | 512)]
    public static float4 saturate([This] float4 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return a.clamp(default, float4.One);
        return new(a.x.saturate(), a.y.saturate(), a.z.saturate(), a.w.saturate());
    }

    [MethodImpl(256 | 512)]
    public static float4 smoothstep(float4 min, float4 max, [This] float4 a)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * fnma(2.0f, t, 3.0f); // (3.0f - (2.0f * t))
    }

    [MethodImpl(256 | 512)]
    public static float4 reflect([This] float4 i, float4 n) => i - 2f * n * dot(i, n);

    [MethodImpl(256 | 512)]
    public static float4 project([This] float4 a, float4 onto) =>
        (float)(dot(a, onto) / dot(onto, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static float4 projectOnPlane([This] float4 a, float4 plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static float4 projectNormalized([This] float4 a, float4 onto) =>
        (float)(dot(a, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static float4 projectOnPlaneNormalized([This] float4 a, float4 plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static float4 radians([This] float4 a) => a * float4.DegToRad;

    [MethodImpl(256 | 512)]
    public static float4 degrees([This] float4 a) => a * float4.RadToDeg;

    [MethodImpl(256 | 512)]
    public static float4 wrap([This] float4 x, float4 min, float4 max)
    {
        if (Vector128.IsHardwareAccelerated)
        {
            var add = select(x >= float4.Zero, min, max);
            var off = x % (max - min);
            return add + off;
        }
        return new(x.x.wrap(min.x, max.x), x.y.wrap(min.y, max.y), x.z.wrap(min.z, max.z), x.w.wrap(min.w, max.w));
    }

    [MethodImpl(256 | 512)]
    public static float4 wrap([This] float4 x, float min, float max)
    {
        if (Vector128.IsHardwareAccelerated)
        {
            var add = select(x >= float4.Zero, min, max);
            var off = x % (max - min);
            return add + off;
        }
        return new(x.x.wrap(min, max), x.y.wrap(min, max), x.z.wrap(min, max), x.w.wrap(min, max));
    }
}

#endregion // float4

#region double2

public partial struct double2
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static double2 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static double2 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static double2 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static double2 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static double2 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static double2 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static double2 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144);
    }
}

[Ex]
public static partial class math
{
    [MethodImpl(256 | 512)]
    public static double2 mod([This] double2 a, double2 b)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Mod(a.vector, b.vector));
        return new(a.x.mod(b.x), a.y.mod(b.y));
    }

    [MethodImpl(256 | 512)]
    public static double2 ceil([This] double2 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.Ceiling(a.vector));
        return new(a.x.ceil(), a.y.ceil());
    }

    [MethodImpl(256 | 512)]
    public static double2 floor([This] double2 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(Vector128.Floor(a.vector));
        return new(a.x.floor(), a.y.floor());
    }

    [MethodImpl(256 | 512)]
    public static double2 round([This] double2 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Round(a.vector));
        return new(a.x.round(), a.y.round());
    }

    [MethodImpl(256 | 512)]
    public static double2 trunc([This] double2 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.RoundToZero(a.vector));
        return new(a.x.trunc(), a.y.trunc());
    }

    [MethodImpl(256 | 512)]
    public static double2 frac([This] double2 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return a - floor(a);
        return new(a.x.frac(), a.y.frac());
    }

    [MethodImpl(256 | 512)]
    public static double2 modf([This] double2 d, out double2 i)
    {
        if (Vector128.IsHardwareAccelerated)
        {
            i = trunc(d);
            return d - i;
        }
        double2 r = new(d.x.modf(out var i0), d.y.modf(out var i1));
        i = new(i0, i1);
        return r;
    }

    [MethodImpl(256 | 512)]
    public static double2 rcp([This] double2 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return new(simd.Rcp(a.vector));
        return new(a.x.rcp(), a.y.rcp());
    }

    [MethodImpl(256 | 512)]
    public static double2 saturate([This] double2 a)
    {
        if (Vector128.IsHardwareAccelerated)
            return a.clamp(default, double2.One);
        return new(a.x.saturate(), a.y.saturate());
    }

    [MethodImpl(256 | 512)]
    public static double2 smoothstep(double2 min, double2 max, [This] double2 a)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * fnma(2.0, t, 3.0); // (3.0 - (2.0 * t))
    }

    [MethodImpl(256 | 512)]
    public static double2 reflect([This] double2 i, double2 n) => i - 2 * n * dot(i, n);

    [MethodImpl(256 | 512)]
    public static double2 project([This] double2 a, double2 onto) =>
        (double)(dot(a, onto) / dot(onto, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static double2 projectOnPlane([This] double2 a, double2 plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static double2 projectNormalized([This] double2 a, double2 onto) =>
        (double)(dot(a, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static double2 projectOnPlaneNormalized([This] double2 a, double2 plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static double2 radians([This] double2 a) => a * double2.DegToRad;

    [MethodImpl(256 | 512)]
    public static double2 degrees([This] double2 a) => a * double2.RadToDeg;

    [MethodImpl(256 | 512)]
    public static double2 wrap([This] double2 x, double2 min, double2 max)
    {
        if (Vector128.IsHardwareAccelerated)
        {
            var add = select(x >= double2.Zero, min, max);
            var off = x % (max - min);
            return add + off;
        }
        return new(x.x.wrap(min.x, max.x), x.y.wrap(min.y, max.y));
    }

    [MethodImpl(256 | 512)]
    public static double2 wrap([This] double2 x, double min, double max)
    {
        if (Vector128.IsHardwareAccelerated)
        {
            var add = select(x >= double2.Zero, min, max);
            var off = x % (max - min);
            return add + off;
        }
        return new(x.x.wrap(min, max), x.y.wrap(min, max));
    }
}

#endregion // double2

#region double3

public partial struct double3
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static double3 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static double3 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static double3 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static double3 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static double3 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static double3 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static double3 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144);
    }
}

[Ex]
public static partial class math
{
    [MethodImpl(256 | 512)]
    public static double3 mod([This] double3 a, double3 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Mod(a.vector, b.vector) & Vector256.Create(-1, -1, -1, 0).AsDouble());
        return new(a.x.mod(b.x), a.y.mod(b.y), a.z.mod(b.z));
    }

    [MethodImpl(256 | 512)]
    public static double3 ceil([This] double3 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(Vector256.Ceiling(a.vector));
        return new(a.x.ceil(), a.y.ceil(), a.z.ceil());
    }

    [MethodImpl(256 | 512)]
    public static double3 floor([This] double3 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(Vector256.Floor(a.vector));
        return new(a.x.floor(), a.y.floor(), a.z.floor());
    }

    [MethodImpl(256 | 512)]
    public static double3 round([This] double3 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Round(a.vector));
        return new(a.x.round(), a.y.round(), a.z.round());
    }

    [MethodImpl(256 | 512)]
    public static double3 trunc([This] double3 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.RoundToZero(a.vector));
        return new(a.x.trunc(), a.y.trunc(), a.z.trunc());
    }

    [MethodImpl(256 | 512)]
    public static double3 frac([This] double3 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return a - floor(a);
        return new(a.x.frac(), a.y.frac(), a.z.frac());
    }

    [MethodImpl(256 | 512)]
    public static double3 modf([This] double3 d, out double3 i)
    {
        if (Vector256.IsHardwareAccelerated)
        {
            i = trunc(d);
            return d - i;
        }
        double3 r = new(d.x.modf(out var i0), d.y.modf(out var i1), d.z.modf(out var i2));
        i = new(i0, i1, i2);
        return r;
    }

    [MethodImpl(256 | 512)]
    public static double3 rcp([This] double3 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Rcp(a.vector));
        return new(a.x.rcp(), a.y.rcp(), a.z.rcp());
    }

    [MethodImpl(256 | 512)]
    public static double3 saturate([This] double3 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return a.clamp(default, double3.One);
        return new(a.x.saturate(), a.y.saturate(), a.z.saturate());
    }

    [MethodImpl(256 | 512)]
    public static double3 smoothstep(double3 min, double3 max, [This] double3 a)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * fnma(2.0, t, 3.0); // (3.0 - (2.0 * t))
    }

    [MethodImpl(256 | 512)]
    public static double3 reflect([This] double3 i, double3 n) => i - 2 * n * dot(i, n);

    [MethodImpl(256 | 512)]
    public static double3 project([This] double3 a, double3 onto) =>
        (double)(dot(a, onto) / dot(onto, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static double3 projectOnPlane([This] double3 a, double3 plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static double3 projectNormalized([This] double3 a, double3 onto) =>
        (double)(dot(a, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static double3 projectOnPlaneNormalized([This] double3 a, double3 plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static double3 radians([This] double3 a) => a * double3.DegToRad;

    [MethodImpl(256 | 512)]
    public static double3 degrees([This] double3 a) => a * double3.RadToDeg;

    [MethodImpl(256 | 512)]
    public static double3 wrap([This] double3 x, double3 min, double3 max)
    {
        if (Vector256.IsHardwareAccelerated)
        {
            var add = select(x >= double3.Zero, min, max);
            var off = x % (max - min);
            return add + off;
        }
        return new(x.x.wrap(min.x, max.x), x.y.wrap(min.y, max.y), x.z.wrap(min.z, max.z));
    }

    [MethodImpl(256 | 512)]
    public static double3 wrap([This] double3 x, double min, double max)
    {
        if (Vector256.IsHardwareAccelerated)
        {
            var add = select(x >= double3.Zero, min, max);
            var off = x % (max - min);
            return add + off;
        }
        return new(x.x.wrap(min, max), x.y.wrap(min, max), x.z.wrap(min, max));
    }
}

#endregion // double3

#region double4

public partial struct double4
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static double4 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static double4 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static double4 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static double4 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static double4 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static double4 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static double4 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144);
    }
}

[Ex]
public static partial class math
{
    [MethodImpl(256 | 512)]
    public static double4 mod([This] double4 a, double4 b)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Mod(a.vector, b.vector));
        return new(a.x.mod(b.x), a.y.mod(b.y), a.z.mod(b.z), a.w.mod(b.w));
    }

    [MethodImpl(256 | 512)]
    public static double4 ceil([This] double4 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(Vector256.Ceiling(a.vector));
        return new(a.x.ceil(), a.y.ceil(), a.z.ceil(), a.w.ceil());
    }

    [MethodImpl(256 | 512)]
    public static double4 floor([This] double4 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(Vector256.Floor(a.vector));
        return new(a.x.floor(), a.y.floor(), a.z.floor(), a.w.floor());
    }

    [MethodImpl(256 | 512)]
    public static double4 round([This] double4 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Round(a.vector));
        return new(a.x.round(), a.y.round(), a.z.round(), a.w.round());
    }

    [MethodImpl(256 | 512)]
    public static double4 trunc([This] double4 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.RoundToZero(a.vector));
        return new(a.x.trunc(), a.y.trunc(), a.z.trunc(), a.w.trunc());
    }

    [MethodImpl(256 | 512)]
    public static double4 frac([This] double4 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return a - floor(a);
        return new(a.x.frac(), a.y.frac(), a.z.frac(), a.w.frac());
    }

    [MethodImpl(256 | 512)]
    public static double4 modf([This] double4 d, out double4 i)
    {
        if (Vector256.IsHardwareAccelerated)
        {
            i = trunc(d);
            return d - i;
        }
        double4 r = new(d.x.modf(out var i0), d.y.modf(out var i1), d.z.modf(out var i2), d.w.modf(out var i3));
        i = new(i0, i1, i2, i3);
        return r;
    }

    [MethodImpl(256 | 512)]
    public static double4 rcp([This] double4 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return new(simd.Rcp(a.vector));
        return new(a.x.rcp(), a.y.rcp(), a.z.rcp(), a.w.rcp());
    }

    [MethodImpl(256 | 512)]
    public static double4 saturate([This] double4 a)
    {
        if (Vector256.IsHardwareAccelerated)
            return a.clamp(default, double4.One);
        return new(a.x.saturate(), a.y.saturate(), a.z.saturate(), a.w.saturate());
    }

    [MethodImpl(256 | 512)]
    public static double4 smoothstep(double4 min, double4 max, [This] double4 a)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * fnma(2.0, t, 3.0); // (3.0 - (2.0 * t))
    }

    [MethodImpl(256 | 512)]
    public static double4 reflect([This] double4 i, double4 n) => i - 2 * n * dot(i, n);

    [MethodImpl(256 | 512)]
    public static double4 project([This] double4 a, double4 onto) =>
        (double)(dot(a, onto) / dot(onto, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static double4 projectOnPlane([This] double4 a, double4 plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static double4 projectNormalized([This] double4 a, double4 onto) =>
        (double)(dot(a, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static double4 projectOnPlaneNormalized([This] double4 a, double4 plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static double4 radians([This] double4 a) => a * double4.DegToRad;

    [MethodImpl(256 | 512)]
    public static double4 degrees([This] double4 a) => a * double4.RadToDeg;

    [MethodImpl(256 | 512)]
    public static double4 wrap([This] double4 x, double4 min, double4 max)
    {
        if (Vector256.IsHardwareAccelerated)
        {
            var add = select(x >= double4.Zero, min, max);
            var off = x % (max - min);
            return add + off;
        }
        return new(x.x.wrap(min.x, max.x), x.y.wrap(min.y, max.y), x.z.wrap(min.z, max.z), x.w.wrap(min.w, max.w));
    }

    [MethodImpl(256 | 512)]
    public static double4 wrap([This] double4 x, double min, double max)
    {
        if (Vector256.IsHardwareAccelerated)
        {
            var add = select(x >= double4.Zero, min, max);
            var off = x % (max - min);
            return add + off;
        }
        return new(x.x.wrap(min, max), x.y.wrap(min, max), x.z.wrap(min, max), x.w.wrap(min, max));
    }
}

#endregion // double4

#region decimal2

public partial struct decimal2
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static decimal2 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277m); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static decimal2 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094m); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static decimal2 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009m);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static decimal2 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923m);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static decimal2 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846m);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static decimal2 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861m);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static decimal2 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144m);
    }
}

[Ex]
public static partial class math
{
    [MethodImpl(256 | 512)]
    public static decimal2 mod([This] decimal2 a, decimal2 b)
    {
        return new(a.x.mod(b.x), a.y.mod(b.y));
    }

    [MethodImpl(256 | 512)]
    public static decimal2 ceil([This] decimal2 a)
    {
        return new(a.x.ceil(), a.y.ceil());
    }

    [MethodImpl(256 | 512)]
    public static decimal2 floor([This] decimal2 a)
    {
        return new(a.x.floor(), a.y.floor());
    }

    [MethodImpl(256 | 512)]
    public static decimal2 round([This] decimal2 a)
    {
        return new(a.x.round(), a.y.round());
    }

    [MethodImpl(256 | 512)]
    public static decimal2 trunc([This] decimal2 a)
    {
        return new(a.x.trunc(), a.y.trunc());
    }

    [MethodImpl(256 | 512)]
    public static decimal2 frac([This] decimal2 a)
    {
        return new(a.x.frac(), a.y.frac());
    }

    [MethodImpl(256 | 512)]
    public static decimal2 modf([This] decimal2 d, out decimal2 i)
    {
        decimal2 r = new(d.x.modf(out var i0), d.y.modf(out var i1));
        i = new(i0, i1);
        return r;
    }

    [MethodImpl(256 | 512)]
    public static decimal2 rcp([This] decimal2 a)
    {
        return new(a.x.rcp(), a.y.rcp());
    }

    [MethodImpl(256 | 512)]
    public static decimal2 saturate([This] decimal2 a)
    {
        return new(a.x.saturate(), a.y.saturate());
    }

    [MethodImpl(256 | 512)]
    public static decimal2 smoothstep(decimal2 min, decimal2 max, [This] decimal2 a)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * fnma(2.0m, t, 3.0m); // (3.0m - (2.0m * t))
    }

    [MethodImpl(256 | 512)]
    public static decimal2 reflect([This] decimal2 i, decimal2 n) => i - 2m * n * dot(i, n);

    [MethodImpl(256 | 512)]
    public static decimal2 project([This] decimal2 a, decimal2 onto) =>
        (decimal)(dot(a, onto) / dot(onto, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static decimal2 projectOnPlane([This] decimal2 a, decimal2 plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static decimal2 projectNormalized([This] decimal2 a, decimal2 onto) =>
        (decimal)(dot(a, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static decimal2 projectOnPlaneNormalized([This] decimal2 a, decimal2 plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static decimal2 radians([This] decimal2 a) => a * decimal2.DegToRad;

    [MethodImpl(256 | 512)]
    public static decimal2 degrees([This] decimal2 a) => a * decimal2.RadToDeg;

    [MethodImpl(256 | 512)]
    public static decimal2 wrap([This] decimal2 x, decimal2 min, decimal2 max)
    {
        return new(x.x.wrap(min.x, max.x), x.y.wrap(min.y, max.y));
    }

    [MethodImpl(256 | 512)]
    public static decimal2 wrap([This] decimal2 x, decimal min, decimal max)
    {
        return new(x.x.wrap(min, max), x.y.wrap(min, max));
    }
}

#endregion // decimal2

#region decimal3

public partial struct decimal3
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static decimal3 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277m); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static decimal3 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094m); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static decimal3 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009m);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static decimal3 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923m);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static decimal3 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846m);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static decimal3 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861m);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static decimal3 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144m);
    }
}

[Ex]
public static partial class math
{
    [MethodImpl(256 | 512)]
    public static decimal3 mod([This] decimal3 a, decimal3 b)
    {
        return new(a.x.mod(b.x), a.y.mod(b.y), a.z.mod(b.z));
    }

    [MethodImpl(256 | 512)]
    public static decimal3 ceil([This] decimal3 a)
    {
        return new(a.x.ceil(), a.y.ceil(), a.z.ceil());
    }

    [MethodImpl(256 | 512)]
    public static decimal3 floor([This] decimal3 a)
    {
        return new(a.x.floor(), a.y.floor(), a.z.floor());
    }

    [MethodImpl(256 | 512)]
    public static decimal3 round([This] decimal3 a)
    {
        return new(a.x.round(), a.y.round(), a.z.round());
    }

    [MethodImpl(256 | 512)]
    public static decimal3 trunc([This] decimal3 a)
    {
        return new(a.x.trunc(), a.y.trunc(), a.z.trunc());
    }

    [MethodImpl(256 | 512)]
    public static decimal3 frac([This] decimal3 a)
    {
        return new(a.x.frac(), a.y.frac(), a.z.frac());
    }

    [MethodImpl(256 | 512)]
    public static decimal3 modf([This] decimal3 d, out decimal3 i)
    {
        decimal3 r = new(d.x.modf(out var i0), d.y.modf(out var i1), d.z.modf(out var i2));
        i = new(i0, i1, i2);
        return r;
    }

    [MethodImpl(256 | 512)]
    public static decimal3 rcp([This] decimal3 a)
    {
        return new(a.x.rcp(), a.y.rcp(), a.z.rcp());
    }

    [MethodImpl(256 | 512)]
    public static decimal3 saturate([This] decimal3 a)
    {
        return new(a.x.saturate(), a.y.saturate(), a.z.saturate());
    }

    [MethodImpl(256 | 512)]
    public static decimal3 smoothstep(decimal3 min, decimal3 max, [This] decimal3 a)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * fnma(2.0m, t, 3.0m); // (3.0m - (2.0m * t))
    }

    [MethodImpl(256 | 512)]
    public static decimal3 reflect([This] decimal3 i, decimal3 n) => i - 2m * n * dot(i, n);

    [MethodImpl(256 | 512)]
    public static decimal3 project([This] decimal3 a, decimal3 onto) =>
        (decimal)(dot(a, onto) / dot(onto, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static decimal3 projectOnPlane([This] decimal3 a, decimal3 plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static decimal3 projectNormalized([This] decimal3 a, decimal3 onto) =>
        (decimal)(dot(a, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static decimal3 projectOnPlaneNormalized([This] decimal3 a, decimal3 plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static decimal3 radians([This] decimal3 a) => a * decimal3.DegToRad;

    [MethodImpl(256 | 512)]
    public static decimal3 degrees([This] decimal3 a) => a * decimal3.RadToDeg;

    [MethodImpl(256 | 512)]
    public static decimal3 wrap([This] decimal3 x, decimal3 min, decimal3 max)
    {
        return new(x.x.wrap(min.x, max.x), x.y.wrap(min.y, max.y), x.z.wrap(min.z, max.z));
    }

    [MethodImpl(256 | 512)]
    public static decimal3 wrap([This] decimal3 x, decimal min, decimal max)
    {
        return new(x.x.wrap(min, max), x.y.wrap(min, max), x.z.wrap(min, max));
    }
}

#endregion // decimal3

#region decimal4

public partial struct decimal4
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static decimal4 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277m); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static decimal4 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094m); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static decimal4 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009m);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static decimal4 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923m);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static decimal4 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846m);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static decimal4 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861m);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static decimal4 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144m);
    }
}

[Ex]
public static partial class math
{
    [MethodImpl(256 | 512)]
    public static decimal4 mod([This] decimal4 a, decimal4 b)
    {
        return new(a.x.mod(b.x), a.y.mod(b.y), a.z.mod(b.z), a.w.mod(b.w));
    }

    [MethodImpl(256 | 512)]
    public static decimal4 ceil([This] decimal4 a)
    {
        return new(a.x.ceil(), a.y.ceil(), a.z.ceil(), a.w.ceil());
    }

    [MethodImpl(256 | 512)]
    public static decimal4 floor([This] decimal4 a)
    {
        return new(a.x.floor(), a.y.floor(), a.z.floor(), a.w.floor());
    }

    [MethodImpl(256 | 512)]
    public static decimal4 round([This] decimal4 a)
    {
        return new(a.x.round(), a.y.round(), a.z.round(), a.w.round());
    }

    [MethodImpl(256 | 512)]
    public static decimal4 trunc([This] decimal4 a)
    {
        return new(a.x.trunc(), a.y.trunc(), a.z.trunc(), a.w.trunc());
    }

    [MethodImpl(256 | 512)]
    public static decimal4 frac([This] decimal4 a)
    {
        return new(a.x.frac(), a.y.frac(), a.z.frac(), a.w.frac());
    }

    [MethodImpl(256 | 512)]
    public static decimal4 modf([This] decimal4 d, out decimal4 i)
    {
        decimal4 r = new(d.x.modf(out var i0), d.y.modf(out var i1), d.z.modf(out var i2), d.w.modf(out var i3));
        i = new(i0, i1, i2, i3);
        return r;
    }

    [MethodImpl(256 | 512)]
    public static decimal4 rcp([This] decimal4 a)
    {
        return new(a.x.rcp(), a.y.rcp(), a.z.rcp(), a.w.rcp());
    }

    [MethodImpl(256 | 512)]
    public static decimal4 saturate([This] decimal4 a)
    {
        return new(a.x.saturate(), a.y.saturate(), a.z.saturate(), a.w.saturate());
    }

    [MethodImpl(256 | 512)]
    public static decimal4 smoothstep(decimal4 min, decimal4 max, [This] decimal4 a)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * fnma(2.0m, t, 3.0m); // (3.0m - (2.0m * t))
    }

    [MethodImpl(256 | 512)]
    public static decimal4 reflect([This] decimal4 i, decimal4 n) => i - 2m * n * dot(i, n);

    [MethodImpl(256 | 512)]
    public static decimal4 project([This] decimal4 a, decimal4 onto) =>
        (decimal)(dot(a, onto) / dot(onto, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static decimal4 projectOnPlane([This] decimal4 a, decimal4 plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static decimal4 projectNormalized([This] decimal4 a, decimal4 onto) =>
        (decimal)(dot(a, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static decimal4 projectOnPlaneNormalized([This] decimal4 a, decimal4 plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static decimal4 radians([This] decimal4 a) => a * decimal4.DegToRad;

    [MethodImpl(256 | 512)]
    public static decimal4 degrees([This] decimal4 a) => a * decimal4.RadToDeg;

    [MethodImpl(256 | 512)]
    public static decimal4 wrap([This] decimal4 x, decimal4 min, decimal4 max)
    {
        return new(x.x.wrap(min.x, max.x), x.y.wrap(min.y, max.y), x.z.wrap(min.z, max.z), x.w.wrap(min.w, max.w));
    }

    [MethodImpl(256 | 512)]
    public static decimal4 wrap([This] decimal4 x, decimal min, decimal max)
    {
        return new(x.x.wrap(min, max), x.y.wrap(min, max), x.z.wrap(min, max), x.w.wrap(min, max));
    }
}

#endregion // decimal4

#region half2

public partial struct half2
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static half2 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277f.half()); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static half2 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094f.half()); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static half2 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009f.half());
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static half2 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923f.half());
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static half2 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846f.half());
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static half2 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861f.half());
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static half2 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144f.half());
    }
}

[Ex]
public static partial class math
{
    [MethodImpl(256 | 512)]
    public static half2 mod([This] half2 a, half2 b)
    {
        return new(a.x.mod(b.x), a.y.mod(b.y));
    }

    [MethodImpl(256 | 512)]
    public static half2 ceil([This] half2 a)
    {
        return new(a.x.ceil(), a.y.ceil());
    }

    [MethodImpl(256 | 512)]
    public static half2 floor([This] half2 a)
    {
        return new(a.x.floor(), a.y.floor());
    }

    [MethodImpl(256 | 512)]
    public static half2 round([This] half2 a)
    {
        return new(a.x.round(), a.y.round());
    }

    [MethodImpl(256 | 512)]
    public static half2 trunc([This] half2 a)
    {
        return new(a.x.trunc(), a.y.trunc());
    }

    [MethodImpl(256 | 512)]
    public static half2 frac([This] half2 a)
    {
        return new(a.x.frac(), a.y.frac());
    }

    [MethodImpl(256 | 512)]
    public static half2 modf([This] half2 d, out half2 i)
    {
        half2 r = new(d.x.modf(out var i0), d.y.modf(out var i1));
        i = new(i0, i1);
        return r;
    }

    [MethodImpl(256 | 512)]
    public static half2 rcp([This] half2 a)
    {
        return new(a.x.rcp(), a.y.rcp());
    }

    [MethodImpl(256 | 512)]
    public static half2 saturate([This] half2 a)
    {
        return new(a.x.saturate(), a.y.saturate());
    }

    [MethodImpl(256 | 512)]
    public static half2 smoothstep(half2 min, half2 max, [This] half2 a)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * fnma(2.0f.half(), t, 3.0f.half()); // (3.0f.half() - (2.0f.half() * t))
    }

    [MethodImpl(256 | 512)]
    public static half2 reflect([This] half2 i, half2 n) => i - 2f.half() * n * dot(i, n);

    [MethodImpl(256 | 512)]
    public static half2 project([This] half2 a, half2 onto) =>
        (half)(dot(a, onto) / dot(onto, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static half2 projectOnPlane([This] half2 a, half2 plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static half2 projectNormalized([This] half2 a, half2 onto) =>
        (half)(dot(a, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static half2 projectOnPlaneNormalized([This] half2 a, half2 plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static half2 radians([This] half2 a) => a * half2.DegToRad;

    [MethodImpl(256 | 512)]
    public static half2 degrees([This] half2 a) => a * half2.RadToDeg;

    [MethodImpl(256 | 512)]
    public static half2 wrap([This] half2 x, half2 min, half2 max)
    {
        return new(x.x.wrap(min.x, max.x), x.y.wrap(min.y, max.y));
    }

    [MethodImpl(256 | 512)]
    public static half2 wrap([This] half2 x, half min, half max)
    {
        return new(x.x.wrap(min, max), x.y.wrap(min, max));
    }
}

#endregion // half2

#region half3

public partial struct half3
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static half3 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277f.half()); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static half3 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094f.half()); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static half3 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009f.half());
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static half3 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923f.half());
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static half3 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846f.half());
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static half3 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861f.half());
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static half3 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144f.half());
    }
}

[Ex]
public static partial class math
{
    [MethodImpl(256 | 512)]
    public static half3 mod([This] half3 a, half3 b)
    {
        return new(a.x.mod(b.x), a.y.mod(b.y), a.z.mod(b.z));
    }

    [MethodImpl(256 | 512)]
    public static half3 ceil([This] half3 a)
    {
        return new(a.x.ceil(), a.y.ceil(), a.z.ceil());
    }

    [MethodImpl(256 | 512)]
    public static half3 floor([This] half3 a)
    {
        return new(a.x.floor(), a.y.floor(), a.z.floor());
    }

    [MethodImpl(256 | 512)]
    public static half3 round([This] half3 a)
    {
        return new(a.x.round(), a.y.round(), a.z.round());
    }

    [MethodImpl(256 | 512)]
    public static half3 trunc([This] half3 a)
    {
        return new(a.x.trunc(), a.y.trunc(), a.z.trunc());
    }

    [MethodImpl(256 | 512)]
    public static half3 frac([This] half3 a)
    {
        return new(a.x.frac(), a.y.frac(), a.z.frac());
    }

    [MethodImpl(256 | 512)]
    public static half3 modf([This] half3 d, out half3 i)
    {
        half3 r = new(d.x.modf(out var i0), d.y.modf(out var i1), d.z.modf(out var i2));
        i = new(i0, i1, i2);
        return r;
    }

    [MethodImpl(256 | 512)]
    public static half3 rcp([This] half3 a)
    {
        return new(a.x.rcp(), a.y.rcp(), a.z.rcp());
    }

    [MethodImpl(256 | 512)]
    public static half3 saturate([This] half3 a)
    {
        return new(a.x.saturate(), a.y.saturate(), a.z.saturate());
    }

    [MethodImpl(256 | 512)]
    public static half3 smoothstep(half3 min, half3 max, [This] half3 a)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * fnma(2.0f.half(), t, 3.0f.half()); // (3.0f.half() - (2.0f.half() * t))
    }

    [MethodImpl(256 | 512)]
    public static half3 reflect([This] half3 i, half3 n) => i - 2f.half() * n * dot(i, n);

    [MethodImpl(256 | 512)]
    public static half3 project([This] half3 a, half3 onto) =>
        (half)(dot(a, onto) / dot(onto, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static half3 projectOnPlane([This] half3 a, half3 plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static half3 projectNormalized([This] half3 a, half3 onto) =>
        (half)(dot(a, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static half3 projectOnPlaneNormalized([This] half3 a, half3 plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static half3 radians([This] half3 a) => a * half3.DegToRad;

    [MethodImpl(256 | 512)]
    public static half3 degrees([This] half3 a) => a * half3.RadToDeg;

    [MethodImpl(256 | 512)]
    public static half3 wrap([This] half3 x, half3 min, half3 max)
    {
        return new(x.x.wrap(min.x, max.x), x.y.wrap(min.y, max.y), x.z.wrap(min.z, max.z));
    }

    [MethodImpl(256 | 512)]
    public static half3 wrap([This] half3 x, half min, half max)
    {
        return new(x.x.wrap(min, max), x.y.wrap(min, max), x.z.wrap(min, max));
    }
}

#endregion // half3

#region half4

public partial struct half4
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static half4 E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277f.half()); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static half4 Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094f.half()); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static half4 Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009f.half());
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static half4 PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923f.half());
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static half4 Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846f.half());
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static half4 RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861f.half());
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static half4 DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144f.half());
    }
}

[Ex]
public static partial class math
{
    [MethodImpl(256 | 512)]
    public static half4 mod([This] half4 a, half4 b)
    {
        return new(a.x.mod(b.x), a.y.mod(b.y), a.z.mod(b.z), a.w.mod(b.w));
    }

    [MethodImpl(256 | 512)]
    public static half4 ceil([This] half4 a)
    {
        return new(a.x.ceil(), a.y.ceil(), a.z.ceil(), a.w.ceil());
    }

    [MethodImpl(256 | 512)]
    public static half4 floor([This] half4 a)
    {
        return new(a.x.floor(), a.y.floor(), a.z.floor(), a.w.floor());
    }

    [MethodImpl(256 | 512)]
    public static half4 round([This] half4 a)
    {
        return new(a.x.round(), a.y.round(), a.z.round(), a.w.round());
    }

    [MethodImpl(256 | 512)]
    public static half4 trunc([This] half4 a)
    {
        return new(a.x.trunc(), a.y.trunc(), a.z.trunc(), a.w.trunc());
    }

    [MethodImpl(256 | 512)]
    public static half4 frac([This] half4 a)
    {
        return new(a.x.frac(), a.y.frac(), a.z.frac(), a.w.frac());
    }

    [MethodImpl(256 | 512)]
    public static half4 modf([This] half4 d, out half4 i)
    {
        half4 r = new(d.x.modf(out var i0), d.y.modf(out var i1), d.z.modf(out var i2), d.w.modf(out var i3));
        i = new(i0, i1, i2, i3);
        return r;
    }

    [MethodImpl(256 | 512)]
    public static half4 rcp([This] half4 a)
    {
        return new(a.x.rcp(), a.y.rcp(), a.z.rcp(), a.w.rcp());
    }

    [MethodImpl(256 | 512)]
    public static half4 saturate([This] half4 a)
    {
        return new(a.x.saturate(), a.y.saturate(), a.z.saturate(), a.w.saturate());
    }

    [MethodImpl(256 | 512)]
    public static half4 smoothstep(half4 min, half4 max, [This] half4 a)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * fnma(2.0f.half(), t, 3.0f.half()); // (3.0f.half() - (2.0f.half() * t))
    }

    [MethodImpl(256 | 512)]
    public static half4 reflect([This] half4 i, half4 n) => i - 2f.half() * n * dot(i, n);

    [MethodImpl(256 | 512)]
    public static half4 project([This] half4 a, half4 onto) =>
        (half)(dot(a, onto) / dot(onto, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static half4 projectOnPlane([This] half4 a, half4 plane_normal) => 
        a - project(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static half4 projectNormalized([This] half4 a, half4 onto) =>
        (half)(dot(a, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static half4 projectOnPlaneNormalized([This] half4 a, half4 plane_normal) => 
        a - projectNormalized(a, plane_normal);

    [MethodImpl(256 | 512)]
    public static half4 radians([This] half4 a) => a * half4.DegToRad;

    [MethodImpl(256 | 512)]
    public static half4 degrees([This] half4 a) => a * half4.RadToDeg;

    [MethodImpl(256 | 512)]
    public static half4 wrap([This] half4 x, half4 min, half4 max)
    {
        return new(x.x.wrap(min.x, max.x), x.y.wrap(min.y, max.y), x.z.wrap(min.z, max.z), x.w.wrap(min.w, max.w));
    }

    [MethodImpl(256 | 512)]
    public static half4 wrap([This] half4 x, half min, half max)
    {
        return new(x.x.wrap(min, max), x.y.wrap(min, max), x.z.wrap(min, max), x.w.wrap(min, max));
    }
}

#endregion // half4
