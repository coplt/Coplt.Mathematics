// generated by template, do not modify manually

namespace Coplt.Mathematics.Simd;

public static partial class simd_math
{
    #region Mod

    #region Vector64<f32>

    [MethodImpl(256 | 512)]
    public static Vector64<f32> Mod(Vector64<f32> x, Vector64<f32> y)
    {
        var div = x / y;
        var flr = Vector64.Floor(div);
        return simd.Fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static Vector64<f32> Mod(Vector64<f32> x, f32 y)
    {
        var div = x / y;
        var flr = Vector64.Floor(div);
        return simd.Fnma(flr, Vector64.Create(y), x);
    }

    #endregion

    #region Vector128<f32>

    [MethodImpl(256 | 512)]
    public static Vector128<f32> Mod(Vector128<f32> x, Vector128<f32> y)
    {
        var div = x / y;
        var flr = Vector128.Floor(div);
        return simd.Fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static Vector128<f32> Mod(Vector128<f32> x, f32 y)
    {
        var div = x / y;
        var flr = Vector128.Floor(div);
        return simd.Fnma(flr, Vector128.Create(y), x);
    }

    #endregion

    #region Vector256<f32>

    [MethodImpl(256 | 512)]
    public static Vector256<f32> Mod(Vector256<f32> x, Vector256<f32> y)
    {
        var div = x / y;
        var flr = Vector256.Floor(div);
        return simd.Fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static Vector256<f32> Mod(Vector256<f32> x, f32 y)
    {
        var div = x / y;
        var flr = Vector256.Floor(div);
        return simd.Fnma(flr, Vector256.Create(y), x);
    }

    #endregion

    #region Vector512<f32>

    [MethodImpl(256 | 512)]
    public static Vector512<f32> Mod(Vector512<f32> x, Vector512<f32> y)
    {
        var div = x / y;
        var flr = Vector512.Floor(div);
        return simd.Fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static Vector512<f32> Mod(Vector512<f32> x, f32 y)
    {
        var div = x / y;
        var flr = Vector512.Floor(div);
        return simd.Fnma(flr, Vector512.Create(y), x);
    }

    #endregion

    #region Vector128<f64>

    [MethodImpl(256 | 512)]
    public static Vector128<f64> Mod(Vector128<f64> x, Vector128<f64> y)
    {
        var div = x / y;
        var flr = Vector128.Floor(div);
        return simd.Fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static Vector128<f64> Mod(Vector128<f64> x, f64 y)
    {
        var div = x / y;
        var flr = Vector128.Floor(div);
        return simd.Fnma(flr, Vector128.Create(y), x);
    }

    #endregion

    #region Vector256<f64>

    [MethodImpl(256 | 512)]
    public static Vector256<f64> Mod(Vector256<f64> x, Vector256<f64> y)
    {
        var div = x / y;
        var flr = Vector256.Floor(div);
        return simd.Fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static Vector256<f64> Mod(Vector256<f64> x, f64 y)
    {
        var div = x / y;
        var flr = Vector256.Floor(div);
        return simd.Fnma(flr, Vector256.Create(y), x);
    }

    #endregion

    #region Vector512<f64>

    [MethodImpl(256 | 512)]
    public static Vector512<f64> Mod(Vector512<f64> x, Vector512<f64> y)
    {
        var div = x / y;
        var flr = Vector512.Floor(div);
        return simd.Fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static Vector512<f64> Mod(Vector512<f64> x, f64 y)
    {
        var div = x / y;
        var flr = Vector512.Floor(div);
        return simd.Fnma(flr, Vector512.Create(y), x);
    }

    #endregion

    #endregion

    #region Rem

    #region Vector64<f32>

    [MethodImpl(256 | 512)]
    public static Vector64<f32> Rem(Vector64<f32> x, Vector64<f32> y)
    {
        var div = x / y;
        var flr = simd.RoundToZero(div);
        return simd.Fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static Vector64<f32> Rem(Vector64<f32> x, f32 y)
    {
        var div = x / y;
        var flr = simd.RoundToZero(div);
        return simd.Fnma(flr, Vector64.Create(y), x);
    }

    #endregion

    #region Vector128<f32>

    [MethodImpl(256 | 512)]
    public static Vector128<f32> Rem(Vector128<f32> x, Vector128<f32> y)
    {
        var div = x / y;
        var flr = simd.RoundToZero(div);
        return simd.Fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static Vector128<f32> Rem(Vector128<f32> x, f32 y)
    {
        var div = x / y;
        var flr = simd.RoundToZero(div);
        return simd.Fnma(flr, Vector128.Create(y), x);
    }

    #endregion

    #region Vector256<f32>

    [MethodImpl(256 | 512)]
    public static Vector256<f32> Rem(Vector256<f32> x, Vector256<f32> y)
    {
        var div = x / y;
        var flr = simd.RoundToZero(div);
        return simd.Fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static Vector256<f32> Rem(Vector256<f32> x, f32 y)
    {
        var div = x / y;
        var flr = simd.RoundToZero(div);
        return simd.Fnma(flr, Vector256.Create(y), x);
    }

    #endregion

    #region Vector512<f32>

    [MethodImpl(256 | 512)]
    public static Vector512<f32> Rem(Vector512<f32> x, Vector512<f32> y)
    {
        var div = x / y;
        var flr = simd.RoundToZero(div);
        return simd.Fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static Vector512<f32> Rem(Vector512<f32> x, f32 y)
    {
        var div = x / y;
        var flr = simd.RoundToZero(div);
        return simd.Fnma(flr, Vector512.Create(y), x);
    }

    #endregion

    #region Vector128<f64>

    [MethodImpl(256 | 512)]
    public static Vector128<f64> Rem(Vector128<f64> x, Vector128<f64> y)
    {
        var div = x / y;
        var flr = simd.RoundToZero(div);
        return simd.Fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static Vector128<f64> Rem(Vector128<f64> x, f64 y)
    {
        var div = x / y;
        var flr = simd.RoundToZero(div);
        return simd.Fnma(flr, Vector128.Create(y), x);
    }

    #endregion

    #region Vector256<f64>

    [MethodImpl(256 | 512)]
    public static Vector256<f64> Rem(Vector256<f64> x, Vector256<f64> y)
    {
        var div = x / y;
        var flr = simd.RoundToZero(div);
        return simd.Fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static Vector256<f64> Rem(Vector256<f64> x, f64 y)
    {
        var div = x / y;
        var flr = simd.RoundToZero(div);
        return simd.Fnma(flr, Vector256.Create(y), x);
    }

    #endregion

    #region Vector512<f64>

    [MethodImpl(256 | 512)]
    public static Vector512<f64> Rem(Vector512<f64> x, Vector512<f64> y)
    {
        var div = x / y;
        var flr = simd.RoundToZero(div);
        return simd.Fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static Vector512<f64> Rem(Vector512<f64> x, f64 y)
    {
        var div = x / y;
        var flr = simd.RoundToZero(div);
        return simd.Fnma(flr, Vector512.Create(y), x);
    }

    #endregion

    #endregion

    #region Wrap

    #region Vector64<f32>

    [MethodImpl(256 | 512)]
    public static Vector64<f32> Wrap(Vector64<f32> x, Vector64<f32> min, Vector64<f32> max)
    {
        var add = Vector64.ConditionalSelect(Vector64.GreaterThanOrEqual(x, default), min, max);
        var off = Rem(x, max - min);
        return add + off;
    }

    [MethodImpl(256 | 512)]
    public static Vector64<f32> Wrap(Vector64<f32> x, f32 min, f32 max)
    {
        var add = Vector64.ConditionalSelect(Vector64.GreaterThanOrEqual(x, default), Vector64.Create(min), Vector64.Create(max));
        var off = Rem(x, max - min);
        return add + off;
    }

    [MethodImpl(256 | 512)]
    public static Vector64<f32> Wrap0ToPi(Vector64<f32> x)
    {
        var add = x + (Vector64.LessThan(x, default) & Vector64.Create(math.F_PI));
        var div = x * math.F_1_Div_PI;
        var flr = simd.RoundToZero(div);
        return simd.Fnma(flr, Vector64.Create(math.F_PI), add);
    }

    [MethodImpl(256 | 512)]
    public static Vector64<f32> Wrap0To2Pi(Vector64<f32> x)
    {
        var add = x + (Vector64.LessThan(x, default) & Vector64.Create(math.F_2_PI));
        var div = x * math.F_1_Div_2_PI;
        var flr = simd.RoundToZero(div);
        return simd.Fnma(flr, Vector64.Create(math.F_2_PI), add);
    }

    [MethodImpl(256 | 512)]
    public static Vector64<f32> Wrap0To4Pi(Vector64<f32> x)
    {
        var add = x + (Vector64.LessThan(x, default) & Vector64.Create(math.F_4_PI));
        var div = x * math.F_1_Div_4_PI;
        var flr = simd.RoundToZero(div);
        return simd.Fnma(flr, Vector64.Create(math.F_4_PI), add);
    }

    #endregion

    #region Vector128<f32>

    [MethodImpl(256 | 512)]
    public static Vector128<f32> Wrap(Vector128<f32> x, Vector128<f32> min, Vector128<f32> max)
    {
        var add = Vector128.ConditionalSelect(Vector128.GreaterThanOrEqual(x, default), min, max);
        var off = Rem(x, max - min);
        return add + off;
    }

    [MethodImpl(256 | 512)]
    public static Vector128<f32> Wrap(Vector128<f32> x, f32 min, f32 max)
    {
        var add = Vector128.ConditionalSelect(Vector128.GreaterThanOrEqual(x, default), Vector128.Create(min), Vector128.Create(max));
        var off = Rem(x, max - min);
        return add + off;
    }

    [MethodImpl(256 | 512)]
    public static Vector128<f32> Wrap0ToPi(Vector128<f32> x)
    {
        var add = x + (Vector128.LessThan(x, default) & Vector128.Create(math.F_PI));
        var div = x * math.F_1_Div_PI;
        var flr = simd.RoundToZero(div);
        return simd.Fnma(flr, Vector128.Create(math.F_PI), add);
    }

    [MethodImpl(256 | 512)]
    public static Vector128<f32> Wrap0To2Pi(Vector128<f32> x)
    {
        var add = x + (Vector128.LessThan(x, default) & Vector128.Create(math.F_2_PI));
        var div = x * math.F_1_Div_2_PI;
        var flr = simd.RoundToZero(div);
        return simd.Fnma(flr, Vector128.Create(math.F_2_PI), add);
    }

    [MethodImpl(256 | 512)]
    public static Vector128<f32> Wrap0To4Pi(Vector128<f32> x)
    {
        var add = x + (Vector128.LessThan(x, default) & Vector128.Create(math.F_4_PI));
        var div = x * math.F_1_Div_4_PI;
        var flr = simd.RoundToZero(div);
        return simd.Fnma(flr, Vector128.Create(math.F_4_PI), add);
    }

    #endregion

    #region Vector256<f32>

    [MethodImpl(256 | 512)]
    public static Vector256<f32> Wrap(Vector256<f32> x, Vector256<f32> min, Vector256<f32> max)
    {
        var add = Vector256.ConditionalSelect(Vector256.GreaterThanOrEqual(x, default), min, max);
        var off = Rem(x, max - min);
        return add + off;
    }

    [MethodImpl(256 | 512)]
    public static Vector256<f32> Wrap(Vector256<f32> x, f32 min, f32 max)
    {
        var add = Vector256.ConditionalSelect(Vector256.GreaterThanOrEqual(x, default), Vector256.Create(min), Vector256.Create(max));
        var off = Rem(x, max - min);
        return add + off;
    }

    [MethodImpl(256 | 512)]
    public static Vector256<f32> Wrap0ToPi(Vector256<f32> x)
    {
        var add = x + (Vector256.LessThan(x, default) & Vector256.Create(math.F_PI));
        var div = x * math.F_1_Div_PI;
        var flr = simd.RoundToZero(div);
        return simd.Fnma(flr, Vector256.Create(math.F_PI), add);
    }

    [MethodImpl(256 | 512)]
    public static Vector256<f32> Wrap0To2Pi(Vector256<f32> x)
    {
        var add = x + (Vector256.LessThan(x, default) & Vector256.Create(math.F_2_PI));
        var div = x * math.F_1_Div_2_PI;
        var flr = simd.RoundToZero(div);
        return simd.Fnma(flr, Vector256.Create(math.F_2_PI), add);
    }

    [MethodImpl(256 | 512)]
    public static Vector256<f32> Wrap0To4Pi(Vector256<f32> x)
    {
        var add = x + (Vector256.LessThan(x, default) & Vector256.Create(math.F_4_PI));
        var div = x * math.F_1_Div_4_PI;
        var flr = simd.RoundToZero(div);
        return simd.Fnma(flr, Vector256.Create(math.F_4_PI), add);
    }

    #endregion

    #region Vector512<f32>

    [MethodImpl(256 | 512)]
    public static Vector512<f32> Wrap(Vector512<f32> x, Vector512<f32> min, Vector512<f32> max)
    {
        var add = Vector512.ConditionalSelect(Vector512.GreaterThanOrEqual(x, default), min, max);
        var off = Rem(x, max - min);
        return add + off;
    }

    [MethodImpl(256 | 512)]
    public static Vector512<f32> Wrap(Vector512<f32> x, f32 min, f32 max)
    {
        var add = Vector512.ConditionalSelect(Vector512.GreaterThanOrEqual(x, default), Vector512.Create(min), Vector512.Create(max));
        var off = Rem(x, max - min);
        return add + off;
    }

    [MethodImpl(256 | 512)]
    public static Vector512<f32> Wrap0ToPi(Vector512<f32> x)
    {
        var add = x + (Vector512.LessThan(x, default) & Vector512.Create(math.F_PI));
        var div = x * math.F_1_Div_PI;
        var flr = simd.RoundToZero(div);
        return simd.Fnma(flr, Vector512.Create(math.F_PI), add);
    }

    [MethodImpl(256 | 512)]
    public static Vector512<f32> Wrap0To2Pi(Vector512<f32> x)
    {
        var add = x + (Vector512.LessThan(x, default) & Vector512.Create(math.F_2_PI));
        var div = x * math.F_1_Div_2_PI;
        var flr = simd.RoundToZero(div);
        return simd.Fnma(flr, Vector512.Create(math.F_2_PI), add);
    }

    [MethodImpl(256 | 512)]
    public static Vector512<f32> Wrap0To4Pi(Vector512<f32> x)
    {
        var add = x + (Vector512.LessThan(x, default) & Vector512.Create(math.F_4_PI));
        var div = x * math.F_1_Div_4_PI;
        var flr = simd.RoundToZero(div);
        return simd.Fnma(flr, Vector512.Create(math.F_4_PI), add);
    }

    #endregion

    #region Vector128<f64>

    [MethodImpl(256 | 512)]
    public static Vector128<f64> Wrap(Vector128<f64> x, Vector128<f64> min, Vector128<f64> max)
    {
        var add = Vector128.ConditionalSelect(Vector128.GreaterThanOrEqual(x, default), min, max);
        var off = Rem(x, max - min);
        return add + off;
    }

    [MethodImpl(256 | 512)]
    public static Vector128<f64> Wrap(Vector128<f64> x, f64 min, f64 max)
    {
        var add = Vector128.ConditionalSelect(Vector128.GreaterThanOrEqual(x, default), Vector128.Create(min), Vector128.Create(max));
        var off = Rem(x, max - min);
        return add + off;
    }

    [MethodImpl(256 | 512)]
    public static Vector128<f64> Wrap0ToPi(Vector128<f64> x)
    {
        var add = x + (Vector128.LessThan(x, default) & Vector128.Create(math.D_PI));
        var div = x * math.D_1_Div_PI;
        var flr = simd.RoundToZero(div);
        return simd.Fnma(flr, Vector128.Create(math.D_PI), add);
    }

    [MethodImpl(256 | 512)]
    public static Vector128<f64> Wrap0To2Pi(Vector128<f64> x)
    {
        var add = x + (Vector128.LessThan(x, default) & Vector128.Create(math.D_2_PI));
        var div = x * math.D_1_Div_2_PI;
        var flr = simd.RoundToZero(div);
        return simd.Fnma(flr, Vector128.Create(math.D_2_PI), add);
    }

    [MethodImpl(256 | 512)]
    public static Vector128<f64> Wrap0To4Pi(Vector128<f64> x)
    {
        var add = x + (Vector128.LessThan(x, default) & Vector128.Create(math.D_4_PI));
        var div = x * math.D_1_Div_4_PI;
        var flr = simd.RoundToZero(div);
        return simd.Fnma(flr, Vector128.Create(math.D_4_PI), add);
    }

    #endregion

    #region Vector256<f64>

    [MethodImpl(256 | 512)]
    public static Vector256<f64> Wrap(Vector256<f64> x, Vector256<f64> min, Vector256<f64> max)
    {
        var add = Vector256.ConditionalSelect(Vector256.GreaterThanOrEqual(x, default), min, max);
        var off = Rem(x, max - min);
        return add + off;
    }

    [MethodImpl(256 | 512)]
    public static Vector256<f64> Wrap(Vector256<f64> x, f64 min, f64 max)
    {
        var add = Vector256.ConditionalSelect(Vector256.GreaterThanOrEqual(x, default), Vector256.Create(min), Vector256.Create(max));
        var off = Rem(x, max - min);
        return add + off;
    }

    [MethodImpl(256 | 512)]
    public static Vector256<f64> Wrap0ToPi(Vector256<f64> x)
    {
        var add = x + (Vector256.LessThan(x, default) & Vector256.Create(math.D_PI));
        var div = x * math.D_1_Div_PI;
        var flr = simd.RoundToZero(div);
        return simd.Fnma(flr, Vector256.Create(math.D_PI), add);
    }

    [MethodImpl(256 | 512)]
    public static Vector256<f64> Wrap0To2Pi(Vector256<f64> x)
    {
        var add = x + (Vector256.LessThan(x, default) & Vector256.Create(math.D_2_PI));
        var div = x * math.D_1_Div_2_PI;
        var flr = simd.RoundToZero(div);
        return simd.Fnma(flr, Vector256.Create(math.D_2_PI), add);
    }

    [MethodImpl(256 | 512)]
    public static Vector256<f64> Wrap0To4Pi(Vector256<f64> x)
    {
        var add = x + (Vector256.LessThan(x, default) & Vector256.Create(math.D_4_PI));
        var div = x * math.D_1_Div_4_PI;
        var flr = simd.RoundToZero(div);
        return simd.Fnma(flr, Vector256.Create(math.D_4_PI), add);
    }

    #endregion

    #region Vector512<f64>

    [MethodImpl(256 | 512)]
    public static Vector512<f64> Wrap(Vector512<f64> x, Vector512<f64> min, Vector512<f64> max)
    {
        var add = Vector512.ConditionalSelect(Vector512.GreaterThanOrEqual(x, default), min, max);
        var off = Rem(x, max - min);
        return add + off;
    }

    [MethodImpl(256 | 512)]
    public static Vector512<f64> Wrap(Vector512<f64> x, f64 min, f64 max)
    {
        var add = Vector512.ConditionalSelect(Vector512.GreaterThanOrEqual(x, default), Vector512.Create(min), Vector512.Create(max));
        var off = Rem(x, max - min);
        return add + off;
    }

    [MethodImpl(256 | 512)]
    public static Vector512<f64> Wrap0ToPi(Vector512<f64> x)
    {
        var add = x + (Vector512.LessThan(x, default) & Vector512.Create(math.D_PI));
        var div = x * math.D_1_Div_PI;
        var flr = simd.RoundToZero(div);
        return simd.Fnma(flr, Vector512.Create(math.D_PI), add);
    }

    [MethodImpl(256 | 512)]
    public static Vector512<f64> Wrap0To2Pi(Vector512<f64> x)
    {
        var add = x + (Vector512.LessThan(x, default) & Vector512.Create(math.D_2_PI));
        var div = x * math.D_1_Div_2_PI;
        var flr = simd.RoundToZero(div);
        return simd.Fnma(flr, Vector512.Create(math.D_2_PI), add);
    }

    [MethodImpl(256 | 512)]
    public static Vector512<f64> Wrap0To4Pi(Vector512<f64> x)
    {
        var add = x + (Vector512.LessThan(x, default) & Vector512.Create(math.D_4_PI));
        var div = x * math.D_1_Div_4_PI;
        var flr = simd.RoundToZero(div);
        return simd.Fnma(flr, Vector512.Create(math.D_4_PI), add);
    }

    #endregion

    #endregion

    #region Log

    #region Vector64<f32>

    [MethodImpl(512)]
    public static Vector64<f32> Log(Vector64<f32> a) => Log2_impl(a) * math.F_Log2;

    [MethodImpl(512)]
    public static Vector64<f32> Log10(Vector64<f32> a) => Log2_impl(a) * (math.F_Log2 / math.F_Log10);

    [MethodImpl(512)]
    public static Vector64<f32> Log2(Vector64<f32> a) => Log2_impl(a);

    [MethodImpl(256 | 512)]
    private static Vector64<f32> Log2_impl(Vector64<f32> a)
    {
        var xl = Vector64.Max(a, Vector64<f32>.Zero).AsInt32();
        var mantissa = (xl >>> 23) - Vector64.Create(0x7F);
        var r = Vector64.ConvertToSingle(mantissa);

        xl = (xl & Vector64.Create(0x7FFFFF)) | Vector64.Create(0x7F << 23);

        var d = (xl.AsSingle() | Vector64<f32>.One) * Vector64.Create(2.0f / 3.0f);

        #region Approx

        // A Taylor Series approximation of ln(x) that relies on the identity that ln(x) = 2*atan((x-1)/(x+1)).
        d = (d - Vector64<f32>.One) / (d + Vector64<f32>.One);
        var sq = d * d;

        var rx = simd.Fma(sq, Vector64.Create(0.2371599674224853515625f), Vector64.Create(0.285279005765914916992188f));
        rx = simd.Fma(rx, sq, Vector64.Create(0.400005519390106201171875f));
        rx = simd.Fma(rx, sq, Vector64.Create(0.666666567325592041015625f));
        rx = simd.Fma(rx, sq, Vector64.Create(2.0f));

        d *= rx;

        #endregion

        r += simd.Fma(d, Vector64.Create(1.4426950408889634f), Vector64.Create(0.58496250072115619f));

        r = Vector64.ConditionalSelect(
            Vector64.GreaterThan(a, Vector64<f32>.Zero),
            r, Vector64.Create(f32.NaN)
        );
        r = Vector64.ConditionalSelect(
            Vector64.Equals(a, Vector64.Create(f32.PositiveInfinity)),
            Vector64.Create(f32.PositiveInfinity), r
        );
        r = Vector64.ConditionalSelect(
            Vector64.Equals(a, Vector64<f32>.Zero),
            Vector64.Create(f32.NegativeInfinity), r
        );

        return r;
    }

    #endregion

    #region Vector128<f32>

    [MethodImpl(512)]
    public static Vector128<f32> Log(Vector128<f32> a) => Log2_impl(a) * math.F_Log2;

    [MethodImpl(512)]
    public static Vector128<f32> Log10(Vector128<f32> a) => Log2_impl(a) * (math.F_Log2 / math.F_Log10);

    [MethodImpl(512)]
    public static Vector128<f32> Log2(Vector128<f32> a) => Log2_impl(a);

    [MethodImpl(256 | 512)]
    private static Vector128<f32> Log2_impl(Vector128<f32> a)
    {
        var xl = Vector128.Max(a, Vector128<f32>.Zero).AsInt32();
        var mantissa = (xl >>> 23) - Vector128.Create(0x7F);
        var r = Vector128.ConvertToSingle(mantissa);

        xl = (xl & Vector128.Create(0x7FFFFF)) | Vector128.Create(0x7F << 23);

        var d = (xl.AsSingle() | Vector128<f32>.One) * Vector128.Create(2.0f / 3.0f);

        #region Approx

        // A Taylor Series approximation of ln(x) that relies on the identity that ln(x) = 2*atan((x-1)/(x+1)).
        d = (d - Vector128<f32>.One) / (d + Vector128<f32>.One);
        var sq = d * d;

        var rx = simd.Fma(sq, Vector128.Create(0.2371599674224853515625f), Vector128.Create(0.285279005765914916992188f));
        rx = simd.Fma(rx, sq, Vector128.Create(0.400005519390106201171875f));
        rx = simd.Fma(rx, sq, Vector128.Create(0.666666567325592041015625f));
        rx = simd.Fma(rx, sq, Vector128.Create(2.0f));

        d *= rx;

        #endregion

        r += simd.Fma(d, Vector128.Create(1.4426950408889634f), Vector128.Create(0.58496250072115619f));

        r = Vector128.ConditionalSelect(
            Vector128.GreaterThan(a, Vector128<f32>.Zero),
            r, Vector128.Create(f32.NaN)
        );
        r = Vector128.ConditionalSelect(
            Vector128.Equals(a, Vector128.Create(f32.PositiveInfinity)),
            Vector128.Create(f32.PositiveInfinity), r
        );
        r = Vector128.ConditionalSelect(
            Vector128.Equals(a, Vector128<f32>.Zero),
            Vector128.Create(f32.NegativeInfinity), r
        );

        return r;
    }

    #endregion

    #region Vector256<f32>

    [MethodImpl(512)]
    public static Vector256<f32> Log(Vector256<f32> a) => Log2_impl(a) * math.F_Log2;

    [MethodImpl(512)]
    public static Vector256<f32> Log10(Vector256<f32> a) => Log2_impl(a) * (math.F_Log2 / math.F_Log10);

    [MethodImpl(512)]
    public static Vector256<f32> Log2(Vector256<f32> a) => Log2_impl(a);

    [MethodImpl(256 | 512)]
    private static Vector256<f32> Log2_impl(Vector256<f32> a)
    {
        var xl = Vector256.Max(a, Vector256<f32>.Zero).AsInt32();
        var mantissa = (xl >>> 23) - Vector256.Create(0x7F);
        var r = Vector256.ConvertToSingle(mantissa);

        xl = (xl & Vector256.Create(0x7FFFFF)) | Vector256.Create(0x7F << 23);

        var d = (xl.AsSingle() | Vector256<f32>.One) * Vector256.Create(2.0f / 3.0f);

        #region Approx

        // A Taylor Series approximation of ln(x) that relies on the identity that ln(x) = 2*atan((x-1)/(x+1)).
        d = (d - Vector256<f32>.One) / (d + Vector256<f32>.One);
        var sq = d * d;

        var rx = simd.Fma(sq, Vector256.Create(0.2371599674224853515625f), Vector256.Create(0.285279005765914916992188f));
        rx = simd.Fma(rx, sq, Vector256.Create(0.400005519390106201171875f));
        rx = simd.Fma(rx, sq, Vector256.Create(0.666666567325592041015625f));
        rx = simd.Fma(rx, sq, Vector256.Create(2.0f));

        d *= rx;

        #endregion

        r += simd.Fma(d, Vector256.Create(1.4426950408889634f), Vector256.Create(0.58496250072115619f));

        r = Vector256.ConditionalSelect(
            Vector256.GreaterThan(a, Vector256<f32>.Zero),
            r, Vector256.Create(f32.NaN)
        );
        r = Vector256.ConditionalSelect(
            Vector256.Equals(a, Vector256.Create(f32.PositiveInfinity)),
            Vector256.Create(f32.PositiveInfinity), r
        );
        r = Vector256.ConditionalSelect(
            Vector256.Equals(a, Vector256<f32>.Zero),
            Vector256.Create(f32.NegativeInfinity), r
        );

        return r;
    }

    #endregion

    #region Vector512<f32>

    [MethodImpl(512)]
    public static Vector512<f32> Log(Vector512<f32> a) => Log2_impl(a) * math.F_Log2;

    [MethodImpl(512)]
    public static Vector512<f32> Log10(Vector512<f32> a) => Log2_impl(a) * (math.F_Log2 / math.F_Log10);

    [MethodImpl(512)]
    public static Vector512<f32> Log2(Vector512<f32> a) => Log2_impl(a);

    [MethodImpl(256 | 512)]
    private static Vector512<f32> Log2_impl(Vector512<f32> a)
    {
        var xl = Vector512.Max(a, Vector512<f32>.Zero).AsInt32();
        var mantissa = (xl >>> 23) - Vector512.Create(0x7F);
        var r = Vector512.ConvertToSingle(mantissa);

        xl = (xl & Vector512.Create(0x7FFFFF)) | Vector512.Create(0x7F << 23);

        var d = (xl.AsSingle() | Vector512<f32>.One) * Vector512.Create(2.0f / 3.0f);

        #region Approx

        // A Taylor Series approximation of ln(x) that relies on the identity that ln(x) = 2*atan((x-1)/(x+1)).
        d = (d - Vector512<f32>.One) / (d + Vector512<f32>.One);
        var sq = d * d;

        var rx = simd.Fma(sq, Vector512.Create(0.2371599674224853515625f), Vector512.Create(0.285279005765914916992188f));
        rx = simd.Fma(rx, sq, Vector512.Create(0.400005519390106201171875f));
        rx = simd.Fma(rx, sq, Vector512.Create(0.666666567325592041015625f));
        rx = simd.Fma(rx, sq, Vector512.Create(2.0f));

        d *= rx;

        #endregion

        r += simd.Fma(d, Vector512.Create(1.4426950408889634f), Vector512.Create(0.58496250072115619f));

        r = Vector512.ConditionalSelect(
            Vector512.GreaterThan(a, Vector512<f32>.Zero),
            r, Vector512.Create(f32.NaN)
        );
        r = Vector512.ConditionalSelect(
            Vector512.Equals(a, Vector512.Create(f32.PositiveInfinity)),
            Vector512.Create(f32.PositiveInfinity), r
        );
        r = Vector512.ConditionalSelect(
            Vector512.Equals(a, Vector512<f32>.Zero),
            Vector512.Create(f32.NegativeInfinity), r
        );

        return r;
    }

    #endregion

    #region Vector128<f64>

    [MethodImpl(512)]
    public static Vector128<f64> Log(Vector128<f64> a) => Log2_impl(a) * math.D_Log2;

    [MethodImpl(512)]
    public static Vector128<f64> Log10(Vector128<f64> a) => Log2_impl(a) * (math.D_Log2 / math.D_Log10);

    [MethodImpl(512)]
    public static Vector128<f64> Log2(Vector128<f64> a) => Log2_impl(a);

    [MethodImpl(256 | 512)]
    private static Vector128<f64> Log2_impl(Vector128<f64> a)
    {
        var xl = Vector128.Max(a, Vector128<f64>.Zero).AsInt64();
        var mantissa = (xl >>> 52) - Vector128.Create(0x3ffL);
        var r = Vector128.ConvertToDouble(mantissa);

        xl = (xl & Vector128.Create(0xfffffffffffffL)) | Vector128.Create(1023L << 52);

        var d = (xl.AsDouble() | Vector128<f64>.One) * Vector128.Create(2.0 / 3.0);

        #region Approx

        // A Taylor Series approximation of ln(x) that relies on the identity that ln(x) = 2*atan((x-1)/(x+1)).
        d = (d - Vector128<f64>.One) / (d + Vector128<f64>.One);
        var sq = d * d;

        var rx = simd.Fma(sq, Vector128.Create(0.148197055177935105296783), Vector128.Create(0.153108178020442575739679));
        rx = simd.Fma(rx, sq, Vector128.Create(0.181837339521549679055568));
        rx = simd.Fma(rx, sq, Vector128.Create(0.22222194152736701733275));
        rx = simd.Fma(rx, sq, Vector128.Create(0.285714288030134544449368));
        rx = simd.Fma(rx, sq, Vector128.Create(0.399999999989941956712869));
        rx = simd.Fma(rx, sq, Vector128.Create(0.666666666666685503450651));
        rx = simd.Fma(rx, sq, Vector128.Create(2.0));

        d *= rx;

        #endregion

        r += simd.Fma(d, Vector128.Create(1.4426950408889634), Vector128.Create(0.58496250072115619));

        r = Vector128.ConditionalSelect(
            Vector128.GreaterThan(a, Vector128<f64>.Zero),
            r, Vector128.Create(f64.NaN)
        );
        r = Vector128.ConditionalSelect(
            Vector128.Equals(a, Vector128.Create(f64.PositiveInfinity)),
            Vector128.Create(f64.PositiveInfinity), r
        );
        r = Vector128.ConditionalSelect(
            Vector128.Equals(a, Vector128<f64>.Zero),
            Vector128.Create(f64.NegativeInfinity), r
        );

        return r;
    }

    #endregion

    #region Vector256<f64>

    [MethodImpl(512)]
    public static Vector256<f64> Log(Vector256<f64> a) => Log2_impl(a) * math.D_Log2;

    [MethodImpl(512)]
    public static Vector256<f64> Log10(Vector256<f64> a) => Log2_impl(a) * (math.D_Log2 / math.D_Log10);

    [MethodImpl(512)]
    public static Vector256<f64> Log2(Vector256<f64> a) => Log2_impl(a);

    [MethodImpl(256 | 512)]
    private static Vector256<f64> Log2_impl(Vector256<f64> a)
    {
        var xl = Vector256.Max(a, Vector256<f64>.Zero).AsInt64();
        var mantissa = (xl >>> 52) - Vector256.Create(0x3ffL);
        var r = Vector256.ConvertToDouble(mantissa);

        xl = (xl & Vector256.Create(0xfffffffffffffL)) | Vector256.Create(1023L << 52);

        var d = (xl.AsDouble() | Vector256<f64>.One) * Vector256.Create(2.0 / 3.0);

        #region Approx

        // A Taylor Series approximation of ln(x) that relies on the identity that ln(x) = 2*atan((x-1)/(x+1)).
        d = (d - Vector256<f64>.One) / (d + Vector256<f64>.One);
        var sq = d * d;

        var rx = simd.Fma(sq, Vector256.Create(0.148197055177935105296783), Vector256.Create(0.153108178020442575739679));
        rx = simd.Fma(rx, sq, Vector256.Create(0.181837339521549679055568));
        rx = simd.Fma(rx, sq, Vector256.Create(0.22222194152736701733275));
        rx = simd.Fma(rx, sq, Vector256.Create(0.285714288030134544449368));
        rx = simd.Fma(rx, sq, Vector256.Create(0.399999999989941956712869));
        rx = simd.Fma(rx, sq, Vector256.Create(0.666666666666685503450651));
        rx = simd.Fma(rx, sq, Vector256.Create(2.0));

        d *= rx;

        #endregion

        r += simd.Fma(d, Vector256.Create(1.4426950408889634), Vector256.Create(0.58496250072115619));

        r = Vector256.ConditionalSelect(
            Vector256.GreaterThan(a, Vector256<f64>.Zero),
            r, Vector256.Create(f64.NaN)
        );
        r = Vector256.ConditionalSelect(
            Vector256.Equals(a, Vector256.Create(f64.PositiveInfinity)),
            Vector256.Create(f64.PositiveInfinity), r
        );
        r = Vector256.ConditionalSelect(
            Vector256.Equals(a, Vector256<f64>.Zero),
            Vector256.Create(f64.NegativeInfinity), r
        );

        return r;
    }

    #endregion

    #region Vector512<f64>

    [MethodImpl(512)]
    public static Vector512<f64> Log(Vector512<f64> a) => Log2_impl(a) * math.D_Log2;

    [MethodImpl(512)]
    public static Vector512<f64> Log10(Vector512<f64> a) => Log2_impl(a) * (math.D_Log2 / math.D_Log10);

    [MethodImpl(512)]
    public static Vector512<f64> Log2(Vector512<f64> a) => Log2_impl(a);

    [MethodImpl(256 | 512)]
    private static Vector512<f64> Log2_impl(Vector512<f64> a)
    {
        var xl = Vector512.Max(a, Vector512<f64>.Zero).AsInt64();
        var mantissa = (xl >>> 52) - Vector512.Create(0x3ffL);
        var r = Vector512.ConvertToDouble(mantissa);

        xl = (xl & Vector512.Create(0xfffffffffffffL)) | Vector512.Create(1023L << 52);

        var d = (xl.AsDouble() | Vector512<f64>.One) * Vector512.Create(2.0 / 3.0);

        #region Approx

        // A Taylor Series approximation of ln(x) that relies on the identity that ln(x) = 2*atan((x-1)/(x+1)).
        d = (d - Vector512<f64>.One) / (d + Vector512<f64>.One);
        var sq = d * d;

        var rx = simd.Fma(sq, Vector512.Create(0.148197055177935105296783), Vector512.Create(0.153108178020442575739679));
        rx = simd.Fma(rx, sq, Vector512.Create(0.181837339521549679055568));
        rx = simd.Fma(rx, sq, Vector512.Create(0.22222194152736701733275));
        rx = simd.Fma(rx, sq, Vector512.Create(0.285714288030134544449368));
        rx = simd.Fma(rx, sq, Vector512.Create(0.399999999989941956712869));
        rx = simd.Fma(rx, sq, Vector512.Create(0.666666666666685503450651));
        rx = simd.Fma(rx, sq, Vector512.Create(2.0));

        d *= rx;

        #endregion

        r += simd.Fma(d, Vector512.Create(1.4426950408889634), Vector512.Create(0.58496250072115619));

        r = Vector512.ConditionalSelect(
            Vector512.GreaterThan(a, Vector512<f64>.Zero),
            r, Vector512.Create(f64.NaN)
        );
        r = Vector512.ConditionalSelect(
            Vector512.Equals(a, Vector512.Create(f64.PositiveInfinity)),
            Vector512.Create(f64.PositiveInfinity), r
        );
        r = Vector512.ConditionalSelect(
            Vector512.Equals(a, Vector512<f64>.Zero),
            Vector512.Create(f64.NegativeInfinity), r
        );

        return r;
    }

    #endregion

    #endregion

    #region Exp

    #region Vector64<f32>

    [MethodImpl(512)]
    public static Vector64<f32> Exp(Vector64<f32> x) => Exp2_impl(x * math.F_1_Div_Log2);

    [MethodImpl(512)]
    public static Vector64<f32> Exp10(Vector64<f32> x) => Exp2_impl(x * 2.302585092994045684f * math.F_1_Div_Log2);

    [MethodImpl(512)]
    public static Vector64<f32> Exp2(Vector64<f32> x) => Exp2_impl(x);

    [MethodImpl(256 | 512)]
    private static Vector64<f32> Exp2_impl(Vector64<f32> x)
    {
        var e = Vector64.GreaterThanOrEqual(x, Vector64.Create(89f)) & Vector64.Create(f32.PositiveInfinity);
        e += simd.Ne(x, x);

        var xx = Vector64.Max(
            Vector64.Min(x, Vector64.Create(81.0f * math.F_1_Div_Log2)),
            Vector64.Create(-81.0f * math.F_1_Div_Log2)
        );

        var fx = simd.Round(xx);

        xx -= fx;
        var r = simd.Fma(xx, Vector64.Create(1.530610536076361E-05f), Vector64.Create(0.000154631026827329f));
        r = simd.Fma(r, xx, Vector64.Create(0.0013333465742372899f));
        r = simd.Fma(r, xx, Vector64.Create(0.00961804886829518f));
        r = simd.Fma(r, xx, Vector64.Create(0.05550410925060949f));
        r = simd.Fma(r, xx, Vector64.Create(0.240226509999339f));
        r = simd.Fma(r, xx, Vector64.Create(0.6931471805500692f));
        r = simd.Fma(r, xx, Vector64.Create(1.0f));

        fx = ((Vector64.ConvertToInt32(fx) + Vector64.Create(127)) << 23).AsSingle();

        r = simd.Fma(r, fx, e);
        r = Vector64.AndNot(r, Vector64.Equals(x, Vector64.Create(f32.NegativeInfinity)));

        return r;
    }

    #endregion

    #region Vector128<f32>

    [MethodImpl(512)]
    public static Vector128<f32> Exp(Vector128<f32> x) => Exp2_impl(x * math.F_1_Div_Log2);

    [MethodImpl(512)]
    public static Vector128<f32> Exp10(Vector128<f32> x) => Exp2_impl(x * 2.302585092994045684f * math.F_1_Div_Log2);

    [MethodImpl(512)]
    public static Vector128<f32> Exp2(Vector128<f32> x) => Exp2_impl(x);

    [MethodImpl(256 | 512)]
    private static Vector128<f32> Exp2_impl(Vector128<f32> x)
    {
        var e = Vector128.GreaterThanOrEqual(x, Vector128.Create(89f)) & Vector128.Create(f32.PositiveInfinity);
        e += simd.Ne(x, x);

        var xx = Vector128.Max(
            Vector128.Min(x, Vector128.Create(81.0f * math.F_1_Div_Log2)),
            Vector128.Create(-81.0f * math.F_1_Div_Log2)
        );

        var fx = simd.Round(xx);

        xx -= fx;
        var r = simd.Fma(xx, Vector128.Create(1.530610536076361E-05f), Vector128.Create(0.000154631026827329f));
        r = simd.Fma(r, xx, Vector128.Create(0.0013333465742372899f));
        r = simd.Fma(r, xx, Vector128.Create(0.00961804886829518f));
        r = simd.Fma(r, xx, Vector128.Create(0.05550410925060949f));
        r = simd.Fma(r, xx, Vector128.Create(0.240226509999339f));
        r = simd.Fma(r, xx, Vector128.Create(0.6931471805500692f));
        r = simd.Fma(r, xx, Vector128.Create(1.0f));

        fx = ((Vector128.ConvertToInt32(fx) + Vector128.Create(127)) << 23).AsSingle();

        r = simd.Fma(r, fx, e);
        r = Vector128.AndNot(r, Vector128.Equals(x, Vector128.Create(f32.NegativeInfinity)));

        return r;
    }

    #endregion

    #region Vector256<f32>

    [MethodImpl(512)]
    public static Vector256<f32> Exp(Vector256<f32> x) => Exp2_impl(x * math.F_1_Div_Log2);

    [MethodImpl(512)]
    public static Vector256<f32> Exp10(Vector256<f32> x) => Exp2_impl(x * 2.302585092994045684f * math.F_1_Div_Log2);

    [MethodImpl(512)]
    public static Vector256<f32> Exp2(Vector256<f32> x) => Exp2_impl(x);

    [MethodImpl(256 | 512)]
    private static Vector256<f32> Exp2_impl(Vector256<f32> x)
    {
        var e = Vector256.GreaterThanOrEqual(x, Vector256.Create(89f)) & Vector256.Create(f32.PositiveInfinity);
        e += simd.Ne(x, x);

        var xx = Vector256.Max(
            Vector256.Min(x, Vector256.Create(81.0f * math.F_1_Div_Log2)),
            Vector256.Create(-81.0f * math.F_1_Div_Log2)
        );

        var fx = simd.Round(xx);

        xx -= fx;
        var r = simd.Fma(xx, Vector256.Create(1.530610536076361E-05f), Vector256.Create(0.000154631026827329f));
        r = simd.Fma(r, xx, Vector256.Create(0.0013333465742372899f));
        r = simd.Fma(r, xx, Vector256.Create(0.00961804886829518f));
        r = simd.Fma(r, xx, Vector256.Create(0.05550410925060949f));
        r = simd.Fma(r, xx, Vector256.Create(0.240226509999339f));
        r = simd.Fma(r, xx, Vector256.Create(0.6931471805500692f));
        r = simd.Fma(r, xx, Vector256.Create(1.0f));

        fx = ((Vector256.ConvertToInt32(fx) + Vector256.Create(127)) << 23).AsSingle();

        r = simd.Fma(r, fx, e);
        r = Vector256.AndNot(r, Vector256.Equals(x, Vector256.Create(f32.NegativeInfinity)));

        return r;
    }

    #endregion

    #region Vector512<f32>

    [MethodImpl(512)]
    public static Vector512<f32> Exp(Vector512<f32> x) => Exp2_impl(x * math.F_1_Div_Log2);

    [MethodImpl(512)]
    public static Vector512<f32> Exp10(Vector512<f32> x) => Exp2_impl(x * 2.302585092994045684f * math.F_1_Div_Log2);

    [MethodImpl(512)]
    public static Vector512<f32> Exp2(Vector512<f32> x) => Exp2_impl(x);

    [MethodImpl(256 | 512)]
    private static Vector512<f32> Exp2_impl(Vector512<f32> x)
    {
        var e = Vector512.GreaterThanOrEqual(x, Vector512.Create(89f)) & Vector512.Create(f32.PositiveInfinity);
        e += simd.Ne(x, x);

        var xx = Vector512.Max(
            Vector512.Min(x, Vector512.Create(81.0f * math.F_1_Div_Log2)),
            Vector512.Create(-81.0f * math.F_1_Div_Log2)
        );

        var fx = simd.Round(xx);

        xx -= fx;
        var r = simd.Fma(xx, Vector512.Create(1.530610536076361E-05f), Vector512.Create(0.000154631026827329f));
        r = simd.Fma(r, xx, Vector512.Create(0.0013333465742372899f));
        r = simd.Fma(r, xx, Vector512.Create(0.00961804886829518f));
        r = simd.Fma(r, xx, Vector512.Create(0.05550410925060949f));
        r = simd.Fma(r, xx, Vector512.Create(0.240226509999339f));
        r = simd.Fma(r, xx, Vector512.Create(0.6931471805500692f));
        r = simd.Fma(r, xx, Vector512.Create(1.0f));

        fx = ((Vector512.ConvertToInt32(fx) + Vector512.Create(127)) << 23).AsSingle();

        r = simd.Fma(r, fx, e);
        r = Vector512.AndNot(r, Vector512.Equals(x, Vector512.Create(f32.NegativeInfinity)));

        return r;
    }

    #endregion

    #region Vector128<f64>

    [MethodImpl(512)]
    public static Vector128<f64> Exp(Vector128<f64> x) => Exp2_impl(x * math.D_1_Div_Log2);

    [MethodImpl(512)]
    public static Vector128<f64> Exp10(Vector128<f64> x) => Exp2_impl(x * 2.302585092994045684 * math.D_1_Div_Log2);

    [MethodImpl(512)]
    public static Vector128<f64> Exp2(Vector128<f64> x) => Exp2_impl(x);

    [MethodImpl(256 | 512)]
    private static Vector128<f64> Exp2_impl(Vector128<f64> x)
    {
        var e = Vector128.GreaterThanOrEqual(x, Vector128.Create(709.0 * 1.4426950408889634)) & Vector128.Create(f64.PositiveInfinity);
        e += simd.Ne(x, x);

        var xx = Vector128.Max(
            Vector128.Min(x, Vector128.Create(709.0 * 1.4426950408889634)),
            Vector128.Create(-709.0 * 1.4426950408889634)
        );
        var fx = simd.Round(xx);

        xx -= fx;
        var sq = xx * xx;
        var r = simd.Fma(sq, Vector128.Create(0.00000000044560630323), Vector128.Create(0.00000010178055034703));
        r = simd.Fma(r, sq, Vector128.Create(0.000015252733847608224));
        r = simd.Fma(r, sq, Vector128.Create(0.0013333558146398846396));
        r = simd.Fma(r, sq, Vector128.Create(0.05550410866482166557484));
        r = simd.Fma(r, sq, Vector128.Create(0.6931471805599453087156032));
        var ro = simd.Fma(sq, Vector128.Create(0.000000007073075504998510), Vector128.Create(0.000001321543919937730177));
        ro = simd.Fma(ro, sq, Vector128.Create(0.0001540353044975008196326));
        ro = simd.Fma(ro, sq, Vector128.Create(0.00961812910759946061829085));
        ro = simd.Fma(ro, sq, Vector128.Create(0.240226506959101195979507231));
        ro = simd.Fma(ro, sq, Vector128<f64>.One);
        r = simd.Fma(r, xx, ro);

        fx += Vector128.Create(6755399441055744.0);
        fx = ((fx.AsInt64() + Vector128.Create(0x3ffL)) << 52).AsDouble();

        r = simd.Fma(r, fx, e);

        return r;
    }

    #endregion

    #region Vector256<f64>

    [MethodImpl(512)]
    public static Vector256<f64> Exp(Vector256<f64> x) => Exp2_impl(x * math.D_1_Div_Log2);

    [MethodImpl(512)]
    public static Vector256<f64> Exp10(Vector256<f64> x) => Exp2_impl(x * 2.302585092994045684 * math.D_1_Div_Log2);

    [MethodImpl(512)]
    public static Vector256<f64> Exp2(Vector256<f64> x) => Exp2_impl(x);

    [MethodImpl(256 | 512)]
    private static Vector256<f64> Exp2_impl(Vector256<f64> x)
    {
        var e = Vector256.GreaterThanOrEqual(x, Vector256.Create(709.0 * 1.4426950408889634)) & Vector256.Create(f64.PositiveInfinity);
        e += simd.Ne(x, x);

        var xx = Vector256.Max(
            Vector256.Min(x, Vector256.Create(709.0 * 1.4426950408889634)),
            Vector256.Create(-709.0 * 1.4426950408889634)
        );
        var fx = simd.Round(xx);

        xx -= fx;
        var sq = xx * xx;
        var r = simd.Fma(sq, Vector256.Create(0.00000000044560630323), Vector256.Create(0.00000010178055034703));
        r = simd.Fma(r, sq, Vector256.Create(0.000015252733847608224));
        r = simd.Fma(r, sq, Vector256.Create(0.0013333558146398846396));
        r = simd.Fma(r, sq, Vector256.Create(0.05550410866482166557484));
        r = simd.Fma(r, sq, Vector256.Create(0.6931471805599453087156032));
        var ro = simd.Fma(sq, Vector256.Create(0.000000007073075504998510), Vector256.Create(0.000001321543919937730177));
        ro = simd.Fma(ro, sq, Vector256.Create(0.0001540353044975008196326));
        ro = simd.Fma(ro, sq, Vector256.Create(0.00961812910759946061829085));
        ro = simd.Fma(ro, sq, Vector256.Create(0.240226506959101195979507231));
        ro = simd.Fma(ro, sq, Vector256<f64>.One);
        r = simd.Fma(r, xx, ro);

        fx += Vector256.Create(6755399441055744.0);
        fx = ((fx.AsInt64() + Vector256.Create(0x3ffL)) << 52).AsDouble();

        r = simd.Fma(r, fx, e);

        return r;
    }

    #endregion

    #region Vector512<f64>

    [MethodImpl(512)]
    public static Vector512<f64> Exp(Vector512<f64> x) => Exp2_impl(x * math.D_1_Div_Log2);

    [MethodImpl(512)]
    public static Vector512<f64> Exp10(Vector512<f64> x) => Exp2_impl(x * 2.302585092994045684 * math.D_1_Div_Log2);

    [MethodImpl(512)]
    public static Vector512<f64> Exp2(Vector512<f64> x) => Exp2_impl(x);

    [MethodImpl(256 | 512)]
    private static Vector512<f64> Exp2_impl(Vector512<f64> x)
    {
        var e = Vector512.GreaterThanOrEqual(x, Vector512.Create(709.0 * 1.4426950408889634)) & Vector512.Create(f64.PositiveInfinity);
        e += simd.Ne(x, x);

        var xx = Vector512.Max(
            Vector512.Min(x, Vector512.Create(709.0 * 1.4426950408889634)),
            Vector512.Create(-709.0 * 1.4426950408889634)
        );
        var fx = simd.Round(xx);

        xx -= fx;
        var sq = xx * xx;
        var r = simd.Fma(sq, Vector512.Create(0.00000000044560630323), Vector512.Create(0.00000010178055034703));
        r = simd.Fma(r, sq, Vector512.Create(0.000015252733847608224));
        r = simd.Fma(r, sq, Vector512.Create(0.0013333558146398846396));
        r = simd.Fma(r, sq, Vector512.Create(0.05550410866482166557484));
        r = simd.Fma(r, sq, Vector512.Create(0.6931471805599453087156032));
        var ro = simd.Fma(sq, Vector512.Create(0.000000007073075504998510), Vector512.Create(0.000001321543919937730177));
        ro = simd.Fma(ro, sq, Vector512.Create(0.0001540353044975008196326));
        ro = simd.Fma(ro, sq, Vector512.Create(0.00961812910759946061829085));
        ro = simd.Fma(ro, sq, Vector512.Create(0.240226506959101195979507231));
        ro = simd.Fma(ro, sq, Vector512<f64>.One);
        r = simd.Fma(r, xx, ro);

        fx += Vector512.Create(6755399441055744.0);
        fx = ((fx.AsInt64() + Vector512.Create(0x3ffL)) << 52).AsDouble();

        r = simd.Fma(r, fx, e);

        return r;
    }

    #endregion

    #endregion

    #region Pow

    #region Vector64<f32>

    [MethodImpl(256 | 512)]
    public static Vector64<f32> Pow(Vector64<f32> a, Vector64<f32> b)
    {
        var sig = Vector64.LessThan(a, default)
                  & simd.Ne(Rem(b, Vector64.Create(2.0f)), default)
                  & Vector64.Create(0x8000_0000).AsSingle();
        var r = Exp2(Log2(Vector64.Abs(a)) * b);
        return r | sig;
    }

    [MethodImpl(256 | 512)]
    public static Vector64<f32> Pow(Vector64<f32> a, f32 b) => Pow(a, Vector64.Create(b));

    #endregion

    #region Vector128<f32>

    [MethodImpl(256 | 512)]
    public static Vector128<f32> Pow(Vector128<f32> a, Vector128<f32> b)
    {
        var sig = Vector128.LessThan(a, default)
                  & simd.Ne(Rem(b, Vector128.Create(2.0f)), default)
                  & Vector128.Create(0x8000_0000).AsSingle();
        var r = Exp2(Log2(Vector128.Abs(a)) * b);
        return r | sig;
    }

    [MethodImpl(256 | 512)]
    public static Vector128<f32> Pow(Vector128<f32> a, f32 b) => Pow(a, Vector128.Create(b));

    #endregion

    #region Vector256<f32>

    [MethodImpl(256 | 512)]
    public static Vector256<f32> Pow(Vector256<f32> a, Vector256<f32> b)
    {
        var sig = Vector256.LessThan(a, default)
                  & simd.Ne(Rem(b, Vector256.Create(2.0f)), default)
                  & Vector256.Create(0x8000_0000).AsSingle();
        var r = Exp2(Log2(Vector256.Abs(a)) * b);
        return r | sig;
    }

    [MethodImpl(256 | 512)]
    public static Vector256<f32> Pow(Vector256<f32> a, f32 b) => Pow(a, Vector256.Create(b));

    #endregion

    #region Vector512<f32>

    [MethodImpl(256 | 512)]
    public static Vector512<f32> Pow(Vector512<f32> a, Vector512<f32> b)
    {
        var sig = Vector512.LessThan(a, default)
                  & simd.Ne(Rem(b, Vector512.Create(2.0f)), default)
                  & Vector512.Create(0x8000_0000).AsSingle();
        var r = Exp2(Log2(Vector512.Abs(a)) * b);
        return r | sig;
    }

    [MethodImpl(256 | 512)]
    public static Vector512<f32> Pow(Vector512<f32> a, f32 b) => Pow(a, Vector512.Create(b));

    #endregion

    #region Vector128<f64>

    [MethodImpl(256 | 512)]
    public static Vector128<f64> Pow(Vector128<f64> a, Vector128<f64> b)
    {
        var sig = Vector128.LessThan(a, default)
                  & simd.Ne(Rem(b, Vector128.Create(2.0)), default)
                  & Vector128.Create(0x8000_0000_0000_0000).AsDouble();
        var r = Exp2(Log2(Vector128.Abs(a)) * b);
        return r | sig;
    }

    [MethodImpl(256 | 512)]
    public static Vector128<f64> Pow(Vector128<f64> a, f64 b) => Pow(a, Vector128.Create(b));

    #endregion

    #region Vector256<f64>

    [MethodImpl(256 | 512)]
    public static Vector256<f64> Pow(Vector256<f64> a, Vector256<f64> b)
    {
        var sig = Vector256.LessThan(a, default)
                  & simd.Ne(Rem(b, Vector256.Create(2.0)), default)
                  & Vector256.Create(0x8000_0000_0000_0000).AsDouble();
        var r = Exp2(Log2(Vector256.Abs(a)) * b);
        return r | sig;
    }

    [MethodImpl(256 | 512)]
    public static Vector256<f64> Pow(Vector256<f64> a, f64 b) => Pow(a, Vector256.Create(b));

    #endregion

    #region Vector512<f64>

    [MethodImpl(256 | 512)]
    public static Vector512<f64> Pow(Vector512<f64> a, Vector512<f64> b)
    {
        var sig = Vector512.LessThan(a, default)
                  & simd.Ne(Rem(b, Vector512.Create(2.0)), default)
                  & Vector512.Create(0x8000_0000_0000_0000).AsDouble();
        var r = Exp2(Log2(Vector512.Abs(a)) * b);
        return r | sig;
    }

    [MethodImpl(256 | 512)]
    public static Vector512<f64> Pow(Vector512<f64> a, f64 b) => Pow(a, Vector512.Create(b));

    #endregion

    #endregion
}
