<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="../types.ttinclude" #><#@ import namespace="System.Linq" #>// generated by template, do not modify manually

namespace Coplt.Mathematics.Simd;
<#
    var types = new[] { "f32", "f64" };
    var sizes = new[] { 64, 128, 256, 512 };
    var pairs = (from t in types
        from s in sizes
        where (t, s) is not ("f64", 64)
        select (t, s)).ToList();
#>

public static partial class simd_math
{
    #region Mod

<#
    foreach (var (type, size) in pairs)
    {
        var vector = $"Vector{size}";
        var vt = $"{vector}<{type}>";
#>
    #region <#= vt #>

    [MethodImpl(256 | 512)]
    public static <#= vt #> Mod(<#= vt #> x, <#= vt #> y)
    {
        var div = x / y;
        var flr = <#= vector #>.Floor(div);
        return simd.Fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static <#= vt #> Mod(<#= vt #> x, <#= type #> y)
    {
        var div = x / y;
        var flr = <#= vector #>.Floor(div);
        return simd.Fnma(flr, <#= vector #>.Create(y), x);
    }

    #endregion

<#
    }
#>
    #endregion

    #region Rem

<#
    foreach (var (type, size) in pairs)
    {
        var vector = $"Vector{size}";
        var vt = $"{vector}<{type}>";
#>
    #region <#= vt #>

    [MethodImpl(256 | 512)]
    public static <#= vt #> Rem(<#= vt #> x, <#= vt #> y)
    {
        var div = x / y;
        var flr = simd.RoundToZero(div);
        return simd.Fnma(flr, y, x);
    }

    [MethodImpl(256 | 512)]
    public static <#= vt #> Rem(<#= vt #> x, <#= type #> y)
    {
        var div = x / y;
        var flr = simd.RoundToZero(div);
        return simd.Fnma(flr, <#= vector #>.Create(y), x);
    }

    #endregion

<#
    }
#>
    #endregion

    #region Wrap

<#
    foreach (var (type, size) in pairs)
    {
        var vector = $"Vector{size}";
        var vt = $"{vector}<{type}>";
        var mc = type == "f32" ? "F" : "D";
#>
    #region <#= vt #>

    [MethodImpl(256 | 512)]
    public static <#= vt #> Wrap(<#= vt #> x, <#= vt #> min, <#= vt #> max)
    {
        var add = <#= vector #>.ConditionalSelect(<#= vector #>.GreaterThanOrEqual(x, default), min, max);
        var off = Rem(x, max - min);
        return add + off;
    }

    [MethodImpl(256 | 512)]
    public static <#= vt #> Wrap(<#= vt #> x, <#= type #> min, <#= type #> max)
    {
        var add = <#= vector #>.ConditionalSelect(<#= vector #>.GreaterThanOrEqual(x, default), <#= vector #>.Create(min), <#= vector #>.Create(max));
        var off = Rem(x, max - min);
        return add + off;
    }

    [MethodImpl(256 | 512)]
    public static <#= vt #> Wrap0ToPi(<#= vt #> x)
    {
        var add = x + (<#= vector #>.LessThan(x, default) & <#= vector #>.Create(math.<#= mc #>_PI));
        var div = x * math.<#= mc #>_1_Div_PI;
        var flr = simd.RoundToZero(div);
        return simd.Fnma(flr, <#= vector #>.Create(math.<#= mc #>_PI), add);
    }

    [MethodImpl(256 | 512)]
    public static <#= vt #> Wrap0To2Pi(<#= vt #> x)
    {
        var add = x + (<#= vector #>.LessThan(x, default) & <#= vector #>.Create(math.<#= mc #>_2_PI));
        var div = x * math.<#= mc #>_1_Div_2_PI;
        var flr = simd.RoundToZero(div);
        return simd.Fnma(flr, <#= vector #>.Create(math.<#= mc #>_2_PI), add);
    }

    [MethodImpl(256 | 512)]
    public static <#= vt #> Wrap0To4Pi(<#= vt #> x)
    {
        var add = x + (<#= vector #>.LessThan(x, default) & <#= vector #>.Create(math.<#= mc #>_4_PI));
        var div = x * math.<#= mc #>_1_Div_4_PI;
        var flr = simd.RoundToZero(div);
        return simd.Fnma(flr, <#= vector #>.Create(math.<#= mc #>_4_PI), add);
    }

    #endregion

<#
    }
#>
    #endregion

    #region Log

<#
    foreach (var size in sizes)
    {
        var type = "f32";
        var vector = $"Vector{size}";
        var vt = $"{vector}<{type}>";
#>
    #region <#= vt #>

    [MethodImpl(512)]
    public static <#= vt #> Log(<#= vt #> a) => Log2_impl(a) * math.F_Log2;

    [MethodImpl(512)]
    public static <#= vt #> Log10(<#= vt #> a) => Log2_impl(a) * (math.F_Log2 / math.F_Log10);

    [MethodImpl(512)]
    public static <#= vt #> Log2(<#= vt #> a) => Log2_impl(a);

    [MethodImpl(256 | 512)]
    private static <#= vt #> Log2_impl(<#= vt #> a)
    {
        var xl = <#= vector #>.Max(a, <#= vt #>.Zero).AsInt32();
        var mantissa = (xl >>> 23) - <#= vector #>.Create(0x7F);
        var r = <#= vector #>.ConvertToSingle(mantissa);

        xl = (xl & <#= vector #>.Create(0x7FFFFF)) | <#= vector #>.Create(0x7F << 23);

        var d = (xl.AsSingle() | <#= vt #>.One) * <#= vector #>.Create(2.0f / 3.0f);

        #region Approx

        // A Taylor Series approximation of ln(x) that relies on the identity that ln(x) = 2*atan((x-1)/(x+1)).
        d = (d - <#= vt #>.One) / (d + <#= vt #>.One);
        var sq = d * d;

        var rx = simd.Fma(sq, <#= vector #>.Create(0.2371599674224853515625f), <#= vector #>.Create(0.285279005765914916992188f));
        rx = simd.Fma(rx, sq, <#= vector #>.Create(0.400005519390106201171875f));
        rx = simd.Fma(rx, sq, <#= vector #>.Create(0.666666567325592041015625f));
        rx = simd.Fma(rx, sq, <#= vector #>.Create(2.0f));

        d *= rx;

        #endregion

        r += simd.Fma(d, <#= vector #>.Create(1.4426950408889634f), <#= vector #>.Create(0.58496250072115619f));

        r = <#= vector #>.ConditionalSelect(
            <#= vector #>.GreaterThan(a, <#= vt #>.Zero),
            r, <#= vector #>.Create(f32.NaN)
        );
        r = <#= vector #>.ConditionalSelect(
            <#= vector #>.Equals(a, <#= vector #>.Create(f32.PositiveInfinity)),
            <#= vector #>.Create(f32.PositiveInfinity), r
        );
        r = <#= vector #>.ConditionalSelect(
            <#= vector #>.Equals(a, <#= vt #>.Zero),
            <#= vector #>.Create(f32.NegativeInfinity), r
        );

        return r;
    }

    #endregion

<#
    }
#>
<#
    foreach (var size in sizes)
    {
        if (size == 64) continue;
        var type = "f64";
        var vector = $"Vector{size}";
        var vt = $"{vector}<{type}>";
#>
    #region <#= vt #>

    [MethodImpl(512)]
    public static <#= vt #> Log(<#= vt #> a) => Log2_impl(a) * math.D_Log2;

    [MethodImpl(512)]
    public static <#= vt #> Log10(<#= vt #> a) => Log2_impl(a) * (math.D_Log2 / math.D_Log10);

    [MethodImpl(512)]
    public static <#= vt #> Log2(<#= vt #> a) => Log2_impl(a);

    [MethodImpl(256 | 512)]
    private static <#= vt #> Log2_impl(<#= vt #> a)
    {
        var xl = <#= vector #>.Max(a, <#= vt #>.Zero).AsInt64();
        var mantissa = (xl >>> 52) - <#= vector #>.Create(0x3ffL);
        var r = <#= vector #>.ConvertToDouble(mantissa);

        xl = (xl & <#= vector #>.Create(0xfffffffffffffL)) | <#= vector #>.Create(1023L << 52);

        var d = (xl.AsDouble() | <#= vt #>.One) * <#= vector #>.Create(2.0 / 3.0);

        #region Approx

        // A Taylor Series approximation of ln(x) that relies on the identity that ln(x) = 2*atan((x-1)/(x+1)).
        d = (d - <#= vt #>.One) / (d + <#= vt #>.One);
        var sq = d * d;

        var rx = simd.Fma(sq, <#= vector #>.Create(0.148197055177935105296783), <#= vector #>.Create(0.153108178020442575739679));
        rx = simd.Fma(rx, sq, <#= vector #>.Create(0.181837339521549679055568));
        rx = simd.Fma(rx, sq, <#= vector #>.Create(0.22222194152736701733275));
        rx = simd.Fma(rx, sq, <#= vector #>.Create(0.285714288030134544449368));
        rx = simd.Fma(rx, sq, <#= vector #>.Create(0.399999999989941956712869));
        rx = simd.Fma(rx, sq, <#= vector #>.Create(0.666666666666685503450651));
        rx = simd.Fma(rx, sq, <#= vector #>.Create(2.0));

        d *= rx;

        #endregion

        r += simd.Fma(d, <#= vector #>.Create(1.4426950408889634), <#= vector #>.Create(0.58496250072115619));

        r = <#= vector #>.ConditionalSelect(
            <#= vector #>.GreaterThan(a, <#= vt #>.Zero),
            r, <#= vector #>.Create(f64.NaN)
        );
        r = <#= vector #>.ConditionalSelect(
            <#= vector #>.Equals(a, <#= vector #>.Create(f64.PositiveInfinity)),
            <#= vector #>.Create(f64.PositiveInfinity), r
        );
        r = <#= vector #>.ConditionalSelect(
            <#= vector #>.Equals(a, <#= vt #>.Zero),
            <#= vector #>.Create(f64.NegativeInfinity), r
        );

        return r;
    }

    #endregion

<#
    }
#>
    #endregion

    #region Exp

<#
    foreach (var size in sizes)
    {
        var type = "f32";
        var vector = $"Vector{size}";
        var vt = $"{vector}<{type}>";
#>
    #region <#= vt #>

    [MethodImpl(512)]
    public static <#= vt #> Exp(<#= vt #> x) => Exp2_impl(x * math.F_1_Div_Log2);

    [MethodImpl(512)]
    public static <#= vt #> Exp10(<#= vt #> x) => Exp2_impl(x * 2.302585092994045684f * math.F_1_Div_Log2);

    [MethodImpl(512)]
    public static <#= vt #> Exp2(<#= vt #> x) => Exp2_impl(x);

    [MethodImpl(256 | 512)]
    private static <#= vt #> Exp2_impl(<#= vt #> x)
    {
        var e = <#= vector #>.GreaterThanOrEqual(x, <#= vector #>.Create(89f)) & <#= vector #>.Create(f32.PositiveInfinity);
        e += simd.Ne(x, x);

        var xx = <#= vector #>.Max(
            <#= vector #>.Min(x, <#= vector #>.Create(81.0f * math.F_1_Div_Log2)),
            <#= vector #>.Create(-81.0f * math.F_1_Div_Log2)
        );

        var fx = simd.Round(xx);

        xx -= fx;
        var r = simd.Fma(xx, <#= vector #>.Create(1.530610536076361E-05f), <#= vector #>.Create(0.000154631026827329f));
        r = simd.Fma(r, xx, <#= vector #>.Create(0.0013333465742372899f));
        r = simd.Fma(r, xx, <#= vector #>.Create(0.00961804886829518f));
        r = simd.Fma(r, xx, <#= vector #>.Create(0.05550410925060949f));
        r = simd.Fma(r, xx, <#= vector #>.Create(0.240226509999339f));
        r = simd.Fma(r, xx, <#= vector #>.Create(0.6931471805500692f));
        r = simd.Fma(r, xx, <#= vector #>.Create(1.0f));

        fx = ((<#= vector #>.ConvertToInt32(fx) + <#= vector #>.Create(127)) << 23).AsSingle();

        r = simd.Fma(r, fx, e);
        r = <#= vector #>.AndNot(r, <#= vector #>.Equals(x, <#= vector #>.Create(f32.NegativeInfinity)));

        return r;
    }

    #endregion

<#
    }
#>
<#
    foreach (var size in sizes)
    {
        if (size == 64) continue;
        var type = "f64";
        var vector = $"Vector{size}";
        var vt = $"{vector}<{type}>";
#>
    #region <#= vt #>

    [MethodImpl(512)]
    public static <#= vt #> Exp(<#= vt #> x) => Exp2_impl(x * math.D_1_Div_Log2);

    [MethodImpl(512)]
    public static <#= vt #> Exp10(<#= vt #> x) => Exp2_impl(x * 2.302585092994045684 * math.D_1_Div_Log2);

    [MethodImpl(512)]
    public static <#= vt #> Exp2(<#= vt #> x) => Exp2_impl(x);

    [MethodImpl(256 | 512)]
    private static <#= vt #> Exp2_impl(<#= vt #> x)
    {
        var e = <#= vector #>.GreaterThanOrEqual(x, <#= vector #>.Create(709.0 * 1.4426950408889634)) & <#= vector #>.Create(f64.PositiveInfinity);
        e += simd.Ne(x, x);

        var xx = <#= vector #>.Max(
            <#= vector #>.Min(x, <#= vector #>.Create(709.0 * 1.4426950408889634)),
            <#= vector #>.Create(-709.0 * 1.4426950408889634)
        );
        var fx = simd.Round(xx);

        xx -= fx;
        var sq = xx * xx;
        var r = simd.Fma(sq, <#= vector #>.Create(0.00000000044560630323), <#= vector #>.Create(0.00000010178055034703));
        r = simd.Fma(r, sq, <#= vector #>.Create(0.000015252733847608224));
        r = simd.Fma(r, sq, <#= vector #>.Create(0.0013333558146398846396));
        r = simd.Fma(r, sq, <#= vector #>.Create(0.05550410866482166557484));
        r = simd.Fma(r, sq, <#= vector #>.Create(0.6931471805599453087156032));
        var ro = simd.Fma(sq, <#= vector #>.Create(0.000000007073075504998510), <#= vector #>.Create(0.000001321543919937730177));
        ro = simd.Fma(ro, sq, <#= vector #>.Create(0.0001540353044975008196326));
        ro = simd.Fma(ro, sq, <#= vector #>.Create(0.00961812910759946061829085));
        ro = simd.Fma(ro, sq, <#= vector #>.Create(0.240226506959101195979507231));
        ro = simd.Fma(ro, sq, <#= vt #>.One);
        r = simd.Fma(r, xx, ro);

        fx += <#= vector #>.Create(6755399441055744.0);
        fx = ((fx.AsInt64() + <#= vector #>.Create(0x3ffL)) << 52).AsDouble();

        r = simd.Fma(r, fx, e);

        return r;
    }

    #endregion

<#
    }
#>
    #endregion

    #region Pow

<#
    foreach (var size in sizes)
    {
        var type = "f32";
        var vector = $"Vector{size}";
        var vt = $"{vector}<{type}>";
#>
    #region <#= vt #>

    [MethodImpl(256 | 512)]
    public static <#= vt #> Pow(<#= vt #> a, <#= vt #> b)
    {
        var sig = <#= vector #>.LessThan(a, default)
                  & simd.Ne(Rem(b, <#= vector #>.Create(2.0f)), default)
                  & <#= vector #>.Create(0x8000_0000).AsSingle();
        var r = Exp2(Log2(<#= vector #>.Abs(a)) * b);
        return r | sig;
    }

    [MethodImpl(256 | 512)]
    public static <#= vt #> Pow(<#= vt #> a, f32 b) => Pow(a, <#= vector #>.Create(b));

    #endregion

<#
    }
#>
<#
    foreach (var size in sizes)
    {
        if (size == 64) continue;
        var type = "f64";
        var vector = $"Vector{size}";
        var vt = $"{vector}<{type}>";
#>
    #region <#= vt #>

    [MethodImpl(256 | 512)]
    public static <#= vt #> Pow(<#= vt #> a, <#= vt #> b)
    {
        var sig = <#= vector #>.LessThan(a, default)
                  & simd.Ne(Rem(b, <#= vector #>.Create(2.0)), default)
                  & <#= vector #>.Create(0x8000_0000_0000_0000).AsDouble();
        var r = Exp2(Log2(<#= vector #>.Abs(a)) * b);
        return r | sig;
    }

    [MethodImpl(256 | 512)]
    public static <#= vt #> Pow(<#= vt #> a, f64 b) => Pow(a, <#= vector #>.Create(b));

    #endregion

<#
    }
#>
    #endregion
}
